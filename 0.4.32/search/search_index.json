{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kiara","title":"kiara","text":"<p>A data-centric workflow orchestration framework.</p> <ul> <li>kiara user documentation: https://dharpa.org/kiara.documentation</li> <li>Code: https://github.com/DHARPA-Project/kiara</li> <li>Development documentation for this repo: https://dharpa.org/kiara</li> </ul>"},{"location":"#description","title":"Description","text":"<p>Kiara is the data orchestration engine developed by the DHARPA project. It uses a modular approach to let users re-use tried and tested data orchestration pipelines, as well as create new ones from existing building blocks. It also helps you manage your research data, and augment it with automatically-, semi-automatically-, and manually- created metadata. Most of this is not yet implemented.</p>"},{"location":"#development","title":"Development","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python (version &gt;=3.6 -- some make targets only work for Python &gt;=3.7, but kiara itself should work on 3.6)</li> <li>pip, virtualenv</li> <li>git</li> <li>make</li> <li>direnv (optional)</li> </ul>"},{"location":"#prepare-development-environment","title":"Prepare development environment","text":"<pre><code>git clone https://github.com/DHARPA-Project/kiara.git\ncd kiara\npython3 -m venv .venv\nsource .venv/bin/activate\nmake init\n</code></pre> <p>If you use direnv, you can alternatively do:</p> <pre><code>git clone https://github.com/DHARPA-Project/kiara.git\ncd kiara\ncp .envrc.disabled .envrc\ndirenv allow\nmake init\n</code></pre> <p>Note: you might want to adjust the Python version in <code>.envrc</code> (should not be necessary in most cases though)</p>"},{"location":"#make-targets","title":"<code>make</code> targets","text":"<ul> <li><code>init</code>: init development project (install project &amp; dev dependencies into virtualenv, as well as pre-commit git hook)</li> <li><code>update-modules</code>: update default kiara modules package from git</li> <li><code>flake</code>: run flake8 tests</li> <li><code>mypy</code>: run mypy tests</li> <li><code>test</code>: run unit tests</li> <li><code>docs</code>: create static documentation pages (under <code>build/site</code>)</li> <li><code>serve-docs</code>: serve documentation pages (incl. auto-reload) for getting direct feedback when working on documentation</li> <li><code>clean</code>: clean build directories</li> </ul> <p>For details (and other, minor targets), check the <code>Makefile</code>.</p>"},{"location":"#running-tests","title":"Running tests","text":"<pre><code>&gt; make test\n# or\n&gt; make coverage\n</code></pre>"},{"location":"#copyright-license","title":"Copyright &amp; license","text":"<p>This project is MPL v2.0 licensed, for the license text please check the LICENSE file in this repository.</p> <ul> <li>Copyright (c) 2021, 2022 DHARPA project</li> <li>Copyright (c) 2021, 2022 Markus Binsteiner</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Development</li> <li>Included components</li> <li>API reference</li> <li>Design docs</li> </ul>"},{"location":"design_docs/","title":"Design documents","text":"<p>This section contains desig-related documents for the Kiara project.</p> <p>Most of those are not up-to-date, but they can help to understand certain design decisions, and why they were made.</p>"},{"location":"design_docs/SUMMARY/","title":"SUMMARY","text":"<ul> <li>*</li> <li>*/</li> </ul>"},{"location":"design_docs/architecture/","title":"Architecture documents","text":"<p>Docs outlining some of the thinking behind the architecture of kiara.</p>"},{"location":"design_docs/architecture/SUMMARY/","title":"SUMMARY","text":"<ul> <li>*</li> <li>*/</li> </ul>"},{"location":"design_docs/architecture/assumptions/","title":"Assumptions &amp; considerations","text":""},{"location":"design_docs/architecture/assumptions/#core-assumptions","title":"Core assumptions","text":"<p>I consider the following assumptions a given. They are not fuelled by user stories, but are the 'minimal' requirements that emerged after initially presenting the 'open questions', and in other discussions with Sean and the team. If any of those assumptions are wrong, some of the conclusions below will have to be adjusted.</p> <ul> <li>our (only) target audience (for now) are digital historians (and maybe also other digital humanity researchers) who can't code themselves</li> <li>the most important outcome of our project is for our target audience to be able to execute workflows in order to explore, explain, transform or augment their data</li> <li>we want the creation of workflows to be as easy and frictionless as possible, although not at the expense of end-user usability</li> <li>we want our product to be used by all DH researchers around the word, independent of their affiliation(s) q- collaboration/sharing of data is not a priority, most of our target audience are either individuals, sometimes small teams (sharing of results and sharing of workflows are different issues, and not included in this assumption)</li> </ul>"},{"location":"design_docs/architecture/assumptions/#considerations-around-adoption","title":"Considerations around adoption","text":"<p>One way to look at how to prioritize and implement some of our user stories is through the lens of ease-of-adoption: which characteristics make our application more likely to be adopted, by a larger group of researchers?</p> <p>Those ones are obvious (at least to me) -- in no particular order:</p> <ul> <li>ease of workflow use</li> <li>ease of file-management use</li> <li>ease of installation (if there is one involved)</li> <li>whether there is a login/account creation requirement</li> <li>how well it integrates and plays with tools researchers already use day to day</li> <li>provides relevant (to them) workflows</li> <li>the cheaper to use the better (free/monthly cost/pay-per-usage)</li> <li>stability / reliability</li> <li>performance (most importantly on the compute side, but also UI)</li> <li>how easy it is to create workflows, and what skills are necessary to do that (easier creation -&gt; more workflows)</li> <li>whether and how easy it will be to share, re-use and adapt workflows (different to sharing data)</li> </ul>"},{"location":"design_docs/architecture/decisions/","title":"Decisions","text":"<p>This page lists a few of the main decisions that were taken, what the considerations around them were, their impact, as well as why they were made.</p>"},{"location":"design_docs/architecture/decisions/#supporting-two-sorts-of-modules-core-and-pipeline-modules","title":"Supporting two sorts of modules: 'core', and 'pipeline' modules","text":"<p>When starting to write code, we didn't have yet many examples of modules and how specific/broad they would be in their utility. I think we should have done a better job gathering those and coming up with a set of modules that would be sufficient for our first 10 or so workflows before writing any code, but alas, we didn't. One way I saw to lower the risk of us implementing us ourselves into a corner was to make our modules as flexible, re-usable and 'combinable' as possible. And the best way I could think of to do that was to have a very simple interface for each module (each module has a defined set of input/output fields, and one main function to transform inputs into outputs), and to allow several modules to be combined into a 'new' module that has those same characteristics/interface.</p> <p>Advantages: - easy to declaratively create re-usable modules with just json/yaml - easy to re-use modules/other pipelines for UI-specific subtasks (like data previews/querying) - in most cases, the higher-level backend code does not know about core- and pipeline- modules, since they can be treated the same</p> <p>Disadvantages: - the lower-level backend code needs to implement two different ways to assemble/create modules, depending on whether it's a core-module, or a pipeline</p>"},{"location":"design_docs/architecture/decisions/#use-of-subclassing-in-general","title":"Use of subclassing in general","text":"<p>Across kiara, I'm using subclassing and inheritance in some instances, esp. important base classes are KiaraModule and PipelineController. I'm aware that this is considered bad practice in a lot of cases, and I have read my share of opinions and thoughts about the matter. In principle I agree, and I'm not 100% happy with every decision I made (or thought I had to made) in this area for kiara, but overall I decided to allow for some inheritance and class-based code sharing in the code, partly to speed up my implementation work, partly because I thought some of the disadvantages (like having to search base classes for some function definitions) are not as bad in a certain context than in others. I can totally see how others would disagree here, though, and there are a few things I would like to change/improve later on, if I find the time.</p> <p>One of the main advantages I get out of using inheritance is being able to automatically discover subclasses of a base class. This is done for multiple of those, like:</p> <ul> <li>KiaraModule</li> <li>ValueTypeOrm</li> <li>MetadataModel</li> </ul> <p>Using auto-discovery in a Python virtualenv removes the need for workflow/module developers to understand Python packaging and entry_points. I've written a project template that sets up all the basics, and developers focus on creating new classes (basically plugins), with no extra registration work to be done. I hope this will aid adoption. And that I've managed to design those base classes well enough so that they are easy to use and understand, so that some of the main drawbacks of subclassing won't matter all that much.</p>"},{"location":"design_docs/architecture/decisions/#requiring-to-subclass-an-abstract-base-class-when-creating-a-module","title":"Requiring to subclass an abstract base class when creating a module","text":"<p>The main class that uses a subclassing-strategy is KiaraModule. At it's heart, it's basically just a wrapper around a pure function, with some utility methods describing it's input and output. One reason I decided to not just create a decorator that wraps any function was the need to be able to describe the input the function takes, and the output it produces in a stricter way than would have been possible with just type hints. Another reason is that this way it is possible to add configuration to a module object, which should make module code much more flexible and re-usable, and developers do not have to implement separate modules for just slightly different use-cases.</p> <p>This design decision does not prevent to allow for more 'loose' implementations of a module, like the above mentioned function with a decorator. Those would be dynamically converted into a <code>KiaraModule</code> subclass/object, with potential downsides of not being able to version control it properly (or as easliy). The point is, though, that the default way of doing things will give us the best guarantees (and metadata).</p> <p>Advantages: - relatively easy to manage 'plugin-like' architecture, discovery of modules - being able to describe module input/output fields in detail - module versioning: by requiring the subclassing of a base class, and also having to add modules as entry_points, it will be possible describe exactly which version of the module was used in a workflow (as well as which version of the base class)</p> <p>Disadvantages: - more abstraction layers than strictly necessary - other, usual disadvantages associated with subclassing/inheritance</p>"},{"location":"design_docs/architecture/decisions/#separating-data-from-the-python-objects-that-describe-them-data-registry","title":"Separating data from the Python objects that describe them / Data registry","text":"<p>TBD</p> <p>Advantages: - efficiency, option to save on memory and IO - (hopefully) decrease of complexity for non trivial scenarios like multi-process or remote job execution</p> <p>Disadvantages: - extra level of abstraction - increase in complexity (at least for simple use-cases)</p>"},{"location":"design_docs/architecture/metadata/","title":"Metadata","text":""},{"location":"design_docs/architecture/metadata/#metadata","title":"Metadata","text":"<p>Metadata is more important in research than in other fields. Metadata can be used to, among other things, track provenance of data, describe authorship, time of creation, location of creation, describing the 'shape' of data (schemas, etc.).</p> <p>In some cases it's not easy to determine what's data and what's metadata. Sometimes metadata becomes data (\"One persons metadata...\"). Handling metadata is difficult, and it regularly gets lost somewhere in the process. Creating metadata in the first place can be very time-consuming, I would wager that is more true in the digital humanities than in the harder sciences.</p> <p>With the growing popularity of the open data movement, people are getting more aware of the importance of metadata, and there is a growing infrastructure and services around all of this (DOIs, RDF, 'linked data', Dublin core, ...). None of it is easy or intuitive to use, but I guess that's just the nature of the beast.</p> <p>I think it is safe to say that whatever we come up with has to be able to create and handle metadata in some way or form, and personally, I think we should 'bake' metadata handling in from the beginning. Looking at the user-stories it's quite clear that this an important topic. How exactly that will look, I think there is some leeway, but all architecture proposals should at least include some indication on how this would be handled.</p>"},{"location":"design_docs/architecture/metadata/#schema-information","title":"Schema information","text":"<p>One important piece of metadata is often schema information: what exactly is the shape of the data, how can I read it? In some cases this can be inferred from the data easily, sometimes it's even obvious. But often that is not the case at all, which makes things like creating generic data exploration tools very hard, if not impossible. We would have, if we choose to create and attach it, all that information available, always, which would mean it would be easy to create generic, peripheral tools like a generic data explorer. It will, of course, also make it easier to re-use such data in other workflows, because users would not have to explicitly specify what their data is; we could infer that from the attached schema.</p>"},{"location":"design_docs/architecture/metadata/#workflow-metadata","title":"Workflow metadata","text":"<p>One thing that is specific to our application is that we have full control over every part of the data-flow. So, we can attach metadata of all inputs and previous steps to each result (or intermediate result) along the way. Which is quite an unique opportunity; this is often not available at all, or has to be done manually by the researcher.</p> <p>There is a lot that can be done with such annotated (result-)data. For example, each data set can include pointers to all the original data that was involved in creating it (or it could even include that data itself), as well as a description of all the transformation steps it went through. This means that one could potentially create a full visual representation of what happened to the data since it was created, just by looking at the attached metadata. This is usually impossible, because there is never a sort of 'unbroken cold-chain' of metadata available. Of course, this would also help with reproducability and related issues.</p> <p>This possibility is something I'm particularly excited about, even though it does not directly appear in any of our user stories (so would not be a core requirement). But it's one of the things I would have liked to have available often in the past.</p>"},{"location":"design_docs/architecture/data/","title":"Data","text":"<p>From looking at the user stories, and after listening to the interviews Lorella conducted and also considering my own personal experience in eResearch, I think its save to say that the central topic we are dealing with is data. Without data, none of the other topics (workflows, visualisation, metadata...) would even exist. Because of its central nature I want to lay out the different forms it comes in, and which characteristics of it are important in our context.</p>"},{"location":"design_docs/architecture/data/#whats-data","title":"What's data?","text":"<p>Data is created from sources. Sources come in different forms (analog, digital) and can be anything from handwritten documents in an archive to a twitter feed. Photos, cave-paintings, what have you. I'm not websters dictionary, but I think one usable working definition of data could be a 'materialized source', in our context 'materialized source in digital form'. From here on out I'll assume we are talking about 'digital' data when I mention data.</p> <p>One thing I'll leave out in this discussion is what is usually called 'dirty data' in data engineering, although it is an important topic. Most of the issues there map fairly well to the structured/unstructured thing below. There are a few differences, but in the interest of clarity let's ignore those for now...</p>"},{"location":"design_docs/architecture/data/#structured-data-data-transformations","title":"Structured data / Data transformations","text":"<p>Important for us is that data can come in two different formats: unstructured, and, who'd have guessed... structured. The same piece of data can be theoretically expressed in structured as well as unstructured form: the meaning to a researcher would be 100% the same, but the ways to handle, digest and operate with the data can differ, and in most scenarios adding structure opens up possibilities to work with the data that weren't there before. In my head I call those two forms 'useless', and 'useful' data, but researcher usually get a bit agitated when I do, so I have learned to not do that in public anymore.</p> <p>For researchers, the most (and arguably only) important feature of 'structure' is that it enables them to do more with the data they already possess. By means of computation. I think it's fair to say that only structured data can be used in a meaningful way in a computational context. With the exception that unstructured data is useful input to create structured data.</p> <p>One more thing to mention is that the line between structured and un-structured is sometimes hard to draw, and can depend entirely on context. \"One persons structured data is another persons unstructured data.\", something like that. In addition, in some instances unstructured data can be converted to structured data trivially, meaning without much effort or any user-interaction. I'd argue we can consider those sorts of datasets basically 'structured'.</p>"},{"location":"design_docs/architecture/data/#example","title":"Example","text":"<p>Lets use a simple example to illustrate all that: a digital image of a document.</p> <p>Depending on what you are interested in, such an image might already be structured data. For example it could contain geo-tags, and a timestamp, which are both digitally readable. If you want to visualize on a map where a document is from, you can do that instantly. Structured data, yay!</p> <p>Similarly, if you are interested in the color of the paper of the document (ok, I'm stretching my argument here as this seems fairly unlikely, but this is really just to illustrate...), you might get the color histogram of the image (which is trivial to extract, but needs some batch-computation), and for your purposes you would also consider the image file structured data.</p> <p>Now, if you are interested in the text content of the document, things get more interesting. You will have to jump through some hoops, and feed the image file to an OCR pipeline that will spit out a text file for example. The data itself would still be the same, but now computers can access not only some probably irrelevant metadata, but also the text content, which, in almost all cases, is where the 'soul' of the data is.</p> <p>It could be argued that 'just' a text file is not actually structured. I'd say that groups of ascii-characters that can be found in english-language dictionaries, separated by whitespaces and new-lines can be considered a structure, even if only barely. The new format certainly allows the researcher to interact with the data in other ways (e.g. full-text search).</p> <p>We can go further, and might be interested in characteristics of the text content (language, topics, etc.). This is where the actual magic happens, everything before that is just rote data preparation: turning unstructured (or 'other-ly' structured) data into (meaningful) structured data... On a technical level, those two parts (preparation/computation) of a research workflow might look (or be) the same, but I think there is a difference worth keeping in mind. If I don't forget I'll elaborate on that later.</p>"},{"location":"design_docs/architecture/data/#big-ish-data","title":"'Big-ish' data","text":"<p>I'm not talking about real 'Big data'-big data here, just largish files, or lots of them, or both. I don't think we'll encounter many use-cases where we have to move or analyze terabytes of data, but I wouldn't be surprised if we come across a few gigabytes worth of it every now and then.</p> <p>There are a few things we have to be prepared for, in those cases:</p> <ul> <li>transferring that sort of data is not trivial (esp. from home internet connections with limited upload bandwidth) -- and we will most likely have to be able to offer some sort of resumable-upload (and download) option (in case of a hosted solution)</li> <li>if we offer a hosted service, we will have to take into account and plan for this, so we don't run out of storage space (we might have to impose quotas, for example)</li> <li>computation-wise, we need to make sure we are prepared for large datasets and handle that in a smart way (if we load a huge dataset into memory, it can crash the machine where that is done)</li> <li>similarly, when we feed large datasets into a pipeline, we might not be able to just duplicate and edit the dataset like we could do for small amounts of data (too expensive, storage-wise) -- so we might need to have different strategies in place on how to execute a workflow, depending on file sizes (for example some sort of copy-on-write)</li> </ul>"},{"location":"design_docs/architecture/data/persistence/","title":"Data persistence","text":"<p>This is a document to describe my plans for storing data (and metadata) in kiara. (Almost) nothing I describe here is inmplemented yet, so it only reflects my current thinking. I think the overall strategy will hold, but there might be changes here and there.</p>"},{"location":"design_docs/architecture/data/persistence/#the-problem","title":"The problem","text":"<p>kiaras main functionality centers around transforming input data sets to output data sets. Those outputs need to be stored, to be of any use later on. Obviously. When deciding how to do this, we must take into account concerns about performance, disk- and memory-usage, data versioning, which metadata to attach, in what way, how to deal with metadata schemas (and versioning of both), etc.</p>"},{"location":"design_docs/architecture/data/persistence/#the-solution","title":"The solution","text":"<p>Well, solution. This is my current thinking of how to tackle the problem in a way that takes into account all of the aspects described above, while still being flexible enough to hopefully be able to incorporate solutions for future unforsseen issues.</p> <p>I am having trouble coming up with a good structure for this document, so I think I'll just try to tell the story from the point of view of data. Starting from a state where data exists outside of kiara, to when it is in a state to be ready to be published. As with everything I'm writing here as an explanation of generic and abstract concepts, some of the technical details I'm describing might be simplified to the point of being incorrect...</p>"},{"location":"design_docs/architecture/data/persistence/#the-7-stages-of-data","title":"The 7 stages of data","text":"<p>One thing I'd like to say before I start to describe those stages: the transformation of a dataset, from one stage to the next, always always always happens by piping the dataset through a kiara module. At absolutely no point is this done without kiaras involvement and knowledge. The dataset is used as input for a module, and the result (technically a new dataset) is a representation of the dataset in its next stage. This is important to keep in mind, as it is crucial for us so we can track data lineage. I'll write more on the specifics of this below, where it makes more sense.</p>"},{"location":"design_docs/architecture/data/persistence/#1-unmanaged","title":"1) Unmanaged","text":"<p>At the beginning, there was csv. Whether I like it or not, csv is the most predominant form data comes in. Csv is bad in a lot of ways, but in my mind the worst thing about it is that it is schema-less. True, in some cases you have a header-line, which gives you column-names, but that's not a requirement. Also, in a lot of cases you can auto-determine the type of each column, and luckily libraries like Pandas or Apache Arrow solved that problem for us so we don't have to do it ourselves every time. But those auto-parsers are not fool-proof, and you end up with integers where you wanted floats (or doubles), or integers where you wanted strings, or vice versa.</p> <p>In some cases we get data in a form that includes at least a semi-schema. Like a sqlite database file (which is more 'strongly' typed). But it's a lucky day when we get data that contains metadata about authorship, how and when it was created, from what sources, etc.</p>"},{"location":"design_docs/architecture/data/persistence/#2-onboarded","title":"2) Onboarded","text":"<p>This is the first thing we need to do to unmanaged data: we need to 'onboard' it, so kiara knows the data exists, and what exact bytes it consists of. This last thing is very important: we have to be able to make sure the data we are talking about is not being changed externally, a lot of things in kiaras approach to data depend on this.</p> <p>Practically, in most cases this means kiara will copy one or several files into a protected area that no other application can/should access. That way we always have a reference version of the dataset (the bytes) we are talking about.</p> <p>One thing kiara does at this stage is give the dataset a uniuqe id, which can be used to reference it later (by users, or other objects/functions). Another thing is to collect some basic metadata: when the file/folder was imported, from what original path, what the filenames are, mime-type, size of files, original file attributes (creation data, permissions, etc.). This can all be captured automatically. We can also record who it was that imported the dataset, if we have some app-global configuration about the current user, like a full name and email-address. Note, that this might or might not be the person who created the dataset.</p> <p>So, at this stage all we did was copy a file(set) into a protected area to sort of 'freeze' it, and augment it with very basic metadata. We don't know anything about the nature of the dataset yet, all we know is the bytes the datasets consists of. It is important to point out that we would not have to store those chunks of bytes as files again, using the same structure as the original set of files. The dataset ceased to be 'files' here for us, we are only interested in the chunks of bytes (and their meaning) from here on out. We could store the data in an object store, zipped, tarred and feathered (pun intended). Or as byte-stream directly on block storage, if we were crazy enough.</p> <p>A side-note that makes things a bit more complicated, but it is probably necessary to address potential concerns: no, we don't actually need to copy the files, and can leave them in place and only generate the metadata and id for them. This might be necessary in cases where the source data is very big (photos, movies, audio-files, other large datasets). I don't think we need to figure out how exactly we deal with this scenario right now, but it basically comes down to making the user aware of what is happening, and what the implications are if the source data is changed externally (inconsistent metadata and potential incorrect result data-sets further down the line). There are strategies to help prevent some of those potential issues (checksums, for example), but overall we have to acknowledge that working with large-sized datasets is always a challenge, and in some cases we might just have to say: \"sorry, this is too big for us right now\".</p>"},{"location":"design_docs/architecture/data/persistence/#3-augmented-with-more-basic-metadata","title":"3) Augmented with more (basic) metadata","text":"<p>To recapitulate: at this stage we have data (chunks of bytes -- not files!!! hit yourself over the head twice with something semi-heavy if you are still think in terms of files from here on out!) in a protected area, some very basic metadata, and an id for each dataset. We might or might not have authorship metadata (arguably one of the most important pieces of metadata), depending on whether who 'onboarded' the dataset actually created it.</p> <p>So, as a first step and following good practice, at this stage we should try to get the user to tell us about authorship and other core metadata about our dataset (licensing, copyright, ...). I don't think we can make this step mandatory, in practice, but we should push fairly hard, even if that means a slight decrease in user experience. It is very important information to have...</p> <p>So, one thing we could do was to have a checkbox that lets the user confirm: I created the data (in which case we can just copy the 'imported-by' field).</p>"},{"location":"design_docs/architecture/data/persistence/#3-typed","title":"3) Typed","text":"<p>Chunks of bytes are not very useful by itself. They need to be interpreted to be of use. This means: determining in some way what the structure of the chunks of bytes is, and then applying common conventions for that particular structure (aka data type/format) when reading the chunks of bytes. Therefore 'interpreting' the chunks of bytes. This is a very obvious thing that happens all the time we use computers, but I think it makes sense to point it out here, because usually this is transparent to the user when they click an 'Open file' button in an application, and even some developers are ignorant to the underlying concept (and can afford to be, since they usually work several abstraction layers above where that is happening).</p> <p>To encapsulate this concept, we will create a 'data type' for each important group of datasets that share some important characteristics. Examples for very simple data types are strings, integers, booleans. I'll ignore those, because those are trivial to use, and that triviality actually makes it harder to explain the concept I'm talking about. More relevant data types are: 'table', 'network graph', 'text corpus', 'photo collection'. Every data type inherently contains a description of, well, the 'type' of data represented by it, and, with that, information about how a user or code caqn access the actual data, and/or some of its properties.</p> <p>From here on out, I'll focus on tabular data in some form or other, since I expect that this will be one of our most important (base-) data types. I expect the reader to 'translate' whatever I'm saying below to other types, and extrapolate the practical differences.</p> <p>So, to explain this step I decided to look at three different use-cases (mostly because we use them in 2 of our example workflows, so people should be familiar with them):</p> <ul> <li>a csv file with tabular data</li> <li>an imported folder of text files (a corpus)</li> <li>two imported csv files containing edge and node information to form a network graph</li> </ul>"},{"location":"design_docs/architecture/data/persistence/#example-tabular-data","title":"Example: tabular data","text":"<p>This is the simplest case, and very common: we have a csv file, and need to have some sort of tabular data structure that we can use to query and analyze the data contained in it.</p> <p>Let's assume we have onboarded a csv file using kiara, so we have a dataset id that we use to point to it. Technically, this dataset is already 'typed': it has the type 'file'. This is not a very useful type, all it allows can tell us is a file name (which in a way is metadata), and the file content. We can ask kiara to interpret the content of this file as table, though, because we know it must be one. This means we 'overlay' a different, more specific data type on top of the same data.</p> <p>Under the hood, kiara will use the Apache Arrow <code>read_csv</code> helper method, which is very smart and fast, and it can create an Arrow Table object out of a csv file. It can figure out file encoding, column names (if present), column types, seperator characters. This detection is not fool-proof, but should work good enough in practice that we don't need to worry about it here. What really happens here is that the <code>read_csv</code> method is not just reading our data, but also, at the same time, is adding some important metadata to our dataset. Pandas can do the same with its csv import method. Even though this adding of metadata is more or less transparent to the user -- so they are not really aware of it -- it happens, and it is a very important thing that must happen to make our dataset useful. In our application, we might or might not want to ask users whether the extracted column names and types are correct, but this is a UI-specific implementation detail.</p> <p>So, considering all this, the important point here is that at this stage we have actual 'table' data, there is no need for the original csv file anymore (except as a reference for data lineage purposes). Our dataset is now of the data type 'table'. Which means we have an assurance that we can query it for table metadata properties (number of rows, number and name of columns, column types, size in bytes, etc.). And we can apply functions against it that are commonly applied against tabular data (sql queries, filters, etc.). That means, a 'data type' is really just a convention, a marker, that tells us how the bytes are organized for a particular set of bytes, and how to interact with it. This is all users and 3rd party-code needs to worry about. Implementation details about how this data is stored or loaded are irrelevant on this level of abstraction. This reduces complexity for kiaras external facing API, while, of course, introducing some extra complexity internally.</p>"},{"location":"design_docs/architecture/data/persistence/#example-text-corpus","title":"Example: text corpus","text":"<p>The source data comes as a folder of files, each file contains (just) text (not structured like json, csv, etc.). When we do the 'onboarding' step for this data, all we do is copy the files verbatim into a new location. There could be some metadata implicit in the relative paths of each file (e.g. languages -- files for the same language live in a subfolder named after the language), and there can also be some metadata in the file names. We preserve all that metadata by copying the folder one-to-one, without changing anything. But it is important to note that this metadata, as of yet, is still uncaptured.</p> <p>The 'soul' of this dataset (meaning: the properties of the dataset we are interested in and we want to use in our investigation, and which will hopefully answer our research question) is in the content of each text file (aka the unicode encoded chunks of bytes). It is important to say again: at this stage the dataset ceased to be a set of files! It is a dataset within kiara that has an id (a single one! not one for every text!), and it has a basic set of metadata fields (the ones we could collect automatically). Yes, the dataset is backed by a set of files in the kiara data store, but that is an implementation detail nobody needs to know about, and I think we should try hard to hide from users. If you haven't noticed so far: I strongly believe the file metaphor is a distraction, and not necessary for us, except when import/export is concerned.</p> <p>Anyway, kiara does not know much about the dataset at this stage. To be of actual use, we need to interpret the data. In this case, we know we want to interpret the data as a text corpus.</p> <p>The most basic shape we can imagine a text corpus to look like is a list of strings (an array, or a single-column table). For making it easier to work with the text corpus in the future, let's make up a convention to save in tabular form, and the column containing the text items is always named <code>text_content</code>. If we use, for example Apache Arrow to store that table, it makes the stored chunks of data much smaller (in comparison to text files), and it also makes the whole thing easier (at least faster) to query. It also allows us to easily attach more (meta-)data to the dataset.</p> <p>Note</p> <p>The distinction between data and metadata becomes a bit blurry here. In a lot of cases, when I say metadata, it is metadata from the point of view of the research proess, not metadata for kiara. I don't know how to make it clear which I'm talking about in each case without making this whole thing even more unreadable as it already is, so I will just have to ask you to figure it out yourself, in each case :-)</p> <p>Because we didn't lose any of the implied metadata when onboarding our folder of text files, it would be a shame if we wouldn't actually capture it. In this case, let's assume we didn't have any subfolders (so no metadata in their name), but our files are named in a special way:</p> <pre><code>[publication_id]_[date_of_publishing]_[other_stuff_we_are_not_interested_in]\n</code></pre> <p>Note</p> <p>The information about the format is important (in a way it is also an input) and we need to retrieve it somehow. This is a real problem that doesn't look like a big problem. But it is, for us. I'll ignore this here, because it would complicate things too much and is only of tangential relevance.</p> <p>This means, we can extract the publication id and the date of publishing with a simple regular expression, and we can add a column for each one to our table that so far only contains the actual text for each item. The publication id will be of type string (even though some of the ids might be integers -- we don't care), and the publication date will be a time format. Now we have a table with 3 columns, and we can already filter the texts by date easily, which is pretty useful! We wouldn't, strictly speaking those two additional columns to have a dataset of type 'text corpus' but it's much more useful that way. As a general rule: if we have metadata like that, it should be extracted and attached to the data in this stage. It's cheap to do in a lot of cases, and we never know when it will be needed later.</p> <p>What we have at this stage is data that has the attributes of a table (columns with name and type info, as well as rows representing an item and it's metadata). This is basically the definition of our 'text corpus' data type: something that allows us to access text content items (the actual important data) using a mandatory column named <code>text_content</code>, and that has zero to N metadata properties for each of those text items. In addition, we can access other metadata that is inherited from the base type (table): number of rows, size in bytes, etc, as well as its lineage (via a reference to the original onboarded dataset). Internally, we'll store this data type as an Arrow table, but again, this is an implementation detail, and neither user nor frontend needs to know about this (exceptions apply, of course, but lets not get bogged down by those just now -- none of them are deal-breakers, as far as I can see).</p>"},{"location":"design_docs/architecture/data/persistence/#example-network-graph-data","title":"Example: network graph data","text":"<p>Similar to the text corpus case above, let's think about what a basic definition of a network graph data type would look like. It would have to include a list of nodes, and a list of edges (that tell us how those nodes are connected). Actually, the list of nodes is implied in the list of edges, so we don't need to provide that if we don't feel like it (although, that doesn't apply if we have nodes that are not part of any edge). In addition, both nodes and edges can have attributes, but those are optional. So, our network graph data type would, at a minimum, need to be able to give us this information about all this via its interface. networkx is one of the most used Python libaries in this space, so let's decide that internally, for us, a network graph is represented as an object of the  Graph class, or one of its subclasses.</p> <p>This class will give us a lot of useful methods and properties to access and query, one problem left is: how do we create an object of this class in a way that fits with our overall strategy? We can't save and load a networkx object directly (pickling would be a bad idea for several reasons), so we need to create (and re-create) it via some other way.</p> <p>For this, lets look at the constructor arguments of this class, as well as what sort of data types we have available that we can use to feed those arguments. One option apparently is to use a list of edges contained in a Pandas dataframe as input, along with a name of columns representing the names of source and target column name, something like:</p> <pre><code>        graph: nx.DiGraph = nx.from_pandas_edgelist(\n            pandas_table,\n            source_column,\n            target_column,\n        )\n</code></pre> <p>This could work for us: as in the other example, we can use a table as the 'backing' data type for our graph object. Considering a graph without any node attributes, we can have a table with a minimum of two columns, and via a convention that we just made up, we say that the source column should be called <code>edge_source</code>, and the target column <code>edge_target</code>. We wrap all this in an Arrow table again, and save it as such. And later load it again, assuming the same convention (which, basically, saves us from asking for 2 column names every time). If our graph also includes node attributes, all we do is extend the implementation of our network graph data type to create a second table with a required column <code>node_id</code>, and one or several more columns that hold node attributes, similar to the metadata in our 'text corpus' example from above.</p>"},{"location":"design_docs/architecture/data/persistence/#4-transformed","title":"4) Transformed","text":"<p>With all that out of the way, we can finally do something interesting with the data. Everything up to this point was more or less housekeeping: importing, tagging, marking, organizing datasets. We still are operating on the same actual data as was contained in the original files (whatever type they were). But we now know exactly what we can do with it without having to ask questions.</p> <p>Using the 3 example from above, we now know we have 3 datasets: one table, one text corpus (which is also a table, but a more specific one), and a network graph. And each of those datasets also comes with metadata, and we know what metadata files are available for what data types, and what the metadata means in each context.</p> <p>A first thing we can do is automatically matching datasets to available workflows: we know what input types a workflow takes (that is included in each workflow metadata). So all we need to do is check the input types of each available workflow against the type of a dataset. This works even with different specificity: give me all workflows that take as input a generic graph. Or: give me all workflows that take a directed graph as input (this is information that is included in the metadata of each network graph dataset).</p>"},{"location":"design_docs/architecture/workflows/","title":"Workflows","text":"<p>If we accept the premise that in the computational context we are really only interested in structured data, it follows that there must be also 'things' that do stuff to our structured data. Let's call those things 'workflows'.</p>"},{"location":"design_docs/architecture/workflows/#definition","title":"Definition","text":"<p>I will concede that 'doing stuff to data' although entirely accurate is probably not the most useful of definitions. Not Websters, all right? Well, how about:</p> <pre><code>\"A workflow is a tool to transform data into more structured data.\"\n</code></pre> <p>\"more\" can be read in one or all of those ways:</p> <ul> <li>'more data' -- we'll create what can be considered 'new' data out of the existing set</li> <li>'better structured' -- improve (and replace) the current structure (fix errors, etc.)</li> <li>'more structure' -- augment existing data with additional structure</li> </ul> <p>In our context, workflows can also have secondary outcomes:</p> <ul> <li>present data in different, more intuitive ways (e.g. visualisations), which researchers can use to get different ideas about the data, or new research questions</li> <li>convert structured data into equivalent structured data, just a different format (e.g csv to Excel spreadsheet)</li> <li>... (I'm sure there's more, just can't think of anything important right now)</li> </ul>"},{"location":"design_docs/architecture/workflows/#deconstructing-a-workflow","title":"Deconstructing a workflow","text":"<p>I've written more about it here, but conceptually, every data workflow is a collection of interconnected modules, where outputs of some modules are connected to inputs of some other modules. The resulting network graph of modules defines a workflow. That's even the case for Jupyter notebooks (which are really just fancy Python/R/Julia scripts); if you squint a bit you can see it: the modules are functions that you call with some inputs, and you use the outputs of those functions (stored in variables) as inputs to other functions. Move along, nothing to see here: this is really just how (most) programs work.</p> <p>As I see it, there are three main differences to programs that are written in 'normal' computer engineering:</p> <ul> <li>the complexity of the resulting interconnected 'network graph' (the interconnection of functions) is usually lower</li> <li>it's a tad easier (or at least possible) to define, separate and re-use the building blocks needed in a majority of workflows (an example would be Numpy or the Pandas libraries, which are basically implementations of abstract problems that crop up often in this domain)</li> <li>it is possible to create workflows entirely out of modules that were previously created, with no or almost no other customization (normally, that customization would be very prominent in a program) -- often-times only some 'glue' code is needed</li> </ul> <p>This means that data engineering workflows could be considered relatively simple script-like applications, where advanced concepts like Object-Oriented-Design, Encapsulation, DRY, YAGNI, ... are not necessary or relevant (in most cases they wouldn't hurt though).</p>"},{"location":"design_docs/architecture/workflows/#data-engineering","title":"Data engineering","text":"<p>This way of looking at workflows is nothing new, there are quite a few tools and projects in the data engineering space which deal with workflows in one level of abstraction or another.</p> <p>As I'll point out below, the main difference to what we try to implement is that we'll add an element of 'interactivity'. But I believe we can still learn a whole lot by looking at some aspects of those other tools. I encourage everyone remotely interested to look up some of those projects, and maybe not read the whole documentation, but at least the 'Why-we-created-yet-another-data-orchestrator', 'Why-we-are-better-than-comparable-projects' as well as 'What-we-learned'-type documentation pages you come across. 'I-tried-project-XXX-and-it-is-crap'-blog posts as well as hackernews comment-threads related to those projects are usually also interesting. The '/r/dataengineering' and '/r/datascience' sub-reddits are ok. But they are on Reddit, so, signal-to-noise is a bit, well..</p> <p>Among others, interesting projects include:</p> <ul> <li>dagster</li> <li>prefect</li> <li>airflow</li> <li> <p>luigi</p> </li> <li> <p>also relevant, but less data-engineering-y: Node-RED, Apache NiFi, IFTTT, Zapier, Huginn, ...</p> </li> </ul>"},{"location":"design_docs/architecture/workflows/#the-workflow-lifecycle","title":"The 'workflow lifecycle'","text":"<p>One thing that I think is also worth considering is the different stages in the lifecycle of a workflow. For illustration, I'll describe how each of those stages relates to the way data science is currently done with Jupyter, which is probably the most used tool in this space at the moment.</p>"},{"location":"design_docs/architecture/workflows/#workflow-creation","title":"Workflow creation","text":"<p>This is the act of designing and implementing a new workflow transformed into one or a set of defined outcomes (which can be new data, or just a visualization, doesn't matter). The actual creation of the workflow is similar to developing a script or application, and offers some freedom on how to implement it (e.g. which supporting libraries to choose, whether and which defaults to set, ...).</p> <p>In the Jupyter-case, this would be the iterative development of a Jupyter notebook, with one cell added after the other. One thing that is different for us is that we will have a much stricter definition of the desired outcome of our workflow, whereas the creation of a Jupyter notebook is typically way more open-ended, and a researcher would easily be able to 'follow some leads' they come across while working on the whole thing. This is a very important distinction that pays to keep in mind, and I can't emphasize this enough: the workflows we are dealing with are a lot more 'static' than typical Jupyter notebooks, because we have decided in advance which ones to implement, and how to implement them. There is not much we can do about this, and it's a trade-off with very little room to negotiate. This has a few important implications on how our product is different from how data science is done by Jupyter users currently. I will probably mention this again and again, because it is not intuitive at first, but has a big impact on how we view what we are building!</p> <p>As per our core assumptions, end-users won't create new workflows, this is done by a group with a yet-to-be-determined 'special' skill set.</p>"},{"location":"design_docs/architecture/workflows/#workflow-execution","title":"Workflow execution","text":"<p>This is when a 'finished' workflow gets run, with a set of inputs that are chosen by the user. The schema/type of those inputs is a requirement that has to be considered by the user. It's possible that a workflow allows for inputs to be in multiple formats, to make the users life easier (e.g. allow both '.csv' as well as '.json' formats), but that also has to be documented and communicated to users. It is not possible to add elements to a workflow, and make it do different things than it was designed to do. Our workflows are static, they never change (except in an 'iterative-development' sense where we release new versions)!</p> <p>Compare that to a researcher who created their own Jupyter notebook: they will have run the workflow itself countless times by then, while developing it. The execution phase is really only that last run that achieves the desired outcome, and which will 'fill' the notebook output cells with the final results. That notebook state is likely to be attached to a publication. Often the data is 'hardcoded' into the notebook itself (for example by adding the data itself in the git repo, and using a relative path to point to it in a notebook). It is also possible, although not as common (as far as I've seen -- I might be wrong here) that researchers spend a bit more time on the notebook and make the inputs easier to change, in order to be able to execute it with different parameters, quickly. This is more like what we will end up with, although I'd argue that the underlying workflow is still much easier to change, fix, and adapt than will be the case with our application.</p> <p>One difference between workflow creation and execution is that the creation part is more common for 'data scientists', and the execution part is a bigger concern for 'data engineers' (both do both, of course). I think, our specific problem sits more in the data engineering than data science space (because our main products are 'fixed'/'static' workflows), which is why I tend to look more for the tools used in that domain (data orchestrators, ...) than in the other (Jupyter, ..) when I look for guidance.</p>"},{"location":"design_docs/architecture/workflows/#workflow-publication","title":"Workflow publication","text":"<p>Once a workflow is run with a set of inputs that yield a meaningful outcome for a researcher, it can be attached to a publication in some way. This has one main purpose: to document and explain the research methodologies that were used, on a different level than 'just' plain language.</p> <p>There is a long-term, idealistic goal of being able to replicate results, but the general sentiment is that it is unrealistic to attempt that at this stage. It doesn't hurt to consider it a sort of 'guiding light', though.</p> <p>It is getting more and more common for researchers to attach Jupyter notebooks to a publication. Jupyter notebooks are a decent fit for this purpose, because the contain plain-text documentation, the actual code, as well as the output(s) of the code in a single file, that has a predictable, well specified format (json, along with a required document schema). As our colleagues at the DHJ project have discovered, it's not a perfect fit, but it can be bent to serve as the basis for a formal, digital publication.</p> <p>In our case, it is my understanding that we would like to have an artefact like this too, and even though it's not one of the 'core' requirements, it would be a very nice thing to have. One strong option is for us to re-use Jupyter notebooks for that. Depending on how we implement our solution, we might already have one as our core element that 'holds' a workflow, in which case this is a non-issue. Or, if that is not the case, we could 'render' a notebook from the metadata we have available, which should also not be too hard to do since the target (the notebook) is well spec'ed. If that's the case, there is one thing I'd like to investigate before we commit though: what characteristics exactly are the ones that make notebooks a good choice for that, and which one are detrimental? As I've mentioned, the DHJ project uses notebooks as the base for creating article-(web)pages, and they came across some issues along the way. So I wonder: is there a better way to achieve the 'document and explain research methodologies' goal than by using a Jupyter notebook? How would that look in a perfect world? How much effort would be involved?</p>"},{"location":"design_docs/architecture/workflows/#interactivity-long-ish-running-computations","title":"Interactivity / Long(-ish) running computations","text":"<p>One component that is different in our scenario to other implementations is the requirement for interactivity. In data-engineering, this is never an issue, you describe your pipeline, then you or someone else uses that with a set of inputs, and off it goes, without any further interaction. Plomp, notification, results, rinse, repeat.</p> <p>For us that will be different, because we are creating a graphical user interface that reflects the workflow, and its state. By definition, graphical user interfaces are interactive, and when a user triggers an action, they expect that to kick off some instant response in the UI (maybe the change in a visualization, or a progress indicator, whatever).</p>"},{"location":"design_docs/architecture/workflows/#computationally-trivialnon-trivial","title":"Computationally trivial/non-trivial","text":"<p>One main difficulty will be to find a good visual way to express what is happening to the user, ideally in the same way for 2 different scenarios:</p> <ul> <li>computations that are computationally trivial, and will return a result back in a few seconds at most</li> <li>computations that take longer</li> </ul> <p>In our workflows, I can see a few different ways those interactions can play out, depending on the characteristics of any particular workflow.</p> <p>So, in the case where a user 'uploads' data or changes a setting:</p> <ul> <li> <p>if the whole workflow is trivial, computationally:</p> <ul> <li>this triggers the whole workflow to execute and return with a new state/result immediately, and the output elements reflect the new state without any noticable delay</li> </ul> </li> <li> <p>if only some (or no) components of the workflows are trivial, computationally:</p> <ul> <li>this triggers the execution of only parts of the workflow immediately (from the point of user input to the next non-trivial step of the workflow).</li> <li>all computationally non-trivial parts of the workflow will have some sort of \"Process\" button that users have to click manually to kick off those parts of the workflow. Otherwise the UI would be locked for an undefined amount of time after every user input -- which would result in a very bad UX).</li> <li>alternatively, workflows with computationally non-trivial parts could have one 'global' \"Process\" button, which would trigger the execution of the whole workflow with all current inputs/settings.</li> </ul> </li> </ul> <p>There will be also inputs that don't directly kick off any processing (like for example control buttons in a visualisation). I think we can ignore those for now, because this is what UIs usually do, and this does not present a difficulty in terms of the overall UI/UX (just like the 'computationally trivial' workflow scenario).</p>"},{"location":"design_docs/architecture/workflows/#ui-representations-for-the-current-workflow-state","title":"UI representations for the current workflow state","text":""},{"location":"design_docs/architecture/workflows/#tldr","title":"tldr;","text":"<p>In some cases it will be impossible for users to use a workflow fully interactively, because one or all workflow steps will take too much time, which means the interactive session has to be interrupted. In those cases (depending on our setup and other circumstances) we might need to include a 'job-management'/'queue' component to our application, which matches running/completed jobs to users and 'sessions'/'experiments' (for lack of a better word). We need to find a visual metaphors for workflows and workflow steps to make that intuitive, ideally in a way so that those scenarios are not handled too differently in comparison to how our 100%-interactive workflows are used and executed. In addition, we have to make sure our backend can deal with all the scenarios we want to support.</p>"},{"location":"design_docs/architecture/workflows/#details-skip-if-you-want","title":"Details, skip if you want","text":"<p>I'll include some suggestions on how all this could look visually, but those are in no way to be taken as gospel. Just the most obvious (to me) visual elements to use, which I hope will make it easier to get my point across. It's probably obvious that the important cases we have to care about are the ones where there is non-trivial computation. I think we can roughly divide them into 4 categories:</p> <ul> <li>execution time of a few seconds:<ul> <li>in this case a 'spinning-wheel'-progress indidcator is probably enough</li> <li>backend-wise, we (probably) don't have to worry (although, it's not a given this will not crash a hosted app if we have too many users and computations are executed 'in-line')</li> </ul> </li> <li>execution time of a few minutes:<ul> <li>not long enough so that for example a browser session would expire</li> <li>in this case it would be good UX-wise to have a semi-exact progress indicator that either shows a 'done'-percentage, or remaining time</li> <li>on the backend-side, we need to separate three scenarios:<ul> <li>local app:<ul> <li>the computation can happen locally, either in a new thread, or a different process (we can also make use of multiple cores if available)</li> </ul> </li> <li>hosted jupyter in some form or other:<ul> <li>the running Jupyter kernel can execute the computation, which is probably a good enough separation to not affect the hosted UI</li> </ul> </li> <li>hosted web app:<ul> <li>there needs to exist some infrastructure we can use to offload the computation, it can't run on the same host as our service (which means a lot of added complexity)</li> <li>there is no need yet for authentication apart from that we need to be able to assign the result of the computation to individual sessions</li> </ul> </li> </ul> </li> </ul> </li> <li>execution time of a few hours:<ul> <li>long enough that a user will have left the computer in between, or closed a browser, etc.</li> <li>now the separation of backend-scenarios kicks in earlier, and also affects the front-end:<ul> <li>local app:<ul> <li>as in the case before, the UI would display a progress-indicator of some sort</li> <li>the computation would happen as a background process, and as long as the user does not shut-down or restart the   computer there is no issue (the job should even survive a suspend/hibernate)</li> </ul> </li> <li>hosted jupyter:<ul> <li>difficult to say, the computation could either still happen in the running Jupyter kernel, or would have to be farmed out to an external service</li> <li>one issue to be aware of is that, depending on how it is configured, Jupyter might or might not kill a notebook process (and underlying kernel)   if there has been no activity in the browser for a while. We'd have to make sure this does not happen, or that we have some sort of user session   management (which should be entirely possible -- but of course increases complexity by quite a bit). The latter will also be necessary if a user   comes back to their session after having been disconnected in some way, because otherwise they'd loose their result.</li> <li>ui-wise there needs to be session and compute-job management, and a list of currently running and past jobs and links to the experiments that produced them</li> </ul> </li> <li>hosted web app:<ul> <li>as with the jupyter case, we'll need session as well as job management</li> </ul> </li> </ul> </li> </ul> </li> <li>execution time of more than a few hours (days, weeks):<ul> <li>in all cases the computation now needs to be outsourced, and submitted to a compute service (cloud, HPC, local dask-cluster, whatever...)</li> <li>all cases need to implement some sort of session authentication and job management (which would probably be a bit more transparent to the user in the local case, but overall it would be implemented in a similar way in each scenario)</li> </ul> </li> </ul>"},{"location":"design_docs/architecture/workflows/#externally-running-computations","title":"Externally running computations","text":"<p>One thing to stress is that 'outsourcing' computationally intensive tasks comes with a considerable amount of complexity. Nothing that can't be implemented, and there are several ways I can think of to do this. I'd still advise to be very aware of the cost and complexity this incurs. I do believe we will have to add that in some form at some stage though, if we are in any way successful and have people adopting our solution. Which means we have to include the issue in our architecture design, even if we only plan to implement it later.</p>"},{"location":"development/","title":"Development","text":"<p>This page is a work in progress, its purpose is to provide an overview of the relevant parts of kiara, as well as links to further information.</p>"},{"location":"development/#basics","title":"Basics","text":"<ul> <li>Getting started: A quick (end-user) introduction to kiara.</li> </ul>"},{"location":"development/#install-a-development-environment","title":"Install a development environment","text":"<ul> <li>install dev env</li> </ul>"},{"location":"development/#create-a-kiara-plugin-package","title":"Create a kiara plugin package","text":"<ul> <li><code>kiara_plugin.develop repo</code></li> </ul>"},{"location":"development/#create-a-kiara-module","title":"Create a kiara module","text":"<ul> <li>create module</li> </ul>"},{"location":"development/#creeae-a-kiara-pipeline","title":"Creeae a kiara pipeline","text":"<ul> <li>create pipeline</li> </ul>"},{"location":"development/SUMMARY/","title":"SUMMARY","text":"<ul> <li>*</li> <li>*/</li> </ul>"},{"location":"development/install/","title":"Install development environment","text":""},{"location":"development/install/#python-package","title":"Python package","text":"<pre><code>&gt; python3 -m venv ~/.venvs/kiara\n&gt; source ~/.venvs/kiara/bin/activate\n&gt; pip install 'kiara[dev_all]'\n...\n...\n...\nSuccessfully installed ... ... ...\n&gt; kiara --help\nUsage: kiara [OPTIONS] COMMAND [ARGS]...\n   ...\n   ...\n</code></pre> <p>In addition to the <code>kiara</code> package, you'll need to install plugin packages, for example:</p> <pre><code>&gt; pip install kiara_plugin.core_types kiara_plugin.tabular\n</code></pre>"},{"location":"development/install/#conda","title":"Conda","text":"<pre><code>&gt; conda create -n kiara python=3.10\n&gt; conda activate kiara\n&gt; conda install -c conda-forge -c dharpa kiara\n</code></pre> <p>And also plugin packages, like:</p> <pre><code>&gt; conda install -c conda-forge -c dharpa kiara_plugin.core_types kiara_plugin.tabular\n</code></pre> <p>Note, the conda install does not include development dependencies, so you'll need to either install those manually, or use pip:</p> <pre><code>&gt; pip install 'kiara[dev_all]'\n</code></pre>"},{"location":"development/modules/SUMMARY/","title":"SUMMARY","text":"<ul> <li>*</li> <li>*/</li> </ul>"},{"location":"development/modules/render_value/","title":"Modules","text":""},{"location":"development/modules/render_value/#create-a-module-that-renders-a-value-of-a-custom-data-type","title":"Create a module that renders a value of a custom data type","text":"<p>When you create a new data type, by default kiara does not know how to render it for specific target(s) (html, terminal, ...). Which means you'll have to create a module for each of the targets you want to support. kiara uses the custom <code>render_value</code> operation type for this.</p> <p>There are multiple ways to implement support for rendering a new data type, the easiest one is to add a method with the following signature to the data type class:</p> <pre><code>    def render_as__&lt;target_type&gt;(\n        self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n    ) -&gt; &lt;target_type_cls&gt;:\n        ...\n        ...\n</code></pre> <p>So, to implement terminal rendering, that would be:</p> <pre><code>    def render_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n    ) -&gt; RenderableType:\n        ...\n        ...\n</code></pre> <p>As an example, here's how to implement basic rendering of a 'dict' value:</p>"},{"location":"included_components/","title":"Summary","text":""},{"location":"included_components/#package-content","title":"Package content","text":"<p>The kiara main package also contains basic, low-level data-types, modules and operations that are necessary for its core functionality. This page lists all of them.</p>"},{"location":"included_components/#data_types","title":"data_types","text":"<ul> <li> <p><code>any</code>: 'Any' type, the parent type for most other types.</p> </li> <li> <p><code>boolean</code>: A boolean.</p> </li> <li> <p><code>bytes</code>: An array of bytes.</p> </li> <li> <p><code>dict</code>: A dictionary.</p> </li> <li> <p><code>doc</code>: Documentation for an internal entity.</p> </li> <li> <p><code>file</code>: A file.</p> </li> <li> <p><code>file_bundle</code>: A bundle of files (like a folder, zip archive, etc.).</p> </li> <li> <p><code>internal</code>: 'A 'marker' base data type for data types that are (mainly) used internally in kiara..</p> </li> <li> <p><code>internal_model</code>: A value type that is used internally.</p> </li> <li> <p><code>none</code>: Type indicating a 'None' value</p> </li> <li> <p><code>python_object</code>: A 'plain' Python object.</p> </li> <li> <p><code>render_scene</code>: A value type to contain information about how to render a value in a specific render scenario.</p> </li> <li> <p><code>render_value_result</code>: A value type to contain information about how to render a value in a specific render scenario.</p> </li> <li> <p><code>string</code>: A string.</p> </li> <li> <p><code>terminal_renderable</code>: A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter.</p> </li> </ul>"},{"location":"included_components/#module_types","title":"module_types","text":"<ul> <li> <p><code>deserialize.file</code>: Deserialize data to a 'file' value instance.</p> </li> <li> <p><code>deserialize.file_bundle</code>: Deserialize data to a 'file' value instance.</p> </li> <li> <p><code>deserialize.from_json</code>: -- n/a --</p> </li> <li> <p><code>export.file</code>: Export files.</p> </li> <li> <p><code>file_bundle.pick.file</code>: Pick a single file from a file_bundle value.</p> </li> <li> <p><code>file_bundle.pick.sub_folder</code>: Pick a sub-folder from a file_bundle, resulting in a new file_bundle.</p> </li> <li> <p><code>import.local.file</code>: Import a file from the local filesystem.</p> </li> <li> <p><code>import.local.file_bundle</code>: Import a folder (file_bundle) from the local filesystem.</p> </li> <li> <p><code>load.bytes</code>: -- n/a --</p> </li> <li> <p><code>load.internal_model</code>: -- n/a --</p> </li> <li> <p><code>load.string</code>: -- n/a --</p> </li> <li> <p><code>pipeline</code>: A utility module to run multiple connected inner-modules and present it as its own entity.</p> </li> <li> <p><code>pretty_print.any.value</code>: -- n/a --</p> </li> <li> <p><code>pretty_print.value</code>: -- n/a --</p> </li> <li> <p><code>render.value</code>: A module that uses render methods attached to DataType classes.</p> </li> <li> <p><code>unpickle.value</code>: -- n/a --</p> </li> <li> <p><code>value.extract_metadata</code>: Base class to use when writing a module to extract metadata from a file.</p> </li> </ul>"},{"location":"included_components/#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>instance.module_config</code>: Base class that describes the configuration a <code>KiaraModule</code> class accepts.</p> </li> <li> <p><code>instance.module_config.pipeline</code>: A class to hold the configuration for a PipelineModule.</p> </li> <li> <p><code>instance.manifest</code>: A class to hold the type and configuration for a module instance.</p> </li> <li> <p><code>instance.manifest_with_inputs</code>: -- n/a --</p> </li> <li> <p><code>instance.job_config</code>: -- n/a --</p> </li> <li> <p><code>instance.job_record</code>: -- n/a --</p> </li> <li> <p><code>instance.value_pedigree</code>: -- n/a --</p> </li> <li> <p><code>instance.pipeline_step</code>: A step within a pipeline-structure, includes information about it's connection(s) and other metadata.</p> </li> <li> <p><code>instance.operation</code>: -- n/a --</p> </li> <li> <p><code>instance.destiny</code>: A destiny is basically a link to a potential future transformation result involving one or several values as input.</p> </li> <li> <p><code>metadata.authors</code>: Information about all authors of a resource.</p> </li> <li> <p><code>metadata.context</code>: Information about the context of a resource.</p> </li> <li> <p><code>metadata.documentation</code>: Documentation about a resource.</p> </li> <li> <p><code>instance.value_schema</code>: The schema of a value.</p> </li> <li> <p><code>instance.execution_context</code>: -- n/a --</p> </li> <li> <p><code>instance.active_job</code>: -- n/a --</p> </li> <li> <p><code>instance.wrapped_python_class</code>: Python class and module information.</p> </li> <li> <p><code>metadata.kiara_module_class</code>: -- n/a --</p> </li> <li> <p><code>metadata.serialized_data</code>: -- n/a --</p> </li> <li> <p><code>instance.serialization_result</code>: -- n/a --</p> </li> <li> <p><code>instance.persisted_data</code>: -- n/a --</p> </li> <li> <p><code>info.data_type_instance</code>: -- n/a --</p> </li> <li> <p><code>instance.value_details</code>: A wrapper class that manages and retieves value data and its details.</p> </li> <li> <p><code>instance.value</code>: -- n/a --</p> </li> <li> <p><code>instance.unloadable_data</code>: A special 'marker' model, indicating that the data of value can't be loaded.</p> </li> <li> <p><code>instance.value_map.readonly</code>: -- n/a --</p> </li> <li> <p><code>instance.value_map.writeable</code>: -- n/a --</p> </li> <li> <p><code>instance.value_map.aliases</code>: A model class that holds a tree of values and their schemas.</p> </li> <li> <p><code>info.runtime.python</code>: -- n/a --</p> </li> <li> <p><code>info.runtime.kiara_plugins</code>: -- n/a --</p> </li> <li> <p><code>info.runtime.kiara_types</code>: -- n/a --</p> </li> <li> <p><code>info.runtime.os</code>: Manages information about the OS this kiara instance is running in.</p> </li> <li> <p><code>instance.operation_details</code>: -- n/a --</p> </li> <li> <p><code>instance.operation_details.base</code>: -- n/a --</p> </li> <li> <p><code>instance.operation_config.manifest</code>: -- n/a --</p> </li> <li> <p><code>instance.operation_config.pipeline</code>: -- n/a --</p> </li> <li> <p><code>filter</code>: -- n/a --</p> </li> <li> <p><code>info.pipeline_stage</code>: -- n/a --</p> </li> <li> <p><code>pipeline_stages</code>: -- n/a --</p> </li> <li> <p><code>info.pipeline_step</code>: -- n/a --</p> </li> <li> <p><code>instance.pipeline_structure</code>: An object that holds one or several steps, and describes the connections between them.</p> </li> <li> <p><code>info.archive_type</code>: -- n/a --</p> </li> <li> <p><code>info.metadata_type</code>: -- n/a --</p> </li> <li> <p><code>info.pipeline</code>: -- n/a --</p> </li> <li> <p><code>info.workflow</code>: -- n/a --</p> </li> <li> <p><code>archive_info</code>: -- n/a --</p> </li> <li> <p><code>info.archive_types</code>: -- n/a --</p> </li> <li> <p><code>info.metadata_types</code>: -- n/a --</p> </li> <li> <p><code>info.workflows</code>: -- n/a --</p> </li> <li> <p><code>info.archives</code>: -- n/a --</p> </li> <li> <p><code>instance.pipeline_state</code>: -- n/a --</p> </li> <li> <p><code>instance.render_scene</code>: -- n/a --</p> </li> <li> <p><code>render_value_result</code>: Object containing all the result properties of a 'render_value' operation.</p> </li> <li> <p><code>value_matcher</code>: An object describing requirements values should satisfy in order to be included in a query result.</p> </li> <li> <p><code>workflow_state</code>: -- n/a --</p> </li> <li> <p><code>instance.workflow</code>: -- n/a --</p> </li> <li> <p><code>context_info</code>: -- n/a --</p> </li> <li> <p><code>metadata.python_class</code>: Python class and module information.</p> </li> <li> <p><code>metadata.file</code>: File stats.</p> </li> <li> <p><code>metadata.file_bundle</code>: File bundle stats.</p> </li> <li> <p><code>instance.data.file</code>: Describes properties for the 'file' value type.</p> </li> <li> <p><code>instance.data.file_bundle</code>: Describes properties for the 'file_bundle' value type.</p> </li> <li> <p><code>info.kiara_model</code>: -- n/a --</p> </li> <li> <p><code>info.data_type</code>: -- n/a --</p> </li> <li> <p><code>info.kiara_module_type</code>: -- n/a --</p> </li> <li> <p><code>info.operation_type</code>: -- n/a --</p> </li> <li> <p><code>info.value</code>: -- n/a --</p> </li> <li> <p><code>info.pipeline_structure</code>: -- n/a --</p> </li> <li> <p><code>info.operation</code>: -- n/a --</p> </li> <li> <p><code>renderer_info</code>: -- n/a --</p> </li> <li> <p><code>info.kiara_models</code>: -- n/a --</p> </li> <li> <p><code>info.data_types</code>: -- n/a --</p> </li> <li> <p><code>info.module_types</code>: -- n/a --</p> </li> <li> <p><code>info.operation_types</code>: -- n/a --</p> </li> <li> <p><code>values_info</code>: -- n/a --</p> </li> <li> <p><code>info.operations</code>: -- n/a --</p> </li> <li> <p><code>renderer_infos</code>: -- n/a --</p> </li> <li> <p><code>metadata.module_config</code>: -- n/a --</p> </li> <li> <p><code>workflow_matcher</code>: An object describing requirements values should satisfy in order to be included in a query result.</p> </li> </ul>"},{"location":"included_components/#operation_types","title":"operation_types","text":"<ul> <li> <p><code>create_from</code>: -- n/a --</p> </li> <li> <p><code>custom_module</code>: -- n/a --</p> </li> <li> <p><code>deserialize</code>: An operation that takes a value, and serializes it into the format suitable to the <code>serialized_value</code> value type.</p> </li> <li> <p><code>export_as</code>: -- n/a --</p> </li> <li> <p><code>extract_metadata</code>: An operation that extracts metadata of a specific type from value data.</p> </li> <li> <p><code>filter</code>: -- n/a --</p> </li> <li> <p><code>import_data</code>: -- n/a --</p> </li> <li> <p><code>pipeline</code>: -- n/a --</p> </li> <li> <p><code>pretty_print</code>: An operation that takes a value, and renders into a format that can be printed for output..</p> </li> <li> <p><code>render_value</code>: An operation that renders a value.</p> </li> </ul>"},{"location":"included_components/#operations","title":"operations","text":"<ul> <li> <p><code>deserialize.bytes.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.file.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.file_bundle.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.from_json</code>: -- n/a --</p> </li> <li> <p><code>deserialize.internal_model.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.string.as.python_object</code>: -- n/a --</p> </li> <li> <p><code>deserialize.value</code>: -- n/a --</p> </li> <li> <p><code>export.file.as.file</code>: -- n/a --</p> </li> <li> <p><code>extract.file.metadata.from.file</code>: Extract 'file' metadata for value type 'file'.</p> </li> <li> <p><code>extract.file_bundle.metadata.from.file_bundle</code>: Extract 'file_bundle' metadata for value type 'file_bundle'.</p> </li> <li> <p><code>extract.python_class.metadata</code>: Extract 'python_class' metadata for value type 'any'.</p> </li> <li> <p><code>file_bundle.pick.file</code>: Pick a single file from a file_bundle value.</p> </li> <li> <p><code>file_bundle.pick.sub_folder</code>: Pick a sub-folder from a file_bundle, resulting in a new file_bundle.</p> </li> <li> <p><code>import.local.file</code>: Import a file from the local filesystem.</p> </li> <li> <p><code>import.local.file_bundle</code>: Import a folder (file_bundle) from the local filesystem.</p> </li> <li> <p><code>pretty_print.as.string</code>: Pretty print a any value as a string.</p> </li> <li> <p><code>pretty_print.as.terminal_renderable</code>: Pretty print a any value as a terminal_renderable.</p> </li> <li> <p><code>pretty_print.internal.as.string</code>: Pretty print a internal value as a string.</p> </li> <li> <p><code>pretty_print.internal.as.terminal_renderable</code>: Pretty print a internal value as a terminal_renderable.</p> </li> <li> <p><code>pretty_print.none.as.string</code>: Pretty print a none value as a string.</p> </li> <li> <p><code>pretty_print.none.as.terminal_renderable</code>: Pretty print a none value as a terminal_renderable.</p> </li> <li> <p><code>pretty_print.string.as.bytes</code>: Pretty print a string value as a bytes.</p> </li> <li> <p><code>render.as.string</code>: Render a 'any' value as a string.</p> </li> <li> <p><code>render.as.terminal_renderable</code>: Render a 'any' value as a terminal_renderable.</p> </li> <li> <p><code>render.dict.as.terminal_renderable</code>: Render a 'dict' value as a terminal_renderable.</p> </li> <li> <p><code>render.internal.as.string</code>: Render a 'internal' value as a string.</p> </li> <li> <p><code>render.internal.as.terminal_renderable</code>: Render a 'internal' value as a terminal_renderable.</p> </li> </ul>"},{"location":"included_components/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Summary</li> <li>data_types</li> <li>module_types</li> <li>kiara_model_types</li> <li>operation_types</li> <li>operations</li> </ul>"},{"location":"included_components/data_types/","title":"data_types","text":""},{"location":"included_components/data_types/#kiara_info.data_types.any","title":"<code>any</code>","text":"type_name any The registered name for this item type. documentation description 'Any' type, the parent type for most other types. Short description of the item. doc This type acts as the parents for all (or at least most) non-internal value types. There are some generic operations (like 'persist_value', or 'pretty_print') which are implemented for this type, so it's descendents have a fallback option in case no subtype-specific operations are implemented for it. In general, it is not recommended to use the 'any' type as module input or output, but it is possible. Values of type 'any' are not allowed to be persisted (at the moment, this might or might not change). Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that implements this module type. value_cls python_class_name object The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name object The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.boolean","title":"<code>boolean</code>","text":"type_name boolean The registered name for this item type. documentation description A boolean. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name BooleanType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.BooleanType The full class namespace. The python class that implements this module type. value_cls python_class_name bool The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name bool The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     boolean   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.bytes","title":"<code>bytes</code>","text":"type_name bytes The registered name for this item type. documentation description An array of bytes. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name BytesType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.BytesType The full class namespace. The python class that implements this module type. value_cls python_class_name bytes The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name bytes The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     bytes   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.dict","title":"<code>dict</code>","text":"type_name dict The registered name for this item type. documentation description A dictionary. Short description of the item. doc In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. This data type is backed by the [DictModel][kiara_plugin.core_types.models.DictModel] class. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that implements this module type. value_cls python_class_name DictModel The name of the Python class. python_module_name kiara.models.data_types The name of the Python module this class lives in. full_name kiara.models.data_types.DictModel The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     dict   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.doc","title":"<code>doc</code>","text":"type_name doc The registered name for this item type. documentation description Documentation for an internal entity. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DocumentationModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.DocumentationModelValueType The full class namespace. The python class that implements this module type. value_cls python_class_name DocumentationMetadataModel The name of the Python class. python_module_name kiara.models.documentation The name of the Python module this class lives in. full_name kiara.models.documentation.DocumentationMetadataModel The full class namespace. The python class of the value itself. data_type_config_cls python_class_name InternalModelTypeConfig The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     doc   </li> <li>     internal_model   </li> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.file","title":"<code>file</code>","text":"type_name file The registered name for this item type. documentation description A file. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that implements this module type. value_cls python_class_name FileModel The name of the Python class. python_module_name kiara.models.filesystem The name of the Python module this class lives in. full_name kiara.models.filesystem.FileModel The full class namespace. The python class of the value itself. data_type_config_cls python_class_name FileTypeConfig The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     file   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles csv_file type_name file type_config content_type csv json_file type_name file type_config content_type json text_file type_name file type_config content_type text binary_file type_name file type_config content_type binary A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.file_bundle","title":"<code>file_bundle</code>","text":"type_name file_bundle The registered name for this item type. documentation description A bundle of files (like a folder, zip archive, etc.). Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that implements this module type. value_cls python_class_name FileBundle The name of the Python class. python_module_name kiara.models.filesystem The name of the Python module this class lives in. full_name kiara.models.filesystem.FileBundle The full class namespace. The python class of the value itself. data_type_config_cls python_class_name FileTypeConfig The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     file_bundle   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles csv_file_bundle type_name file_bundle type_config content_type csv json_file_bundle type_name file_bundle type_config content_type json text_file_bundle type_name file_bundle type_config content_type text binary_file_bundle type_name file_bundle type_config content_type binary A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.internal","title":"<code>internal</code>","text":"type_name internal The registered name for this item type. documentation description 'A 'marker' base data type for data types that are (mainly) used internally in kiara.. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that implements this module type. value_cls python_class_name object The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name object The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.internal_model","title":"<code>internal_model</code>","text":"type_name internal_model The registered name for this item type. documentation description A value type that is used internally. Short description of the item. doc This type should not be used by user-facing modules and/or operations. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name InternalModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelValueType The full class namespace. The python class that implements this module type. value_cls python_class_name KiaraModel The name of the Python class. python_module_name kiara.models The name of the Python module this class lives in. full_name kiara.models.KiaraModel The full class namespace. The python class of the value itself. data_type_config_cls python_class_name InternalModelTypeConfig The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     internal_model   </li> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.none","title":"<code>none</code>","text":"type_name none The registered name for this item type. documentation description Type indicating a 'None' value Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NoneType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.NoneType The full class namespace. The python class that implements this module type. value_cls python_class_name SpecialValue The name of the Python class. python_module_name kiara.defaults The name of the Python module this class lives in. full_name kiara.defaults.SpecialValue The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     none   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.internal","title":"<code>internal</code>","text":"type_name internal The registered name for this item type. documentation description 'A 'marker' base data type for data types that are (mainly) used internally in kiara.. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that implements this module type. value_cls python_class_name object The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name object The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.render_scene","title":"<code>render_scene</code>","text":"type_name render_scene The registered name for this item type. documentation description A value type to contain information about how to render a value in a specific render scenario. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderSceneDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType The full class namespace. The python class that implements this module type. value_cls python_class_name RenderScene The name of the Python class. python_module_name kiara.models.rendering The name of the Python module this class lives in. full_name kiara.models.rendering.RenderScene The full class namespace. The python class of the value itself. data_type_config_cls python_class_name RenderSceneTypeConfig The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderSceneTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     render_scene   </li> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.render_value_result","title":"<code>render_value_result</code>","text":"type_name render_value_result The registered name for this item type. documentation description A value type to contain information about how to render a value in a specific render scenario. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that implements this module type. value_cls python_class_name RenderValueResult The name of the Python class. python_module_name kiara.models.rendering The name of the Python module this class lives in. full_name kiara.models.rendering.RenderValueResult The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     render_value_result   </li> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.string","title":"<code>string</code>","text":"type_name string The registered name for this item type. documentation description A string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that implements this module type. value_cls python_class_name str The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name str The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     string   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/data_types/#kiara_info.data_types.terminal_renderable","title":"<code>terminal_renderable</code>","text":"type_name terminal_renderable The registered name for this item type. documentation description A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter. Short description of the item. doc Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name TerminalRenderable The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.TerminalRenderable The full class namespace. The python class that implements this module type. value_cls python_class_name object The name of the Python class. python_module_name builtins The name of the Python module this class lives in. full_name object The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     terminal_renderable   </li> <li>     internal   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types."},{"location":"included_components/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.module_config","title":"<code>instance.module_config</code>","text":"type_name instance.module_config The registered name for this item type. documentation description Base class that describes the configuration a [``KiaraModule``][kiara.module.KiaraModule] class accepts. Short description of the item. doc This is stored in the ``_config_cls`` class attribute in each ``KiaraModule`` class.  There are two config options every ``KiaraModule`` supports:   - ``constants``, and  - ``defaults``   Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default  values that override the schema defaults, and those can be overwritten by users. If both a constant and a default  value is set for an input field, an error is thrown. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraModuleConfig The name of the Python class. python_module_name kiara.models.module The name of the Python module this class lives in. full_name kiara.models.module.KiaraModuleConfig The full class namespace. The python class that implements this module type. metadata_schema title KiaraModuleConfig description Base class that describes the configuration a [``KiaraModule``][kiara.module.KiaraModule] class accepts.  This is stored in the ``_config_cls`` class attribute in each ``KiaraModule`` class.  There are two config options every ``KiaraModule`` supports:   - ``constants``, and  - ``defaults``   Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default  values that override the schema defaults, and those can be overwritten by users. If both a constant and a default  value is set for an input field, an error is thrown. type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.module_config.pipeline","title":"<code>instance.module_config.pipeline</code>","text":"type_name instance.module_config.pipeline The registered name for this item type. documentation description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule]. Short description of the item. doc If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineConfig The name of the Python class. python_module_name kiara.models.module.pipeline The name of the Python module this class lives in. full_name kiara.models.module.pipeline.PipelineConfig The full class namespace. The python class that implements this module type. metadata_schema title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.manifest","title":"<code>instance.manifest</code>","text":"type_name instance.manifest The registered name for this item type. documentation description A class to hold the type and configuration for a module instance. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name Manifest The name of the Python class. python_module_name kiara.models.module.manifest The name of the Python module this class lives in. full_name kiara.models.module.manifest.Manifest The full class namespace. The python class that implements this module type. metadata_schema title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.manifest_with_inputs","title":"<code>instance.manifest_with_inputs</code>","text":"type_name instance.manifest_with_inputs The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name InputsManifest The name of the Python class. python_module_name kiara.models.module.manifest The name of the Python module this class lives in. full_name kiara.models.module.manifest.InputsManifest The full class namespace. The python class that implements this module type. metadata_schema title InputsManifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid required <ul> <li>     module_type   </li> <li>     inputs   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.job_config","title":"<code>instance.job_config</code>","text":"type_name instance.job_config The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name JobConfig The name of the Python class. python_module_name kiara.models.module.jobs The name of the Python module this class lives in. full_name kiara.models.module.jobs.JobConfig The full class namespace. The python class that implements this module type. metadata_schema title JobConfig description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid required <ul> <li>     module_type   </li> <li>     inputs   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.job_record","title":"<code>instance.job_record</code>","text":"type_name instance.job_record The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name JobRecord The name of the Python class. python_module_name kiara.models.module.jobs The name of the Python module this class lives in. full_name kiara.models.module.jobs.JobRecord The full class namespace. The python class that implements this module type. metadata_schema title JobRecord description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid job_id title Job Id description The globally unique id for this job. type string format uuid environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object inputs_data_hash title Inputs Data Hash description A map of the hashes of this jobs inputs. type string outputs title Outputs description References to the job outputs. type object additionalProperties type string format uuid runtime_details title Runtime Details description Runtime details for the job. allOf <ul> <li> $ref #/definitions/JobRuntimeDetails </li> </ul> job_metadata title Job Metadata description Optional metadata for this job. type object required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     job_id   </li> <li>     environment_hashes   </li> <li>     outputs   </li> </ul> additionalProperties False definitions LogMessage title LogMessage type object properties timestamp title Timestamp description The time the message was logged. type string format date-time log_level title Log Level description The log level. type integer msg title Msg description The log message type string required <ul> <li>     log_level   </li> <li>     msg   </li> </ul> JobLog title JobLog type object properties log title Log description The logs for this job. type array items $ref #/definitions/LogMessage percent_finished title Percent Finished description Describes how much of the job is finished. A negative number means the module does not support progress tracking. default -1 type integer JobRuntimeDetails title JobRuntimeDetails type object properties job_log title Job Log description The lob jog. allOf <ul> <li> $ref #/definitions/JobLog </li> </ul> submitted title Submitted description When the job was submitted. type string format date-time started title Started description When the job was started. type string format date-time finished title Finished description When the job was finished. type string format date-time runtime title Runtime description The duration of the job. type number required <ul> <li>     job_log   </li> <li>     submitted   </li> <li>     started   </li> <li>     finished   </li> <li>     runtime   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_pedigree","title":"<code>instance.value_pedigree</code>","text":"type_name instance.value_pedigree The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValuePedigree The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.ValuePedigree The full class namespace. The python class that implements this module type. metadata_schema title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.pipeline_step","title":"<code>instance.pipeline_step</code>","text":"type_name instance.pipeline_step The registered name for this item type. documentation description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineStep The name of the Python class. python_module_name kiara.models.module.pipeline The name of the Python module this class lives in. full_name kiara.models.module.pipeline.PipelineStep The full class namespace. The python class that implements this module type. metadata_schema title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.operation","title":"<code>instance.operation</code>","text":"type_name instance.operation The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name Operation The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.Operation The full class namespace. The python class that implements this module type. metadata_schema title Operation description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean operation_id title Operation Id description The (unique) id of this operation. type string operation_details title Operation Details description The operation specific details of this operation. allOf <ul> <li> $ref #/definitions/OperationDetails </li> </ul> doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> metadata title Metadata description Additional metadata for this operation. type object required <ul> <li>     module_type   </li> <li>     operation_id   </li> <li>     operation_details   </li> <li>     doc   </li> <li>     module_details   </li> </ul> additionalProperties False definitions OperationDetails title OperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean required <ul> <li>     operation_id   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.destiny","title":"<code>instance.destiny</code>","text":"type_name instance.destiny The registered name for this item type. documentation description A destiny is basically a link to a potential future transformation result involving one or several values as input. Short description of the item. doc It is immutable, once executed, each of the input values can only have one destiny with a specific alias. This is similar to what is usually called a 'future' in programming languages, but more deterministic, sorta. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name Destiny The name of the Python class. python_module_name kiara.models.module.destiny The name of the Python module this class lives in. full_name kiara.models.module.destiny.Destiny The full class namespace. The python class that implements this module type. metadata_schema title Destiny description A destiny is basically a link to a potential future transformation result involving one or several values as input.  It is immutable, once executed, each of the input values can only have one destiny with a specific alias. This is similar to what is usually called a 'future' in programming languages, but more deterministic, sorta. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean destiny_id title Destiny Id description The id of this destiny. type string format uuid destiny_alias title Destiny Alias description The path to (the) destiny. type string module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> fixed_inputs title Fixed Inputs description Inputs that are known in advance. type object additionalProperties type string format uuid inputs_schema title Inputs Schema description The schemas of all deferred input fields. type object additionalProperties $ref #/definitions/ValueSchema deferred_inputs title Deferred Inputs description Potentially required external inputs that are needed for this destiny to materialize. type object additionalProperties type string format uuid result_field_name title Result Field Name description The name of the result field. type string result_schema title Result Schema description The value schema of the result. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> result_value_id title Result Value Id description The value id of the result. type string format uuid required <ul> <li>     module_type   </li> <li>     destiny_id   </li> <li>     destiny_alias   </li> <li>     module_details   </li> <li>     fixed_inputs   </li> <li>     inputs_schema   </li> <li>     deferred_inputs   </li> <li>     result_field_name   </li> <li>     result_schema   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.authors","title":"<code>metadata.authors</code>","text":"type_name metadata.authors The registered name for this item type. documentation description Information about all authors of a resource. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name AuthorsMetadataModel The name of the Python class. python_module_name kiara.models.documentation The name of the Python module this class lives in. full_name kiara.models.documentation.AuthorsMetadataModel The full class namespace. The python class that implements this module type. metadata_schema title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel definitions AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.context","title":"<code>metadata.context</code>","text":"type_name metadata.context The registered name for this item type. documentation description Information about the context of a resource. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ContextMetadataModel The name of the Python class. python_module_name kiara.models.documentation The name of the Python module this class lives in. full_name kiara.models.documentation.ContextMetadataModel The full class namespace. The python class that implements this module type. metadata_schema title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string definitions LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.documentation","title":"<code>metadata.documentation</code>","text":"type_name metadata.documentation The registered name for this item type. documentation description Documentation about a resource. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DocumentationMetadataModel The name of the Python class. python_module_name kiara.models.documentation The name of the Python module this class lives in. full_name kiara.models.documentation.DocumentationMetadataModel The full class namespace. The python class that implements this module type. metadata_schema title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_schema","title":"<code>instance.value_schema</code>","text":"type_name instance.value_schema The registered name for this item type. documentation description The schema of a value. Short description of the item. doc The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueSchema The name of the Python class. python_module_name kiara.models.values.value_schema The name of the Python module this class lives in. full_name kiara.models.values.value_schema.ValueSchema The full class namespace. The python class that implements this module type. metadata_schema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.execution_context","title":"<code>instance.execution_context</code>","text":"type_name instance.execution_context The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExecutionContext The name of the Python class. python_module_name kiara.models.module.jobs The name of the Python module this class lives in. full_name kiara.models.module.jobs.ExecutionContext The full class namespace. The python class that implements this module type. metadata_schema title ExecutionContext description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties working_dir title Working Dir description The path of the working directory. type string pipeline_dir title Pipeline Dir description The path of the pipeline file that is being executed (if applicable). type string additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.active_job","title":"<code>instance.active_job</code>","text":"type_name instance.active_job The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ActiveJob The name of the Python class. python_module_name kiara.models.module.jobs The name of the Python module this class lives in. full_name kiara.models.module.jobs.ActiveJob The full class namespace. The python class that implements this module type. metadata_schema title ActiveJob description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties job_id title Job Id description The job id. type string format uuid job_config title Job Config description The job details. allOf <ul> <li> $ref #/definitions/JobConfig </li> </ul> status description The current status of the job. default __job_created__ allOf <ul> <li> $ref #/definitions/JobStatus </li> </ul> job_log title Job Log description The lob jog. allOf <ul> <li> $ref #/definitions/JobLog </li> </ul> submitted title Submitted description When the job was submitted. type string format date-time started title Started description When the job was started. type string format date-time finished title Finished description When the job was finished. type string format date-time results title Results description The result(s). type object additionalProperties type string format uuid error title Error description Potential error message. type string required <ul> <li>     job_id   </li> <li>     job_config   </li> <li>     job_log   </li> </ul> additionalProperties False definitions JobConfig title JobConfig description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid required <ul> <li>     module_type   </li> <li>     inputs   </li> </ul> additionalProperties False JobStatus title JobStatus description An enumeration. enum <ul> <li>     __job_created__   </li> <li>     __job_started__   </li> <li>     __job_success__   </li> <li>     __job_failed__   </li> </ul> LogMessage title LogMessage type object properties timestamp title Timestamp description The time the message was logged. type string format date-time log_level title Log Level description The log level. type integer msg title Msg description The log message type string required <ul> <li>     log_level   </li> <li>     msg   </li> </ul> JobLog title JobLog type object properties log title Log description The logs for this job. type array items $ref #/definitions/LogMessage percent_finished title Percent Finished description Describes how much of the job is finished. A negative number means the module does not support progress tracking. default -1 type integer The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.wrapped_python_class","title":"<code>instance.wrapped_python_class</code>","text":"type_name instance.wrapped_python_class The registered name for this item type. documentation description Python class and module information. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PythonClass The name of the Python class. python_module_name kiara.models.python_class The name of the Python module this class lives in. full_name kiara.models.python_class.PythonClass The full class namespace. The python class that implements this module type. metadata_schema title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.kiara_module_class","title":"<code>metadata.kiara_module_class</code>","text":"type_name metadata.kiara_module_class The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraModuleInstance The name of the Python class. python_module_name kiara.models.python_class The name of the Python module this class lives in. full_name kiara.models.python_class.KiaraModuleInstance The full class namespace. The python class that implements this module type. metadata_schema title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.serialized_data","title":"<code>metadata.serialized_data</code>","text":"type_name metadata.serialized_data The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name SerializationMetadata The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.SerializationMetadata The full class namespace. The python class that implements this module type. metadata_schema title SerializationMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment title Environment description Hash(es) for the environments the value was created/serialized. type object additionalProperties type integer deserialize title Deserialize description Suggested manifest configs to use to de-serialize the data. type object additionalProperties $ref #/definitions/Manifest additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.serialization_result","title":"<code>instance.serialization_result</code>","text":"type_name instance.serialization_result The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name SerializationResult The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.SerializationResult The full class namespace. The python class that implements this module type. metadata_schema title SerializationResult description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type title Data Type description The name of the data type for this serialized value. type string data_type_config title Data Type Config description The (optional) config for the data type for this serialized value. type object serialization_profile title Serialization Profile description An identifying name for the serialization method used. type string metadata title Metadata description Optional metadata describing aspects of the serialization used. allOf <ul> <li> $ref #/definitions/SerializationMetadata </li> </ul> hash_codec title Hash Codec description The codec used to hash the value. default sha2-256 type string data title Data description One or several byte arrays representing the serialized state of the value. type object additionalProperties anyOf <ul> <li> $ref #/definitions/SerializedBytes </li> <li> $ref #/definitions/SerializedListOfBytes </li> <li> $ref #/definitions/SerializedFile </li> <li> $ref #/definitions/SerializedFiles </li> <li> $ref #/definitions/SerializedInlineJson </li> </ul> required <ul> <li>     data_type   </li> <li>     serialization_profile   </li> <li>     data   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False SerializationMetadata title SerializationMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment title Environment description Hash(es) for the environments the value was created/serialized. type object additionalProperties type integer deserialize title Deserialize description Suggested manifest configs to use to de-serialize the data. type object additionalProperties $ref #/definitions/Manifest additionalProperties False SerializedBytes title SerializedBytes type object properties codec title Codec description The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table. type string type title Type default chunk enum <ul> <li>     chunk   </li> </ul> type string chunk title Chunk description A byte-array type string format binary required <ul> <li>     codec   </li> <li>     chunk   </li> </ul> additionalProperties False SerializedListOfBytes title SerializedListOfBytes type object properties codec title Codec description The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table. type string type title Type default chunks enum <ul> <li>     chunks   </li> </ul> type string chunks title Chunks description A list of byte arrays. type array items type string format binary required <ul> <li>     codec   </li> <li>     chunks   </li> </ul> additionalProperties False SerializedFile title SerializedFile type object properties codec title Codec description The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table. type string type title Type default file enum <ul> <li>     file   </li> </ul> type string file title File description A path to a file containing the serialized data. type string required <ul> <li>     codec   </li> <li>     file   </li> </ul> additionalProperties False SerializedFiles title SerializedFiles type object properties codec title Codec description The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table. type string type title Type default files enum <ul> <li>     files   </li> </ul> type string files title Files description A list of strings, pointing to files containing parts of the serialized data. type array items type string required <ul> <li>     codec   </li> <li>     files   </li> </ul> additionalProperties False SerializedInlineJson title SerializedInlineJson type object properties codec title Codec description The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table. type string type title Type default inline-json enum <ul> <li>     inline-json   </li> </ul> type string inline_data title Inline Data description Data that will not be stored externally, but inline in the containing model. This should only contain data types that can be serialized reliably using json (scalars, etc.). required <ul> <li>     codec   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.persisted_data","title":"<code>instance.persisted_data</code>","text":"type_name instance.persisted_data The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PersistedData The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.PersistedData The full class namespace. The python class that implements this module type. metadata_schema title PersistedData description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type title Data Type description The name of the data type for this serialized value. type string data_type_config title Data Type Config description The (optional) config for the data type for this serialized value. type object serialization_profile title Serialization Profile description An identifying name for the serialization method used. type string metadata title Metadata description Optional metadata describing aspects of the serialization used. allOf <ul> <li> $ref #/definitions/SerializationMetadata </li> </ul> hash_codec title Hash Codec description The codec used to hash the value. default sha2-256 type string archive_id title Archive Id description The id of the store that persisted the data. type string format uuid chunk_id_map title Chunk Id Map description Reference-ids that resolve to the values' serialized chunks. type object additionalProperties $ref #/definitions/SerializedChunkIDs required <ul> <li>     data_type   </li> <li>     serialization_profile   </li> <li>     archive_id   </li> <li>     chunk_id_map   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False SerializationMetadata title SerializationMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment title Environment description Hash(es) for the environments the value was created/serialized. type object additionalProperties type integer deserialize title Deserialize description Suggested manifest configs to use to de-serialize the data. type object additionalProperties $ref #/definitions/Manifest additionalProperties False SerializedChunkIDs title SerializedChunkIDs type object properties type title Type default chunk-ids enum <ul> <li>     chunk-ids   </li> </ul> type string chunk_id_list title Chunk Id List description A list of chunk ids, which will be resolved via the attached data registry. type array items type string archive_id title Archive Id description The preferred data archive to get the chunks from. type string format uuid size title Size description The size of all chunks combined. type integer required <ul> <li>     chunk_id_list   </li> <li>     size   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.data_type_instance","title":"<code>info.data_type_instance</code>","text":"type_name info.data_type_instance The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DataTypeInfo The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.DataTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False definitions DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_details","title":"<code>instance.value_details</code>","text":"type_name instance.value_details The registered name for this item type. documentation description A wrapper class that manages and retieves value data and its details. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueDetails The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.ValueDetails The full class namespace. The python class that implements this module type. metadata_schema title ValueDetails description A wrapper class that manages and retieves value data and its details. type object properties value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the data type this value is made of. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> required <ul> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value","title":"<code>instance.value</code>","text":"type_name instance.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name Value The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.Value The full class namespace. The python class that implements this module type. metadata_schema title Value description A wrapper class that manages and retieves value data and its details. type object properties value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the data type this value is made of. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object property_links title Property Links description Links to values that are properties of this value. type object additionalProperties type string format uuid destiny_backlinks title Destiny Backlinks description Backlinks to values that this value acts as destiny/or property for. type object additionalProperties type string required <ul> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> <li>     environment_hashes   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.unloadable_data","title":"<code>instance.unloadable_data</code>","text":"type_name instance.unloadable_data The registered name for this item type. documentation description A special 'marker' model, indicating that the data of value can't be loaded. Short description of the item. doc In most cases, the reason this happens is because the current kiara context is missing some value types and/or modules. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name UnloadableData The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.UnloadableData The full class namespace. The python class that implements this module type. metadata_schema title UnloadableData description A special 'marker' model, indicating that the data of value can't be loaded.  In most cases, the reason this happens is because the current kiara context is missing some value types and/or modules. type object properties value title Value description A reference to the value. allOf <ul> <li> $ref #/definitions/Value </li> </ul> required <ul> <li>     value   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False Value title Value description A wrapper class that manages and retieves value data and its details. type object properties value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the data type this value is made of. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object property_links title Property Links description Links to values that are properties of this value. type object additionalProperties type string format uuid destiny_backlinks title Destiny Backlinks description Backlinks to values that this value acts as destiny/or property for. type object additionalProperties type string required <ul> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> <li>     environment_hashes   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_map.readonly","title":"<code>instance.value_map.readonly</code>","text":"type_name instance.value_map.readonly The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueMapReadOnly The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.ValueMapReadOnly The full class namespace. The python class that implements this module type. metadata_schema title ValueMapReadOnly description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties values_schema title Values Schema description The schemas for all the values in this set. type object additionalProperties $ref #/definitions/ValueSchema value_items title Value Items description The values contained in this set. type object additionalProperties $ref #/definitions/Value required <ul> <li>     values_schema   </li> <li>     value_items   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False Value title Value description A wrapper class that manages and retieves value data and its details. type object properties value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the data type this value is made of. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object property_links title Property Links description Links to values that are properties of this value. type object additionalProperties type string format uuid destiny_backlinks title Destiny Backlinks description Backlinks to values that this value acts as destiny/or property for. type object additionalProperties type string required <ul> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> <li>     environment_hashes   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_map.writeable","title":"<code>instance.value_map.writeable</code>","text":"type_name instance.value_map.writeable The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueMapWritable The name of the Python class. python_module_name kiara.models.values.value The name of the Python module this class lives in. full_name kiara.models.values.value.ValueMapWritable The full class namespace. The python class that implements this module type. metadata_schema title ValueMapWritable description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties values_schema title Values Schema description The schemas for all the values in this set. type object additionalProperties $ref #/definitions/ValueSchema value_items title Value Items description The values contained in this set. type object additionalProperties $ref #/definitions/Value pedigree title Pedigree description The pedigree to add to all of the result values. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> unique_value_ids title Unique Value Ids description Whether this value map always creates new value(id)s, even when a dataset with matching hash is found. default True type boolean required <ul> <li>     values_schema   </li> <li>     pedigree   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False Value title Value description A wrapper class that manages and retieves value data and its details. type object properties value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the data type this value is made of. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object property_links title Property Links description Links to values that are properties of this value. type object additionalProperties type string format uuid destiny_backlinks title Destiny Backlinks description Backlinks to values that this value acts as destiny/or property for. type object additionalProperties type string required <ul> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> <li>     environment_hashes   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.value_map.aliases","title":"<code>instance.value_map.aliases</code>","text":"type_name instance.value_map.aliases The registered name for this item type. documentation description A model class that holds a tree of values and their schemas. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name AliasValueMap The name of the Python class. python_module_name kiara.models.aliases The name of the Python module this class lives in. full_name kiara.models.aliases.AliasValueMap The full class namespace. The python class that implements this module type. metadata_schema $ref #/definitions/AliasValueMap definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False AliasValueMap title AliasValueMap description A model class that holds a tree of values and their schemas. type object properties values_schema title Values Schema description The schemas for all the values in this set. type object additionalProperties $ref #/definitions/ValueSchema alias title Alias description This maps own (full) alias. type string version title Version description The version of this map (in this maps parent). type integer created title Created description The time this map was created. type string format date-time assoc_schema title Assoc Schema description The schema for this maps associated value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> assoc_value title Assoc Value description The value that is associated with this map. type string format uuid value_items title Value Items description The values contained in this set. type object additionalProperties type object additionalProperties $ref #/definitions/AliasValueMap required <ul> <li>     values_schema   </li> <li>     version   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.runtime.python","title":"<code>info.runtime.python</code>","text":"type_name info.runtime.python The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PythonRuntimeEnvironment The name of the Python class. python_module_name kiara.models.runtime_environment.python The name of the Python module this class lives in. full_name kiara.models.runtime_environment.python.PythonRuntimeEnvironment The full class namespace. The python class that implements this module type. metadata_schema title PythonRuntimeEnvironment description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment_type title Environment Type enum <ul> <li>     python   </li> </ul> type string python_version title Python Version description The version of Python. type string packages title Packages description The packages installed in the Python (virtual) environment. type array items $ref #/definitions/PythonPackage required <ul> <li>     environment_type   </li> <li>     python_version   </li> <li>     packages   </li> </ul> additionalProperties False definitions PythonPackage title PythonPackage type object properties name title Name description The name of the Python package. type string version title Version description The version of the package. type string required <ul> <li>     name   </li> <li>     version   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.runtime.kiara_plugins","title":"<code>info.runtime.kiara_plugins</code>","text":"type_name info.runtime.kiara_plugins The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraPluginsRuntimeEnvironment The name of the Python class. python_module_name kiara.models.runtime_environment.python The name of the Python module this class lives in. full_name kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment The full class namespace. The python class that implements this module type. metadata_schema title KiaraPluginsRuntimeEnvironment description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment_type title Environment Type enum <ul> <li>     kiara_plugins   </li> </ul> type string kiara_plugins title Kiara Plugins description The kiara plugin packages installed in the Python (virtual) environment. type array items $ref #/definitions/PythonPackage required <ul> <li>     environment_type   </li> <li>     kiara_plugins   </li> </ul> additionalProperties False definitions PythonPackage title PythonPackage type object properties name title Name description The name of the Python package. type string version title Version description The version of the package. type string required <ul> <li>     name   </li> <li>     version   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.runtime.kiara_types","title":"<code>info.runtime.kiara_types</code>","text":"type_name info.runtime.kiara_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraTypesRuntimeEnvironment The name of the Python class. python_module_name kiara.models.runtime_environment.kiara The name of the Python module this class lives in. full_name kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment The full class namespace. The python class that implements this module type. metadata_schema title KiaraTypesRuntimeEnvironment description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment_type title Environment Type enum <ul> <li>     kiara_types   </li> </ul> type string archive_types title Archive Types description The available implemented store types. allOf <ul> <li> $ref #/definitions/ArchiveTypeClassesInfo </li> </ul> metadata_types title Metadata Types description The available metadata types. allOf <ul> <li> $ref #/definitions/MetadataTypeClassesInfo </li> </ul> required <ul> <li>     environment_type   </li> <li>     archive_types   </li> <li>     metadata_types   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ArchiveTypeInfo title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False ArchiveTypeClassesInfo title ArchiveTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The archive info instances for each type. type object additionalProperties $ref #/definitions/ArchiveTypeInfo type_name title Type Name default archive_type enum <ul> <li>     archive_type   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False MetadataTypeInfo title MetadataTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> metadata_schema title Metadata Schema description The (json) schema for this metadata value. type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     metadata_schema   </li> </ul> additionalProperties False MetadataTypeClassesInfo title MetadataTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The value metadata info instances for each type. type object additionalProperties $ref #/definitions/MetadataTypeInfo type_name title Type Name default value_metadata enum <ul> <li>     value_metadata   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.runtime.os","title":"<code>info.runtime.os</code>","text":"type_name info.runtime.os The registered name for this item type. documentation description Manages information about the OS this kiara instance is running in. Short description of the item. doc # TODO: details for other OS's (mainly BSDs) Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OSRuntimeEnvironment The name of the Python class. python_module_name kiara.models.runtime_environment.operating_system The name of the Python module this class lives in. full_name kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment The full class namespace. The python class that implements this module type. metadata_schema title OSRuntimeEnvironment description Manages information about the OS this kiara instance is running in.  # TODO: details for other OS's (mainly BSDs) type object properties environment_type title Environment Type enum <ul> <li>     operating_system   </li> </ul> type string operation_system title Operation System description The operation system name. type string platform title Platform description The platform name. type string release title Release description The platform release name. type string version title Version description The platform version name. type string machine title Machine description The architecture. type string os_specific title Os Specific description OS specific platform metadata. type object required <ul> <li>     environment_type   </li> <li>     operation_system   </li> <li>     platform   </li> <li>     release   </li> <li>     version   </li> <li>     machine   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.operation_details","title":"<code>instance.operation_details</code>","text":"type_name instance.operation_details The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OperationDetails The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.OperationDetails The full class namespace. The python class that implements this module type. metadata_schema title OperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean required <ul> <li>     operation_id   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.operation_details.base","title":"<code>instance.operation_details.base</code>","text":"type_name instance.operation_details.base The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name BaseOperationDetails The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.BaseOperationDetails The full class namespace. The python class that implements this module type. metadata_schema title BaseOperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean module_inputs_schema title Module Inputs Schema description The input schemas of the module. type object additionalProperties $ref #/definitions/ValueSchema module_outputs_schema title Module Outputs Schema description The output schemas of the module. type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     operation_id   </li> <li>     module_inputs_schema   </li> <li>     module_outputs_schema   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.operation_config.manifest","title":"<code>instance.operation_config.manifest</code>","text":"type_name instance.operation_config.manifest The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ManifestOperationConfig The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.ManifestOperationConfig The full class namespace. The python class that implements this module type. metadata_schema title ManifestOperationConfig description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object required <ul> <li>     doc   </li> <li>     module_type   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.operation_config.pipeline","title":"<code>instance.operation_config.pipeline</code>","text":"type_name instance.operation_config.pipeline The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineOperationConfig The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.PipelineOperationConfig The full class namespace. The python class that implements this module type. metadata_schema title PipelineOperationConfig description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> pipeline_name title Pipeline Name description The pipeline id. type string pipeline_config title Pipeline Config description The pipeline config data. type object module_map title Module Map description A lookup map to resolves operation ids to module names/configs. type object metadata title Metadata description Additional metadata for the pipeline. type object required <ul> <li>     doc   </li> <li>     pipeline_name   </li> <li>     pipeline_config   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.filter","title":"<code>filter</code>","text":"type_name filter The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name Filter The name of the Python class. python_module_name kiara.models.module.operation The name of the Python module this class lives in. full_name kiara.models.module.operation.Filter The full class namespace. The python class that implements this module type. metadata_schema title Filter description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation title Operation description The underlying operation providing which does the filtering. allOf <ul> <li> $ref #/definitions/Operation </li> </ul> input_name title Input Name description The input name to use for the dataset to filter. type string output_name title Output Name description The output name to use for the dataset to filter. type string data_type title Data Type description The type of the dataset that gets filtered. type string required <ul> <li>     operation   </li> <li>     input_name   </li> <li>     output_name   </li> <li>     data_type   </li> </ul> additionalProperties False definitions OperationDetails title OperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean required <ul> <li>     operation_id   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False Operation title Operation description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean operation_id title Operation Id description The (unique) id of this operation. type string operation_details title Operation Details description The operation specific details of this operation. allOf <ul> <li> $ref #/definitions/OperationDetails </li> </ul> doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> metadata title Metadata description Additional metadata for this operation. type object required <ul> <li>     module_type   </li> <li>     operation_id   </li> <li>     operation_details   </li> <li>     doc   </li> <li>     module_details   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.pipeline_stage","title":"<code>info.pipeline_stage</code>","text":"type_name info.pipeline_stage The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineStage The name of the Python class. python_module_name kiara.models.module.pipeline.stages The name of the Python module this class lives in. full_name kiara.models.module.pipeline.stages.PipelineStage The full class namespace. The python class that implements this module type. metadata_schema title PipelineStage description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties stage_index title Stage Index description The index of this stage. type integer steps title Steps description The pipeline steps that are executed in this stage. type array items type string connected_outputs title Connected Outputs description Previous step outputs that are connected to this stage. type array items type string stage_outputs title Stage Outputs description The outputs of this stage. type array items type string pipeline_inputs title Pipeline Inputs description The pipeline inputs required for this stage. type array items type string pipeline_outputs title Pipeline Outputs description The pipeline outputs that are ready once this stage is processed. type array items type string previous_pipeline_inputs title Previous Pipeline Inputs description Pipeline inputs that are already set by this stage. type array items type string previous_pipeline_outputs title Previous Pipeline Outputs description Pipeline outputs that are already computed by this stage. type array items type string required <ul> <li>     stage_index   </li> <li>     steps   </li> <li>     connected_outputs   </li> <li>     stage_outputs   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     previous_pipeline_inputs   </li> <li>     previous_pipeline_outputs   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.pipeline_stages","title":"<code>pipeline_stages</code>","text":"type_name pipeline_stages The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineStages The name of the Python class. python_module_name kiara.models.module.pipeline.stages The name of the Python module this class lives in. full_name kiara.models.module.pipeline.stages.PipelineStages The full class namespace. The python class that implements this module type. metadata_schema title PipelineStages description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties stages title Stages description The pipeline stages. type array items $ref #/definitions/PipelineStage required <ul> <li>     stages   </li> </ul> additionalProperties False definitions PipelineStage title PipelineStage description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties stage_index title Stage Index description The index of this stage. type integer steps title Steps description The pipeline steps that are executed in this stage. type array items type string connected_outputs title Connected Outputs description Previous step outputs that are connected to this stage. type array items type string stage_outputs title Stage Outputs description The outputs of this stage. type array items type string pipeline_inputs title Pipeline Inputs description The pipeline inputs required for this stage. type array items type string pipeline_outputs title Pipeline Outputs description The pipeline outputs that are ready once this stage is processed. type array items type string previous_pipeline_inputs title Previous Pipeline Inputs description Pipeline inputs that are already set by this stage. type array items type string previous_pipeline_outputs title Previous Pipeline Outputs description Pipeline outputs that are already computed by this stage. type array items type string required <ul> <li>     stage_index   </li> <li>     steps   </li> <li>     connected_outputs   </li> <li>     stage_outputs   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     previous_pipeline_inputs   </li> <li>     previous_pipeline_outputs   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.pipeline_step","title":"<code>info.pipeline_step</code>","text":"type_name info.pipeline_step The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name StepInfo The name of the Python class. python_module_name kiara.models.module.pipeline.structure The name of the Python module this class lives in. full_name kiara.models.module.pipeline.structure.StepInfo The full class namespace. The python class that implements this module type. metadata_schema title StepInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties step title Step description The pipeline step object. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> inputs title Inputs description Reference(s) to the fields that feed this steps inputs. type object additionalProperties $ref #/definitions/StepInputRef outputs title Outputs description Reference(s) to the fields that are fed by this steps outputs. type object additionalProperties $ref #/definitions/StepOutputRef required title Required description Whether this step is always required or whether all his outputs feed into optional input fields. type boolean required <ul> <li>     step   </li> <li>     inputs   </li> <li>     outputs   </li> <li>     required   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False StepInputRef title StepInputRef description An input to a step.  This object can either have a 'connected_outputs' set, or a 'connected_pipeline_input', not both. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema step_id title Step Id description The step id. type string connected_outputs title Connected Outputs description A potential connected list of one or several module outputs. type array items $ref #/definitions/StepValueAddress connected_pipeline_input title Connected Pipeline Input description A potential pipeline input. type string is_constant title Is Constant description Whether this input is a constant and can't be changed by the user. type boolean required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     step_id   </li> <li>     is_constant   </li> </ul> additionalProperties False StepOutputRef title StepOutputRef description An output to a step. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema step_id title Step Id description The step id. type string pipeline_output title Pipeline Output description The connected pipeline output. type string connected_inputs title Connected Inputs description The step inputs that are connected to this step output type array items $ref #/definitions/StepValueAddress required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     step_id   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.pipeline_structure","title":"<code>instance.pipeline_structure</code>","text":"type_name instance.pipeline_structure The registered name for this item type. documentation description An object that holds one or several steps, and describes the connections between them. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineStructure The name of the Python class. python_module_name kiara.models.module.pipeline.structure The name of the Python module this class lives in. full_name kiara.models.module.pipeline.structure.PipelineStructure The full class namespace. The python class that implements this module type. metadata_schema title PipelineStructure description An object that holds one or several steps, and describes the connections between them. type object properties pipeline_config title Pipeline Config description The underlying pipeline config. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> steps title Steps description The pipeline steps  type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description The input aliases. type object additionalProperties type string output_aliases title Output Aliases description The output aliases. type object additionalProperties type string required <ul> <li>     pipeline_config   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.archive_type","title":"<code>info.archive_type</code>","text":"type_name info.archive_type The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ArchiveTypeInfo The name of the Python class. python_module_name kiara.models.archives The name of the Python module this class lives in. full_name kiara.models.archives.ArchiveTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.metadata_type","title":"<code>info.metadata_type</code>","text":"type_name info.metadata_type The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name MetadataTypeInfo The name of the Python class. python_module_name kiara.models.values.value_metadata The name of the Python module this class lives in. full_name kiara.models.values.value_metadata.MetadataTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title MetadataTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> metadata_schema title Metadata Schema description The (json) schema for this metadata value. type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     metadata_schema   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.pipeline","title":"<code>info.pipeline</code>","text":"type_name info.pipeline The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineInfo The name of the Python class. python_module_name kiara.models.module.pipeline.pipeline The name of the Python module this class lives in. full_name kiara.models.module.pipeline.pipeline.PipelineInfo The full class namespace. The python class that implements this module type. metadata_schema title PipelineInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> pipeline_config title Pipeline Config description The configuration of the pipeline. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> pipeline_state title Pipeline State description The current input details. allOf <ul> <li> $ref #/definitions/PipelineState </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     pipeline_config   </li> <li>     pipeline_state   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> StepStatus title StepStatus description Enum to describe the state of a workflow. enum <ul> <li>     inputs_invalid   </li> <li>     inputs_ready   </li> <li>     results_ready   </li> </ul> StepDetails title StepDetails type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid step title Step description The pipeline step details. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> step_id title Step Id description The id of the step. type string processing_stage title Processing Stage description The execution stage where this step is executed. type integer status description The current status of this step. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string inputs title Inputs description The current inputs of this step. type object additionalProperties type string format uuid outputs title Outputs description The current outputs of this step. type object additionalProperties type string format uuid required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     step   </li> <li>     step_id   </li> <li>     processing_stage   </li> <li>     status   </li> <li>     inputs   </li> <li>     outputs   </li> </ul> PipelineState title PipelineState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid pipeline_status description The current status of this pipeline. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string pipeline_inputs title Pipeline Inputs description The current pipeline inputs. type object additionalProperties type string format uuid pipeline_outputs title Pipeline Outputs description The current pipeline outputs. type object additionalProperties type string format uuid step_states title Step States description The state of each step within this pipeline. type object additionalProperties $ref #/definitions/StepDetails required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     pipeline_status   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     step_states   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.workflow","title":"<code>info.workflow</code>","text":"type_name info.workflow The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name WorkflowInfo The name of the Python class. python_module_name kiara.models.workflow The name of the Python module this class lives in. full_name kiara.models.workflow.WorkflowInfo The full class namespace. The python class that implements this module type. metadata_schema title WorkflowInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> workflow_metadata title Workflow Metadata description The workflow details. allOf <ul> <li> $ref #/definitions/WorkflowMetadata </li> </ul> workflow_state_ids title Workflow State Ids description All states for this workflow. type array items type string pipeline_info title Pipeline Info description The current state of the workflows' pipeline. allOf <ul> <li> $ref #/definitions/PipelineInfo </li> </ul> current_input_values title Current Input Values description The current workflow inputs (after aliasing). allOf <ul> <li> $ref #/definitions/ValueMap </li> </ul> current_output_values title Current Output Values description The current workflow outputs (after aliasing). allOf <ul> <li> $ref #/definitions/ValueMap </li> </ul> input_aliases title Input Aliases description The (current) input aliases for this workflow. type object additionalProperties type string output_aliases title Output Aliases description The (current) output aliases for this workflow. type object additionalProperties type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     workflow_metadata   </li> <li>     workflow_state_ids   </li> <li>     pipeline_info   </li> <li>     current_input_values   </li> <li>     current_output_values   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string WorkflowMetadata title WorkflowMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties workflow_id title Workflow Id description The globaly unique uuid for this workflow. type string format uuid documentation title Documentation description A description for this workflow. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description The author(s) of this workflow. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Workflow context details. allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> current_state title Current State description A reference to the current state of this workflow. type string workflow_history title Workflow History description A history of all the states of this workflow. type object additionalProperties type string input_aliases title Input Aliases description A set of aliases that can be used to forward inputs to their (unaliased) pipeline inputs. type object additionalProperties type string output_aliases title Output Aliases description A set of aliases to make output field names more user friendly. type object additionalProperties type string is_persisted title Is Persisted description Whether this workflow is persisted in it's current state in a kiara store. default False type boolean required <ul> <li>     workflow_id   </li> </ul> additionalProperties False Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> StepStatus title StepStatus description Enum to describe the state of a workflow. enum <ul> <li>     inputs_invalid   </li> <li>     inputs_ready   </li> <li>     results_ready   </li> </ul> StepDetails title StepDetails type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid step title Step description The pipeline step details. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> step_id title Step Id description The id of the step. type string processing_stage title Processing Stage description The execution stage where this step is executed. type integer status description The current status of this step. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string inputs title Inputs description The current inputs of this step. type object additionalProperties type string format uuid outputs title Outputs description The current outputs of this step. type object additionalProperties type string format uuid required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     step   </li> <li>     step_id   </li> <li>     processing_stage   </li> <li>     status   </li> <li>     inputs   </li> <li>     outputs   </li> </ul> PipelineState title PipelineState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid pipeline_status description The current status of this pipeline. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string pipeline_inputs title Pipeline Inputs description The current pipeline inputs. type object additionalProperties type string format uuid pipeline_outputs title Pipeline Outputs description The current pipeline outputs. type object additionalProperties type string format uuid step_states title Step States description The state of each step within this pipeline. type object additionalProperties $ref #/definitions/StepDetails required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     pipeline_status   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     step_states   </li> </ul> additionalProperties False PipelineInfo title PipelineInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> pipeline_config title Pipeline Config description The configuration of the pipeline. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> pipeline_state title Pipeline State description The current input details. allOf <ul> <li> $ref #/definitions/PipelineState </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     pipeline_config   </li> <li>     pipeline_state   </li> </ul> additionalProperties False ValueMap title ValueMap description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties values_schema title Values Schema description The schemas for all the values in this set. type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     values_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.archive_info","title":"<code>archive_info</code>","text":"type_name archive_info The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ArchiveInfo The name of the Python class. python_module_name kiara.models.archives The name of the Python module this class lives in. full_name kiara.models.archives.ArchiveInfo The full class namespace. The python class that implements this module type. metadata_schema title ArchiveInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> archive_id title Archive Id description The (globally unique) archive id. type string format uuid archive_type_info title Archive Type Info description Information about this archives' type. allOf <ul> <li> $ref #/definitions/ArchiveTypeInfo </li> </ul> config title Config description The configuration of this archive. type object details title Details description Type dependent (runtime) details for this archive. allOf <ul> <li> $ref #/definitions/ArchiveDetails </li> </ul> aliases title Aliases description Aliases for this archive. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     archive_id   </li> <li>     archive_type_info   </li> <li>     config   </li> <li>     details   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ArchiveTypeInfo title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False ArchiveDetails title ArchiveDetails type object properties size title Size description The size of the stored archive. type integer The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.archive_types","title":"<code>info.archive_types</code>","text":"type_name info.archive_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ArchiveTypeClassesInfo The name of the Python class. python_module_name kiara.models.archives The name of the Python module this class lives in. full_name kiara.models.archives.ArchiveTypeClassesInfo The full class namespace. The python class that implements this module type. metadata_schema title ArchiveTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The archive info instances for each type. type object additionalProperties $ref #/definitions/ArchiveTypeInfo type_name title Type Name default archive_type enum <ul> <li>     archive_type   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ArchiveTypeInfo title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.metadata_types","title":"<code>info.metadata_types</code>","text":"type_name info.metadata_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name MetadataTypeClassesInfo The name of the Python class. python_module_name kiara.models.values.value_metadata The name of the Python module this class lives in. full_name kiara.models.values.value_metadata.MetadataTypeClassesInfo The full class namespace. The python class that implements this module type. metadata_schema title MetadataTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The value metadata info instances for each type. type object additionalProperties $ref #/definitions/MetadataTypeInfo type_name title Type Name default value_metadata enum <ul> <li>     value_metadata   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False MetadataTypeInfo title MetadataTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> metadata_schema title Metadata Schema description The (json) schema for this metadata value. type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     metadata_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.workflows","title":"<code>info.workflows</code>","text":"type_name info.workflows The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name WorkflowGroupInfo The name of the Python class. python_module_name kiara.models.workflow The name of the Python module this class lives in. full_name kiara.models.workflow.WorkflowGroupInfo The full class namespace. The python class that implements this module type. metadata_schema title WorkflowGroupInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The workflow infos objects for each workflow. type object additionalProperties $ref #/definitions/WorkflowInfo aliases title Aliases description The available aliases. type object additionalProperties type string format uuid required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string WorkflowMetadata title WorkflowMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties workflow_id title Workflow Id description The globaly unique uuid for this workflow. type string format uuid documentation title Documentation description A description for this workflow. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description The author(s) of this workflow. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Workflow context details. allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> current_state title Current State description A reference to the current state of this workflow. type string workflow_history title Workflow History description A history of all the states of this workflow. type object additionalProperties type string input_aliases title Input Aliases description A set of aliases that can be used to forward inputs to their (unaliased) pipeline inputs. type object additionalProperties type string output_aliases title Output Aliases description A set of aliases to make output field names more user friendly. type object additionalProperties type string is_persisted title Is Persisted description Whether this workflow is persisted in it's current state in a kiara store. default False type boolean required <ul> <li>     workflow_id   </li> </ul> additionalProperties False Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> StepStatus title StepStatus description Enum to describe the state of a workflow. enum <ul> <li>     inputs_invalid   </li> <li>     inputs_ready   </li> <li>     results_ready   </li> </ul> StepDetails title StepDetails type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid step title Step description The pipeline step details. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> step_id title Step Id description The id of the step. type string processing_stage title Processing Stage description The execution stage where this step is executed. type integer status description The current status of this step. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string inputs title Inputs description The current inputs of this step. type object additionalProperties type string format uuid outputs title Outputs description The current outputs of this step. type object additionalProperties type string format uuid required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     step   </li> <li>     step_id   </li> <li>     processing_stage   </li> <li>     status   </li> <li>     inputs   </li> <li>     outputs   </li> </ul> PipelineState title PipelineState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid pipeline_status description The current status of this pipeline. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string pipeline_inputs title Pipeline Inputs description The current pipeline inputs. type object additionalProperties type string format uuid pipeline_outputs title Pipeline Outputs description The current pipeline outputs. type object additionalProperties type string format uuid step_states title Step States description The state of each step within this pipeline. type object additionalProperties $ref #/definitions/StepDetails required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     pipeline_status   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     step_states   </li> </ul> additionalProperties False PipelineInfo title PipelineInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> pipeline_config title Pipeline Config description The configuration of the pipeline. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> pipeline_state title Pipeline State description The current input details. allOf <ul> <li> $ref #/definitions/PipelineState </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     pipeline_config   </li> <li>     pipeline_state   </li> </ul> additionalProperties False ValueMap title ValueMap description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties values_schema title Values Schema description The schemas for all the values in this set. type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     values_schema   </li> </ul> additionalProperties False WorkflowInfo title WorkflowInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> workflow_metadata title Workflow Metadata description The workflow details. allOf <ul> <li> $ref #/definitions/WorkflowMetadata </li> </ul> workflow_state_ids title Workflow State Ids description All states for this workflow. type array items type string pipeline_info title Pipeline Info description The current state of the workflows' pipeline. allOf <ul> <li> $ref #/definitions/PipelineInfo </li> </ul> current_input_values title Current Input Values description The current workflow inputs (after aliasing). allOf <ul> <li> $ref #/definitions/ValueMap </li> </ul> current_output_values title Current Output Values description The current workflow outputs (after aliasing). allOf <ul> <li> $ref #/definitions/ValueMap </li> </ul> input_aliases title Input Aliases description The (current) input aliases for this workflow. type object additionalProperties type string output_aliases title Output Aliases description The (current) output aliases for this workflow. type object additionalProperties type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     workflow_metadata   </li> <li>     workflow_state_ids   </li> <li>     pipeline_info   </li> <li>     current_input_values   </li> <li>     current_output_values   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.archives","title":"<code>info.archives</code>","text":"type_name info.archives The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ArchiveGroupInfo The name of the Python class. python_module_name kiara.models.archives The name of the Python module this class lives in. full_name kiara.models.archives.ArchiveGroupInfo The full class namespace. The python class that implements this module type. metadata_schema title ArchiveGroupInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The info for each archive. type object additionalProperties $ref #/definitions/ArchiveInfo required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ArchiveTypeInfo title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False ArchiveDetails title ArchiveDetails type object properties size title Size description The size of the stored archive. type integer ArchiveInfo title ArchiveInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> archive_id title Archive Id description The (globally unique) archive id. type string format uuid archive_type_info title Archive Type Info description Information about this archives' type. allOf <ul> <li> $ref #/definitions/ArchiveTypeInfo </li> </ul> config title Config description The configuration of this archive. type object details title Details description Type dependent (runtime) details for this archive. allOf <ul> <li> $ref #/definitions/ArchiveDetails </li> </ul> aliases title Aliases description Aliases for this archive. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     archive_id   </li> <li>     archive_type_info   </li> <li>     config   </li> <li>     details   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.pipeline_state","title":"<code>instance.pipeline_state</code>","text":"type_name instance.pipeline_state The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineState The name of the Python class. python_module_name kiara.models.events.pipeline The name of the Python module this class lives in. full_name kiara.models.events.pipeline.PipelineState The full class namespace. The python class that implements this module type. metadata_schema title PipelineState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid pipeline_status description The current status of this pipeline. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string pipeline_inputs title Pipeline Inputs description The current pipeline inputs. type object additionalProperties type string format uuid pipeline_outputs title Pipeline Outputs description The current pipeline outputs. type object additionalProperties type string format uuid step_states title Step States description The state of each step within this pipeline. type object additionalProperties $ref #/definitions/StepDetails required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     pipeline_status   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     step_states   </li> </ul> additionalProperties False definitions StepStatus title StepStatus description Enum to describe the state of a workflow. enum <ul> <li>     inputs_invalid   </li> <li>     inputs_ready   </li> <li>     results_ready   </li> </ul> Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False StepDetails title StepDetails type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid step title Step description The pipeline step details. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> step_id title Step Id description The id of the step. type string processing_stage title Processing Stage description The execution stage where this step is executed. type integer status description The current status of this step. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string inputs title Inputs description The current inputs of this step. type object additionalProperties type string format uuid outputs title Outputs description The current outputs of this step. type object additionalProperties type string format uuid required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     step   </li> <li>     step_id   </li> <li>     processing_stage   </li> <li>     status   </li> <li>     inputs   </li> <li>     outputs   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.render_scene","title":"<code>instance.render_scene</code>","text":"type_name instance.render_scene The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderScene The name of the Python class. python_module_name kiara.models.rendering The name of the Python module this class lives in. full_name kiara.models.rendering.RenderScene The full class namespace. The python class that implements this module type. metadata_schema $ref #/definitions/RenderScene definitions RenderScene title RenderScene description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties title title Title description The title of this scene. type string disabled title Disabled description Whether this scene should be displayed as 'disabled' in a UI. default False type boolean description title Description description Description of what this scene renders. default -- n/a -- type string manifest_hash title Manifest Hash description The hash of the manifest of the referenced render scene. type string render_config title Render Config description The inputs used with the referenced manifest. type object related_scenes title Related Scenes description Other render scenes, related to this one. type object additionalProperties $ref #/definitions/RenderScene required <ul> <li>     title   </li> <li>     manifest_hash   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.render_value_result","title":"<code>render_value_result</code>","text":"type_name render_value_result The registered name for this item type. documentation description Object containing all the result properties of a 'render_value' operation. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderValueResult The name of the Python class. python_module_name kiara.models.rendering The name of the Python module this class lives in. full_name kiara.models.rendering.RenderValueResult The full class namespace. The python class that implements this module type. metadata_schema title RenderValueResult description Object containing all the result properties of a 'render_value' operation. type object properties value_id title Value Id description The value that was rendered. type string format uuid render_config title Render Config description The config that was used to render this. type object render_manifest title Render Manifest description The id of the manifest that was used to render this. type string related_scenes title Related Scenes description Other render scenes, related to this one. type object additionalProperties $ref #/definitions/RenderScene manifest_lookup title Manifest Lookup description The manifests referenced in this model, indexed by the hashes. type object additionalProperties $ref #/definitions/Manifest rendered title Rendered description The rendered object. required <ul> <li>     value_id   </li> <li>     render_manifest   </li> </ul> additionalProperties False definitions RenderScene title RenderScene description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties title title Title description The title of this scene. type string disabled title Disabled description Whether this scene should be displayed as 'disabled' in a UI. default False type boolean description title Description description Description of what this scene renders. default -- n/a -- type string manifest_hash title Manifest Hash description The hash of the manifest of the referenced render scene. type string render_config title Render Config description The inputs used with the referenced manifest. type object related_scenes title Related Scenes description Other render scenes, related to this one. type object additionalProperties $ref #/definitions/RenderScene required <ul> <li>     title   </li> <li>     manifest_hash   </li> </ul> additionalProperties False Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.value_matcher","title":"<code>value_matcher</code>","text":"type_name value_matcher The registered name for this item type. documentation description An object describing requirements values should satisfy in order to be included in a query result. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueMatcher The name of the Python class. python_module_name kiara.models.values.matchers The name of the Python module this class lives in. full_name kiara.models.values.matchers.ValueMatcher The full class namespace. The python class that implements this module type. metadata_schema title ValueMatcher description An object describing requirements values should satisfy in order to be included in a query result. type object properties data_types title Data Types description The data type. type array items type string allow_sub_types title Allow Sub Types description Allow subtypes. default True type boolean min_size title Min Size description The minimum size for the dataset. default 0 type integer max_size title Max Size description The maximum size for the dataset. type integer allow_internal title Allow Internal description Allow internal data types. default False type boolean has_alias title Has Alias description Value must have at least one alias. default True type boolean additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.workflow_state","title":"<code>workflow_state</code>","text":"type_name workflow_state The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name WorkflowState The name of the Python class. python_module_name kiara.models.workflow The name of the Python module this class lives in. full_name kiara.models.workflow.WorkflowState The full class namespace. The python class that implements this module type. metadata_schema title WorkflowState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties steps title Steps description The current steps in the workflow. type array items $ref #/definitions/PipelineStep inputs title Inputs description The current (pipeline) input values. type object additionalProperties type string format uuid pipeline_info title Pipeline Info description Details about the pipeline and its state. allOf <ul> <li> $ref #/definitions/PipelineInfo </li> </ul> required <ul> <li>     pipeline_info   </li> </ul> additionalProperties False definitions Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> StepStatus title StepStatus description Enum to describe the state of a workflow. enum <ul> <li>     inputs_invalid   </li> <li>     inputs_ready   </li> <li>     results_ready   </li> </ul> StepDetails title StepDetails type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid step title Step description The pipeline step details. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> step_id title Step Id description The id of the step. type string processing_stage title Processing Stage description The execution stage where this step is executed. type integer status description The current status of this step. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string inputs title Inputs description The current inputs of this step. type object additionalProperties type string format uuid outputs title Outputs description The current outputs of this step. type object additionalProperties type string format uuid required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     step   </li> <li>     step_id   </li> <li>     processing_stage   </li> <li>     status   </li> <li>     inputs   </li> <li>     outputs   </li> </ul> PipelineState title PipelineState description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The id of the kiara context. type string format uuid pipeline_id title Pipeline Id description The id of the pipeline. type string format uuid pipeline_status description The current status of this pipeline. allOf <ul> <li> $ref #/definitions/StepStatus </li> </ul> invalid_details title Invalid Details description Details about fields that are invalid (if status &lt; 'INPUTS_READY'. type object additionalProperties type string pipeline_inputs title Pipeline Inputs description The current pipeline inputs. type object additionalProperties type string format uuid pipeline_outputs title Pipeline Outputs description The current pipeline outputs. type object additionalProperties type string format uuid step_states title Step States description The state of each step within this pipeline. type object additionalProperties $ref #/definitions/StepDetails required <ul> <li>     kiara_id   </li> <li>     pipeline_id   </li> <li>     pipeline_status   </li> <li>     pipeline_inputs   </li> <li>     pipeline_outputs   </li> <li>     step_states   </li> </ul> additionalProperties False PipelineInfo title PipelineInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> pipeline_config title Pipeline Config description The configuration of the pipeline. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> pipeline_state title Pipeline State description The current input details. allOf <ul> <li> $ref #/definitions/PipelineState </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     pipeline_config   </li> <li>     pipeline_state   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.workflow","title":"<code>instance.workflow</code>","text":"type_name instance.workflow The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name WorkflowMetadata The name of the Python class. python_module_name kiara.models.workflow The name of the Python module this class lives in. full_name kiara.models.workflow.WorkflowMetadata The full class namespace. The python class that implements this module type. metadata_schema title WorkflowMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties workflow_id title Workflow Id description The globaly unique uuid for this workflow. type string format uuid documentation title Documentation description A description for this workflow. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description The author(s) of this workflow. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Workflow context details. allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> current_state title Current State description A reference to the current state of this workflow. type string workflow_history title Workflow History description A history of all the states of this workflow. type object additionalProperties type string input_aliases title Input Aliases description A set of aliases that can be used to forward inputs to their (unaliased) pipeline inputs. type object additionalProperties type string output_aliases title Output Aliases description A set of aliases to make output field names more user friendly. type object additionalProperties type string is_persisted title Is Persisted description Whether this workflow is persisted in it's current state in a kiara store. default False type boolean required <ul> <li>     workflow_id   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.context_info","title":"<code>context_info</code>","text":"type_name context_info The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ContextInfo The name of the Python class. python_module_name kiara.models.context The name of the Python module this class lives in. full_name kiara.models.context.ContextInfo The full class namespace. The python class that implements this module type. metadata_schema title ContextInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties kiara_id title Kiara Id description The (globally unique) id of the kiara context. type string format uuid context_name title Context Name description The local alias for this context. type string value_ids title Value Ids description The ids of all stored values in this context. type array items type string format uuid aliases title Aliases description All available aliases within this context (and the value ids they refer to). type object additionalProperties type string format uuid archives title Archives description The archives registered in this context. allOf <ul> <li> $ref #/definitions/ArchiveGroupInfo </li> </ul> invalid title Invalid description Whether this context has errors. bool False type boolean comment title Comment description (Optional) comment about this context. type string required <ul> <li>     kiara_id   </li> <li>     value_ids   </li> <li>     aliases   </li> <li>     archives   </li> <li>     invalid   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ArchiveTypeInfo title ArchiveTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> is_writable title Is Writable description Whether this archive is writeable. default False type boolean supported_item_types title Supported Item Types description The item types this archive suports. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     supported_item_types   </li> </ul> additionalProperties False ArchiveDetails title ArchiveDetails type object properties size title Size description The size of the stored archive. type integer ArchiveInfo title ArchiveInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> archive_id title Archive Id description The (globally unique) archive id. type string format uuid archive_type_info title Archive Type Info description Information about this archives' type. allOf <ul> <li> $ref #/definitions/ArchiveTypeInfo </li> </ul> config title Config description The configuration of this archive. type object details title Details description Type dependent (runtime) details for this archive. allOf <ul> <li> $ref #/definitions/ArchiveDetails </li> </ul> aliases title Aliases description Aliases for this archive. type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     archive_id   </li> <li>     archive_type_info   </li> <li>     config   </li> <li>     details   </li> </ul> additionalProperties False ArchiveGroupInfo title ArchiveGroupInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The info for each archive. type object additionalProperties $ref #/definitions/ArchiveInfo required <ul> <li>     item_infos   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.python_class","title":"<code>metadata.python_class</code>","text":"type_name metadata.python_class The registered name for this item type. documentation description Python class and module information. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PythonClassMetadata The name of the Python class. python_module_name kiara.models.values.value_metadata.included_metadata_types The name of the Python module this class lives in. full_name kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata The full class namespace. The python class that implements this module type. metadata_schema title PythonClassMetadata description Python class and module information. type object properties python_class title Python Class description Details about the Python class that backs this value. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     python_class   </li> </ul> additionalProperties False definitions PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.file","title":"<code>metadata.file</code>","text":"type_name metadata.file The registered name for this item type. documentation description File stats. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileMetadata The name of the Python class. python_module_name kiara.models.values.value_metadata.included_metadata_types The name of the Python module this class lives in. full_name kiara.models.values.value_metadata.included_metadata_types.FileMetadata The full class namespace. The python class that implements this module type. metadata_schema title FileMetadata description File stats. type object properties file title File description The file-specific metadata. allOf <ul> <li> $ref #/definitions/FileModel </li> </ul> required <ul> <li>     file   </li> </ul> additionalProperties False definitions FileModel title FileModel description Describes properties for the 'file' value type. type object properties mime_type title Mime Type description The mime type of the file. type string file_name title File Name default The name of the file. type string size title Size description The size of the file. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     mime_type   </li> <li>     size   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.file_bundle","title":"<code>metadata.file_bundle</code>","text":"type_name metadata.file_bundle The registered name for this item type. documentation description File bundle stats. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileBundleMetadata The name of the Python class. python_module_name kiara.models.values.value_metadata.included_metadata_types The name of the Python module this class lives in. full_name kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata The full class namespace. The python class that implements this module type. metadata_schema title FileBundleMetadata description File bundle stats. type object properties file_bundle title File Bundle description The file-specific metadata. allOf <ul> <li> $ref #/definitions/FileBundle </li> </ul> required <ul> <li>     file_bundle   </li> </ul> additionalProperties False definitions FileModel title FileModel description Describes properties for the 'file' value type. type object properties mime_type title Mime Type description The mime type of the file. type string file_name title File Name default The name of the file. type string size title Size description The size of the file. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     mime_type   </li> <li>     size   </li> </ul> additionalProperties False FileBundle title FileBundle description Describes properties for the 'file_bundle' value type. type object properties bundle_name title Bundle Name description The name of this bundle. type string number_of_files title Number Of Files description How many files are included in this bundle. type integer included_files title Included Files description A map of all the included files, incl. their properties. Uses the relative path of each file as key. type object additionalProperties $ref #/definitions/FileModel size title Size description The size of all files in this folder, combined. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     bundle_name   </li> <li>     number_of_files   </li> <li>     included_files   </li> <li>     size   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.data.file","title":"<code>instance.data.file</code>","text":"type_name instance.data.file The registered name for this item type. documentation description Describes properties for the 'file' value type. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileModel The name of the Python class. python_module_name kiara.models.filesystem The name of the Python module this class lives in. full_name kiara.models.filesystem.FileModel The full class namespace. The python class that implements this module type. metadata_schema title FileModel description Describes properties for the 'file' value type. type object properties mime_type title Mime Type description The mime type of the file. type string file_name title File Name default The name of the file. type string size title Size description The size of the file. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     mime_type   </li> <li>     size   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.instance.data.file_bundle","title":"<code>instance.data.file_bundle</code>","text":"type_name instance.data.file_bundle The registered name for this item type. documentation description Describes properties for the 'file_bundle' value type. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FileBundle The name of the Python class. python_module_name kiara.models.filesystem The name of the Python module this class lives in. full_name kiara.models.filesystem.FileBundle The full class namespace. The python class that implements this module type. metadata_schema title FileBundle description Describes properties for the 'file_bundle' value type. type object properties bundle_name title Bundle Name description The name of this bundle. type string number_of_files title Number Of Files description How many files are included in this bundle. type integer included_files title Included Files description A map of all the included files, incl. their properties. Uses the relative path of each file as key. type object additionalProperties $ref #/definitions/FileModel size title Size description The size of all files in this folder, combined. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     bundle_name   </li> <li>     number_of_files   </li> <li>     included_files   </li> <li>     size   </li> </ul> additionalProperties False definitions FileModel title FileModel description Describes properties for the 'file' value type. type object properties mime_type title Mime Type description The mime type of the file. type string file_name title File Name default The name of the file. type string size title Size description The size of the file. type integer metadata title Metadata description Additional, ustructured, user-defined metadata. type object required <ul> <li>     mime_type   </li> <li>     size   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.kiara_model","title":"<code>info.kiara_model</code>","text":"type_name info.kiara_model The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraModelTypeInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.KiaraModelTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title KiaraModelTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> metadata_schema title Metadata Schema description The (json) schema for this model data. type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     metadata_schema   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.data_type","title":"<code>info.data_type</code>","text":"type_name info.data_type The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DataTypeClassInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.DataTypeClassInfo The full class namespace. The python class that implements this module type. metadata_schema title DataTypeClassInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> value_cls title Value Cls description The python class of the value itself. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> data_type_config_cls title Data Type Config Cls description The python class holding the schema for configuring this type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> lineage title Lineage description This types lineage. type array items type string qualifier_profiles title Qualifier Profiles description A map of qualifier profiles for this data types. type object additionalProperties type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     value_cls   </li> <li>     data_type_config_cls   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.kiara_module_type","title":"<code>info.kiara_module_type</code>","text":"type_name info.kiara_module_type The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ModuleTypeInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.ModuleTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title ModuleTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> module_src title Module Src description The source code of the process method of the module. type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     module_src   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.operation_type","title":"<code>info.operation_type</code>","text":"type_name info.operation_type The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OperationTypeInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.OperationTypeInfo The full class namespace. The python class that implements this module type. metadata_schema title OperationTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.value","title":"<code>info.value</code>","text":"type_name info.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.ValueInfo The full class namespace. The python class that implements this module type. metadata_schema title ValueInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> value_id title Value Id description The id of the value. type string format uuid kiara_id title Kiara Id description The id of the kiara context this value belongs to. type string format uuid value_schema title Value Schema description The schema that was used for this Value. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> value_status description The set/unset status of this value. allOf <ul> <li> $ref #/definitions/ValueStatus </li> </ul> value_size title Value Size description The size of this value, in bytes. type integer value_hash title Value Hash description The hash of this value. type string pedigree title Pedigree description Information about the module and inputs that went into creating this value. allOf <ul> <li> $ref #/definitions/ValuePedigree </li> </ul> pedigree_output_name title Pedigree Output Name description The output name that produced this value (using the manifest inside the pedigree). type string data_type_info title Data Type Info description Information about the underlying data type and it's configuration. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> aliases title Aliases description The aliases that are registered for this value. type array items type string serialized title Serialized description Details for the serialization process that was used for this value. allOf <ul> <li> $ref #/definitions/PersistedData </li> </ul> properties title Properties description Property data for this value. type object destiny_links title Destiny Links description References to all the values that act as destiny for this value in this context. type object additionalProperties type string format uuid environment_hashes title Environment Hashes description Hashes for the environments this value was created in. type object additionalProperties type object additionalProperties type string enviroments title Enviroments description Information about the environments this value was created in. type object additionalProperties type object property_links title Property Links description Links to values that are properties of this value. type object additionalProperties type string format uuid destiny_backlinks title Destiny Backlinks description Backlinks to values that this value acts as destiny/or property for. type object additionalProperties type string is_internal title Is Internal description Whether this value is only used internally in kiara. default False type boolean is_persisted title Is Persisted description Whether this value is stored in at least one data store. type boolean required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     value_id   </li> <li>     kiara_id   </li> <li>     value_schema   </li> <li>     value_status   </li> <li>     value_size   </li> <li>     value_hash   </li> <li>     pedigree   </li> <li>     pedigree_output_name   </li> <li>     data_type_info   </li> <li>     environment_hashes   </li> <li>     is_persisted   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False ValueStatus title ValueStatus description An enumeration. enum <ul> <li>     unknown   </li> <li>     not set   </li> <li>     none   </li> <li>     default   </li> <li>     set   </li> </ul> ValuePedigree title ValuePedigree description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean inputs title Inputs description A map of all the input fields and value references. type object additionalProperties type string format uuid kiara_id title Kiara Id description The id of the kiara context a value was created in. type string format uuid environments title Environments description References to the runtime environment details a value was created in. type object additionalProperties type string required <ul> <li>     module_type   </li> <li>     inputs   </li> <li>     kiara_id   </li> <li>     environments   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False SerializationMetadata title SerializationMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties environment title Environment description Hash(es) for the environments the value was created/serialized. type object additionalProperties type integer deserialize title Deserialize description Suggested manifest configs to use to de-serialize the data. type object additionalProperties $ref #/definitions/Manifest additionalProperties False SerializedChunkIDs title SerializedChunkIDs type object properties type title Type default chunk-ids enum <ul> <li>     chunk-ids   </li> </ul> type string chunk_id_list title Chunk Id List description A list of chunk ids, which will be resolved via the attached data registry. type array items type string archive_id title Archive Id description The preferred data archive to get the chunks from. type string format uuid size title Size description The size of all chunks combined. type integer required <ul> <li>     chunk_id_list   </li> <li>     size   </li> </ul> additionalProperties False PersistedData title PersistedData description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type title Data Type description The name of the data type for this serialized value. type string data_type_config title Data Type Config description The (optional) config for the data type for this serialized value. type object serialization_profile title Serialization Profile description An identifying name for the serialization method used. type string metadata title Metadata description Optional metadata describing aspects of the serialization used. allOf <ul> <li> $ref #/definitions/SerializationMetadata </li> </ul> hash_codec title Hash Codec description The codec used to hash the value. default sha2-256 type string archive_id title Archive Id description The id of the store that persisted the data. type string format uuid chunk_id_map title Chunk Id Map description Reference-ids that resolve to the values' serialized chunks. type object additionalProperties $ref #/definitions/SerializedChunkIDs required <ul> <li>     data_type   </li> <li>     serialization_profile   </li> <li>     archive_id   </li> <li>     chunk_id_map   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.pipeline_structure","title":"<code>info.pipeline_structure</code>","text":"type_name info.pipeline_structure The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineStructureInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.PipelineStructureInfo The full class namespace. The python class that implements this module type. metadata_schema title PipelineStructureInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> pipeline_config title Pipeline Config description The underlying pipeline config. allOf <ul> <li> $ref #/definitions/PipelineConfig </li> </ul> steps title Steps description All steps for this pipeline, indexed by their step_id. type object additionalProperties $ref #/definitions/PipelineStep step_details title Step Details description Additional information for each step. type object additionalProperties $ref #/definitions/StepInfo input_aliases title Input Aliases description The input aliases. type object additionalProperties type string output_aliases title Output Aliases description The output aliases. type object additionalProperties type string constants title Constants description The input constants for this pipeline. type object defaults title Defaults description The default inputs for this pipeline. type object pipeline_input_fields title Pipeline Input Fields description The pipeline inputs schema. type object additionalProperties $ref #/definitions/FieldInfo pipeline_output_fields title Pipeline Output Fields description The pipeline outputs schema. type object additionalProperties $ref #/definitions/FieldInfo pipeline_input_refs title Pipeline Input Refs description References to the step inputs that are linked to pipeline inputs. type object additionalProperties $ref #/definitions/PipelineInputRef pipeline_output_refs title Pipeline Output Refs description References to the step outputs that are linked to pipeline outputs. type object additionalProperties $ref #/definitions/PipelineOutputRef execution_graph title Execution Graph description Data describing the execution graph of this pipeline. type object data_flow_graph title Data Flow Graph description Data describing the data flow of this pipeline. type object data_flow_graph_simple title Data Flow Graph Simple description Data describing the (simplified) data flow of this pipeline. type object processing_stages title Processing Stages description A list of lists, containing all the step_ids per stage, in the order of execution. type array items type array items type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     pipeline_config   </li> <li>     steps   </li> <li>     step_details   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> <li>     constants   </li> <li>     defaults   </li> <li>     pipeline_input_fields   </li> <li>     pipeline_output_fields   </li> <li>     pipeline_input_refs   </li> <li>     pipeline_output_refs   </li> <li>     execution_graph   </li> <li>     data_flow_graph   </li> <li>     data_flow_graph_simple   </li> <li>     processing_stages   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string Manifest title Manifest description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean required <ul> <li>     module_type   </li> </ul> additionalProperties False StepValueAddress title StepValueAddress description Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure. type object properties step_id title Step Id description The id of a step within a pipeline. type string value_name title Value Name description The name of the value (output name or pipeline input name). type string sub_value title Sub Value description A reference to a subitem of a value (e.g. column, list item) type object required <ul> <li>     step_id   </li> <li>     value_name   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False PipelineStep title PipelineStep description A step within a pipeline-structure, includes information about it's connection(s) and other metadata. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The module config. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean step_id title Step Id description Locally unique id (within a pipeline) of this step. type string manifest_src title Manifest Src description The original manfifest provided by the user. allOf <ul> <li> $ref #/definitions/Manifest </li> </ul> input_links title Input Links description The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs. type object additionalProperties type array items $ref #/definitions/StepValueAddress module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> doc title Doc description A description what this step does. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     module_type   </li> <li>     step_id   </li> <li>     manifest_src   </li> <li>     module_details   </li> <li>     doc   </li> </ul> additionalProperties False PipelineConfig title PipelineConfig description A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].  If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.  To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.  Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``, in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.  Examples:      Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):      ``` python     and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")     not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}     nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",                         steps=[and_step, not_step],                         input_aliases={                             \"and__a\": \"a\",                             \"and__b\": \"b\"                         },                         output_aliases={                             \"not__y\": \"y\"                         }}     ```      Or, the same thing in json:      ``` json     {       \"module_type_name\": \"nand\",       \"doc\": \"Returns 'False' if both inputs are 'True'.\",       \"steps\": [         {           \"module_type\": \"and\",           \"step_id\": \"and\"         },         {           \"module_type\": \"not\",           \"step_id\": \"not\",           \"input_links\": {             \"a\": \"and.y\"           }         }       ],       \"input_aliases\": {         \"and__a\": \"a\",         \"and__b\": \"b\"       },       \"output_aliases\": {         \"not__y\": \"y\"       }     }     ``` type object properties constants title Constants description Value constants for this module. type object defaults title Defaults description Value defaults for this module. type object pipeline_name title Pipeline Name description The name of this pipeline. type string steps title Steps description A list of steps/modules of this pipeline, and their connections. type array items $ref #/definitions/PipelineStep input_aliases title Input Aliases description A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value. type object additionalProperties type string output_aliases title Output Aliases description A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value. type object additionalProperties type string doc title Doc description Documentation about what the pipeline does. default -- n/a -- allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> context title Context description Metadata for this workflow. type object required <ul> <li>     pipeline_name   </li> <li>     steps   </li> <li>     input_aliases   </li> <li>     output_aliases   </li> </ul> StepInputRef title StepInputRef description An input to a step.  This object can either have a 'connected_outputs' set, or a 'connected_pipeline_input', not both. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema step_id title Step Id description The step id. type string connected_outputs title Connected Outputs description A potential connected list of one or several module outputs. type array items $ref #/definitions/StepValueAddress connected_pipeline_input title Connected Pipeline Input description A potential pipeline input. type string is_constant title Is Constant description Whether this input is a constant and can't be changed by the user. type boolean required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     step_id   </li> <li>     is_constant   </li> </ul> additionalProperties False StepOutputRef title StepOutputRef description An output to a step. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema step_id title Step Id description The step id. type string pipeline_output title Pipeline Output description The connected pipeline output. type string connected_inputs title Connected Inputs description The step inputs that are connected to this step output type array items $ref #/definitions/StepValueAddress required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     step_id   </li> </ul> additionalProperties False StepInfo title StepInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties step title Step description The pipeline step object. allOf <ul> <li> $ref #/definitions/PipelineStep </li> </ul> inputs title Inputs description Reference(s) to the fields that feed this steps inputs. type object additionalProperties $ref #/definitions/StepInputRef outputs title Outputs description Reference(s) to the fields that are fed by this steps outputs. type object additionalProperties $ref #/definitions/StepOutputRef required title Required description Whether this step is always required or whether all his outputs feed into optional input fields. type boolean required <ul> <li>     step   </li> <li>     inputs   </li> <li>     outputs   </li> <li>     required   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False FieldInfo title FieldInfo type object properties field_name title Field Name description The field name. type string field_schema title Field Schema description The schema of the field. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> data_type_info title Data Type Info description Information about the data type instance of the associated value. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> value_required title Value Required description Whether user input is required (meaning: 'optional' is False, and no default set). type boolean required <ul> <li>     field_name   </li> <li>     field_schema   </li> <li>     data_type_info   </li> <li>     value_required   </li> </ul> PipelineInputRef title PipelineInputRef description An input to a pipeline. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema connected_inputs title Connected Inputs description The step inputs that are connected to this pipeline input type array items $ref #/definitions/StepValueAddress is_constant title Is Constant description Whether this input is a constant and can't be changed by the user. type boolean required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     is_constant   </li> </ul> additionalProperties False PipelineOutputRef title PipelineOutputRef description An output to a pipeline. type object properties value_name title Value Name type string value_schema $ref #/definitions/ValueSchema connected_output title Connected Output description Connected step outputs. allOf <ul> <li> $ref #/definitions/StepValueAddress </li> </ul> required <ul> <li>     value_name   </li> <li>     value_schema   </li> <li>     connected_output   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.operation","title":"<code>info.operation</code>","text":"type_name info.operation The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OperationInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.OperationInfo The full class namespace. The python class that implements this module type. metadata_schema title OperationInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> operation title Operation description The operation instance. allOf <ul> <li> $ref #/definitions/Operation </li> </ul> operation_types title Operation Types description The operation types this operation belongs to. type array items type string input_fields title Input Fields description The inputs schema for this operation. type object additionalProperties $ref #/definitions/FieldInfo output_fields title Output Fields description The outputs schema for this operation. type object additionalProperties $ref #/definitions/FieldInfo required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     operation   </li> <li>     operation_types   </li> <li>     input_fields   </li> <li>     output_fields   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string OperationDetails title OperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean required <ul> <li>     operation_id   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False Operation title Operation description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean operation_id title Operation Id description The (unique) id of this operation. type string operation_details title Operation Details description The operation specific details of this operation. allOf <ul> <li> $ref #/definitions/OperationDetails </li> </ul> doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> metadata title Metadata description Additional metadata for this operation. type object required <ul> <li>     module_type   </li> <li>     operation_id   </li> <li>     operation_details   </li> <li>     doc   </li> <li>     module_details   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False FieldInfo title FieldInfo type object properties field_name title Field Name description The field name. type string field_schema title Field Schema description The schema of the field. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> data_type_info title Data Type Info description Information about the data type instance of the associated value. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> value_required title Value Required description Whether user input is required (meaning: 'optional' is False, and no default set). type boolean required <ul> <li>     field_name   </li> <li>     field_schema   </li> <li>     data_type_info   </li> <li>     value_required   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.renderer_info","title":"<code>renderer_info</code>","text":"type_name renderer_info The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RendererInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.RendererInfo The full class namespace. The python class that implements this module type. metadata_schema title RendererInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> renderer_config title Renderer Config description The renderer config. type object renderer_cls title Renderer Cls description The Python class that implements the renderer. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> supported_inputs title Supported Inputs description Descriptions of the supported inputs. type array items type string supported_source_types title Supported Source Types description Descriptions of the supported source types. type array items type string supported_target_types title Supported Target Types description Descriptions of the supported target types. type array items type string supported_python_classes title Supported Python Classes description A list of supported Python types that are acceptable as inputs. type array items $ref #/definitions/PythonClass required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     renderer_config   </li> <li>     renderer_cls   </li> <li>     supported_inputs   </li> <li>     supported_source_types   </li> <li>     supported_target_types   </li> <li>     supported_python_classes   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.kiara_models","title":"<code>info.kiara_models</code>","text":"type_name info.kiara_models The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraModelClassesInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.KiaraModelClassesInfo The full class namespace. The python class that implements this module type. metadata_schema title KiaraModelClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The value metadata info instances for each type. type object additionalProperties $ref #/definitions/KiaraModelTypeInfo type_name title Type Name default kiara_model enum <ul> <li>     kiara_model   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False KiaraModelTypeInfo title KiaraModelTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> metadata_schema title Metadata Schema description The (json) schema for this model data. type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     metadata_schema   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.data_types","title":"<code>info.data_types</code>","text":"type_name info.data_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DataTypeClassesInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.DataTypeClassesInfo The full class namespace. The python class that implements this module type. metadata_schema title DataTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The data_type info instances for each type. type object additionalProperties $ref #/definitions/DataTypeClassInfo type_name title Type Name default data_type enum <ul> <li>     data_type   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeClassInfo title DataTypeClassInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> value_cls title Value Cls description The python class of the value itself. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> data_type_config_cls title Data Type Config Cls description The python class holding the schema for configuring this type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> lineage title Lineage description This types lineage. type array items type string qualifier_profiles title Qualifier Profiles description A map of qualifier profiles for this data types. type object additionalProperties type object required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     value_cls   </li> <li>     data_type_config_cls   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.module_types","title":"<code>info.module_types</code>","text":"type_name info.module_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ModuleTypesInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.ModuleTypesInfo The full class namespace. The python class that implements this module type. metadata_schema title ModuleTypesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The module type info instances for each type. type object additionalProperties $ref #/definitions/ModuleTypeInfo type_name title Type Name default module_type enum <ul> <li>     module_type   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ModuleTypeInfo title ModuleTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> module_src title Module Src description The source code of the process method of the module. type string required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> <li>     module_src   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.operation_types","title":"<code>info.operation_types</code>","text":"type_name info.operation_types The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OperationTypeClassesInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.OperationTypeClassesInfo The full class namespace. The python class that implements this module type. metadata_schema title OperationTypeClassesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The operation info instances for each type. type object additionalProperties $ref #/definitions/OperationTypeInfo type_name title Type Name default operation_type enum <ul> <li>     operation_type   </li> </ul> type string required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False OperationTypeInfo title OperationTypeInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> python_class title Python Class description The python class that implements this module type. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     python_class   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.values_info","title":"<code>values_info</code>","text":"type_name values_info The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValuesInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.ValuesInfo The full class namespace. The python class that implements this module type. metadata_schema title ValuesInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The info items. type object additionalProperties $ref #/definitions/ItemInfo required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string ItemInfo title ItemInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.info.operations","title":"<code>info.operations</code>","text":"type_name info.operations The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name OperationGroupInfo The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.OperationGroupInfo The full class namespace. The python class that implements this module type. metadata_schema title OperationGroupInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The operation info instances for each type. type object additionalProperties $ref #/definitions/OperationInfo required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string OperationDetails title OperationDetails description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties operation_id title Operation Id description The id of the operation. type string is_internal_operation title Is Internal Operation description Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). default False type boolean required <ul> <li>     operation_id   </li> </ul> additionalProperties False ValueSchema title ValueSchema description The schema of a value.  The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that will be used if no user input was given (yet) for a value.  For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field. type object properties type title Type description The type of the value. type string type_config title Type Config description Configuration for the type, in case it's complex. type object default title Default description A default value. default __not_set__ optional title Optional description Whether this value is required (True), or whether 'None' value is allowed (False). default False type boolean is_constant title Is Constant description Whether the value is a constant. default False type boolean doc title Doc description A description for the value of this input field. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> required <ul> <li>     type   </li> </ul> additionalProperties False KiaraModuleInstance title KiaraModuleInstance description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string module_config title Module Config description The module config. type object inputs_schema title Inputs Schema description The schema for the module input(s). type object additionalProperties $ref #/definitions/ValueSchema outputs_schema title Outputs Schema description The schema for the module output(s). type object additionalProperties $ref #/definitions/ValueSchema required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> <li>     module_config   </li> <li>     inputs_schema   </li> <li>     outputs_schema   </li> </ul> additionalProperties False Operation title Operation description A class to hold the type and configuration for a module instance. type object properties module_type title Module Type description The module type. type string module_config title Module Config description The configuration for the module. type object is_resolved title Is Resolved description Whether the configuration of this module was augmented with the module type defaults etc. default False type boolean operation_id title Operation Id description The (unique) id of this operation. type string operation_details title Operation Details description The operation specific details of this operation. allOf <ul> <li> $ref #/definitions/OperationDetails </li> </ul> doc title Doc description Documentation for this operation. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> module_details title Module Details description The class of the underlying module. allOf <ul> <li> $ref #/definitions/KiaraModuleInstance </li> </ul> metadata title Metadata description Additional metadata for this operation. type object required <ul> <li>     module_type   </li> <li>     operation_id   </li> <li>     operation_details   </li> <li>     doc   </li> <li>     module_details   </li> </ul> additionalProperties False DataTypeCharacteristics title DataTypeCharacteristics type object properties is_scalar title Is Scalar description Whether the data desribed by this data type behaves like a skalar. default False type boolean is_json_serializable title Is Json Serializable description Whether the data can be serialized to json without information loss. default False type boolean PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False DataTypeInfo title DataTypeInfo description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties data_type_name title Data Type Name description The registered name of this data type. type string data_type_config title Data Type Config description The (optional) configuration for this data type. type object characteristics title Characteristics description Characteristics of this data type. allOf <ul> <li> $ref #/definitions/DataTypeCharacteristics </li> </ul> data_type_class title Data Type Class description The python class that is associated with this model. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> required <ul> <li>     data_type_name   </li> <li>     characteristics   </li> <li>     data_type_class   </li> </ul> additionalProperties False FieldInfo title FieldInfo type object properties field_name title Field Name description The field name. type string field_schema title Field Schema description The schema of the field. allOf <ul> <li> $ref #/definitions/ValueSchema </li> </ul> data_type_info title Data Type Info description Information about the data type instance of the associated value. allOf <ul> <li> $ref #/definitions/DataTypeInfo </li> </ul> value_required title Value Required description Whether user input is required (meaning: 'optional' is False, and no default set). type boolean required <ul> <li>     field_name   </li> <li>     field_schema   </li> <li>     data_type_info   </li> <li>     value_required   </li> </ul> OperationInfo title OperationInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> operation title Operation description The operation instance. allOf <ul> <li> $ref #/definitions/Operation </li> </ul> operation_types title Operation Types description The operation types this operation belongs to. type array items type string input_fields title Input Fields description The inputs schema for this operation. type object additionalProperties $ref #/definitions/FieldInfo output_fields title Output Fields description The outputs schema for this operation. type object additionalProperties $ref #/definitions/FieldInfo required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> <li>     operation   </li> <li>     operation_types   </li> <li>     input_fields   </li> <li>     output_fields   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.renderer_infos","title":"<code>renderer_infos</code>","text":"type_name renderer_infos The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RendererInfos The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.RendererInfos The full class namespace. The python class that implements this module type. metadata_schema title RendererInfos description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties group_title title Group Title description The group alias. type string item_infos title Item Infos description The info items. type object additionalProperties $ref #/definitions/ItemInfo required <ul> <li>     item_infos   </li> </ul> additionalProperties False definitions DocumentationMetadataModel title Documentation description Documentation about a resource. type object properties description title Description description Short description of the item. default -- n/a -- type string doc title Doc description Detailed documentation of the item (in markdown). type string additionalProperties False AuthorModel title Author description Details about an author of a resource. type object properties name title Name description The full name of the author. type string email title Email description The email address of the author type string format email required <ul> <li>     name   </li> </ul> AuthorsMetadataModel title Authors description Information about all authors of a resource. type object properties authors title Authors description The authors/creators of this item. type array items $ref #/definitions/AuthorModel LinkModel title Link description A description and url for a reference of any kind. type object properties url title Url description The url. minLength 1 maxLength 65536 format uri type string desc title Desc description A short description of the link content. default -- n/a -- type string required <ul> <li>     url   </li> </ul> ContextMetadataModel title Context description Information about the context of a resource. type object properties references title References description References for the item. type object additionalProperties $ref #/definitions/LinkModel tags title Tags description A list of tags for the item. type array items type string labels title Labels description A list of labels for the item. type object additionalProperties type string ItemInfo title ItemInfo description Base class that holds/manages information about an item within kiara. type object properties type_name title Type Name description The registered name for this item type. type string documentation title Documentation description Documentation for the item. allOf <ul> <li> $ref #/definitions/DocumentationMetadataModel </li> </ul> authors title Authors description Information about authorship for the item. allOf <ul> <li> $ref #/definitions/AuthorsMetadataModel </li> </ul> context title Context description Generic properties of this item (description, tags, labels, references, ...). allOf <ul> <li> $ref #/definitions/ContextMetadataModel </li> </ul> required <ul> <li>     type_name   </li> <li>     documentation   </li> <li>     authors   </li> <li>     context   </li> </ul> additionalProperties False The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.metadata.module_config","title":"<code>metadata.module_config</code>","text":"type_name metadata.module_config The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name KiaraModuleConfigMetadata The name of the Python class. python_module_name kiara.interfaces.python_api.models.info The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata The full class namespace. The python class that implements this module type. metadata_schema title KiaraModuleConfigMetadata description Base class that all models in kiara inherit from.  This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc. type object properties python_class title Python Class description The config model python class. allOf <ul> <li> $ref #/definitions/PythonClass </li> </ul> config_values title Config Values description The available configuration values. type object additionalProperties $ref #/definitions/ValueTypeAndDescription required <ul> <li>     python_class   </li> <li>     config_values   </li> </ul> additionalProperties False definitions PythonClass title PythonClass description Python class and module information. type object properties python_class_name title Python Class Name description The name of the Python class. type string python_module_name title Python Module Name description The name of the Python module this class lives in. type string full_name title Full Name description The full class namespace. type string required <ul> <li>     python_class_name   </li> <li>     python_module_name   </li> <li>     full_name   </li> </ul> additionalProperties False ValueTypeAndDescription title ValueTypeAndDescription type object properties description title Description description The description for the value. type string type title Type description The value type. type string value_default title Value Default description Default for the value. required title Required description Whether this value is required type boolean required <ul> <li>     description   </li> <li>     type   </li> <li>     required   </li> </ul> The (json) schema for this model data."},{"location":"included_components/kiara_model_types/#kiara_info.kiara_model_types.workflow_matcher","title":"<code>workflow_matcher</code>","text":"type_name workflow_matcher The registered name for this item type. documentation description An object describing requirements values should satisfy in order to be included in a query result. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name WorkflowMatcher The name of the Python class. python_module_name kiara.interfaces.python_api.models.workflow The name of the Python module this class lives in. full_name kiara.interfaces.python_api.models.workflow.WorkflowMatcher The full class namespace. The python class that implements this module type. metadata_schema title WorkflowMatcher description An object describing requirements values should satisfy in order to be included in a query result. type object properties has_alias title Has Alias description Workflow must have at least one alias. default False type boolean additionalProperties False The (json) schema for this model data."},{"location":"included_components/module_types/","title":"module_types","text":""},{"location":"included_components/module_types/#kiara_info.module_types.deserialize.file","title":"<code>deserialize.file</code>","text":"type_name deserialize.file The registered name for this item type. documentation description Deserialize data to a 'file' value instance. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DeserializeFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.DeserializeFileModule The full class namespace. The python class that implements this module type. module_src class DeserializeFileModule(DeserializeValueModule):     \"\"\"Deserialize data to a 'file' value instance.\"\"\"      _module_type_name = \"deserialize.file\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:         return {\"python_object\": FileModel}      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:         return \"file\"      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"copy\"      def to__python_object(self, data: SerializedData, **config: Any):          keys = list(data.get_keys())         keys.remove(\"__file_metadata__\")         assert len(keys) == 1          file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")         assert file_metadata_chunks.get_number_of_chunks() == 1         file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))         assert len(file_metadata_json) == 1         file_metadata = orjson.loads(file_metadata_json[0])          chunks = data.get_serialized_data(keys[0])         assert chunks.get_number_of_chunks() == 1          files = list(chunks.get_chunks(as_files=True, symlink_ok=True))         assert len(files) == 1          file: str = files[0]  # type: ignore          fm = FileModel.load_file(             source=file,             file_name=file_metadata[\"file_name\"],         )         return fm  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.deserialize.file_bundle","title":"<code>deserialize.file_bundle</code>","text":"type_name deserialize.file_bundle The registered name for this item type. documentation description Deserialize data to a 'file' value instance. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DeserializeFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule The full class namespace. The python class that implements this module type. module_src class DeserializeFileBundleModule(DeserializeValueModule):     \"\"\"Deserialize data to a 'file' value instance.\"\"\"      _module_type_name = \"deserialize.file_bundle\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:         return {\"python_object\": FileBundle}      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:         return \"file_bundle\"      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"copy\"      def to__python_object(self, data: SerializedData, **config: Any):          keys = list(data.get_keys())         keys.remove(\"__file_metadata__\")          file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")         assert file_metadata_chunks.get_number_of_chunks() == 1         file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))         assert len(file_metadata_json) == 1         metadata = orjson.loads(file_metadata_json[0])         file_metadata = metadata[\"included_files\"]         bundle_name = metadata[\"bundle_name\"]         # bundle_import_time = metadata[\"import_time\"]         sum_size = metadata[\"size\"]         number_of_files = metadata[\"number_of_files\"]          included_files = {}         for rel_path in keys:              chunks = data.get_serialized_data(rel_path)             assert chunks.get_number_of_chunks() == 1              files = list(chunks.get_chunks(as_files=True, symlink_ok=True))             assert len(files) == 1              file: str = files[0]  # type: ignore             file_name = file_metadata[rel_path][\"file_name\"]             # import_time = file_metadata[rel_path][\"import_time\"]             fm = FileModel.load_file(source=file, file_name=file_name)             included_files[rel_path] = fm          fb = FileBundle(             included_files=included_files,             bundle_name=bundle_name,             # import_time=bundle_import_time,             number_of_files=number_of_files,             size=sum_size,         )         return fb  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.deserialize.from_json","title":"<code>deserialize.from_json</code>","text":"type_name deserialize.from_json The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DeserializeFromJsonModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule The full class namespace. The python class that implements this module type. module_src class DeserializeFromJsonModule(KiaraModule):      _module_type_name: str = \"deserialize.from_json\"     _config_cls = DeserializeJsonConfig      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:         return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"value\": {                 \"type\": \"any\",                 \"doc\": \"The value object to deserialize the data for.\",             }         }      def create_outputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"python_object\": {                 \"type\": \"python_object\",                 \"doc\": \"The deserialized python object.\",             }         }      def process(self, inputs: ValueMap, outputs: ValueMap):          value: Value = inputs.get_value_obj(\"value\")         serialized: SerializedData = value.serialized_data          chunks = serialized.get_serialized_data(self.get_config_value(\"result_path\"))         assert chunks.get_number_of_chunks() == 1         _data = list(chunks.get_chunks(as_files=False))         assert len(_data) == 1         _chunk: bytes = _data[0]  # type: ignore          deserialized = orjson.loads(_chunk)          outputs.set_value(\"python_object\", deserialized)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.export.file","title":"<code>export.file</code>","text":"type_name export.file The registered name for this item type. documentation description Export files. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExportFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ExportFileModule The full class namespace. The python class that implements this module type. module_src class ExportFileModule(DataExportModule):     \"\"\"Export files.\"\"\"      _module_type_name = \"export.file\"      def export__file__as__file(self, value: FileModel, base_path: str, name: str):          target_path = os.path.join(base_path, value.file_name)          shutil.copy2(value.path, target_path)          return {\"files\": target_path}  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.file_bundle.pick.file","title":"<code>file_bundle.pick.file</code>","text":"type_name file_bundle.pick.file The registered name for this item type. documentation description Pick a single file from a file_bundle value. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PickFileFromFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule The full class namespace. The python class that implements this module type. module_src class PickFileFromFileBundleModule(KiaraModule):     \"\"\"Pick a single file from a file_bundle value.\"\"\"      _module_type_name = \"file_bundle.pick.file\"      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},             \"path\": {\"type\": \"string\", \"doc\": \"The relative path of the file to pick.\"},         }      def create_outputs_schema(         self,     ) -&gt; ValueMapSchema:          return {\"file\": {\"type\": \"file\", \"doc\": \"The file.\"}}      def process(self, inputs: ValueMap, outputs: ValueMap):          file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")         path: str = inputs.get_value_data(\"path\")          if path not in file_bundle.included_files.keys():             raise KiaraProcessingException(                 f\"Can't pick file '{path}' from file bundle: file not available.\"             )          file: FileModel = file_bundle.included_files[path]          outputs.set_value(\"file\", file)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.file_bundle.pick.sub_folder","title":"<code>file_bundle.pick.sub_folder</code>","text":"type_name file_bundle.pick.sub_folder The registered name for this item type. documentation description Pick a sub-folder from a file_bundle, resulting in a new file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PickSubBundle The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.PickSubBundle The full class namespace. The python class that implements this module type. module_src class PickSubBundle(KiaraModule):     \"\"\"Pick a sub-folder from a file_bundle, resulting in a new file_bundle.\"\"\"      _module_type_name = \"file_bundle.pick.sub_folder\"      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},             \"sub_path\": {                 \"type\": \"string\",                 \"doc\": \"The relative path of the sub-folder to pick.\",             },         }      def create_outputs_schema(self) -&gt; ValueMapSchema:         return {             \"file_bundle\": {                 \"type\": \"file_bundle\",                 \"doc\": \"The picked (sub-)file_bundle.\",             }         }      def process(self, inputs: ValueMap, outputs: ValueMap):          file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")         sub_path: str = inputs.get_value_data(\"sub_path\")          result = {}         for path, file in file_bundle.included_files.items():             if path.startswith(sub_path):                 result[path] = file          if not result:             raise KiaraProcessingException(                 f\"Can't pick sub-folder '{sub_path}' from file bundle: no matches.\"             )          new_file_bundle: FileBundle = FileBundle.create_from_file_models(             result, bundle_name=f\"{file_bundle.bundle_name}_{sub_path}\"         )          outputs.set_value(\"file_bundle\", new_file_bundle)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.import.local.file","title":"<code>import.local.file</code>","text":"type_name import.local.file The registered name for this item type. documentation description Import a file from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ImportLocalFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ImportLocalFileModule The full class namespace. The python class that implements this module type. module_src class ImportLocalFileModule(KiaraModule):     \"\"\"Import a file from the local filesystem.\"\"\"      _module_type_name = \"import.local.file\"      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          return {\"path\": {\"type\": \"string\", \"doc\": \"The local path to the file.\"}}      def create_outputs_schema(         self,     ) -&gt; ValueMapSchema:          return {\"file\": {\"type\": \"file\", \"doc\": \"The loaded files.\"}}      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:         return ModuleCharacteristics(is_idempotent=False)      def process(self, inputs: ValueMap, outputs: ValueMap):          path = inputs.get_value_data(\"path\")          file = FileModel.load_file(source=path)         outputs.set_value(\"file\", file)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.import.local.file_bundle","title":"<code>import.local.file_bundle</code>","text":"type_name import.local.file_bundle The registered name for this item type. documentation description Import a folder (file_bundle) from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ImportLocalFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule The full class namespace. The python class that implements this module type. module_src class ImportLocalFileBundleModule(KiaraModule):     \"\"\"Import a folder (file_bundle) from the local filesystem.\"\"\"      _module_type_name = \"import.local.file_bundle\"     _config_cls = ImportFileBundleConfig      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"path\": {\"type\": \"string\", \"doc\": \"The local path of the folder to import.\"}         }      def create_outputs_schema(         self,     ) -&gt; ValueMapSchema:          return {             \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The imported file bundle.\"}         }      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:         return DEFAULT_NO_IDEMPOTENT_MODULE_CHARACTERISTICS      def process(self, inputs: ValueMap, outputs: ValueMap):          path = inputs.get_value_data(\"path\")          include = self.get_config_value(\"include_file_types\")         exclude = self.get_config_value(\"exclude_file_types\")          config = FolderImportConfig(include_files=include, exclude_files=exclude)          file_bundle = FileBundle.import_folder(source=path, import_config=config)         outputs.set_value(\"file_bundle\", file_bundle)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.load.bytes","title":"<code>load.bytes</code>","text":"type_name load.bytes The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name LoadBytesModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadBytesModule The full class namespace. The python class that implements this module type. module_src class LoadBytesModule(DeserializeValueModule):      _module_type_name = \"load.bytes\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:         return {\"python_object\": bytes}      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"raw\"      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:         return \"bytes\"      def to__python_object(self, data: SerializedData, **config: Any) -&gt; bytes:          chunks = data.get_serialized_data(\"bytes\")         assert chunks.get_number_of_chunks() == 1         _chunks = list(chunks.get_chunks(as_files=False))         assert len(_chunks) == 1         _chunk: bytes = _chunks[0]  # type: ignore         return _chunk  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.load.internal_model","title":"<code>load.internal_model</code>","text":"type_name load.internal_model The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name LoadInternalModel The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadInternalModel The full class namespace. The python class that implements this module type. module_src class LoadInternalModel(DeserializeValueModule):      _module_type_name = \"load.internal_model\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:         return {\"python_object\": KiaraModel}      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"json\"      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:         return \"internal_model\"      def to__python_object(self, data: SerializedData, **config: Any) -&gt; KiaraModel:          chunks = data.get_serialized_data(\"data\")         assert chunks.get_number_of_chunks() == 1         _chunks = list(chunks.get_chunks(as_files=False))         assert len(_chunks) == 1          bytes_string: bytes = _chunks[0]  # type: ignore         model_data = orjson.loads(bytes_string)          model_id: str = data.data_type_config[\"kiara_model_id\"]         model_registry = ModelRegistry.instance()         m_cls = model_registry.get_model_cls(kiara_model_id=model_id)         obj = m_cls(**model_data)         return obj  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.load.string","title":"<code>load.string</code>","text":"type_name load.string The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name LoadStringModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadStringModule The full class namespace. The python class that implements this module type. module_src class LoadStringModule(DeserializeValueModule):      _module_type_name = \"load.string\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:         return {\"python_object\": str}      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"raw\"      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:         return \"string\"      def to__python_object(self, data: SerializedData, **config: Any) -&gt; str:          chunks = data.get_serialized_data(\"string\")         assert chunks.get_number_of_chunks() == 1         _chunks = list(chunks.get_chunks(as_files=False))         assert len(_chunks) == 1          bytes_string: bytes = _chunks[0]  # type: ignore         return bytes_string.decode(\"utf-8\")  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.pipeline","title":"<code>pipeline</code>","text":"type_name pipeline The registered name for this item type. documentation description A utility module to run multiple connected inner-modules and present it as its own entity. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pipeline The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pipeline.PipelineModule The full class namespace. The python class that implements this module type. module_src class PipelineModule(KiaraModule):     \"\"\"A utility module to run multiple connected inner-modules and present it as its own entity.\"\"\"      _config_cls = PipelineConfig     _module_type_name = \"pipeline\"      def __init__(         self,         module_config: Union[None, KIARA_CONFIG, Mapping[str, Any]] = None,     ):         self._job_registry: Union[JobRegistry, None] = None         super().__init__(module_config=module_config)      @classmethod     def is_pipeline(cls) -&gt; bool:         return True      def _set_job_registry(self, job_registry: \"JobRegistry\"):         self._job_registry = job_registry      @property     def operation(self) -&gt; \"Operation\":          if self._operation is not None:             return self._operation          from kiara.models.module.operation import Operation          self._operation = Operation.create_from_module(self, doc=self.config.doc)         return self._operation      def create_inputs_schema(         self,     ) -&gt; ValueMapSchema:          pipeline_structure: PipelineStructure = self.config.structure         inputs_schema = pipeline_structure.pipeline_inputs_schema         return inputs_schema      def create_outputs_schema(         self,     ) -&gt; ValueMapSchema:         pipeline_structure: PipelineStructure = self.config.structure         return pipeline_structure.pipeline_outputs_schema      def process(self, inputs: ValueMap, outputs: ValueMapWritable, job_log: JobLog):          pipeline_structure: PipelineStructure = self.config.structure          pipeline = Pipeline(structure=pipeline_structure, kiara=outputs._kiara)          assert self._job_registry is not None         controller = SinglePipelineBatchController(             pipeline=pipeline, job_registry=self._job_registry         )          pipeline.set_pipeline_inputs(inputs=inputs)         step_details = controller.process_pipeline()          errors: Dict[str, Union[Exception, uuid.UUID]] = {}         for step_id, details in step_details.items():             if isinstance(details, Exception):                 errors[step_id] = details             else:                 job = self._job_registry.get_job(details)                 if job.error:                     if job._exception:                         errors[step_id] = job._exception                     else:                         errors[step_id] = Exception(job.error)          if errors:             msg = \"Error processing pipeline:\"             for f, e in errors.items():                 msg = f\"{msg}\\n  - {f}: {e}\"              raise KiaraProcessingException(f\"Errors while processing pipeline: {msg}\")          # TODO: resolve values first?         outputs.set_values(**pipeline.get_current_pipeline_outputs())  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.pretty_print.any.value","title":"<code>pretty_print.any.value</code>","text":"type_name pretty_print.any.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PrettyPrintAnyValueModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.PrettyPrintAnyValueModule The full class namespace. The python class that implements this module type. module_src class PrettyPrintAnyValueModule(PrettyPrintModule):      _module_type_name = \"pretty_print.any.value\"      # def pretty_print__any__as__string(self, value: Value, render_config: Dict[str, Any]):     #     #     data = value.data     #     if isinstance(data, KiaraModel):     #         return data.json(option=orjson.OPT_INDENT_2)     #     else:     #         return str(data)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.pretty_print.value","title":"<code>pretty_print.value</code>","text":"type_name pretty_print.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. The python class that implements this module type. module_src class ValueTypePrettyPrintModule(KiaraModule):      _module_type_name = \"pretty_print.value\"     _config_cls = PrettyPrintConfig      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:         return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS      def create_inputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          source_type = self.get_config_value(\"source_type\")         assert source_type not in [\"target\", \"base_name\"]          schema = {             \"value\": {                 \"type\": source_type,                 \"doc\": \"The value to render.\",                 \"optional\": True,             },             \"render_config\": {                 \"type\": \"any\",                 \"doc\": \"Value type dependent render configuration.\",                 \"optional\": True,             },         }          return schema      def create_outputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          return {             \"rendered_value\": {                 \"type\": self.get_config_value(\"target_type\"),                 \"doc\": \"The rendered value.\",             }         }      def process(self, inputs: ValueMap, outputs: ValueMap):          # source_type = self.get_config_value(\"source_type\")         target_type = self.get_config_value(\"target_type\")          source_value = inputs.get_value_obj(\"value\")         render_config = inputs.get_value_obj(\"render_config\")          if not source_value.is_set:             outputs.set_value(\"rendered_value\", \"-- none/not set --\")             return          try:             data_type_cls = source_value.data_type_info.data_type_class.get_class()             data_type = data_type_cls(**source_value.value_schema.type_config)         except Exception as e:             source_data_type = source_value.data_type_name             log_message(\"data_type.unknown\", data_type=source_data_type, error=e)              from kiara.data_types.included_core_types import AnyType              data_type = AnyType()          func_name = f\"pretty_print_as__{target_type}\"         func = getattr(data_type, func_name)          render_config_dict = render_config.data         if render_config_dict is None:             render_config_dict = {}          result = func(value=source_value, render_config=render_config_dict)         # TODO: check we have the correct type?         outputs.set_value(\"rendered_value\", result)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.render.value","title":"<code>render.value</code>","text":"type_name render.value The registered name for this item type. documentation description A module that uses render methods attached to DataType classes. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. The python class that implements this module type. module_src class ValueTypeRenderModule(KiaraModule):     \"\"\"A module that uses render methods attached to DataType classes.\"\"\"      _module_type_name = \"render.value\"     _config_cls = RenderValueModuleConfig      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:         return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS      def create_inputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          source_type = self.get_config_value(\"source_type\")         assert source_type not in [\"target\", \"base_name\"]          schema = {             \"value\": {                 \"type\": source_type,                 \"doc\": \"The value to render.\",                 \"optional\": False,             },             \"render_config\": {                 \"type\": \"dict\",                 \"doc\": \"Instructions/config on how (or what) to render the provided value.\",                 \"default\": {},             },         }          return schema      def create_outputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          outputs = {             \"render_value_result\": {                 \"type\": \"render_value_result\",                 \"doc\": \"The rendered value, incl. some metadata.\",             },         }          return outputs      def process(self, inputs: ValueMap, outputs: ValueMap):          source_value = inputs.get_value_obj(\"value\")         if not source_value.is_set:             raise KiaraProcessingException(                 f\"Can't render value '{source_value.value_id}': value not set.\"             )          # source_type = self.get_config_value(\"source_type\")         target_type = self.get_config_value(\"target_type\")          render_scene: DictModel = inputs.get_value_data(\"render_config\")          try:             data_type_cls = source_value.data_type_info.data_type_class.get_class()             data_type = data_type_cls(**source_value.value_schema.type_config)          except Exception as e:             source_data_type = source_value.data_type_name             log_message(\"data_type.unknown\", data_type=source_data_type, error=e)              from kiara.data_types.included_core_types import AnyType              data_type = AnyType()          func_name = f\"render_as__{target_type}\"         func = getattr(data_type, func_name)          if render_scene:             rc = render_scene.dict_data         else:             rc = {}          result = func(             value=source_value,             render_config=rc,             manifest=self.manifest,         )          if isinstance(result, RenderValueResult):             render_scene_result = result         else:             render_scene_result = RenderValueResult(                 value_id=source_value.value_id,                 render_config=rc,                 render_manifest=self.manifest.manifest_hash,                 rendered=result,                 related_scenes={},                 manifest_lookup={self.manifest.manifest_hash: self.manifest},             )          outputs.set_value(\"render_value_result\", render_scene_result)  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.unpickle.value","title":"<code>unpickle.value</code>","text":"type_name unpickle.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name UnpickleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.UnpickleModule The full class namespace. The python class that implements this module type. module_src class UnpickleModule(DeserializeValueModule):      _module_type_name = \"unpickle.value\"      @classmethod     def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:          return {\"python_object\": object}      @classmethod     def retrieve_supported_serialization_profile(cls) -&gt; str:         return \"pickle\"      @classmethod     def retrieve_serialized_value_type(cls) -&gt; str:          return \"any\"      def to__python_object(self, data: SerializedData, **config: Any):          try:             import pickle5 as pickle         except Exception:             import pickle  # type: ignore          assert \"python_object\" in data.get_keys()         python_object_data = data.get_serialized_data(\"python_object\")         assert python_object_data.get_number_of_chunks() == 1          _bytes = list(python_object_data.get_chunks(as_files=False))[0]         data = pickle.loads(_bytes)          return data  The source code of the process method of the module."},{"location":"included_components/module_types/#kiara_info.module_types.value.extract_metadata","title":"<code>value.extract_metadata</code>","text":"type_name value.extract_metadata The registered name for this item type. documentation description Base class to use when writing a module to extract metadata from a file. Short description of the item. doc It's possible to use any arbitrary *kiara* module for this purpose, but sub-classing this makes it easier. Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExtractMetadataModule The name of the Python class. python_module_name kiara.modules.included_core_modules.metadata The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.metadata.ExtractMetadataModule The full class namespace. The python class that implements this module type. module_src class ExtractMetadataModule(KiaraModule):     \"\"\"Base class to use when writing a module to extract metadata from a file.      It's possible to use any arbitrary *kiara* module for this purpose, but sub-classing this makes it easier.     \"\"\"      _config_cls = MetadataModuleConfig     _module_type_name: str = \"value.extract_metadata\"      def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:          return ModuleCharacteristics(             is_idempotent=True, is_internal=True, unique_result_values=True         )      def create_inputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          data_type_name = self.get_config_value(\"data_type\")         inputs = {             \"value\": {                 \"type\": data_type_name,                 \"doc\": f\"A value of type '{data_type_name}'\",                 \"optional\": False,             }         }         return inputs      def create_outputs_schema(         self,     ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:          kiara_model_id: str = self.get_config_value(\"kiara_model_id\")          # TODO: check it's subclassing the right class          outputs = {             \"value_metadata\": {                 \"type\": \"internal_model\",                 \"type_config\": {\"kiara_model_id\": kiara_model_id},                 \"doc\": \"The metadata for the provided value.\",             }         }          return outputs      def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:          value = inputs.get_value_obj(\"value\")          kiara_model_id: str = self.get_config_value(\"kiara_model_id\")          model_registry = ModelRegistry.instance()         metadata_model_cls: Type[ValueMetadata] = model_registry.get_model_cls(kiara_model_id=kiara_model_id, required_subclass=ValueMetadata)  # type: ignore          metadata = metadata_model_cls.create_value_metadata(value=value)          if not isinstance(metadata, metadata_model_cls):             raise KiaraProcessingException(                 f\"Invalid metadata model result, should be class '{metadata_model_cls.__name__}', but is: {metadata.__class__.__name__}. This is most likely a bug.\"             )          outputs.set_value(\"value_metadata\", metadata)  The source code of the process method of the module."},{"location":"included_components/operation_types/","title":"operation_types","text":""},{"location":"included_components/operation_types/#kiara_info.operation_types.create_from","title":"<code>create_from</code>","text":"type_name create_from The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name CreateFromOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.create_from The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.create_from.CreateFromOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.custom_module","title":"<code>custom_module</code>","text":"type_name custom_module The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name CustomModuleOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.CustomModuleOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.deserialize","title":"<code>deserialize</code>","text":"type_name deserialize The registered name for this item type. documentation description An operation that takes a value, and serializes it into the format suitable to the [`serialized_value`][kiara.data_types.included_core_types.SeriailzedValue] value type. Short description of the item. doc For a module profile to be picked up by this operation type, it needs to have: - exactly one output field of type `serialized_value` - either one of (in this order):   - exactly one input field   - one input field where the field name equals the type name   - an input field called 'value' Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name DeSerializeOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.serialize The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.serialize.DeSerializeOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.export_as","title":"<code>export_as</code>","text":"type_name export_as The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExportAsOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.export_as The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.export_as.ExportAsOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.extract_metadata","title":"<code>extract_metadata</code>","text":"type_name extract_metadata The registered name for this item type. documentation description An operation that extracts metadata of a specific type from value data. Short description of the item. doc For a module profile to be picked up by this operation type, it needs to have: - exactly one input field - that input field must have the same name as its value type, or be 'value' - exactly one output field, whose field name is called 'value_metadata', and where the value has the type 'internal_model' Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ExtractMetadataOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.metadata The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.filter","title":"<code>filter</code>","text":"type_name filter The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name FilterOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.filter The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.filter.FilterOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.import_data","title":"<code>import_data</code>","text":"type_name import_data The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name ImportDataOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.import_data The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.import_data.ImportDataOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.pipeline","title":"<code>pipeline</code>","text":"type_name pipeline The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PipelineOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.pipeline The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.pipeline.PipelineOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.pretty_print","title":"<code>pretty_print</code>","text":"type_name pretty_print The registered name for this item type. documentation description An operation that takes a value, and renders into a format that can be printed for output.. Short description of the item. doc For a module profile to be picked up by this operation type, it needs to have: - exactly one output field named \"rendered_value\" - exactly two input fields, one of them named after the type it supports, and the other called 'render_config', of type 'dict' Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name PrettyPrintOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.pretty_print The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operation_types/#kiara_info.operation_types.render_value","title":"<code>render_value</code>","text":"type_name render_value The registered name for this item type. documentation description An operation that renders a value. Short description of the item. doc A 'render_value' operation typically is named follwing the pattern:  ```  'render..as.' ```  It has 2 inputs:   - 'value': the value to render   - 'reneer_config' a target type-specific configuration dict  And one output:   - `render_value_result`: using internal type [RenderValueResultDataType][kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType] Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name RenderValueOperationType The name of the Python class. python_module_name kiara.operations.included_core_operations.render_value The name of the Python module this class lives in. full_name kiara.operations.included_core_operations.render_value.RenderValueOperationType The full class namespace. The python class that implements this module type."},{"location":"included_components/operations/","title":"operations","text":""},{"location":"included_components/operations/#kiara_info.operations.deserialize.bytes.as.python_object","title":"<code>deserialize.bytes.as.python_object</code>","text":"type_name deserialize.bytes.as.python_object The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type load.bytes The module type. module_config constants defaults value_type bytes target_profile python_object serialization_profile raw The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.bytes.as.python_object The (unique) id of this operation. operation_details operation_id deserialize.bytes.as.python_object The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema bytes type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type bytes value_input_field bytes object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile raw The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name LoadBytesModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadBytesModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type bytes The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile raw The name of the serialization profile used to serialize the source value. The module config. inputs_schema bytes type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields bytes field_name bytes The field name. field_schema type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name bytes The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name BytesType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.BytesType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.file.as.python_object","title":"<code>deserialize.file.as.python_object</code>","text":"type_name deserialize.file.as.python_object The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type deserialize.file The module type. module_config constants defaults value_type file target_profile python_object serialization_profile copy The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.file.as.python_object The (unique) id of this operation. operation_details operation_id deserialize.file.as.python_object The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type file value_input_field file object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile copy The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name DeserializeFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.DeserializeFileModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type file The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile copy The name of the serialization profile used to serialize the source value. The module config. inputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields file field_name file The field name. field_schema type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.file_bundle.as.python_object","title":"<code>deserialize.file_bundle.as.python_object</code>","text":"type_name deserialize.file_bundle.as.python_object The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type deserialize.file_bundle The module type. module_config constants defaults value_type file_bundle target_profile python_object serialization_profile copy The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.file_bundle.as.python_object The (unique) id of this operation. operation_details operation_id deserialize.file_bundle.as.python_object The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type file_bundle value_input_field file_bundle object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile copy The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name DeserializeFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type file_bundle The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile copy The name of the serialization profile used to serialize the source value. The module config. inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields file_bundle field_name file_bundle The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.from_json","title":"<code>deserialize.from_json</code>","text":"type_name deserialize.from_json The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type deserialize.from_json The module type. module_config constants defaults result_path data The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.from_json The (unique) id of this operation. operation_details operation_id deserialize.from_json The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object to deserialize the data for. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name DeserializeFromJsonModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. result_path data The path of the result dictionary to return. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object to deserialize the data for. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     custom_module   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object to deserialize the data for. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.internal_model.as.python_object","title":"<code>deserialize.internal_model.as.python_object</code>","text":"type_name deserialize.internal_model.as.python_object The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type load.internal_model The module type. module_config constants defaults value_type internal_model target_profile python_object serialization_profile json The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.internal_model.as.python_object The (unique) id of this operation. operation_details operation_id deserialize.internal_model.as.python_object The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema internal_model type internal_model The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type internal_model value_input_field internal_model object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile json The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name LoadInternalModel The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadInternalModel The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type internal_model The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile json The name of the serialization profile used to serialize the source value. The module config. inputs_schema internal_model type internal_model The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields internal_model field_name internal_model The field name. field_schema type internal_model The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal_model The registered name of this data type. data_type_config kiara_model_id None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.string.as.python_object","title":"<code>deserialize.string.as.python_object</code>","text":"type_name deserialize.string.as.python_object The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type load.string The module type. module_config constants defaults value_type string target_profile python_object serialization_profile raw The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.string.as.python_object The (unique) id of this operation. operation_details operation_id deserialize.string.as.python_object The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema string type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type string value_input_field string object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile raw The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name LoadStringModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.LoadStringModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type string The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile raw The name of the serialization profile used to serialize the source value. The module config. inputs_schema string type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields string field_name string The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.deserialize.value","title":"<code>deserialize.value</code>","text":"type_name deserialize.value The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type unpickle.value The module type. module_config constants defaults value_type any target_profile python_object serialization_profile pickle The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id deserialize.value The (unique) id of this operation. operation_details operation_id deserialize.value The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema any type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. value_type any value_input_field any object_output_field python_object The (output) field name containing the deserialized python class. serialization_profile pickle The name for the serialization profile used on the source value. target_profile python_object The target profile name. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name UnpickleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.serialization The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.serialization.UnpickleModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. value_type any The value type of the actual (unserialized) value. target_profile python_object The profile name of the de-serialization result data. serialization_profile pickle The name of the serialization profile used to serialize the source value. The module config. inputs_schema any type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. deserialization_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema python_object type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     deserialize   </li> </ul> The operation types this operation belongs to. input_fields any field_name any The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value object. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). deserialization_config field_name deserialization_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Serialization-format specific configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields python_object field_name python_object The field name. field_schema type python_object The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The deserialized python object instance. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name PythonObjectType The name of the Python class. python_module_name kiara.data_types.included_core_types.serialization The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.serialization.PythonObjectType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.export.file.as.file","title":"<code>export.file.as.file</code>","text":"type_name export.file.as.file The registered name for this item type. documentation description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type export.file The module type. module_config constants defaults target_profile file source_type file The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id export.file.as.file The (unique) id of this operation. operation_details operation_id export.file.as.file The id of the operation. is_internal_operation False Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file'. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. base_path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The directory to export the file(s) to. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. name type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The (base) name of the exported file(s). Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. export_metadata type boolean The type of the value. type_config Configuration for the type, in case it's complex. default False A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Whether to also export the value metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema export_details type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Details about the exported files/folders. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type file The type of the value to be created. target_profile file The result profile type. optional_args base_path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The directory to export the file(s) to. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. name type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The (base) name of the exported file(s). Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. export_metadata type boolean The type of the value. type_config Configuration for the type, in case it's complex. default False A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Whether to also export the value metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. Optional arguments. The operation specific details of this operation. doc description -- n/a -- Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ExportFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ExportFileModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. target_profile file The name of the target profile. Used to distinguish different target formats for the same data type. source_type file The type of the source data that is going to be exported. The module config. inputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file'. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. base_path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The directory to export the file(s) to. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. name type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The (base) name of the exported file(s). Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. export_metadata type boolean The type of the value. type_config Configuration for the type, in case it's complex. default False A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Whether to also export the value metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema export_details type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Details about the exported files/folders. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     export_as   </li> </ul> The operation types this operation belongs to. input_fields file field_name file The field name. field_schema type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file'. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). base_path field_name base_path The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The directory to export the file(s) to. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). name field_name name The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The (base) name of the exported file(s). Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). export_metadata field_name export_metadata The field name. field_schema type boolean The type of the value. type_config Configuration for the type, in case it's complex. default False A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Whether to also export the value metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name boolean The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name BooleanType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.BooleanType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields export_details field_name export_details The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Details about the exported files/folders. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.extract.file.metadata.from.file","title":"<code>extract.file.metadata.from.file</code>","text":"type_name extract.file.metadata.from.file The registered name for this item type. documentation description Extract 'file' metadata for value type 'file'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type value.extract_metadata The module type. module_config constants defaults data_type file kiara_model_id metadata.file The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id extract.file.metadata.from.file The (unique) id of this operation. operation_details operation_id extract.file.metadata.from.file The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.file Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. data_type file The data type this metadata operation can be used with. metadata_key file The metadata key. input_field_name value The input field name. result_field_name value_metadata The result field name. The operation specific details of this operation. doc description Extract 'file' metadata for value type 'file'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ExtractMetadataModule The name of the Python class. python_module_name kiara.modules.included_core_modules.metadata The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.metadata.ExtractMetadataModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. data_type file The data type this module will be used for. kiara_model_id metadata.file The id of the kiara (metadata) model. The module config. inputs_schema value type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.file Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     extract_metadata   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields value_metadata field_name value_metadata The field name. field_schema type internal_model The type of the value. type_config kiara_model_id metadata.file Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal_model The registered name of this data type. data_type_config kiara_model_id metadata.file The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.extract.file_bundle.metadata.from.file_bundle","title":"<code>extract.file_bundle.metadata.from.file_bundle</code>","text":"type_name extract.file_bundle.metadata.from.file_bundle The registered name for this item type. documentation description Extract 'file_bundle' metadata for value type 'file_bundle'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type value.extract_metadata The module type. module_config constants defaults data_type file_bundle kiara_model_id metadata.file_bundle The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id extract.file_bundle.metadata.from.file_bundle The (unique) id of this operation. operation_details operation_id extract.file_bundle.metadata.from.file_bundle The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file_bundle' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.file_bundle Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. data_type file_bundle The data type this metadata operation can be used with. metadata_key file_bundle The metadata key. input_field_name value The input field name. result_field_name value_metadata The result field name. The operation specific details of this operation. doc description Extract 'file_bundle' metadata for value type 'file_bundle'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ExtractMetadataModule The name of the Python class. python_module_name kiara.modules.included_core_modules.metadata The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.metadata.ExtractMetadataModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. data_type file_bundle The data type this module will be used for. kiara_model_id metadata.file_bundle The id of the kiara (metadata) model. The module config. inputs_schema value type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file_bundle' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.file_bundle Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     extract_metadata   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'file_bundle' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields value_metadata field_name value_metadata The field name. field_schema type internal_model The type of the value. type_config kiara_model_id metadata.file_bundle Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal_model The registered name of this data type. data_type_config kiara_model_id metadata.file_bundle The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.extract.python_class.metadata","title":"<code>extract.python_class.metadata</code>","text":"type_name extract.python_class.metadata The registered name for this item type. documentation description Extract 'python_class' metadata for value type 'any'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type value.extract_metadata The module type. module_config constants defaults data_type any kiara_model_id metadata.python_class The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id extract.python_class.metadata The (unique) id of this operation. operation_details operation_id extract.python_class.metadata The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'any' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.python_class Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. data_type any The data type this metadata operation can be used with. metadata_key python_class The metadata key. input_field_name value The input field name. result_field_name value_metadata The result field name. The operation specific details of this operation. doc description Extract 'python_class' metadata for value type 'any'. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ExtractMetadataModule The name of the Python class. python_module_name kiara.modules.included_core_modules.metadata The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.metadata.ExtractMetadataModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. data_type any The data type this module will be used for. kiara_model_id metadata.python_class The id of the kiara (metadata) model. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'any' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema value_metadata type internal_model The type of the value. type_config kiara_model_id metadata.python_class Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     extract_metadata   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description A value of type 'any' Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields value_metadata field_name value_metadata The field name. field_schema type internal_model The type of the value. type_config kiara_model_id metadata.python_class Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The metadata for the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal_model The registered name of this data type. data_type_config kiara_model_id metadata.python_class The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalModelValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalModelValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.file_bundle.pick.file","title":"<code>file_bundle.pick.file</code>","text":"type_name file_bundle.pick.file The registered name for this item type. documentation description Pick a single file from a file_bundle value. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type file_bundle.pick.file The module type. module_config constants defaults The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id file_bundle.pick.file The (unique) id of this operation. operation_details operation_id file_bundle.pick.file The id of the operation. is_internal_operation False Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the file to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. The operation specific details of this operation. doc description Pick a single file from a file_bundle value. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name PickFileFromFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. The module config. inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the file to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     custom_module   </li> </ul> The operation types this operation belongs to. input_fields file_bundle field_name file_bundle The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). path field_name path The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the file to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields file field_name file The field name. field_schema type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.file_bundle.pick.sub_folder","title":"<code>file_bundle.pick.sub_folder</code>","text":"type_name file_bundle.pick.sub_folder The registered name for this item type. documentation description Pick a sub-folder from a file_bundle, resulting in a new file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type file_bundle.pick.sub_folder The module type. module_config constants defaults The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id file_bundle.pick.sub_folder The (unique) id of this operation. operation_details operation_id file_bundle.pick.sub_folder The id of the operation. is_internal_operation False Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. sub_path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the sub-folder to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The picked (sub-)file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. The operation specific details of this operation. doc description Pick a sub-folder from a file_bundle, resulting in a new file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name PickSubBundle The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.PickSubBundle The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. The module config. inputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. sub_path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the sub-folder to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The picked (sub-)file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     custom_module   </li> </ul> The operation types this operation belongs to. input_fields file_bundle field_name file_bundle The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). sub_path field_name sub_path The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The relative path of the sub-folder to pick. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields file_bundle field_name file_bundle The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The picked (sub-)file_bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.import.local.file","title":"<code>import.local.file</code>","text":"type_name import.local.file The registered name for this item type. documentation description Import a file from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type import.local.file The module type. module_config constants defaults The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id import.local.file The (unique) id of this operation. operation_details operation_id import.local.file The id of the operation. is_internal_operation False Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path to the file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The loaded files. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. The operation specific details of this operation. doc description Import a file from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ImportLocalFileModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ImportLocalFileModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. The module config. inputs_schema path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path to the file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema file type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The loaded files. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     custom_module   </li> </ul> The operation types this operation belongs to. input_fields path field_name path The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path to the file. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields file field_name file The field name. field_schema type file The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The loaded files. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.import.local.file_bundle","title":"<code>import.local.file_bundle</code>","text":"type_name import.local.file_bundle The registered name for this item type. documentation description Import a folder (file_bundle) from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type import.local.file_bundle The module type. module_config constants defaults include_file_types None exclude_file_types None The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id import.local.file_bundle The (unique) id of this operation. operation_details operation_id import.local.file_bundle The id of the operation. is_internal_operation False Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path of the folder to import. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The imported file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. The operation specific details of this operation. doc description Import a folder (file_bundle) from the local filesystem. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ImportLocalFileBundleModule The name of the Python class. python_module_name kiara.modules.included_core_modules.filesystem The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. include_file_types None File types to include. exclude_file_types None File types to include. The module config. inputs_schema path type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path of the folder to import. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema file_bundle type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The imported file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     custom_module   </li> </ul> The operation types this operation belongs to. input_fields path field_name path The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The local path of the folder to import. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields file_bundle field_name file_bundle The field name. field_schema type file_bundle The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The imported file bundle. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name file_bundle The registered name of this data type. data_type_config content_type None The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name FileBundleValueType The name of the Python class. python_module_name kiara.data_types.included_core_types.filesystem The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.filesystem.FileBundleValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.as.string","title":"<code>pretty_print.as.string</code>","text":"type_name pretty_print.as.string The registered name for this item type. documentation description Pretty print a any value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type any target_type string The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.as.string The (unique) id of this operation. operation_details operation_id pretty_print.as.string The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type any The type of the value to be rendered. target_type string The type of the render result. The operation specific details of this operation. doc description Pretty print a any value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type any The value type of the source value. target_type string The value type of the rendered value. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.as.terminal_renderable","title":"<code>pretty_print.as.terminal_renderable</code>","text":"type_name pretty_print.as.terminal_renderable The registered name for this item type. documentation description Pretty print a any value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type any target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.as.terminal_renderable The (unique) id of this operation. operation_details operation_id pretty_print.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type any The type of the value to be rendered. target_type terminal_renderable The type of the render result. The operation specific details of this operation. doc description Pretty print a any value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type any The value type of the source value. target_type terminal_renderable The value type of the rendered value. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name terminal_renderable The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name TerminalRenderable The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.TerminalRenderable The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.internal.as.string","title":"<code>pretty_print.internal.as.string</code>","text":"type_name pretty_print.internal.as.string The registered name for this item type. documentation description Pretty print a internal value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type internal target_type string The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.internal.as.string The (unique) id of this operation. operation_details operation_id pretty_print.internal.as.string The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type internal The type of the value to be rendered. target_type string The type of the render result. The operation specific details of this operation. doc description Pretty print a internal value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type internal The value type of the source value. target_type string The value type of the rendered value. The module config. inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.internal.as.terminal_renderable","title":"<code>pretty_print.internal.as.terminal_renderable</code>","text":"type_name pretty_print.internal.as.terminal_renderable The registered name for this item type. documentation description Pretty print a internal value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type internal target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.internal.as.terminal_renderable The (unique) id of this operation. operation_details operation_id pretty_print.internal.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type internal The type of the value to be rendered. target_type terminal_renderable The type of the render result. The operation specific details of this operation. doc description Pretty print a internal value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type internal The value type of the source value. target_type terminal_renderable The value type of the rendered value. The module config. inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name terminal_renderable The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name TerminalRenderable The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.TerminalRenderable The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.none.as.string","title":"<code>pretty_print.none.as.string</code>","text":"type_name pretty_print.none.as.string The registered name for this item type. documentation description Pretty print a none value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type none target_type string The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.none.as.string The (unique) id of this operation. operation_details operation_id pretty_print.none.as.string The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type none The type of the value to be rendered. target_type string The type of the render result. The operation specific details of this operation. doc description Pretty print a none value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type none The value type of the source value. target_type string The value type of the rendered value. The module config. inputs_schema value type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name none The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name NoneType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.NoneType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.none.as.terminal_renderable","title":"<code>pretty_print.none.as.terminal_renderable</code>","text":"type_name pretty_print.none.as.terminal_renderable The registered name for this item type. documentation description Pretty print a none value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type none target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.none.as.terminal_renderable The (unique) id of this operation. operation_details operation_id pretty_print.none.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type none The type of the value to be rendered. target_type terminal_renderable The type of the render result. The operation specific details of this operation. doc description Pretty print a none value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type none The value type of the source value. target_type terminal_renderable The value type of the rendered value. The module config. inputs_schema value type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type none The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name none The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name NoneType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.NoneType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type terminal_renderable The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name terminal_renderable The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name TerminalRenderable The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.TerminalRenderable The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.pretty_print.string.as.bytes","title":"<code>pretty_print.string.as.bytes</code>","text":"type_name pretty_print.string.as.bytes The registered name for this item type. documentation description Pretty print a string value as a bytes. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type pretty_print.value The module type. module_config constants defaults source_type string target_type bytes The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id pretty_print.string.as.bytes The (unique) id of this operation. operation_details operation_id pretty_print.string.as.bytes The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema rendered_value type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_type string The type of the value to be rendered. target_type bytes The type of the render result. The operation specific details of this operation. doc description Pretty print a string value as a bytes. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypePrettyPrintModule The name of the Python class. python_module_name kiara.modules.included_core_modules.pretty_print The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type string The value type of the source value. target_type bytes The value type of the rendered value. The module config. inputs_schema value type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema rendered_value type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     pretty_print   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type string The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name string The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar True Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name StringType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.StringType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional True Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Value type dependent render configuration. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields rendered_value field_name rendered_value The field name. field_schema type bytes The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name bytes The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name BytesType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.BytesType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.render.as.string","title":"<code>render.as.string</code>","text":"type_name render.as.string The registered name for this item type. documentation description Render a 'any' value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type render.value The module type. module_config constants defaults source_type any target_type string The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id render.as.string The (unique) id of this operation. operation_details operation_id render.as.string The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_data_type any The data type that will be rendered. target_data_type string The rendered data type. The operation specific details of this operation. doc description Render a 'any' value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type any The (kiara) data type to be rendered. target_type string The (kiara) data type of210 the rendered result. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     render_value   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields render_value_result field_name render_value_result The field name. field_schema type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name render_value_result The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.render.as.terminal_renderable","title":"<code>render.as.terminal_renderable</code>","text":"type_name render.as.terminal_renderable The registered name for this item type. documentation description Render a 'any' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type render.value The module type. module_config constants defaults source_type any target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id render.as.terminal_renderable The (unique) id of this operation. operation_details operation_id render.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_data_type any The data type that will be rendered. target_data_type terminal_renderable The rendered data type. The operation specific details of this operation. doc description Render a 'any' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type any The (kiara) data type to be rendered. target_type terminal_renderable The (kiara) data type of210 the rendered result. The module config. inputs_schema value type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     render_value   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type any The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name any The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name AnyType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.AnyType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields render_value_result field_name render_value_result The field name. field_schema type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name render_value_result The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.render.dict.as.terminal_renderable","title":"<code>render.dict.as.terminal_renderable</code>","text":"type_name render.dict.as.terminal_renderable The registered name for this item type. documentation description Render a 'dict' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type render.value The module type. module_config constants defaults source_type dict target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id render.dict.as.terminal_renderable The (unique) id of this operation. operation_details operation_id render.dict.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_data_type dict The data type that will be rendered. target_data_type terminal_renderable The rendered data type. The operation specific details of this operation. doc description Render a 'dict' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type dict The (kiara) data type to be rendered. target_type terminal_renderable The (kiara) data type of210 the rendered result. The module config. inputs_schema value type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     render_value   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields render_value_result field_name render_value_result The field name. field_schema type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name render_value_result The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.render.internal.as.string","title":"<code>render.internal.as.string</code>","text":"type_name render.internal.as.string The registered name for this item type. documentation description Render a 'internal' value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type render.value The module type. module_config constants defaults source_type internal target_type string The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id render.internal.as.string The (unique) id of this operation. operation_details operation_id render.internal.as.string The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_data_type internal The data type that will be rendered. target_data_type string The rendered data type. The operation specific details of this operation. doc description Render a 'internal' value as a string. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type internal The (kiara) data type to be rendered. target_type string The (kiara) data type of210 the rendered result. The module config. inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     render_value   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields render_value_result field_name render_value_result The field name. field_schema type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name render_value_result The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"included_components/operations/#kiara_info.operations.render.internal.as.terminal_renderable","title":"<code>render.internal.as.terminal_renderable</code>","text":"type_name render.internal.as.terminal_renderable The registered name for this item type. documentation description Render a 'internal' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for the item. authors authors <ul> <li> name Markus Binsteiner The full name of the author. email markus@frkl.io The email address of the author </li> </ul> The authors/creators of this item. Information about authorship for the item. context references source_repo url https://github.com/DHARPA-Project/kiara The url. desc The kiara project git repository. A short description of the link content. documentation url https://dharpa.org/kiara_documentation/ The url. desc The url for kiara documentation. A short description of the link content. References for the item. tags <ul> </ul> A list of tags for the item. labels package kiara A list of labels for the item. Generic properties of this item (description, tags, labels, references, ...). operation module_type render.value The module type. module_config constants defaults source_type internal target_type terminal_renderable The configuration for the module. is_resolved False Whether the configuration of this module was augmented with the module type defaults etc. operation_id render.internal.as.terminal_renderable The (unique) id of this operation. operation_details operation_id render.internal.as.terminal_renderable The id of the operation. is_internal_operation True Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.). module_inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The input schemas of the module. module_outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The output schemas of the module. source_data_type internal The data type that will be rendered. target_data_type terminal_renderable The rendered data type. The operation specific details of this operation. doc description Render a 'internal' value as a terminal_renderable. Short description of the item. doc None Detailed documentation of the item (in markdown). Documentation for this operation. module_details python_class_name ValueTypeRenderModule The name of the Python class. python_module_name kiara.modules.included_core_modules.render_value The name of the Python module this class lives in. full_name kiara.modules.included_core_modules.render_value.ValueTypeRenderModule The full class namespace. module_config constants Value constants for this module. defaults Value defaults for this module. source_type internal The (kiara) data type to be rendered. target_type terminal_renderable The (kiara) data type of210 the rendered result. The module config. inputs_schema value type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. render_config type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module input(s). outputs_schema render_value_result type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema for the module output(s). The class of the underlying module. metadata Additional metadata for this operation. The operation instance. operation_types <ul> <li>     render_value   </li> </ul> The operation types this operation belongs to. input_fields value field_name value The field name. field_schema type internal The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The value to render. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name internal The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name InternalType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.InternalType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). render_config field_name render_config The field name. field_schema type dict The type of the value. type_config Configuration for the type, in case it's complex. default A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description Instructions/config on how (or what) to render the provided value. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name dict The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable True Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name DictValueType The name of the Python class. python_module_name kiara.data_types.included_core_types The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.DictValueType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required False Whether user input is required (meaning: 'optional' is False, and no default set). The inputs schema for this operation. output_fields render_value_result field_name render_value_result The field name. field_schema type render_value_result The type of the value. type_config Configuration for the type, in case it's complex. default SpecialValue.NOT_SET A default value. optional False Whether this value is required (True), or whether 'None' value is allowed (False). is_constant False Whether the value is a constant. doc description The rendered value, incl. some metadata. Short description of the item. doc None Detailed documentation of the item (in markdown). A description for the value of this input field. The schema of the field. data_type_info data_type_name render_value_result The registered name of this data type. data_type_config The (optional) configuration for this data type. characteristics is_scalar False Whether the data desribed by this data type behaves like a skalar. is_json_serializable False Whether the data can be serialized to json without information loss. Characteristics of this data type. data_type_class python_class_name RenderValueResultDataType The name of the Python class. python_module_name kiara.data_types.included_core_types.internal.render_value The name of the Python module this class lives in. full_name kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType The full class namespace. The python class that is associated with this model. Information about the data type instance of the associated value. value_required True Whether user input is required (meaning: 'optional' is False, and no default set). The outputs schema for this operation."},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara<ul> <li>api</li> <li>context<ul> <li>config</li> <li>orm</li> </ul> </li> <li>data_types<ul> <li>included_core_types<ul> <li>filesystem</li> <li>internal<ul> <li>render_value</li> </ul> </li> <li>metadata</li> <li>serialization</li> </ul> </li> </ul> </li> <li>defaults</li> <li>doc<ul> <li>gen_info_pages</li> <li>generate_api_doc</li> <li>mkdocs_macros_cli</li> <li>mkdocs_macros_kiara</li> <li>mkdocstrings<ul> <li>collector</li> <li>handler</li> <li>renderer</li> </ul> </li> </ul> </li> <li>exceptions</li> <li>interfaces<ul> <li>cli<ul> <li>config<ul> <li>commands</li> </ul> </li> <li>context<ul> <li>commands</li> </ul> </li> <li>data<ul> <li>commands</li> </ul> </li> <li>module<ul> <li>commands</li> </ul> </li> <li>operation<ul> <li>commands</li> </ul> </li> <li>pipeline<ul> <li>commands</li> </ul> </li> <li>render<ul> <li>commands</li> </ul> </li> <li>run</li> <li>type<ul> <li>commands</li> </ul> </li> <li>workflow<ul> <li>commands</li> </ul> </li> </ul> </li> <li>python_api<ul> <li>batch</li> <li>models<ul> <li>info</li> <li>job</li> <li>workflow</li> </ul> </li> <li>operation</li> <li>utils</li> <li>value</li> <li>workflow</li> </ul> </li> <li>tui<ul> <li>pager</li> <li>widgets<ul> <li>pager</li> </ul> </li> </ul> </li> </ul> </li> <li>models<ul> <li>aliases</li> <li>archives</li> <li>context</li> <li>data_types</li> <li>documentation</li> <li>events<ul> <li>alias_registry</li> <li>data_registry</li> <li>destiny_registry</li> <li>job_registry</li> <li>pipeline</li> <li>workflow_registry</li> </ul> </li> <li>filesystem</li> <li>module<ul> <li>destiny</li> <li>jobs</li> <li>manifest</li> <li>operation</li> <li>persistence</li> <li>pipeline<ul> <li>controller</li> <li>pipeline</li> <li>stages</li> <li>structure</li> <li>value_refs</li> </ul> </li> </ul> </li> <li>python_class</li> <li>rendering<ul> <li>values</li> </ul> </li> <li>runtime_environment<ul> <li>kiara</li> <li>operating_system</li> <li>python</li> </ul> </li> <li>values<ul> <li>data_type</li> <li>lineage</li> <li>matchers</li> <li>value</li> <li>value_metadata<ul> <li>included_metadata_types</li> </ul> </li> <li>value_schema</li> </ul> </li> <li>workflow</li> </ul> </li> <li>modules<ul> <li>included_core_modules<ul> <li>create_from</li> <li>export_as</li> <li>filesystem</li> <li>filter</li> <li>metadata</li> <li>pipeline</li> <li>pretty_print</li> <li>render_value</li> <li>serialization</li> </ul> </li> </ul> </li> <li>operations<ul> <li>included_core_operations<ul> <li>create_from</li> <li>export_as</li> <li>filter</li> <li>import_data</li> <li>metadata</li> <li>pipeline</li> <li>pretty_print</li> <li>render_data</li> <li>render_value</li> <li>serialize</li> </ul> </li> </ul> </li> <li>processing<ul> <li>synchronous</li> </ul> </li> <li>registries<ul> <li>aliases<ul> <li>archives</li> </ul> </li> <li>data<ul> <li>data_store<ul> <li>filesystem_store</li> </ul> </li> </ul> </li> <li>destinies<ul> <li>filesystem_store</li> <li>registry</li> </ul> </li> <li>environment</li> <li>events<ul> <li>metadata</li> <li>registry</li> </ul> </li> <li>ids</li> <li>jobs<ul> <li>job_store<ul> <li>filesystem_store</li> </ul> </li> </ul> </li> <li>models</li> <li>modules</li> <li>operations</li> <li>rendering</li> <li>templates</li> <li>types</li> <li>workflows<ul> <li>archives</li> </ul> </li> </ul> </li> <li>renderers<ul> <li>included_renderers<ul> <li>api</li> <li>pipeline</li> <li>value</li> </ul> </li> <li>jinja</li> </ul> </li> <li>utils<ul> <li>class_loading</li> <li>cli<ul> <li>exceptions</li> <li>rich_click</li> <li>run</li> </ul> </li> <li>concurrency</li> <li>data</li> <li>db</li> <li>debug</li> <li>develop</li> <li>dicts</li> <li>doc</li> <li>downloads</li> <li>files</li> <li>global_metadata</li> <li>graphs</li> <li>hashfs</li> <li>hashing</li> <li>html</li> <li>json</li> <li>metadata</li> <li>models</li> <li>modules</li> <li>operations</li> <li>output</li> <li>pipelines</li> <li>string_vars</li> <li>values</li> <li>windows</li> <li>yaml</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara/__init__/","title":"kiara","text":""},{"location":"reference/kiara/__init__/#kiara-attributes","title":"Attributes","text":""},{"location":"reference/kiara/__init__/#kiara.builtins","title":"<code>builtins = __import__('__builtin__')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/__init__/#kiara.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara Python package', 'references': {'source_repo': {'desc': 'The kiara project git repository.', 'url': 'https://github.com/DHARPA-Project/kiara'}, 'documentation': {'desc': 'The url for kiara documentation.', 'url': 'https://dharpa.org/kiara_documentation/'}}, 'tags': [], 'labels': {'package': 'kiara'}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/__init__/#kiara.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/__init__/#kiara.find_model_classes_api","title":"<code>find_model_classes_api: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara.interfaces.python_api.models')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/__init__/#kiara.find_renderer_classes","title":"<code>find_renderer_classes: KiaraEntryPointItem = (find_kiara_renderers_under, 'kiara.renderers.included_renderers')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/__init__/#kiara-functions","title":"Functions","text":""},{"location":"reference/kiara/__init__/#kiara.dbg","title":"<code>dbg(*objects: typing.Any, sep: str = ' ', end: str = '\\n', file: typing.Union[typing.IO[str], None] = None, flush: bool = False)</code>","text":"Source code in <code>kiara/__init__.py</code> <pre><code>def dbg(\n    *objects: typing.Any,\n    sep: str = \" \",\n    end: str = \"\\n\",\n    file: typing.Union[typing.IO[str], None] = None,\n    flush: bool = False,\n):\n\n    for obj in objects:\n        try:\n            rich_print(obj, sep=sep, end=end, file=file, flush=flush)\n        except Exception:\n            rich_print(\n                f\"[green]{obj}[/green]\", sep=sep, end=end, file=file, flush=flush\n            )\n</code></pre>"},{"location":"reference/kiara/__init__/#kiara.DBG","title":"<code>DBG(*objects: typing.Any, sep: str = ' ', end: str = '\\n', file: typing.Union[typing.IO[str], None] = None, flush: bool = False)</code>","text":"Source code in <code>kiara/__init__.py</code> <pre><code>def DBG(\n    *objects: typing.Any,\n    sep: str = \" \",\n    end: str = \"\\n\",\n    file: typing.Union[typing.IO[str], None] = None,\n    flush: bool = False,\n):\n\n    objs = (\n        [\"[green]----------------------------------------------[/green]\"]  # noqa\n        + list(objects)\n        + [\"[green]----------------------------------------------[/green]\"]\n    )\n    dbg(*objs, sep=sep, end=end, file=file, flush=flush)\n</code></pre>"},{"location":"reference/kiara/__init__/#kiara.get_version","title":"<code>get_version() -&gt; str</code>","text":"<p>Return the current version of Kiara.</p> Source code in <code>kiara/__init__.py</code> <pre><code>def get_version() -&gt; str:\n\"\"\"Return the current version of *Kiara*.\"\"\"\n    from pkg_resources import DistributionNotFound, get_distribution\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = get_distribution(dist_name).version\n    except DistributionNotFound:\n\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except (Exception):\n            __version__ = \"unknown\"\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara/api/","title":"api","text":""},{"location":"reference/kiara/api/#kiara.api-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.api.ValueMapSchema","title":"<code>ValueMapSchema = Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.api-classes","title":"Classes","text":""},{"location":"reference/kiara/api/#kiara.api.ValueSchema","title":"<code>ValueSchema</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>The schema of a value.</p> <p>The schema contains the ValueTypeOrm of a value, as well as an optional default that will be used if no user input was given (yet) for a value.</p> <p>For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the <code>type_config</code> field.</p> Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>class ValueSchema(KiaraModel):\n\"\"\"The schema of a value.\n\n    The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that\n    will be used if no user input was given (yet) for a value.\n\n    For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field.\n    \"\"\"\n\n    _kiara_model_id = \"instance.value_schema\"\n\n    class Config:\n        use_enum_values = True\n        # extra = Extra.forbid\n\n    type: str = Field(description=\"The type of the value.\")\n    type_config: typing.Dict[str, typing.Any] = Field(\n        description=\"Configuration for the type, in case it's complex.\",\n        default_factory=dict,\n    )\n    default: typing.Any = Field(\n        description=\"A default value.\", default=SpecialValue.NOT_SET\n    )\n\n    optional: bool = Field(\n        description=\"Whether this value is required (True), or whether 'None' value is allowed (False).\",\n        default=False,\n    )\n    is_constant: bool = Field(\n        description=\"Whether the value is a constant.\", default=False\n    )\n\n    doc: DocumentationMetadataModel = Field(\n        default_factory=DocumentationMetadataModel,\n        description=\"A description for the value of this input field.\",\n    )\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        doc = DocumentationMetadataModel.create(value)\n        return doc\n\n    def _retrieve_data_to_hash(self) -&gt; typing.Any:\n\n        return {\"type\": self.type, \"type_config\": self.type_config}\n\n    def is_required(self):\n\n        if self.optional:\n            return False\n        else:\n            if self.default in [None, SpecialValue.NOT_SET, SpecialValue.NO_VALUE]:\n                return True\n            else:\n                return False\n\n    # def validate_types(self, kiara: \"Kiara\"):\n    #\n    #     if self.type not in kiara.value_type_names:\n    #         raise ValueError(\n    #             f\"Invalid value type '{self.type}', available data_types: {kiara.value_type_names}\"\n    #         )\n\n    def __eq__(self, other):\n\n        if not isinstance(other, ValueSchema):\n            return False\n\n        return (self.type, self.default) == (other.type, other.default)\n\n    def __hash__(self):\n\n        return hash((self.type, self.default))\n\n    def __repr__(self):\n\n        return f\"ValueSchema(type={self.type}, default={self.default}, optional={self.optional})\"\n\n    def __str__(self):\n\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.ValueSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.type","title":"<code>type: str = Field(description='The type of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.type_config","title":"<code>type_config: typing.Dict[str, typing.Any] = Field(description=\"Configuration for the type, in case it's complex.\", default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.default","title":"<code>default: typing.Any = Field(description='A default value.', default=SpecialValue.NOT_SET)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.optional","title":"<code>optional: bool = Field(description=\"Whether this value is required (True), or whether 'None' value is allowed (False).\", default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.is_constant","title":"<code>is_constant: bool = Field(description='Whether the value is a constant.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.doc","title":"<code>doc: DocumentationMetadataModel = Field(default_factory=DocumentationMetadataModel, description='A description for the value of this input field.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.api.ValueSchema-classes","title":"Classes","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>class Config:\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.Config-attributes","title":"Attributes","text":"<code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/api/#kiara.api.ValueSchema-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    doc = DocumentationMetadataModel.create(value)\n    return doc\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value_schema.ValueSchema.is_required","title":"<code>is_required()</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>def is_required(self):\n\n    if self.optional:\n        return False\n    else:\n        if self.default in [None, SpecialValue.NOT_SET, SpecialValue.NO_VALUE]:\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraModuleConfig","title":"<code>KiaraModuleConfig</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Base class that describes the configuration a <code>KiaraModule</code> class accepts.</p> <p>This is stored in the <code>_config_cls</code> class attribute in each <code>KiaraModule</code> class.</p> <p>There are two config options every <code>KiaraModule</code> supports:</p> <ul> <li><code>constants</code>, and</li> <li><code>defaults</code></li> </ul> <p>Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default  values that override the schema defaults, and those can be overwritten by users. If both a constant and a default  value is set for an input field, an error is thrown.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>class KiaraModuleConfig(KiaraModel):\n\"\"\"Base class that describes the configuration a [``KiaraModule``][kiara.module.KiaraModule] class accepts.\n\n    This is stored in the ``_config_cls`` class attribute in each ``KiaraModule`` class.\n\n    There are two config options every ``KiaraModule`` supports:\n\n     - ``constants``, and\n     - ``defaults``\n\n     Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default\n     values that override the schema defaults, and those can be overwritten by users. If both a constant and a default\n     value is set for an input field, an error is thrown.\n    \"\"\"\n\n    _kiara_model_id = \"instance.module_config\"\n\n    @classmethod\n    def requires_config(cls, config: Union[Mapping[str, Any], None] = None) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n        for field_name, field in cls.__fields__.items():\n            if field.required and field.default is None:\n                if config:\n                    if config.get(field_name, None) is None:\n                        return True\n                else:\n                    return True\n        return False\n\n    _config_hash: str = PrivateAttr(default=None)\n    constants: Dict[str, Any] = Field(\n        default_factory=dict, description=\"Value constants for this module.\"\n    )\n    defaults: Dict[str, Any] = Field(\n        default_factory=dict, description=\"Value defaults for this module.\"\n    )\n\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n\n    def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n        if key not in self.__fields__:\n            raise Exception(\n                f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n            )\n\n        return getattr(self, key)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        my_table = Table(box=box.MINIMAL, show_header=False)\n        my_table.add_column(\"Field name\", style=\"i\")\n        my_table.add_column(\"Value\")\n        for field in self.__fields__:\n            attr = getattr(self, field)\n            if isinstance(attr, str):\n                attr_str = attr\n            elif hasattr(attr, \"create_renderable\"):\n                attr_str = attr.create_renderable()\n            elif isinstance(attr, BaseModel):\n                attr_str = attr.json(option=orjson.orjson.OPT_INDENT_2)\n            else:\n                attr_str = str(attr)\n            my_table.add_row(field, attr_str)\n\n        return my_table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.constants","title":"<code>constants: Dict[str, Any] = Field(default_factory=dict, description='Value constants for this module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.defaults","title":"<code>defaults: Dict[str, Any] = Field(default_factory=dict, description='Value defaults for this module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.api.KiaraModuleConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/__init__.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/api/#kiara.api.KiaraModuleConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.requires_config","title":"<code>requires_config(config: Union[Mapping[str, Any], None] = None) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Return whether this class can be used as-is, or requires configuration before an instance can be created.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>@classmethod\ndef requires_config(cls, config: Union[Mapping[str, Any], None] = None) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n    for field_name, field in cls.__fields__.items():\n        if field.required and field.default is None:\n            if config:\n                if config.get(field_name, None) is None:\n                    return True\n            else:\n                return True\n    return False\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Get the value for the specified configuation key.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n    if key not in self.__fields__:\n        raise Exception(\n            f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n        )\n\n    return getattr(self, key)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.module.KiaraModuleConfig.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    my_table = Table(box=box.MINIMAL, show_header=False)\n    my_table.add_column(\"Field name\", style=\"i\")\n    my_table.add_column(\"Value\")\n    for field in self.__fields__:\n        attr = getattr(self, field)\n        if isinstance(attr, str):\n            attr_str = attr\n        elif hasattr(attr, \"create_renderable\"):\n            attr_str = attr.create_renderable()\n        elif isinstance(attr, BaseModel):\n            attr_str = attr.json(option=orjson.orjson.OPT_INDENT_2)\n        else:\n            attr_str = str(attr)\n        my_table.add_row(field, attr_str)\n\n    return my_table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraAPI","title":"<code>KiaraAPI</code>","text":"<p>         Bases: <code>object</code></p> <p>Public API for clients</p> <p>This class wraps a Kiara instance, and allows easy a access to tasks that are typically done by a frontend. The return types of each method are json seriable in most cases.</p> <p>Can be extended for special scenarios and augmented with scenario-specific methdos (Jupyter, web-frontend, ...)</p> <p>The naming of the API endpoints follows a (loose-ish) convention: - list_: return a list of ids or items, if items, filtering is supported - get_: get specific instances of a type (operation, value, etc.) - retrieve_: get augmented information about an instance or type of something. This usually implies that there is some overhead, so before you use this, make sure that there is not 'get_' or 'list_*' endpoint that could give you what you need. .</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>class KiaraAPI(object):\n\"\"\"Public API for clients\n\n    This class wraps a [Kiara][kiara.context.kiara.Kiara] instance, and allows easy a access to tasks that are\n    typically done by a frontend. The return types of each method are json seriable in most cases.\n\n    Can be extended for special scenarios and augmented with scenario-specific methdos (Jupyter, web-frontend, ...)\n\n    The naming of the API endpoints follows a (loose-ish) convention:\n    - list_*: return a list of ids or items, if items, filtering is supported\n    - get_*: get specific instances of a type (operation, value, etc.)\n    - retrieve_*: get augmented information about an instance or type of something. This usually implies that there is some overhead,\n    so before you use this, make sure that there is not 'get_*' or 'list_*' endpoint that could give you what you need.\n    .\"\"\"\n\n    _instance: Union[\"KiaraAPI\", None] = None\n\n    @classmethod\n    def instance(\n        cls,\n    ) -&gt; \"KiaraAPI\":\n\n        if cls._instance is not None:\n            return cls._instance\n\n        from kiara.context import KiaraConfig\n\n        config = KiaraConfig()\n\n        api = KiaraAPI(kiara_config=config)\n        cls._instance = api\n        return api\n\n    def __init__(self, kiara_config: \"KiaraConfig\"):\n\n        self._kiara_config: KiaraConfig = kiara_config\n        self._contexts: Dict[str, Kiara] = {}\n        self._workflow_cache: Dict[uuid.UUID, Workflow] = {}\n\n        self._current_context: Union[None, Kiara] = None\n        self._current_context_alias: Union[None, str] = None\n\n    @cached_property\n    def doc(self) -&gt; Dict[str, str]:\n\"\"\"Get the documentation for this API.\"\"\"\n\n        result = {}\n        for method_name in dir(self):\n            if method_name.startswith(\"_\"):\n                continue\n\n            method = getattr(self.__class__, method_name)\n            doc = inspect.getdoc(method)\n            if doc is None:\n                doc = \"-- n/a --\"\n            else:\n                doc = textwrap.dedent(doc)\n\n            result[method_name] = doc\n\n        return result\n\n    @property\n    def context(self) -&gt; \"Kiara\":\n\"\"\"Return the kiara context.\n\n        DON\"T USE THIS! This is going away in the production release.\n        \"\"\"\n\n        if self._current_context is None:\n            self._current_context = self._kiara_config.create_context(\n                extra_pipelines=None\n            )\n            self._current_context_alias = self._kiara_config.default_context\n\n        return self._current_context\n\n    def get_runtime_config(self) -&gt; \"KiaraRuntimeConfig\":\n\"\"\"Retrieve the current runtime configuration.\"\"\"\n        return self.context.runtime_config\n\n    def get_context_info(self) -&gt; ContextInfo:\n\"\"\"Retrieve information about the current kiara context.\"\"\"\n\n        context_config = self._kiara_config.get_context_config(\n            self.get_current_context_name()\n        )\n        info = ContextInfo.create_from_context_config(\n            context_config,\n            context_name=self.get_current_context_name(),\n            runtime_config=self._kiara_config.runtime_config,\n        )\n\n        return info\n\n    def ensure_plugin_packages(\n        self, package_names: Union[str, Iterable[str]], update: bool = False\n    ) -&gt; Union[bool, None]:\n\"\"\"Ensure that the specified packages are installed.\n\n        Arguments:\n          package_names: The names of the packages to install.\n          update: If True, update the packages if they are already installed\n\n        Returns:\n            'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.\n        \"\"\"\n\n        if isinstance(package_names, str):\n            package_names = [package_names]\n\n        env_reg = EnvironmentRegistry.instance()\n        python_env: PythonRuntimeEnvironment = env_reg.environments[  # type: ignore\n            \"python\"\n        ]  # type: ignore\n\n        if not package_names:\n            package_names = OFFICIAL_KIARA_PLUGINS  # type: ignore\n\n        if not update:\n            plugin_packages: List[str] = []\n            pkgs = [p.name.replace(\"_\", \"-\") for p in python_env.packages]\n            for package_name in package_names:\n                if package_name.startswith(\"git:\"):\n                    package_name = package_name.replace(\"git:\", \"\")\n                    git = True\n                else:\n                    git = False\n                package_name = package_name.replace(\"_\", \"-\")\n                if not package_name.startswith(\"kiara-plugin.\"):\n                    package_name = f\"kiara-plugin.{package_name}\"\n\n                if git or package_name.replace(\"_\", \"-\") not in pkgs:\n                    if git:\n                        package_name = package_name.replace(\"-\", \"_\")\n                        plugin_packages.append(\n                            f\"git+https://x:x@github.com/DHARPA-project/{package_name}@develop\"\n                        )\n                    else:\n                        plugin_packages.append(package_name)\n        else:\n            plugin_packages = package_names  # type: ignore\n\n        in_jupyter = \"google.colab\" in sys.modules or \"jupyter_client\" in sys.modules\n\n        if not plugin_packages:\n            if in_jupyter:\n                return None\n            else:\n                # nothing to do\n                return False\n\n        class DummyContext(object):\n            def __getattribute__(self, item):\n                raise Exception(\n                    \"Currently installing plugins, no other operations are allowed.\"\n                )\n\n        current_context_name = self._current_context_alias\n        for k in self._contexts.keys():\n            self._contexts[k] = DummyContext()  # type: ignore\n        self._current_context = DummyContext()  # type: ignore\n\n        cmd = [\"-q\", \"--isolated\", \"install\"]\n        if update:\n            cmd.append(\"--upgrade\")\n        cmd.extend(plugin_packages)\n\n        if in_jupyter:\n            from IPython import get_ipython\n\n            ipython = get_ipython()\n            cmd_str = f\"sc -l stdout = {sys.executable} -m pip {' '.join(cmd)}\"\n            ipython.magic(cmd_str)\n            exit_code = 100\n        else:\n            import pip._internal.cli.main as pip\n\n            log_message(\n                \"install.python_packages\", packages=plugin_packages, update=update\n            )\n            exit_code = pip.main(cmd)\n\n        self._contexts.clear()\n        self._current_context = None\n        self._current_context_alias = None\n\n        EnvironmentRegistry._instance = None\n        if current_context_name:\n            self.set_active_context(context_name=current_context_name)\n\n        if exit_code == 100:\n            raise SystemExit(\n                f\"Please manually re-run all cells. Updated or newly installed plugin packages: {', '.join(plugin_packages)}.\"\n            )\n        elif exit_code != 0:\n            raise Exception(\n                f\"Failed to install plugin packages: {', '.join(plugin_packages)}\"\n            )\n\n        return True\n\n    # ==================================================================================================================\n    # context-management related functions\n    def list_context_names(self) -&gt; List[str]:\n\"\"\"list the names of all available/registered contexts.\"\"\"\n\n        return list(self._kiara_config.available_context_names)\n\n    def retrieve_context_infos(self) -&gt; ContextInfos:\n\"\"\"Retrieve information about the available/registered contexts.\"\"\"\n\n        return ContextInfos.create_context_infos(self._kiara_config.context_configs)\n\n    def get_current_context_name(self) -&gt; str:\n\"\"\"Retrieve the name fo the current context.\"\"\"\n\n        if self._current_context_alias is None:\n            self.context\n        return self._current_context_alias  # type: ignore\n\n    def create_new_context(self, context_name: str, set_active: bool) -&gt; None:\n\"\"\"Create a new context.\n\n        Arguments:\n            context_name: the name of the new context\n            set_active: set the newly created context as the active one\n        \"\"\"\n\n        if context_name in self.list_context_names():\n            raise Exception(\n                f\"Can't create context with name '{context_name}': context already exists.\"\n            )\n\n        ctx = self._kiara_config.create_context(context_name, extra_pipelines=None)\n        if set_active:\n            self._current_context = ctx\n            self._current_context_alias = context_name\n\n    def set_active_context(self, context_name: str, create: bool = False) -&gt; None:\n\n        if not context_name:\n            raise Exception(\"No context name provided.\")\n\n        if context_name == self._current_context_alias:\n            return\n        if context_name not in self.list_context_names():\n            if create:\n                self._current_context = self._kiara_config.create_context(\n                    context=context_name, extra_pipelines=None\n                )\n                self._current_context_alias = context_name\n                return\n            else:\n                raise Exception(f\"No context with name '{context_name}' available.\")\n\n        self._current_context = self._kiara_config.create_context(\n            context=context_name, extra_pipelines=None\n        )\n        self._current_context_alias = context_name\n\n    # ==================================================================================================================\n    # methods for data_types\n\n    def list_data_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered data types.\"\"\"\n\n        return self.context.type_registry.data_type_names\n\n    def is_internal_data_type(self, data_type_name: str) -&gt; bool:\n\"\"\"Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.\"\"\"\n\n        return self.context.type_registry.is_internal_type(\n            data_type_name=data_type_name\n        )\n\n    def retrieve_data_types_info(\n        self, filter: Union[str, Iterable[str], None]\n    ) -&gt; DataTypeClassesInfo:\n\"\"\"Retrieve information about all data types.\n\n        A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific\n        Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.\n\n        Arguments:\n            filter: an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)\n\n        Returns:\n            an object containing all information about all data types\n        \"\"\"\n\n        if filter:\n            if isinstance(filter, str):\n                filter = [filter]\n\n            title = f\"Filtered data_types: {filter}\"\n            data_type_names: Iterable[str] = []\n\n            for m in self.context.type_registry.data_type_names:\n                match = True\n\n                for f in filter:\n\n                    if f.lower() not in m.lower():\n                        match = False\n                        break\n\n                if match:\n                    data_type_names.append(m)  # type: ignore\n        else:\n            title = \"All data types\"\n            data_type_names = self.context.type_registry.data_type_names\n\n        data_types = {\n            d: self.context.type_registry.get_data_type_cls(d) for d in data_type_names\n        }\n        data_types_info = DataTypeClassesInfo.create_from_type_items(\n            kiara=self.context, group_title=title, **data_types\n        )\n\n        return data_types_info  # type: ignore\n\n    def retrieve_data_type_info(self, data_type_name: str) -&gt; DataTypeClassInfo:\n\"\"\"Retrieve information about a specific data type.\n\n        Arguments:\n            data_type: the registered name of the data type\n\n        Returns:\n            an object containing all information about a data type\n        \"\"\"\n\n        dt_cls = self.context.type_registry.get_data_type_cls(data_type_name)\n        info = DataTypeClassInfo.create_from_type_class(\n            kiara=self.context, type_cls=dt_cls\n        )\n        return info\n\n    # ==================================================================================================================\n    # methods for module and operations info\n\n    def list_module_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered module types.\"\"\"\n\n        return list(self.context.module_registry.get_module_type_names())\n\n    def retrieve_module_types_info(\n        self, filter: Union[None, str, Iterable[str]] = None\n    ) -&gt; ModuleTypesInfo:\n\"\"\"Retrieve information for all available module types (or a filtered subset thereof).\n\n        A module type is Python class that inherits from [KiaraModule][kiara.modules.KiaraModule], and is the basic\n        building block for processing pipelines. Module types are not used directly by users, Operations are. Operations\n         are instantiated modules (meaning: the module &amp; some (optional) configuration).\n\n        Arguments:\n            filter: an optional string (or list of string) the returned module names have to match (all filters in case of list)\n\n        Returns:\n            a mapping object containing module names as keys, and information about the modules as values\n        \"\"\"\n\n        if filter:\n\n            if isinstance(filter, str):\n                filter = [filter]\n            title = f\"Filtered modules: {filter}\"\n            module_types_names: Iterable[str] = []\n\n            for m in self.context.module_registry.get_module_type_names():\n                match = True\n\n                for f in filter:\n\n                    if f.lower() not in m.lower():\n                        match = False\n                        break\n\n                if match:\n                    module_types_names.append(m)  # type: ignore\n        else:\n            title = \"All modules\"\n            module_types_names = self.context.module_registry.get_module_type_names()\n\n        module_types = {\n            n: self.context.module_registry.get_module_class(n)\n            for n in module_types_names\n        }\n\n        module_types_info = ModuleTypesInfo.create_from_type_items(  # type: ignore\n            kiara=self.context, group_title=title, **module_types\n        )\n        return module_types_info  # type: ignore\n\n    def retrieve_module_type_info(self, module_type: str) -&gt; ModuleTypeInfo:\n\"\"\"Retrieve information about a specific module type.\n\n        This can be used to retrieve information like module documentation and configuration options.\n\n        Arguments:\n            module_type: the registered name of the module\n\n        Returns:\n            an object containing all information about a module type\n        \"\"\"\n\n        m_cls = self.context.module_registry.get_module_class(module_type)\n        info = ModuleTypeInfo.create_from_type_class(kiara=self.context, type_cls=m_cls)\n        return info\n\n    def create_operation(\n        self,\n        module_type: str,\n        module_config: Union[Mapping[str, Any], str, None] = None,\n    ) -&gt; Operation:\n\"\"\"Create an [Operation][kiara.models.module.operation.Operation] instance for the specified module type and (optional) config.\n\n        This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.\n\n        Arguments:\n            module_type: the registered name of the module\n            module_config: (Optional) configuration for the module instance.\n\n        Returns:\n            an Operation instance (which contains all the available information about an instantiated module)\n        \"\"\"\n\n        if module_config is None:\n            module_config = {}\n        elif isinstance(module_config, str):\n            try:\n                module_config = json.load(module_config)  # type: ignore\n            except Exception:\n                try:\n                    module_config = yaml.load(module_config)  # type: ignore\n                except Exception:\n                    raise Exception(\n                        f\"Can't parse module config string: {module_config}.\"\n                    )\n\n        if module_type == \"pipeline\":\n            if not module_config:\n                raise Exception(\"Pipeline configuration can't be empty.\")\n            assert module_config is None or isinstance(module_config, Mapping)\n            operation = create_operation(\"pipeline\", operation_config=module_config)\n            return operation\n        else:\n            mc = Manifest(module_type=module_type, module_config=module_config)\n            module_obj = self.context.module_registry.create_module(mc)\n\n            return module_obj.operation\n\n    def list_operation_ids(\n        self,\n        filter: Union[str, None, Iterable[str]] = None,\n        include_internal: bool = False,\n    ) -&gt; List[str]:\n\"\"\"Get a list of all operation ids that match the specified filter.\n\n        Arguments:\n            filter: an optional single or list of filters (all filters must match the operation id for the operation to be included)\n            include_internal: also return internal operations\n        \"\"\"\n\n        if not filter and include_internal:\n            return sorted(self.context.operation_registry.operation_ids)\n\n        else:\n            return sorted(\n                self.list_operations(\n                    filter=filter, include_internal=include_internal\n                ).keys()\n            )\n\n    def get_operation(\n        self,\n        operation: Union[Mapping[str, Any], str, Path],\n        allow_external: Union[bool, None] = None,\n    ) -&gt; Operation:\n\"\"\"Return the operation instance with the specified id.\n\n        This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.\n\n        The order in which the operation argument is resolved:\n        - if it's a string, and an existing, registered operation_id, the associated operation is returned\n        - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)\n\n        Arguments:\n            operation: the operation id, module_type_name, path to a file, or url\n            allow_external: if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.\n\n        Returns:\n            operation instance data\n        \"\"\"\n\n        _module_type = None\n        _module_config = None\n\n        if allow_external is None:\n            allow_external = self.get_runtime_config().allow_external\n\n        if isinstance(operation, Path):\n            operation = operation.as_posix()\n\n        if isinstance(operation, str):\n\n            if operation in self.list_operation_ids(include_internal=True):\n                _operation = self.context.operation_registry.get_operation(operation)\n                return _operation\n\n            if not allow_external:\n                raise NoSuchExecutionTargetException(\n                    selected_target=operation,\n                    available_targets=self.context.operation_registry.operation_ids,\n                    msg=f\"Can't find operation with id '{operation}', and external operations are not allowed.\",\n                )\n\n            if os.path.isfile(operation):\n                try:\n                    # we use the 'from_file' here, because that will resolve any relative paths in the pipeline\n                    # if this doesn't work, we just assume the file is not a pipeline configuration but\n                    # a manifest file with 'module_type' and optional 'module_config' keys\n                    pipeline_conf = PipelineConfig.from_file(\n                        path=operation, kiara=self.context\n                    )\n                    _module_config = pipeline_conf.dict()\n                except Exception as e:\n                    log_exception(e)\n                    _module_config = get_data_from_file(operation)\n            elif operation.startswith(\"http\"):\n                _module_config = get_data_from_url(operation)\n            else:\n                try:\n                    _module_config = json.load(operation)  # type: ignore\n                except Exception:\n                    try:\n                        _module_config = yaml.load(operation)  # type: ignore\n                    except Exception:\n                        raise Exception(\n                            f\"Can't parse configuration string: {operation}.\"\n                        )\n        else:\n            _module_config = dict(operation)\n\n        if \"module_type\" in _module_config.keys():\n            _module_type = _module_config[\"module_type\"]\n            _module_config = _module_config.get(\"module_config\", {})\n        else:\n            _module_type = \"pipeline\"\n\n        op = self.create_operation(\n            module_type=_module_type, module_config=_module_config\n        )\n        return op\n\n    def list_operations(\n        self,\n        filter: Union[str, None, Iterable[str]] = None,\n        input_types: Union[str, Iterable[str], None] = None,\n        output_types: Union[str, Iterable[str], None] = None,\n        operation_types: Union[str, Iterable[str], None] = None,\n        python_packages: Union[str, Iterable[str], None] = None,\n        include_internal: bool = False,\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"List all available values, optionally filter.\n\n        Arguments:\n            filter: the (optional) filter string(s), an operation must match all of them to be included in the result\n            input_types: each operation must have at least one input that matches one of the specified types\n            output_types: each operation must have at least one output that matches one of the specified types\n            operation_types: only include operations of the specified type(s)\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            python_packages: only include operations that are contained in one of the provided python packages\n        Returns:\n            a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value\n        \"\"\"\n\n        if operation_types:\n            if isinstance(operation_types, str):\n                operation_types = [operation_types]\n            temp: Dict[str, Operation] = {}\n            for op_type_name in operation_types:\n                op_type = self.context.operation_registry.operation_types.get(\n                    op_type_name, None\n                )\n                if op_type is None:\n                    raise Exception(f\"Operation type not registered: {op_type_name}\")\n\n                temp.update(op_type.operations)\n            operations: Mapping[str, Operation] = temp\n        else:\n            operations = self.context.operation_registry.operations\n\n        if filter:\n            if isinstance(filter, str):\n                filter = [filter]\n            temp = {}\n            for op_id, op in operations.items():\n                match = True\n                for f in filter:\n                    if not f:\n                        continue\n                    if f.lower() not in op_id.lower():\n                        match = False\n                        break\n                if match:\n                    temp[op_id] = op\n            operations = temp\n\n        if not include_internal:\n            temp = {}\n            for op_id, op in operations.items():\n                if not op.operation_details.is_internal_operation:\n                    temp[op_id] = op\n\n            operations = temp\n\n        if input_types:\n            if isinstance(input_types, str):\n                input_types = [input_types]\n            temp = {}\n            for op_id, op in operations.items():\n                for input_type in input_types:\n                    match = False\n                    for schema in op.inputs_schema.values():\n                        if schema.type == input_type:\n                            temp[op_id] = op\n                            match = True\n                            break\n                    if match:\n                        break\n\n            operations = temp\n\n        if output_types:\n            if isinstance(output_types, str):\n                output_types = [output_types]\n            temp = {}\n            for op_id, op in operations.items():\n                for output_type in output_types:\n                    match = False\n                    for schema in op.outputs_schema.values():\n                        if schema.type == output_type:\n                            temp[op_id] = op\n                            match = True\n                            break\n                    if match:\n                        break\n\n            operations = temp\n\n        if python_packages:\n            temp = {}\n            if isinstance(python_packages, str):\n                python_packages = [python_packages]\n            for op_id, op in operations.items():\n                info = OperationInfo.create_from_instance(\n                    kiara=self.context, instance=op\n                )\n                pkg = info.context.labels.get(\"package\", None)\n                if pkg in python_packages:\n                    temp[pkg] = op\n            operations = temp\n\n        return operations\n\n    def retrieve_operation_info(\n        self, operation: str, allow_external: bool = False\n    ) -&gt; OperationInfo:\n\"\"\"Return the full information for the specified operation id.\n\n        This is similar to the 'get_operation' method, but returns additional information. Only use this instead of\n        'get_operation' if you need the additional info, as it's more expensive to get.\n\n        Arguments:\n            operation: the operation id\n\n        Returns:\n            augmented operation instance data\n        \"\"\"\n\n        if not allow_external:\n            op = self.context.operation_registry.get_operation(operation_id=operation)\n        else:\n            op = create_operation(module_or_operation=operation)\n        op_info = OperationInfo.create_from_operation(kiara=self.context, operation=op)\n        return op_info\n\n    def retrieve_operations_info(\n        self,\n        *filters,\n        input_types: Union[str, Iterable[str], None] = None,\n        output_types: Union[str, Iterable[str], None] = None,\n        operation_types: Union[str, Iterable[str], None] = None,\n        python_packages: Union[str, Iterable[str], None] = None,\n        include_internal: bool = False,\n    ) -&gt; OperationGroupInfo:\n\"\"\"Retrieve information about the matching operations.\n\n        This retrieves the same list of operations as [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations],\n        but augments each result instance with additional information that might be useful in frontends.\n\n        'OperationInfo' objects contains augmented information on top of what 'normal' [Operation][kiara.models.module.operation.Operation] objects\n        hold, but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations] method\n        instead.\n\n        Arguments:\n            filters: the (optional) filter strings, an operation must match all of them to be included in the result\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            output_types: each operation must have at least one output that matches one of the specified types\n            operation_types: only include operations of the specified type(s)\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            python_packages: only include operations that are contained in one of the provided python packages\n        Returns:\n            a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value\n        \"\"\"\n\n        title = \"Available operations\"\n        if filters:\n            title = \"Filtered operations\"\n\n        operations = self.list_operations(\n            filters,\n            input_types=input_types,\n            output_types=output_types,\n            include_internal=include_internal,\n            operation_types=operation_types,\n            python_packages=python_packages,\n        )\n\n        ops_info = OperationGroupInfo.create_from_operations(\n            kiara=self.context, group_title=title, **operations\n        )\n        return ops_info\n\n    # ==================================================================================================================\n    # methods relating to pipelines\n    def register_pipeline(\n        self,\n        data: Union[Path, str, Mapping[str, Any]],\n        operation_id: Union[str, None] = None,\n    ) -&gt; Operation:\n\"\"\"Register a pipelne as new operation into this context.\n\n        Arguments:\n            data: a dict or a path to a json/yaml file containing the definition\n            operation_id: the id to use for the operation (if not specified, the id will be auto-determined)\n\n        Returns:\n            the assembled operation\n        \"\"\"\n\n        return self.context.operation_registry.register_pipeline(\n            data=data, operation_id=operation_id\n        )\n\n    def register_pipelines(\n        self, *pipeline_paths: Union[str, Path]\n    ) -&gt; Dict[str, Operation]:\n\"\"\"Register all pipelines found in the specified paths.\"\"\"\n\n        return self.context.operation_registry.register_pipelines(*pipeline_paths)\n\n    # ==================================================================================================================\n    # methods relating to values and data\n\n    def register_data(\n        self,\n        data: Any,\n        data_type: Union[None, str] = None,\n        reuse_existing: bool = False,\n    ) -&gt; Value:\n\"\"\"Register data with kiara.\n\n        This will create a new value instance from the data and return it. The data/value itself won't be stored\n        in a store, you have to use the 'store_value' function for that.\n\n        Arguments:\n            data: the data to register\n            data_type: (optional) the data type of the data. If not provided, kiara will try to infer the data type.\n            reuse_existing: whether to re-use an existing value that is already registered and has the same hash.\n\n        Returns:\n            a [kiara.models.values.value.Value] instance\n        \"\"\"\n\n        if data_type is None:\n            raise NotImplementedError(\n                \"Infering data types not implemented yet. Please provide one manually.\"\n            )\n\n        value = self.context.data_registry.register_data(\n            data=data, schema=data_type, reuse_existing=reuse_existing\n        )\n        return value\n\n    def list_value_ids(self, **matcher_params) -&gt; List[uuid.UUID]:\n\"\"\"List all available value ids for this kiara context.\n\n        This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n        having to look up the details of each value (like [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n        does). This method can also be used with a matcher, but in this case the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n        would be preferable in most cases, because it is called under the hood, and the performance advantage of not\n        having to look up value details is gone.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a list of value ids\n        \"\"\"\n\n        if matcher_params:\n            values = self.list_values(**matcher_params)\n            return sorted(values.keys())\n        else:\n            _values = self.context.data_registry.retrieve_all_available_value_ids()\n            return sorted(_values)\n\n    def list_values(self, **matcher_params: Any) -&gt; Dict[uuid.UUID, Value]:\n\"\"\"List all available values, optionally filter.\n\n        Retrieve information about all values that are available in the current kiara context session (both stored\n        and non-stored).\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n        \"\"\"\n\n        if matcher_params:\n            matcher = ValueMatcher.create_matcher(**matcher_params)\n\n            values = self.context.data_registry.find_values(matcher=matcher)\n        else:\n            # TODO: make that parallel?\n            values = {\n                k: self.context.data_registry.get_value(k)\n                for k in self.context.data_registry.retrieve_all_available_value_ids()\n            }\n\n        return values\n\n    def get_value(self, value: Union[str, Value, uuid.UUID]) -&gt; Value:\n\"\"\"Retrieve a value instance with the specified id or alias.\n\n        Raises an exception if no value could be found.\n\n        Arguments:\n            value: a value id, alias or object that has a 'value_id' attribute.\n\n        Returns:\n            the Value instance\n        \"\"\"\n\n        return self.context.data_registry.get_value(value=value)\n\n    def retrieve_value_info(self, value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo:\n\"\"\"Retrieve an info object for a value.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.get_value] method\n        instead.\n\n        Arguments:\n            value: a value id, alias or object that has a 'value_id' attribute.\n\n        Returns:\n            the ValueInfo instance\n\n        \"\"\"\n\n        _value = self.get_value(value=value)\n        return ValueInfo.create_from_instance(kiara=self.context, instance=_value)\n\n    def retrieve_values_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n        This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n        but augments each result value instance with additional information that might be useful in frontends.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values] method\n        instead.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n        \"\"\"\n\n        values = self.list_values(**matcher_params)\n\n        infos = ValuesInfo.create_from_instances(\n            kiara=self.context, instances={str(k): v for k, v in values.items()}\n        )\n        return infos  # type: ignore\n\n    def list_alias_names(self, **matcher_params) -&gt; List[str]:\n\"\"\"List all available alias keys.\n\n        This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n        having to look up the details of each value (like [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n        does). This method can also be used with a matcher, but in this case the [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n        would be preferrable in most cases, because it is called under the hood, and the performance advantage of not\n        having to look up value details is gone.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a list of value ids\n        \"\"\"\n\n        if matcher_params:\n            values = self.list_aliases(**matcher_params)\n            return list(values.keys())\n        else:\n            _values = self.context.alias_registry.all_aliases\n            return list(_values)\n\n    def list_aliases(self, **matcher_params) -&gt; Dict[str, Value]:\n\"\"\"List all available values that have an alias assigned, optionally filter.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n        \"\"\"\n\n        if matcher_params:\n            matcher_params[\"has_alias\"] = True\n            all_values = self.list_values(**matcher_params)\n            result: Dict[str, Value] = {}\n            for value in all_values.values():\n                aliases = self.context.alias_registry.find_aliases_for_value_id(\n                    value_id=value.value_id\n                )\n                for a in aliases:\n                    if a in result.keys():\n                        raise Exception(\n                            f\"Duplicate value alias '{a}': this is most likely a bug.\"\n                        )\n                    result[a] = value\n\n            result = {k: result[k] for k in sorted(result.keys())}\n        else:\n            # faster if not other matcher params\n            all_aliases = self.context.alias_registry.all_aliases\n            result = {\n                k: self.context.data_registry.get_value(f\"alias:{k}\")\n                for k in all_aliases\n            }\n\n        return result\n\n    def retrieve_aliases_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n        This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n        but augments each result value instance with additional information that might be useful in frontends.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.list_aliases] method\n        instead.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n        \"\"\"\n\n        values = self.list_aliases(**matcher_params)\n\n        infos = ValuesInfo.create_from_instances(\n            kiara=self.context, instances={str(k): v for k, v in values.items()}\n        )\n        return infos  # type: ignore\n\n    def assemble_value_map(\n        self,\n        values: Mapping[str, Union[uuid.UUID, None, str, Value]],\n        values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n        register_data: bool = False,\n        reuse_existing_data: bool = False,\n    ) -&gt; ValueMap:\n\"\"\"Retrive a [ValueMap][TODO] object from the provided value ids or value links.\n\n        By default, this method can only use values/datasets that are already registered in *kiara*. If you want to\n        auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.\n\n        Arguments:\n            values: a dictionary with the values in question\n            values_schema: an optional dictionary with the schema for each of the values that are not yet registered\n            register_data: whether to allow auto-registration of 'raw' data\n            reuse_existing_data: whether to reuse existing data with the same hash as the 'raw' data that is being registered\n\n        Returns:\n            a value map instance\n        \"\"\"\n\n        if register_data:\n            temp: Dict[str, Union[str, Value, uuid.UUID, None]] = {}\n            for k, v in values.items():\n\n                if isinstance(v, (Value, uuid.UUID)):\n                    temp[k] = v\n                    continue\n\n                if isinstance(v, str):\n                    try:\n                        v = uuid.UUID(v)\n                        temp[k] = v\n                        continue\n                    except Exception:\n                        if v.startswith(\"alias:\"):  # type: ignore\n                            _v = v.replace(\"alias:\", \"\")  # type: ignore\n                        else:\n                            _v = v\n                        if _v in self.list_aliases():\n                            temp[k] = f\"alias:{_v}\"\n                            continue\n\n                if not values_schema:\n                    raise Exception(\n                        f\"Can't assemble value map field without schema: '{k}' -- {str(v)}\"\n                    )\n\n                if k not in values_schema.keys():\n                    raise Exception(\n                        f\"Can't assemble value map field without schema key: '{k}' -- {str(v)}\"\n                    )\n\n                if v is None:\n                    temp[k] = None\n                else:\n                    _v = self.register_data(\n                        data=v,\n                        data_type=values_schema[k].type,\n                        reuse_existing=reuse_existing_data,\n                    )\n                    temp[k] = _v\n            values = temp\n\n        return self.context.data_registry.load_values(\n            values=values, values_schema=values_schema\n        )\n\n    def store_value(\n        self,\n        value: Union[str, uuid.UUID, Value],\n        alias: Union[str, Iterable[str], None],\n        allow_overwrite: bool = True,\n    ) -&gt; StoreValueResult:\n\"\"\"Store the specified value in the (default) value store.\n\n        Arguments:\n            value: the value (or a reference to it)\n            alias: (Optional) aliases for the value\n            allow_overwrite: whether to allow overwriting existing aliases\n        \"\"\"\n\n        if isinstance(alias, str):\n            alias = [alias]\n\n        value_obj = self.get_value(value)\n        persisted_data: Union[None, PersistedData] = None\n        try:\n            persisted_data = self.context.data_registry.store_value(value=value_obj)\n            if alias:\n                self.context.alias_registry.register_aliases(\n                    value_obj.value_id, *alias, allow_overwrite=allow_overwrite\n                )\n            result = StoreValueResult.construct(\n                value=value_obj,\n                aliases=sorted(alias) if alias else [],\n                error=None,\n                persisted_data=persisted_data,\n            )\n        except Exception as e:\n            log_exception(e)\n            result = StoreValueResult.construct(\n                value=value_obj,\n                aliases=sorted(alias) if alias else [],\n                error=str(e),\n                persisted_data=persisted_data,\n            )\n\n        return result\n\n    def store_values(\n        self,\n        values: Mapping[str, Union[str, uuid.UUID, Value]],\n        alias_map: Mapping[str, Iterable[str]],\n    ) -&gt; StoreValuesResult:\n\"\"\"Store multiple values into the (default) kiara value store.\n\n        Values are identified by unique keys in both input arguments, the alias map references the key that is used in\n        the 'values' argument.\n\n        Arguments:\n            values: a map of value keys/values\n            alias_map: a map of value keys aliases\n\n        Returns:\n            an object outlining which values (identified by the specified value key) where stored and how\n        \"\"\"\n\n        result = {}\n        for field_name, value in values.items():\n            aliases = alias_map.get(field_name)\n            value_obj = self.get_value(value)\n            store_result = self.store_value(value=value_obj, alias=aliases)\n            result[field_name] = store_result\n\n        return StoreValuesResult.construct(__root__=result)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # operation-related methods\n\n    def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType:\n\"\"\"Get the management object for the specified operation type.\"\"\"\n\n        return self.context.operation_registry.get_operation_type(op_type=op_type)\n\n    def retrieve_operation_type_info(\n        self, op_type: Union[str, Type[OP_TYPE]]\n    ) -&gt; OperationTypeInfo:\n\"\"\"Get an info object for the specified operation type.\"\"\"\n\n        _op_type = self.get_operation_type(op_type=op_type)\n        return OperationTypeInfo.create_from_type_class(\n            kiara=self.context, type_cls=_op_type.__class__\n        )\n\n    def find_operation_id(\n        self, module_type: str, module_config: Union[None, Mapping[str, Any]] = None\n    ) -&gt; Union[None, str]:\n\"\"\"Try to find the registered operation id for the specified module type and configuration.\n\n        Arguments:\n            module_type: the module type\n            module_config: the module configuration\n\n        Returns:\n            the registered operation id, if found, or None\n        \"\"\"\n\n        manifest = self.context.create_manifest(\n            module_or_operation=module_type, config=module_config\n        )\n        return self.context.operation_registry.find_operation_id(manifest=manifest)\n\n    def assemble_filter_pipeline_config(\n        self,\n        data_type: str,\n        filters: Union[str, Iterable[str], Mapping[str, str]],\n        endpoint: Union[None, Manifest, str] = None,\n        endpoint_input_field: Union[str, None] = None,\n        endpoint_step_id: Union[str, None] = None,\n        extra_input_aliases: Union[None, Mapping[str, str]] = None,\n        extra_output_aliases: Union[None, Mapping[str, str]] = None,\n    ) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n        Optionally, a module that uses the filtered dataset as input can be specified.\n\n        # TODO: document filter names\n        For the 'filters' argument, the accepted inputs are:\n        - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n        - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n        - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n        Arguments:\n            data_type: the type of the data to filter\n            filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n            endpoint: optional module to put as last step in the created pipeline\n            endpoing_input_field: field name of the input that will receive the filtered value\n            endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n            extra_input_aliases: extra output aliases to add to the pipeline config\n            extra_output_aliases: extra output aliases to add to the pipeline config\n\n        Returns:\n            the (pipeline) module configuration of the filter pipeline\n        \"\"\"\n\n        filter_op_type: FilterOperationType = self.context.operation_registry.get_operation_type(\"filter\")  # type: ignore\n        pipeline_config = filter_op_type.assemble_filter_pipeline_config(\n            data_type=data_type,\n            filters=filters,\n            endpoint=endpoint,\n            endpoint_input_field=endpoint_input_field,\n            endpoint_step_id=endpoint_step_id,\n            extra_input_aliases=extra_input_aliases,\n            extra_output_aliases=extra_output_aliases,\n        )\n\n        return pipeline_config\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # render-related methods\n\n    def retrieve_renderer_infos(\n        self, source_type: Union[str, None] = None\n    ) -&gt; RendererInfos:\n\n        if not source_type:\n            renderers = self.context.render_registry.registered_renderers\n        else:\n            renderers = self.context.render_registry.retrieve_renderers_for_source_type(\n                source_type=source_type\n            )\n\n        group = {k.get_renderer_alias(): k for k in renderers}\n        infos = RendererInfos.create_from_instances(kiara=self.context, instances=group)\n        return infos  # type: ignore\n\n    def retrieve_renderers_for(self, source_type: str) -&gt; List[KiaraRenderer]:\n\n        return self.context.render_registry.retrieve_renderers_for_source_type(\n            source_type=source_type\n        )\n\n    def render(\n        self,\n        item: Any,\n        source_type: str,\n        target_type: str,\n        render_config: Union[Mapping[str, Any], None] = None,\n    ) -&gt; Any:\n\n        registry = self.context.render_registry\n        result = registry.render(\n            item=item,\n            source_type=source_type,\n            target_type=target_type,\n            render_config=render_config,\n        )\n        return result\n\n    def assemble_render_pipeline(\n        self,\n        data_type: str,\n        target_format: Union[str, Iterable[str]] = \"string\",\n        filters: Union[None, str, Iterable[str], Mapping[str, str]] = None,\n        use_pretty_print: bool = False,\n    ) -&gt; Operation:\n\"\"\"Create a manifest describing a transformation that renders a value of the specified data type in the target format.\n\n        If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n        the value type of the source value, and the provided target format.\n\n        Arguments:\n            value: the value (or value id)\n            target_format: the format into which to render the value\n            filters: a list of filters to apply to the value before rendering it\n            use_pretty_print: if True, use a 'pretty_print' operation instead of 'render_value'\n\n        Returns:\n            the manifest for the transformation\n        \"\"\"\n\n        if data_type not in self.context.data_type_names:\n            raise DataTypeUnknownException(data_type=data_type)\n\n        if use_pretty_print:\n            pretty_print_op_type: PrettyPrintOperationType = (\n                self.context.operation_registry.get_operation_type(\"pretty_print\")\n            )  # type: ignore\n            ops = pretty_print_op_type.get_target_types_for(data_type)\n        else:\n            render_op_type: RenderValueOperationType = self.context.operation_registry.get_operation_type(\n                # type: ignore\n                \"render_value\"\n            )  # type: ignore\n            ops = render_op_type.get_render_operations_for_source_type(data_type)\n\n        if isinstance(target_format, str):\n            target_format = [target_format]\n\n        match = None\n        for _target_type in target_format:\n            if _target_type not in ops.keys():\n                continue\n            match = ops[_target_type]\n            break\n\n        if not match:\n            if not ops:\n                msg = f\"No render operations registered for source type '{data_type}'.\"\n            else:\n                msg = f\"Registered target types for source type '{data_type}': {', '.join(ops.keys())}.\"\n            raise Exception(\n                f\"No render operation for source type '{data_type}' to target type(s) registered: '{', '.join(target_format)}'. {msg}\"\n            )\n\n        if filters:\n            # filter_op_type: FilterOperationType = self._kiara.operation_registry.get_operation_type(\"filter\")  # type: ignore\n            endpoint = Manifest(\n                module_type=match.module_type, module_config=match.module_config\n            )\n            extra_input_aliases = {\"render_value.render_config\": \"render_config\"}\n            extra_output_aliases = {\n                \"render_value.render_value_result\": \"render_value_result\"\n            }\n            pipeline_config = self.assemble_filter_pipeline_config(\n                data_type=data_type,\n                filters=filters,\n                endpoint=endpoint,\n                endpoint_input_field=\"value\",\n                endpoint_step_id=\"render_value\",\n                extra_input_aliases=extra_input_aliases,\n                extra_output_aliases=extra_output_aliases,\n            )\n            manifest = Manifest(\n                module_type=\"pipeline\", module_config=pipeline_config.dict()\n            )\n            module = self.context.module_registry.create_module(manifest=manifest)\n            operation = Operation.create_from_module(module, doc=pipeline_config.doc)\n        else:\n            operation = match\n\n        return operation\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # job-related methods\n    def queue_manifest(\n        self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job using the provided manifest to describe the module and config that should be executed.\n\n        Arguments:\n            manifest: the manifest\n            inputs: the job inputs (can be either references to values, or raw inputs\n\n        Returns:\n            a result value map instance\n        \"\"\"\n\n        if inputs is None:\n            inputs = {}\n\n        job_config = self.context.job_registry.prepare_job_config(\n            manifest=manifest, inputs=inputs\n        )\n\n        job_id = self.context.job_registry.execute_job(\n            job_config=job_config, wait=False\n        )\n        return job_id\n\n    def run_manifest(\n        self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n    ) -&gt; ValueMap:\n\"\"\"Run a job using the provided manifest to describe the module and config that should be executed.\n\n        Arguments:\n            manifest: the manifest\n            inputs: the job inputs (can be either references to values, or raw inputs\n\n        Returns:\n            a result value map instance\n        \"\"\"\n\n        job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n        return self.context.job_registry.retrieve_result(job_id=job_id)\n\n    def queue_job(\n        self,\n        operation: Union[str, Path, Manifest, OperationInfo],\n        inputs: Mapping[str, Any],\n        operation_config: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n        This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n        Arguments:\n            operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n            inputs: the operation inputs\n            operation_config: the (optional) module config in case 'operation' is a module name\n\n        Returns:\n            the queued job id\n        \"\"\"\n\n        if isinstance(operation, Path):\n            if not operation.is_file():\n                raise Exception(\n                    f\"Can't queue job from file '{operation.as_posix()}': file does not exist.\"\n                )\n            operation = operation.as_posix()\n        elif isinstance(operation, OperationInfo):\n            operation = operation.operation\n\n        if not isinstance(operation, Manifest):\n            manifest: Manifest = create_operation(\n                module_or_operation=operation,\n                operation_config=operation_config,\n                kiara=self.context,\n            )\n        else:\n            manifest = operation\n\n        job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n        return job_id\n\n    def run_job(\n        self,\n        operation: Union[str, Path, Manifest, OperationInfo],\n        inputs: Union[None, Mapping[str, Any]] = None,\n        operation_config: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; ValueMap:\n\"\"\"Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n        This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n        In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead,\n        since this is a blocking operation.\n\n        Arguments:\n            operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n            inputs: the operation inputs\n            operation_config: the (optional) module config in case 'operation' is a module name\n\n        Returns:\n            the job result value map\n\n        \"\"\"\n\n        if inputs is None:\n            inputs = {}\n        job_id = self.queue_job(\n            operation=operation, inputs=inputs, operation_config=operation_config\n        )\n        return self.context.job_registry.retrieve_result(job_id=job_id)\n\n    def get_job(self, job_id: Union[str, uuid.UUID]) -&gt; ActiveJob:\n\"\"\"Retrieve the status of the job with the provided id.\"\"\"\n\n        if isinstance(job_id, str):\n            job_id = uuid.UUID(job_id)\n\n        job_status = self.context.job_registry.get_job(job_id=job_id)\n        return job_status\n\n    def get_job_result(self, job_id: Union[str, uuid.UUID]) -&gt; ValueMap:\n\"\"\"Retrieve the result(s) of the specified job.\"\"\"\n\n        if isinstance(job_id, str):\n            job_id = uuid.UUID(job_id)\n\n        result = self.context.job_registry.retrieve_result(job_id=job_id)\n        return result\n\n    def render_value(\n        self,\n        value: Union[str, uuid.UUID, Value],\n        target_format: Union[str, Iterable[str]] = \"string\",\n        filters: Union[None, Iterable[str], Mapping[str, str]] = None,\n        render_config: Union[Mapping[str, str], None] = None,\n        add_root_scenes: bool = True,\n        use_pretty_print: bool = False,\n    ) -&gt; RenderValueResult:\n\"\"\"Render a value in the specified target format.\n\n        If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n        the value type of the source value, and the provided target format.\n\n        Arguments:\n            value: the value (or value id)\n            target_format: the format into which to render the value\n            filters: an (optional) list of filters\n            render_config: manifest specific render configuration\n            add_root_scenes: add root scenes to the result\n            use_pretty_print: use 'pretty_print' operation instead of 'render_value'\n\n        Returns:\n            the rendered value data, and any related scenes, if applicable\n        \"\"\"\n\n        _value = self.get_value(value)\n        try:\n            render_operation: Union[None, Operation] = self.assemble_render_pipeline(\n                data_type=_value.data_type_name,\n                target_format=target_format,\n                filters=filters,\n                use_pretty_print=use_pretty_print,\n            )\n\n        except Exception as e:\n\n            log_message(\n                \"create_render_pipeline.failure\",\n                source_type=_value.data_type_name,\n                target_format=target_format,\n                error=e,\n            )\n\n            if use_pretty_print:\n                pretty_print_ops: PrettyPrintOperationType = self.context.operation_registry.get_operation_type(\"pretty_print\")  # type: ignore\n                if not isinstance(target_format, str):\n                    raise NotImplementedError(\n                        \"Can't handle multiple target formats for 'render_value' yet.\"\n                    )\n                render_operation = (\n                    pretty_print_ops.get_operation_for_render_combination(\n                        source_type=\"any\", target_type=target_format\n                    )\n                )\n            else:\n                render_ops: RenderValueOperationType = self.context.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n                if not isinstance(target_format, str):\n                    raise NotImplementedError(\n                        \"Can't handle multiple target formats for 'render_value' yet.\"\n                    )\n                render_operation = render_ops.get_render_operation(\n                    source_type=\"any\", target_type=target_format\n                )\n\n        if render_operation is None:\n            raise Exception(\n                f\"Could not find render operation for value: {_value.value_id}\"\n            )\n\n        if render_config and \"render_config\" in render_config.keys():\n            # raise NotImplementedError()\n            # TODO: is this necessary?\n            render_config = render_config[\"render_config\"]  # type: ignore\n            # manifest_hash = render_config[\"manifest_hash\"]\n            # if manifest_hash != render_operation.manifest_hash:\n            #     raise NotImplementedError(\n            #         \"Using a non-default render operation is not supported (yet).\"\n            #     )\n            # render_config = render_config[\"render_config\"]\n\n        if render_config is None:\n            render_config = {}\n        else:\n            render_config = dict(render_config)\n\n        # render_type = render_config.pop(\"render_type\", None)\n        # if not render_type or render_type == \"data\":\n        #     pass\n        # elif render_type == \"metadata\":\n        #     pass\n        # elif render_type == \"properties\":\n        #     pass\n        # elif render_type == \"lineage\":\n        #     pass\n\n        result = render_operation.run(\n            kiara=self.context,\n            inputs={\"value\": _value, \"render_config\": render_config},\n        )\n\n        if use_pretty_print:\n            render_result: Value = result[\"rendered_value\"]\n            value_render_data = render_result.data\n        else:\n            render_result = result[\"render_value_result\"]\n\n            if render_result.data_type_name != \"render_value_result\":\n                raise Exception(\n                    f\"Invalid result type for render operation: {render_result.data_type_name}\"\n                )\n\n            value_render_data: RenderValueResult = render_result.data  # type: ignore\n\n        return value_render_data\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # workflow-related methods\n\n    def list_workflow_ids(self) -&gt; List[uuid.UUID]:\n\"\"\"List all available workflow ids.\"\"\"\n\n        return list(self.context.workflow_registry.all_workflow_ids)\n\n    def list_workflow_alias_names(self) -&gt; List[str]:\n\"\"\" \"List all available workflow aliases.\"\"\"\n\n        return list(self.context.workflow_registry.workflow_aliases.keys())\n\n    def get_workflow(\n        self, workflow: Union[str, uuid.UUID], create_if_necessary: bool = True\n    ) -&gt; Workflow:\n\"\"\"Retrieve the workflow instance with the specified id or alias.\"\"\"\n\n        no_such_alias: bool = False\n        workflow_id: Union[uuid.UUID, None] = None\n        workflow_alias: Union[str, None] = None\n\n        if isinstance(workflow, str):\n            try:\n                workflow_id = uuid.UUID(workflow)\n            except Exception:\n                workflow_alias = workflow\n                try:\n                    workflow_id = self.context.workflow_registry.get_workflow_id(\n                        workflow_alias=workflow\n                    )\n                except NoSuchWorkflowException:\n                    no_such_alias = True\n        else:\n            workflow_id = workflow\n\n        if workflow_id is None:\n            raise Exception(f\"Can't retrieve workflow for: {workflow}\")\n\n        if workflow_id in self._workflow_cache.keys():\n            return self._workflow_cache[workflow_id]\n\n        if workflow_id is None and not create_if_necessary:\n            if not no_such_alias:\n                msg = f\"No workflow with id '{workflow}' registered.\"\n            else:\n                msg = f\"No workflow with alias '{workflow}' registered.\"\n\n            raise NoSuchWorkflowException(workflow=workflow, msg=msg)\n\n        if workflow_id:\n            # workflow_metadata = self.context.workflow_registry.get_workflow_metadata(\n            #     workflow=workflow_id\n            # )\n            workflow_obj = Workflow(kiara=self.context, workflow=workflow_id)\n            self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n        else:\n            # means we need to create it\n            workflow_obj = self.create_workflow(workflow_alias=workflow_alias)\n\n        return workflow_obj\n\n    def retrieve_workflow_info(self, workflow: Union[str, uuid.UUID, Workflow]):\n\n        if isinstance(workflow, Workflow):\n            _workflow: Workflow = workflow\n        else:\n            _workflow = self.get_workflow(workflow)\n\n        return WorkflowInfo.create_from_workflow(workflow=_workflow)\n\n    def list_workflows(self, **matcher_params) -&gt; Mapping[uuid.UUID, Workflow]:\n\"\"\"List all available workflow sessions, indexed by their unique id.\"\"\"\n\n        workflows = {}\n\n        matcher = WorkflowMatcher(**matcher_params)\n        if matcher.has_alias:\n            for (\n                alias,\n                workflow_id,\n            ) in self.context.workflow_registry.workflow_aliases.items():\n\n                workflow = self.get_workflow(workflow=workflow_id)\n                workflows[workflow.workflow_id] = workflow\n            return workflows\n        else:\n            for workflow_id in self.context.workflow_registry.all_workflow_ids:\n                workflow = self.get_workflow(workflow=workflow_id)\n                workflows[workflow_id] = workflow\n            return workflows\n\n    def list_workflow_aliases(self, **matcher_params) -&gt; Dict[str, Workflow]:\n\"\"\"List all available workflow sessions that have an alias, indexed by alias.\"\"\"\n\n        if matcher_params:\n            matcher_params[\"has_alias\"] = True\n            workflows = self.list_workflows(**matcher_params)\n            result: Dict[str, Workflow] = {}\n            for workflow in workflows.values():\n                aliases = self.context.workflow_registry.get_aliases(\n                    workflow_id=workflow.workflow_id\n                )\n                for a in aliases:\n                    if a in result.keys():\n                        raise Exception(\n                            f\"Duplicate workflow alias '{a}': this is most likely a bug.\"\n                        )\n                    result[a] = workflow\n            result = {k: result[k] for k in sorted(result.keys())}\n        else:\n            # faster if not other matcher params\n            all_aliases = self.context.workflow_registry.workflow_aliases\n            result = {\n                a: self.get_workflow(workflow=all_aliases[a])\n                for a in sorted(all_aliases.keys())\n            }\n        return result\n\n    def retrieve_workflows_info(self, **matcher_params: Any) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by (stringified) workflow-id.\"\"\"\n\n        workflows = self.list_workflows(**matcher_params)\n\n        workflow_infos = WorkflowGroupInfo.create_from_workflows(\n            *workflows.values(),\n            group_title=None,\n            alias_map=self.context.workflow_registry.workflow_aliases,\n        )\n        return workflow_infos\n\n    def retrieve_workflow_aliases_info(\n        self, **matcher_params: Any\n    ) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by alias.\"\"\"\n\n        workflows = self.list_workflow_aliases(**matcher_params)\n        workflow_infos = WorkflowGroupInfo.create_from_workflows(\n            *workflows.values(),\n            group_title=None,\n            alias_map=self.context.workflow_registry.workflow_aliases,\n        )\n        return workflow_infos\n\n    def create_workflow(\n        self,\n        workflow_alias: Union[None, str] = None,\n        initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None,\n        initial_inputs: Union[None, Mapping[str, Any]] = None,\n        documentation: Union[Any, None] = None,\n        save: bool = False,\n        force_alias: bool = False,\n    ) -&gt; Workflow:\n\n        if workflow_alias is not None:\n            try:\n                uuid.UUID(workflow_alias)\n                raise Exception(\n                    f\"Can't create workflow, provided alias can't be a uuid: {workflow_alias}.\"\n                )\n            except Exception:\n                pass\n\n        workflow_id = ID_REGISTRY.generate()\n        metadata = WorkflowMetadata(\n            workflow_id=workflow_id, documentation=documentation\n        )\n\n        workflow_obj = Workflow(kiara=self.context, workflow=metadata)\n        if workflow_alias:\n            workflow_obj._pending_aliases.add(workflow_alias)\n\n        if initial_pipeline:\n            operation = self.get_operation(operation=initial_pipeline)\n            if operation.module_type == \"pipeline\":\n                pipeline_details: PipelineOperationDetails = operation.operation_details  # type: ignore\n                workflow_obj.add_steps(*pipeline_details.pipeline_config.steps)\n                input_aliases = pipeline_details.pipeline_config.input_aliases\n                for k, v in input_aliases.items():\n                    workflow_obj.set_input_alias(input_field=k, alias=v)\n                output_aliases = pipeline_details.pipeline_config.output_aliases\n                for k, v in output_aliases.items():\n                    workflow_obj.set_output_alias(output_field=k, alias=v)\n            else:\n                raise NotImplementedError()\n\n            workflow_obj.set_inputs(**operation.module.config.defaults)\n\n        if initial_inputs:\n            workflow_obj.set_inputs(**initial_inputs)\n\n        self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n\n        if save:\n            if force_alias and workflow_alias:\n                self.context.workflow_registry.unregister_alias(workflow_alias)\n            workflow_obj.save()\n\n        return workflow_obj\n\n    def _repr_html_(self):\n\n        info = self.get_context_info()\n        r = info.create_renderable()\n        mime_bundle = r._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n        return mime_bundle[\"text/html\"]\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraAPI-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.doc","title":"<code>doc: Dict[str, str]</code>  <code>property</code> <code>cached</code>","text":"<p>Get the documentation for this API.</p>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.context","title":"<code>context: Kiara</code>  <code>property</code>","text":"<p>Return the kiara context.</p> <p>DON\"T USE THIS! This is going away in the production release.</p>"},{"location":"reference/kiara/api/#kiara.api.KiaraAPI-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.instance","title":"<code>instance() -&gt; KiaraAPI</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>@classmethod\ndef instance(\n    cls,\n) -&gt; \"KiaraAPI\":\n\n    if cls._instance is not None:\n        return cls._instance\n\n    from kiara.context import KiaraConfig\n\n    config = KiaraConfig()\n\n    api = KiaraAPI(kiara_config=config)\n    cls._instance = api\n    return api\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_runtime_config","title":"<code>get_runtime_config() -&gt; KiaraRuntimeConfig</code>","text":"<p>Retrieve the current runtime configuration.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_runtime_config(self) -&gt; \"KiaraRuntimeConfig\":\n\"\"\"Retrieve the current runtime configuration.\"\"\"\n    return self.context.runtime_config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_context_info","title":"<code>get_context_info() -&gt; ContextInfo</code>","text":"<p>Retrieve information about the current kiara context.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_context_info(self) -&gt; ContextInfo:\n\"\"\"Retrieve information about the current kiara context.\"\"\"\n\n    context_config = self._kiara_config.get_context_config(\n        self.get_current_context_name()\n    )\n    info = ContextInfo.create_from_context_config(\n        context_config,\n        context_name=self.get_current_context_name(),\n        runtime_config=self._kiara_config.runtime_config,\n    )\n\n    return info\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.ensure_plugin_packages","title":"<code>ensure_plugin_packages(package_names: Union[str, Iterable[str]], update: bool = False) -&gt; Union[bool, None]</code>","text":"<p>Ensure that the specified packages are installed.</p> <p>Parameters:</p> Name Type Description Default <code>package_names</code> <code>Union[str, Iterable[str]]</code> <p>The names of the packages to install.</p> required <code>update</code> <code>bool</code> <p>If True, update the packages if they are already installed</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[bool, None]</code> <p>'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def ensure_plugin_packages(\n    self, package_names: Union[str, Iterable[str]], update: bool = False\n) -&gt; Union[bool, None]:\n\"\"\"Ensure that the specified packages are installed.\n\n    Arguments:\n      package_names: The names of the packages to install.\n      update: If True, update the packages if they are already installed\n\n    Returns:\n        'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.\n    \"\"\"\n\n    if isinstance(package_names, str):\n        package_names = [package_names]\n\n    env_reg = EnvironmentRegistry.instance()\n    python_env: PythonRuntimeEnvironment = env_reg.environments[  # type: ignore\n        \"python\"\n    ]  # type: ignore\n\n    if not package_names:\n        package_names = OFFICIAL_KIARA_PLUGINS  # type: ignore\n\n    if not update:\n        plugin_packages: List[str] = []\n        pkgs = [p.name.replace(\"_\", \"-\") for p in python_env.packages]\n        for package_name in package_names:\n            if package_name.startswith(\"git:\"):\n                package_name = package_name.replace(\"git:\", \"\")\n                git = True\n            else:\n                git = False\n            package_name = package_name.replace(\"_\", \"-\")\n            if not package_name.startswith(\"kiara-plugin.\"):\n                package_name = f\"kiara-plugin.{package_name}\"\n\n            if git or package_name.replace(\"_\", \"-\") not in pkgs:\n                if git:\n                    package_name = package_name.replace(\"-\", \"_\")\n                    plugin_packages.append(\n                        f\"git+https://x:x@github.com/DHARPA-project/{package_name}@develop\"\n                    )\n                else:\n                    plugin_packages.append(package_name)\n    else:\n        plugin_packages = package_names  # type: ignore\n\n    in_jupyter = \"google.colab\" in sys.modules or \"jupyter_client\" in sys.modules\n\n    if not plugin_packages:\n        if in_jupyter:\n            return None\n        else:\n            # nothing to do\n            return False\n\n    class DummyContext(object):\n        def __getattribute__(self, item):\n            raise Exception(\n                \"Currently installing plugins, no other operations are allowed.\"\n            )\n\n    current_context_name = self._current_context_alias\n    for k in self._contexts.keys():\n        self._contexts[k] = DummyContext()  # type: ignore\n    self._current_context = DummyContext()  # type: ignore\n\n    cmd = [\"-q\", \"--isolated\", \"install\"]\n    if update:\n        cmd.append(\"--upgrade\")\n    cmd.extend(plugin_packages)\n\n    if in_jupyter:\n        from IPython import get_ipython\n\n        ipython = get_ipython()\n        cmd_str = f\"sc -l stdout = {sys.executable} -m pip {' '.join(cmd)}\"\n        ipython.magic(cmd_str)\n        exit_code = 100\n    else:\n        import pip._internal.cli.main as pip\n\n        log_message(\n            \"install.python_packages\", packages=plugin_packages, update=update\n        )\n        exit_code = pip.main(cmd)\n\n    self._contexts.clear()\n    self._current_context = None\n    self._current_context_alias = None\n\n    EnvironmentRegistry._instance = None\n    if current_context_name:\n        self.set_active_context(context_name=current_context_name)\n\n    if exit_code == 100:\n        raise SystemExit(\n            f\"Please manually re-run all cells. Updated or newly installed plugin packages: {', '.join(plugin_packages)}.\"\n        )\n    elif exit_code != 0:\n        raise Exception(\n            f\"Failed to install plugin packages: {', '.join(plugin_packages)}\"\n        )\n\n    return True\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_context_names","title":"<code>list_context_names() -&gt; List[str]</code>","text":"<p>list the names of all available/registered contexts.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_context_names(self) -&gt; List[str]:\n\"\"\"list the names of all available/registered contexts.\"\"\"\n\n    return list(self._kiara_config.available_context_names)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_context_infos","title":"<code>retrieve_context_infos() -&gt; ContextInfos</code>","text":"<p>Retrieve information about the available/registered contexts.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_context_infos(self) -&gt; ContextInfos:\n\"\"\"Retrieve information about the available/registered contexts.\"\"\"\n\n    return ContextInfos.create_context_infos(self._kiara_config.context_configs)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_current_context_name","title":"<code>get_current_context_name() -&gt; str</code>","text":"<p>Retrieve the name fo the current context.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_current_context_name(self) -&gt; str:\n\"\"\"Retrieve the name fo the current context.\"\"\"\n\n    if self._current_context_alias is None:\n        self.context\n    return self._current_context_alias  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.create_new_context","title":"<code>create_new_context(context_name: str, set_active: bool) -&gt; None</code>","text":"<p>Create a new context.</p> <p>Parameters:</p> Name Type Description Default <code>context_name</code> <code>str</code> <p>the name of the new context</p> required <code>set_active</code> <code>bool</code> <p>set the newly created context as the active one</p> required Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_new_context(self, context_name: str, set_active: bool) -&gt; None:\n\"\"\"Create a new context.\n\n    Arguments:\n        context_name: the name of the new context\n        set_active: set the newly created context as the active one\n    \"\"\"\n\n    if context_name in self.list_context_names():\n        raise Exception(\n            f\"Can't create context with name '{context_name}': context already exists.\"\n        )\n\n    ctx = self._kiara_config.create_context(context_name, extra_pipelines=None)\n    if set_active:\n        self._current_context = ctx\n        self._current_context_alias = context_name\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.set_active_context","title":"<code>set_active_context(context_name: str, create: bool = False) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def set_active_context(self, context_name: str, create: bool = False) -&gt; None:\n\n    if not context_name:\n        raise Exception(\"No context name provided.\")\n\n    if context_name == self._current_context_alias:\n        return\n    if context_name not in self.list_context_names():\n        if create:\n            self._current_context = self._kiara_config.create_context(\n                context=context_name, extra_pipelines=None\n            )\n            self._current_context_alias = context_name\n            return\n        else:\n            raise Exception(f\"No context with name '{context_name}' available.\")\n\n    self._current_context = self._kiara_config.create_context(\n        context=context_name, extra_pipelines=None\n    )\n    self._current_context_alias = context_name\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_data_type_names","title":"<code>list_data_type_names() -&gt; List[str]</code>","text":"<p>Get a list of all registered data types.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_data_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered data types.\"\"\"\n\n    return self.context.type_registry.data_type_names\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.is_internal_data_type","title":"<code>is_internal_data_type(data_type_name: str) -&gt; bool</code>","text":"<p>Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def is_internal_data_type(self, data_type_name: str) -&gt; bool:\n\"\"\"Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.\"\"\"\n\n    return self.context.type_registry.is_internal_type(\n        data_type_name=data_type_name\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_data_types_info","title":"<code>retrieve_data_types_info(filter: Union[str, Iterable[str], None]) -&gt; DataTypeClassesInfo</code>","text":"<p>Retrieve information about all data types.</p> <p>A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, Iterable[str], None]</code> <p>an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)</p> required <p>Returns:</p> Type Description <code>DataTypeClassesInfo</code> <p>an object containing all information about all data types</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_data_types_info(\n    self, filter: Union[str, Iterable[str], None]\n) -&gt; DataTypeClassesInfo:\n\"\"\"Retrieve information about all data types.\n\n    A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific\n    Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.\n\n    Arguments:\n        filter: an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)\n\n    Returns:\n        an object containing all information about all data types\n    \"\"\"\n\n    if filter:\n        if isinstance(filter, str):\n            filter = [filter]\n\n        title = f\"Filtered data_types: {filter}\"\n        data_type_names: Iterable[str] = []\n\n        for m in self.context.type_registry.data_type_names:\n            match = True\n\n            for f in filter:\n\n                if f.lower() not in m.lower():\n                    match = False\n                    break\n\n            if match:\n                data_type_names.append(m)  # type: ignore\n    else:\n        title = \"All data types\"\n        data_type_names = self.context.type_registry.data_type_names\n\n    data_types = {\n        d: self.context.type_registry.get_data_type_cls(d) for d in data_type_names\n    }\n    data_types_info = DataTypeClassesInfo.create_from_type_items(\n        kiara=self.context, group_title=title, **data_types\n    )\n\n    return data_types_info  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_data_type_info","title":"<code>retrieve_data_type_info(data_type_name: str) -&gt; DataTypeClassInfo</code>","text":"<p>Retrieve information about a specific data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <p>the registered name of the data type</p> required <p>Returns:</p> Type Description <code>DataTypeClassInfo</code> <p>an object containing all information about a data type</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_data_type_info(self, data_type_name: str) -&gt; DataTypeClassInfo:\n\"\"\"Retrieve information about a specific data type.\n\n    Arguments:\n        data_type: the registered name of the data type\n\n    Returns:\n        an object containing all information about a data type\n    \"\"\"\n\n    dt_cls = self.context.type_registry.get_data_type_cls(data_type_name)\n    info = DataTypeClassInfo.create_from_type_class(\n        kiara=self.context, type_cls=dt_cls\n    )\n    return info\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_module_type_names","title":"<code>list_module_type_names() -&gt; List[str]</code>","text":"<p>Get a list of all registered module types.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_module_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered module types.\"\"\"\n\n    return list(self.context.module_registry.get_module_type_names())\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_module_types_info","title":"<code>retrieve_module_types_info(filter: Union[None, str, Iterable[str]] = None) -&gt; ModuleTypesInfo</code>","text":"<p>Retrieve information for all available module types (or a filtered subset thereof).</p> <p>A module type is Python class that inherits from KiaraModule, and is the basic building block for processing pipelines. Module types are not used directly by users, Operations are. Operations  are instantiated modules (meaning: the module &amp; some (optional) configuration).</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[None, str, Iterable[str]]</code> <p>an optional string (or list of string) the returned module names have to match (all filters in case of list)</p> <code>None</code> <p>Returns:</p> Type Description <code>ModuleTypesInfo</code> <p>a mapping object containing module names as keys, and information about the modules as values</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_module_types_info(\n    self, filter: Union[None, str, Iterable[str]] = None\n) -&gt; ModuleTypesInfo:\n\"\"\"Retrieve information for all available module types (or a filtered subset thereof).\n\n    A module type is Python class that inherits from [KiaraModule][kiara.modules.KiaraModule], and is the basic\n    building block for processing pipelines. Module types are not used directly by users, Operations are. Operations\n     are instantiated modules (meaning: the module &amp; some (optional) configuration).\n\n    Arguments:\n        filter: an optional string (or list of string) the returned module names have to match (all filters in case of list)\n\n    Returns:\n        a mapping object containing module names as keys, and information about the modules as values\n    \"\"\"\n\n    if filter:\n\n        if isinstance(filter, str):\n            filter = [filter]\n        title = f\"Filtered modules: {filter}\"\n        module_types_names: Iterable[str] = []\n\n        for m in self.context.module_registry.get_module_type_names():\n            match = True\n\n            for f in filter:\n\n                if f.lower() not in m.lower():\n                    match = False\n                    break\n\n            if match:\n                module_types_names.append(m)  # type: ignore\n    else:\n        title = \"All modules\"\n        module_types_names = self.context.module_registry.get_module_type_names()\n\n    module_types = {\n        n: self.context.module_registry.get_module_class(n)\n        for n in module_types_names\n    }\n\n    module_types_info = ModuleTypesInfo.create_from_type_items(  # type: ignore\n        kiara=self.context, group_title=title, **module_types\n    )\n    return module_types_info  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_module_type_info","title":"<code>retrieve_module_type_info(module_type: str) -&gt; ModuleTypeInfo</code>","text":"<p>Retrieve information about a specific module type.</p> <p>This can be used to retrieve information like module documentation and configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the registered name of the module</p> required <p>Returns:</p> Type Description <code>ModuleTypeInfo</code> <p>an object containing all information about a module type</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_module_type_info(self, module_type: str) -&gt; ModuleTypeInfo:\n\"\"\"Retrieve information about a specific module type.\n\n    This can be used to retrieve information like module documentation and configuration options.\n\n    Arguments:\n        module_type: the registered name of the module\n\n    Returns:\n        an object containing all information about a module type\n    \"\"\"\n\n    m_cls = self.context.module_registry.get_module_class(module_type)\n    info = ModuleTypeInfo.create_from_type_class(kiara=self.context, type_cls=m_cls)\n    return info\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.create_operation","title":"<code>create_operation(module_type: str, module_config: Union[Mapping[str, Any], str, None] = None) -&gt; Operation</code>","text":"<p>Create an Operation instance for the specified module type and (optional) config.</p> <p>This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the registered name of the module</p> required <code>module_config</code> <code>Union[Mapping[str, Any], str, None]</code> <p>(Optional) configuration for the module instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>an Operation instance (which contains all the available information about an instantiated module)</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_operation(\n    self,\n    module_type: str,\n    module_config: Union[Mapping[str, Any], str, None] = None,\n) -&gt; Operation:\n\"\"\"Create an [Operation][kiara.models.module.operation.Operation] instance for the specified module type and (optional) config.\n\n    This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.\n\n    Arguments:\n        module_type: the registered name of the module\n        module_config: (Optional) configuration for the module instance.\n\n    Returns:\n        an Operation instance (which contains all the available information about an instantiated module)\n    \"\"\"\n\n    if module_config is None:\n        module_config = {}\n    elif isinstance(module_config, str):\n        try:\n            module_config = json.load(module_config)  # type: ignore\n        except Exception:\n            try:\n                module_config = yaml.load(module_config)  # type: ignore\n            except Exception:\n                raise Exception(\n                    f\"Can't parse module config string: {module_config}.\"\n                )\n\n    if module_type == \"pipeline\":\n        if not module_config:\n            raise Exception(\"Pipeline configuration can't be empty.\")\n        assert module_config is None or isinstance(module_config, Mapping)\n        operation = create_operation(\"pipeline\", operation_config=module_config)\n        return operation\n    else:\n        mc = Manifest(module_type=module_type, module_config=module_config)\n        module_obj = self.context.module_registry.create_module(mc)\n\n        return module_obj.operation\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_operation_ids","title":"<code>list_operation_ids(filter: Union[str, None, Iterable[str]] = None, include_internal: bool = False) -&gt; List[str]</code>","text":"<p>Get a list of all operation ids that match the specified filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, None, Iterable[str]]</code> <p>an optional single or list of filters (all filters must match the operation id for the operation to be included)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>also return internal operations</p> <code>False</code> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_operation_ids(\n    self,\n    filter: Union[str, None, Iterable[str]] = None,\n    include_internal: bool = False,\n) -&gt; List[str]:\n\"\"\"Get a list of all operation ids that match the specified filter.\n\n    Arguments:\n        filter: an optional single or list of filters (all filters must match the operation id for the operation to be included)\n        include_internal: also return internal operations\n    \"\"\"\n\n    if not filter and include_internal:\n        return sorted(self.context.operation_registry.operation_ids)\n\n    else:\n        return sorted(\n            self.list_operations(\n                filter=filter, include_internal=include_internal\n            ).keys()\n        )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_operation","title":"<code>get_operation(operation: Union[Mapping[str, Any], str, Path], allow_external: Union[bool, None] = None) -&gt; Operation</code>","text":"<p>Return the operation instance with the specified id.</p> <p>This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.</p> <p>The order in which the operation argument is resolved: - if it's a string, and an existing, registered operation_id, the associated operation is returned - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[Mapping[str, Any], str, Path]</code> <p>the operation id, module_type_name, path to a file, or url</p> required <code>allow_external</code> <code>Union[bool, None]</code> <p>if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>operation instance data</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_operation(\n    self,\n    operation: Union[Mapping[str, Any], str, Path],\n    allow_external: Union[bool, None] = None,\n) -&gt; Operation:\n\"\"\"Return the operation instance with the specified id.\n\n    This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.\n\n    The order in which the operation argument is resolved:\n    - if it's a string, and an existing, registered operation_id, the associated operation is returned\n    - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)\n\n    Arguments:\n        operation: the operation id, module_type_name, path to a file, or url\n        allow_external: if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.\n\n    Returns:\n        operation instance data\n    \"\"\"\n\n    _module_type = None\n    _module_config = None\n\n    if allow_external is None:\n        allow_external = self.get_runtime_config().allow_external\n\n    if isinstance(operation, Path):\n        operation = operation.as_posix()\n\n    if isinstance(operation, str):\n\n        if operation in self.list_operation_ids(include_internal=True):\n            _operation = self.context.operation_registry.get_operation(operation)\n            return _operation\n\n        if not allow_external:\n            raise NoSuchExecutionTargetException(\n                selected_target=operation,\n                available_targets=self.context.operation_registry.operation_ids,\n                msg=f\"Can't find operation with id '{operation}', and external operations are not allowed.\",\n            )\n\n        if os.path.isfile(operation):\n            try:\n                # we use the 'from_file' here, because that will resolve any relative paths in the pipeline\n                # if this doesn't work, we just assume the file is not a pipeline configuration but\n                # a manifest file with 'module_type' and optional 'module_config' keys\n                pipeline_conf = PipelineConfig.from_file(\n                    path=operation, kiara=self.context\n                )\n                _module_config = pipeline_conf.dict()\n            except Exception as e:\n                log_exception(e)\n                _module_config = get_data_from_file(operation)\n        elif operation.startswith(\"http\"):\n            _module_config = get_data_from_url(operation)\n        else:\n            try:\n                _module_config = json.load(operation)  # type: ignore\n            except Exception:\n                try:\n                    _module_config = yaml.load(operation)  # type: ignore\n                except Exception:\n                    raise Exception(\n                        f\"Can't parse configuration string: {operation}.\"\n                    )\n    else:\n        _module_config = dict(operation)\n\n    if \"module_type\" in _module_config.keys():\n        _module_type = _module_config[\"module_type\"]\n        _module_config = _module_config.get(\"module_config\", {})\n    else:\n        _module_type = \"pipeline\"\n\n    op = self.create_operation(\n        module_type=_module_type, module_config=_module_config\n    )\n    return op\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_operations","title":"<code>list_operations(filter: Union[str, None, Iterable[str]] = None, input_types: Union[str, Iterable[str], None] = None, output_types: Union[str, Iterable[str], None] = None, operation_types: Union[str, Iterable[str], None] = None, python_packages: Union[str, Iterable[str], None] = None, include_internal: bool = False) -&gt; Mapping[str, Operation]</code>","text":"<p>List all available values, optionally filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, None, Iterable[str]]</code> <p>the (optional) filter string(s), an operation must match all of them to be included in the result</p> <code>None</code> <code>input_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one input that matches one of the specified types</p> <code>None</code> <code>output_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one output that matches one of the specified types</p> <code>None</code> <code>operation_types</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations of the specified type(s)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>python_packages</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations that are contained in one of the provided python packages</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_operations(\n    self,\n    filter: Union[str, None, Iterable[str]] = None,\n    input_types: Union[str, Iterable[str], None] = None,\n    output_types: Union[str, Iterable[str], None] = None,\n    operation_types: Union[str, Iterable[str], None] = None,\n    python_packages: Union[str, Iterable[str], None] = None,\n    include_internal: bool = False,\n) -&gt; Mapping[str, Operation]:\n\"\"\"List all available values, optionally filter.\n\n    Arguments:\n        filter: the (optional) filter string(s), an operation must match all of them to be included in the result\n        input_types: each operation must have at least one input that matches one of the specified types\n        output_types: each operation must have at least one output that matches one of the specified types\n        operation_types: only include operations of the specified type(s)\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        python_packages: only include operations that are contained in one of the provided python packages\n    Returns:\n        a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value\n    \"\"\"\n\n    if operation_types:\n        if isinstance(operation_types, str):\n            operation_types = [operation_types]\n        temp: Dict[str, Operation] = {}\n        for op_type_name in operation_types:\n            op_type = self.context.operation_registry.operation_types.get(\n                op_type_name, None\n            )\n            if op_type is None:\n                raise Exception(f\"Operation type not registered: {op_type_name}\")\n\n            temp.update(op_type.operations)\n        operations: Mapping[str, Operation] = temp\n    else:\n        operations = self.context.operation_registry.operations\n\n    if filter:\n        if isinstance(filter, str):\n            filter = [filter]\n        temp = {}\n        for op_id, op in operations.items():\n            match = True\n            for f in filter:\n                if not f:\n                    continue\n                if f.lower() not in op_id.lower():\n                    match = False\n                    break\n            if match:\n                temp[op_id] = op\n        operations = temp\n\n    if not include_internal:\n        temp = {}\n        for op_id, op in operations.items():\n            if not op.operation_details.is_internal_operation:\n                temp[op_id] = op\n\n        operations = temp\n\n    if input_types:\n        if isinstance(input_types, str):\n            input_types = [input_types]\n        temp = {}\n        for op_id, op in operations.items():\n            for input_type in input_types:\n                match = False\n                for schema in op.inputs_schema.values():\n                    if schema.type == input_type:\n                        temp[op_id] = op\n                        match = True\n                        break\n                if match:\n                    break\n\n        operations = temp\n\n    if output_types:\n        if isinstance(output_types, str):\n            output_types = [output_types]\n        temp = {}\n        for op_id, op in operations.items():\n            for output_type in output_types:\n                match = False\n                for schema in op.outputs_schema.values():\n                    if schema.type == output_type:\n                        temp[op_id] = op\n                        match = True\n                        break\n                if match:\n                    break\n\n        operations = temp\n\n    if python_packages:\n        temp = {}\n        if isinstance(python_packages, str):\n            python_packages = [python_packages]\n        for op_id, op in operations.items():\n            info = OperationInfo.create_from_instance(\n                kiara=self.context, instance=op\n            )\n            pkg = info.context.labels.get(\"package\", None)\n            if pkg in python_packages:\n                temp[pkg] = op\n        operations = temp\n\n    return operations\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_operation_info","title":"<code>retrieve_operation_info(operation: str, allow_external: bool = False) -&gt; OperationInfo</code>","text":"<p>Return the full information for the specified operation id.</p> <p>This is similar to the 'get_operation' method, but returns additional information. Only use this instead of 'get_operation' if you need the additional info, as it's more expensive to get.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>the operation id</p> required <p>Returns:</p> Type Description <code>OperationInfo</code> <p>augmented operation instance data</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operation_info(\n    self, operation: str, allow_external: bool = False\n) -&gt; OperationInfo:\n\"\"\"Return the full information for the specified operation id.\n\n    This is similar to the 'get_operation' method, but returns additional information. Only use this instead of\n    'get_operation' if you need the additional info, as it's more expensive to get.\n\n    Arguments:\n        operation: the operation id\n\n    Returns:\n        augmented operation instance data\n    \"\"\"\n\n    if not allow_external:\n        op = self.context.operation_registry.get_operation(operation_id=operation)\n    else:\n        op = create_operation(module_or_operation=operation)\n    op_info = OperationInfo.create_from_operation(kiara=self.context, operation=op)\n    return op_info\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_operations_info","title":"<code>retrieve_operations_info(*filters, input_types: Union[str, Iterable[str], None] = None, output_types: Union[str, Iterable[str], None] = None, operation_types: Union[str, Iterable[str], None] = None, python_packages: Union[str, Iterable[str], None] = None, include_internal: bool = False) -&gt; OperationGroupInfo</code>","text":"<p>Retrieve information about the matching operations.</p> <p>This retrieves the same list of operations as list_operations, but augments each result instance with additional information that might be useful in frontends.</p> <p>'OperationInfo' objects contains augmented information on top of what 'normal' Operation objects hold, but they can take longer to create/resolve. If you don't need any of the augmented information, just use the list_operations method instead.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <p>the (optional) filter strings, an operation must match all of them to be included in the result</p> <code>()</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>output_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one output that matches one of the specified types</p> <code>None</code> <code>operation_types</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations of the specified type(s)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>python_packages</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations that are contained in one of the provided python packages</p> <code>None</code> <p>Returns:</p> Type Description <code>OperationGroupInfo</code> <p>a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operations_info(\n    self,\n    *filters,\n    input_types: Union[str, Iterable[str], None] = None,\n    output_types: Union[str, Iterable[str], None] = None,\n    operation_types: Union[str, Iterable[str], None] = None,\n    python_packages: Union[str, Iterable[str], None] = None,\n    include_internal: bool = False,\n) -&gt; OperationGroupInfo:\n\"\"\"Retrieve information about the matching operations.\n\n    This retrieves the same list of operations as [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations],\n    but augments each result instance with additional information that might be useful in frontends.\n\n    'OperationInfo' objects contains augmented information on top of what 'normal' [Operation][kiara.models.module.operation.Operation] objects\n    hold, but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations] method\n    instead.\n\n    Arguments:\n        filters: the (optional) filter strings, an operation must match all of them to be included in the result\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        output_types: each operation must have at least one output that matches one of the specified types\n        operation_types: only include operations of the specified type(s)\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        python_packages: only include operations that are contained in one of the provided python packages\n    Returns:\n        a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value\n    \"\"\"\n\n    title = \"Available operations\"\n    if filters:\n        title = \"Filtered operations\"\n\n    operations = self.list_operations(\n        filters,\n        input_types=input_types,\n        output_types=output_types,\n        include_internal=include_internal,\n        operation_types=operation_types,\n        python_packages=python_packages,\n    )\n\n    ops_info = OperationGroupInfo.create_from_operations(\n        kiara=self.context, group_title=title, **operations\n    )\n    return ops_info\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.register_pipeline","title":"<code>register_pipeline(data: Union[Path, str, Mapping[str, Any]], operation_id: Union[str, None] = None) -&gt; Operation</code>","text":"<p>Register a pipelne as new operation into this context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Path, str, Mapping[str, Any]]</code> <p>a dict or a path to a json/yaml file containing the definition</p> required <code>operation_id</code> <code>Union[str, None]</code> <p>the id to use for the operation (if not specified, the id will be auto-determined)</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>the assembled operation</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_pipeline(\n    self,\n    data: Union[Path, str, Mapping[str, Any]],\n    operation_id: Union[str, None] = None,\n) -&gt; Operation:\n\"\"\"Register a pipelne as new operation into this context.\n\n    Arguments:\n        data: a dict or a path to a json/yaml file containing the definition\n        operation_id: the id to use for the operation (if not specified, the id will be auto-determined)\n\n    Returns:\n        the assembled operation\n    \"\"\"\n\n    return self.context.operation_registry.register_pipeline(\n        data=data, operation_id=operation_id\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.register_pipelines","title":"<code>register_pipelines(*pipeline_paths: Union[str, Path]) -&gt; Dict[str, Operation]</code>","text":"<p>Register all pipelines found in the specified paths.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_pipelines(\n    self, *pipeline_paths: Union[str, Path]\n) -&gt; Dict[str, Operation]:\n\"\"\"Register all pipelines found in the specified paths.\"\"\"\n\n    return self.context.operation_registry.register_pipelines(*pipeline_paths)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.register_data","title":"<code>register_data(data: Any, data_type: Union[None, str] = None, reuse_existing: bool = False) -&gt; Value</code>","text":"<p>Register data with kiara.</p> <p>This will create a new value instance from the data and return it. The data/value itself won't be stored in a store, you have to use the 'store_value' function for that.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>the data to register</p> required <code>data_type</code> <code>Union[None, str]</code> <p>(optional) the data type of the data. If not provided, kiara will try to infer the data type.</p> <code>None</code> <code>reuse_existing</code> <code>bool</code> <p>whether to re-use an existing value that is already registered and has the same hash.</p> <code>False</code> <p>Returns:</p> Type Description <code>Value</code> <p>a [kiara.models.values.value.Value] instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_data(\n    self,\n    data: Any,\n    data_type: Union[None, str] = None,\n    reuse_existing: bool = False,\n) -&gt; Value:\n\"\"\"Register data with kiara.\n\n    This will create a new value instance from the data and return it. The data/value itself won't be stored\n    in a store, you have to use the 'store_value' function for that.\n\n    Arguments:\n        data: the data to register\n        data_type: (optional) the data type of the data. If not provided, kiara will try to infer the data type.\n        reuse_existing: whether to re-use an existing value that is already registered and has the same hash.\n\n    Returns:\n        a [kiara.models.values.value.Value] instance\n    \"\"\"\n\n    if data_type is None:\n        raise NotImplementedError(\n            \"Infering data types not implemented yet. Please provide one manually.\"\n        )\n\n    value = self.context.data_registry.register_data(\n        data=data, schema=data_type, reuse_existing=reuse_existing\n    )\n    return value\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_value_ids","title":"<code>list_value_ids(**matcher_params) -&gt; List[uuid.UUID]</code>","text":"<p>List all available value ids for this kiara context.</p> <p>This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without having to look up the details of each value (like list_values does). This method can also be used with a matcher, but in this case the list_values would be preferable in most cases, because it is called under the hood, and the performance advantage of not having to look up value details is gone.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[uuid.UUID]</code> <p>a list of value ids</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_value_ids(self, **matcher_params) -&gt; List[uuid.UUID]:\n\"\"\"List all available value ids for this kiara context.\n\n    This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n    having to look up the details of each value (like [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n    does). This method can also be used with a matcher, but in this case the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n    would be preferable in most cases, because it is called under the hood, and the performance advantage of not\n    having to look up value details is gone.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a list of value ids\n    \"\"\"\n\n    if matcher_params:\n        values = self.list_values(**matcher_params)\n        return sorted(values.keys())\n    else:\n        _values = self.context.data_registry.retrieve_all_available_value_ids()\n        return sorted(_values)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_values","title":"<code>list_values(**matcher_params: Any) -&gt; Dict[uuid.UUID, Value]</code>","text":"<p>List all available values, optionally filter.</p> <p>Retrieve information about all values that are available in the current kiara context session (both stored and non-stored).</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <code>Any</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[uuid.UUID, Value]</code> <p>a dictionary with value_id as key, and [kiara.models.values.value.Value] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_values(self, **matcher_params: Any) -&gt; Dict[uuid.UUID, Value]:\n\"\"\"List all available values, optionally filter.\n\n    Retrieve information about all values that are available in the current kiara context session (both stored\n    and non-stored).\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n    \"\"\"\n\n    if matcher_params:\n        matcher = ValueMatcher.create_matcher(**matcher_params)\n\n        values = self.context.data_registry.find_values(matcher=matcher)\n    else:\n        # TODO: make that parallel?\n        values = {\n            k: self.context.data_registry.get_value(k)\n            for k in self.context.data_registry.retrieve_all_available_value_ids()\n        }\n\n    return values\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_value","title":"<code>get_value(value: Union[str, Value, uuid.UUID]) -&gt; Value</code>","text":"<p>Retrieve a value instance with the specified id or alias.</p> <p>Raises an exception if no value could be found.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, Value, uuid.UUID]</code> <p>a value id, alias or object that has a 'value_id' attribute.</p> required <p>Returns:</p> Type Description <code>Value</code> <p>the Value instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_value(self, value: Union[str, Value, uuid.UUID]) -&gt; Value:\n\"\"\"Retrieve a value instance with the specified id or alias.\n\n    Raises an exception if no value could be found.\n\n    Arguments:\n        value: a value id, alias or object that has a 'value_id' attribute.\n\n    Returns:\n        the Value instance\n    \"\"\"\n\n    return self.context.data_registry.get_value(value=value)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_value_info","title":"<code>retrieve_value_info(value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo</code>","text":"<p>Retrieve an info object for a value.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the get_value method instead.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>a value id, alias or object that has a 'value_id' attribute.</p> required <p>Returns:</p> Type Description <code>ValueInfo</code> <p>the ValueInfo instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_value_info(self, value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo:\n\"\"\"Retrieve an info object for a value.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.get_value] method\n    instead.\n\n    Arguments:\n        value: a value id, alias or object that has a 'value_id' attribute.\n\n    Returns:\n        the ValueInfo instance\n\n    \"\"\"\n\n    _value = self.get_value(value=value)\n    return ValueInfo.create_from_instance(kiara=self.context, instance=_value)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_values_info","title":"<code>retrieve_values_info(**matcher_params) -&gt; ValuesInfo</code>","text":"<p>Retrieve information about the matching values.</p> <p>This retrieves the same list of values as list_values, but augments each result value instance with additional information that might be useful in frontends.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the list_values method instead.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValuesInfo</code> <p>a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_values_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n    This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n    but augments each result value instance with additional information that might be useful in frontends.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values] method\n    instead.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n    \"\"\"\n\n    values = self.list_values(**matcher_params)\n\n    infos = ValuesInfo.create_from_instances(\n        kiara=self.context, instances={str(k): v for k, v in values.items()}\n    )\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_alias_names","title":"<code>list_alias_names(**matcher_params) -&gt; List[str]</code>","text":"<p>List all available alias keys.</p> <p>This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without having to look up the details of each value (like list_aliases does). This method can also be used with a matcher, but in this case the list_aliases would be preferrable in most cases, because it is called under the hood, and the performance advantage of not having to look up value details is gone.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of value ids</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_alias_names(self, **matcher_params) -&gt; List[str]:\n\"\"\"List all available alias keys.\n\n    This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n    having to look up the details of each value (like [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n    does). This method can also be used with a matcher, but in this case the [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n    would be preferrable in most cases, because it is called under the hood, and the performance advantage of not\n    having to look up value details is gone.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a list of value ids\n    \"\"\"\n\n    if matcher_params:\n        values = self.list_aliases(**matcher_params)\n        return list(values.keys())\n    else:\n        _values = self.context.alias_registry.all_aliases\n        return list(_values)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_aliases","title":"<code>list_aliases(**matcher_params) -&gt; Dict[str, Value]</code>","text":"<p>List all available values that have an alias assigned, optionally filter.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Value]</code> <p>a dictionary with value_id as key, and [kiara.models.values.value.Value] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_aliases(self, **matcher_params) -&gt; Dict[str, Value]:\n\"\"\"List all available values that have an alias assigned, optionally filter.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n    \"\"\"\n\n    if matcher_params:\n        matcher_params[\"has_alias\"] = True\n        all_values = self.list_values(**matcher_params)\n        result: Dict[str, Value] = {}\n        for value in all_values.values():\n            aliases = self.context.alias_registry.find_aliases_for_value_id(\n                value_id=value.value_id\n            )\n            for a in aliases:\n                if a in result.keys():\n                    raise Exception(\n                        f\"Duplicate value alias '{a}': this is most likely a bug.\"\n                    )\n                result[a] = value\n\n        result = {k: result[k] for k in sorted(result.keys())}\n    else:\n        # faster if not other matcher params\n        all_aliases = self.context.alias_registry.all_aliases\n        result = {\n            k: self.context.data_registry.get_value(f\"alias:{k}\")\n            for k in all_aliases\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_aliases_info","title":"<code>retrieve_aliases_info(**matcher_params) -&gt; ValuesInfo</code>","text":"<p>Retrieve information about the matching values.</p> <p>This retrieves the same list of values as list_values, but augments each result value instance with additional information that might be useful in frontends.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the get_value method instead.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValuesInfo</code> <p>a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_aliases_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n    This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n    but augments each result value instance with additional information that might be useful in frontends.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.list_aliases] method\n    instead.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n    \"\"\"\n\n    values = self.list_aliases(**matcher_params)\n\n    infos = ValuesInfo.create_from_instances(\n        kiara=self.context, instances={str(k): v for k, v in values.items()}\n    )\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.assemble_value_map","title":"<code>assemble_value_map(values: Mapping[str, Union[uuid.UUID, None, str, Value]], values_schema: Union[None, Mapping[str, ValueSchema]] = None, register_data: bool = False, reuse_existing_data: bool = False) -&gt; ValueMap</code>","text":"<p>Retrive a ValueMap object from the provided value ids or value links.</p> <p>By default, this method can only use values/datasets that are already registered in kiara. If you want to auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Mapping[str, Union[uuid.UUID, None, str, Value]]</code> <p>a dictionary with the values in question</p> required <code>values_schema</code> <code>Union[None, Mapping[str, ValueSchema]]</code> <p>an optional dictionary with the schema for each of the values that are not yet registered</p> <code>None</code> <code>register_data</code> <code>bool</code> <p>whether to allow auto-registration of 'raw' data</p> <code>False</code> <code>reuse_existing_data</code> <code>bool</code> <p>whether to reuse existing data with the same hash as the 'raw' data that is being registered</p> <code>False</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>a value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_value_map(\n    self,\n    values: Mapping[str, Union[uuid.UUID, None, str, Value]],\n    values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n    register_data: bool = False,\n    reuse_existing_data: bool = False,\n) -&gt; ValueMap:\n\"\"\"Retrive a [ValueMap][TODO] object from the provided value ids or value links.\n\n    By default, this method can only use values/datasets that are already registered in *kiara*. If you want to\n    auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.\n\n    Arguments:\n        values: a dictionary with the values in question\n        values_schema: an optional dictionary with the schema for each of the values that are not yet registered\n        register_data: whether to allow auto-registration of 'raw' data\n        reuse_existing_data: whether to reuse existing data with the same hash as the 'raw' data that is being registered\n\n    Returns:\n        a value map instance\n    \"\"\"\n\n    if register_data:\n        temp: Dict[str, Union[str, Value, uuid.UUID, None]] = {}\n        for k, v in values.items():\n\n            if isinstance(v, (Value, uuid.UUID)):\n                temp[k] = v\n                continue\n\n            if isinstance(v, str):\n                try:\n                    v = uuid.UUID(v)\n                    temp[k] = v\n                    continue\n                except Exception:\n                    if v.startswith(\"alias:\"):  # type: ignore\n                        _v = v.replace(\"alias:\", \"\")  # type: ignore\n                    else:\n                        _v = v\n                    if _v in self.list_aliases():\n                        temp[k] = f\"alias:{_v}\"\n                        continue\n\n            if not values_schema:\n                raise Exception(\n                    f\"Can't assemble value map field without schema: '{k}' -- {str(v)}\"\n                )\n\n            if k not in values_schema.keys():\n                raise Exception(\n                    f\"Can't assemble value map field without schema key: '{k}' -- {str(v)}\"\n                )\n\n            if v is None:\n                temp[k] = None\n            else:\n                _v = self.register_data(\n                    data=v,\n                    data_type=values_schema[k].type,\n                    reuse_existing=reuse_existing_data,\n                )\n                temp[k] = _v\n        values = temp\n\n    return self.context.data_registry.load_values(\n        values=values, values_schema=values_schema\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.store_value","title":"<code>store_value(value: Union[str, uuid.UUID, Value], alias: Union[str, Iterable[str], None], allow_overwrite: bool = True) -&gt; StoreValueResult</code>","text":"<p>Store the specified value in the (default) value store.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>the value (or a reference to it)</p> required <code>alias</code> <code>Union[str, Iterable[str], None]</code> <p>(Optional) aliases for the value</p> required <code>allow_overwrite</code> <code>bool</code> <p>whether to allow overwriting existing aliases</p> <code>True</code> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def store_value(\n    self,\n    value: Union[str, uuid.UUID, Value],\n    alias: Union[str, Iterable[str], None],\n    allow_overwrite: bool = True,\n) -&gt; StoreValueResult:\n\"\"\"Store the specified value in the (default) value store.\n\n    Arguments:\n        value: the value (or a reference to it)\n        alias: (Optional) aliases for the value\n        allow_overwrite: whether to allow overwriting existing aliases\n    \"\"\"\n\n    if isinstance(alias, str):\n        alias = [alias]\n\n    value_obj = self.get_value(value)\n    persisted_data: Union[None, PersistedData] = None\n    try:\n        persisted_data = self.context.data_registry.store_value(value=value_obj)\n        if alias:\n            self.context.alias_registry.register_aliases(\n                value_obj.value_id, *alias, allow_overwrite=allow_overwrite\n            )\n        result = StoreValueResult.construct(\n            value=value_obj,\n            aliases=sorted(alias) if alias else [],\n            error=None,\n            persisted_data=persisted_data,\n        )\n    except Exception as e:\n        log_exception(e)\n        result = StoreValueResult.construct(\n            value=value_obj,\n            aliases=sorted(alias) if alias else [],\n            error=str(e),\n            persisted_data=persisted_data,\n        )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.store_values","title":"<code>store_values(values: Mapping[str, Union[str, uuid.UUID, Value]], alias_map: Mapping[str, Iterable[str]]) -&gt; StoreValuesResult</code>","text":"<p>Store multiple values into the (default) kiara value store.</p> <p>Values are identified by unique keys in both input arguments, the alias map references the key that is used in the 'values' argument.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Mapping[str, Union[str, uuid.UUID, Value]]</code> <p>a map of value keys/values</p> required <code>alias_map</code> <code>Mapping[str, Iterable[str]]</code> <p>a map of value keys aliases</p> required <p>Returns:</p> Type Description <code>StoreValuesResult</code> <p>an object outlining which values (identified by the specified value key) where stored and how</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def store_values(\n    self,\n    values: Mapping[str, Union[str, uuid.UUID, Value]],\n    alias_map: Mapping[str, Iterable[str]],\n) -&gt; StoreValuesResult:\n\"\"\"Store multiple values into the (default) kiara value store.\n\n    Values are identified by unique keys in both input arguments, the alias map references the key that is used in\n    the 'values' argument.\n\n    Arguments:\n        values: a map of value keys/values\n        alias_map: a map of value keys aliases\n\n    Returns:\n        an object outlining which values (identified by the specified value key) where stored and how\n    \"\"\"\n\n    result = {}\n    for field_name, value in values.items():\n        aliases = alias_map.get(field_name)\n        value_obj = self.get_value(value)\n        store_result = self.store_value(value=value_obj, alias=aliases)\n        result[field_name] = store_result\n\n    return StoreValuesResult.construct(__root__=result)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_operation_type","title":"<code>get_operation_type(op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType</code>","text":"<p>Get the management object for the specified operation type.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType:\n\"\"\"Get the management object for the specified operation type.\"\"\"\n\n    return self.context.operation_registry.get_operation_type(op_type=op_type)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_operation_type_info","title":"<code>retrieve_operation_type_info(op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationTypeInfo</code>","text":"<p>Get an info object for the specified operation type.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operation_type_info(\n    self, op_type: Union[str, Type[OP_TYPE]]\n) -&gt; OperationTypeInfo:\n\"\"\"Get an info object for the specified operation type.\"\"\"\n\n    _op_type = self.get_operation_type(op_type=op_type)\n    return OperationTypeInfo.create_from_type_class(\n        kiara=self.context, type_cls=_op_type.__class__\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.find_operation_id","title":"<code>find_operation_id(module_type: str, module_config: Union[None, Mapping[str, Any]] = None) -&gt; Union[None, str]</code>","text":"<p>Try to find the registered operation id for the specified module type and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the module type</p> required <code>module_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the module configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>the registered operation id, if found, or None</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def find_operation_id(\n    self, module_type: str, module_config: Union[None, Mapping[str, Any]] = None\n) -&gt; Union[None, str]:\n\"\"\"Try to find the registered operation id for the specified module type and configuration.\n\n    Arguments:\n        module_type: the module type\n        module_config: the module configuration\n\n    Returns:\n        the registered operation id, if found, or None\n    \"\"\"\n\n    manifest = self.context.create_manifest(\n        module_or_operation=module_type, config=module_config\n    )\n    return self.context.operation_registry.find_operation_id(manifest=manifest)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.assemble_filter_pipeline_config","title":"<code>assemble_filter_pipeline_config(data_type: str, filters: Union[str, Iterable[str], Mapping[str, str]], endpoint: Union[None, Manifest, str] = None, endpoint_input_field: Union[str, None] = None, endpoint_step_id: Union[str, None] = None, extra_input_aliases: Union[None, Mapping[str, str]] = None, extra_output_aliases: Union[None, Mapping[str, str]] = None) -&gt; PipelineConfig</code>","text":"<p>Assemble a (pipeline) module config to filter values of a specific data type.</p> <p>Optionally, a module that uses the filtered dataset as input can be specified.</p>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.assemble_filter_pipeline_config--todo-document-filter-names","title":"TODO: document filter names","text":"<p>For the 'filters' argument, the accepted inputs are: - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically - a map of string pairs: the keys are step ids, the values operation ids or filter names</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>the type of the data to filter</p> required <code>filters</code> <code>Union[str, Iterable[str], Mapping[str, str]]</code> <p>a list of operation ids or filter names (and potentiall step_ids if type is a mapping)</p> required <code>endpoint</code> <code>Union[None, Manifest, str]</code> <p>optional module to put as last step in the created pipeline</p> <code>None</code> <code>endpoing_input_field</code> <p>field name of the input that will receive the filtered value</p> required <code>endpoint_step_id</code> <code>Union[str, None]</code> <p>id to use for the endpoint step (module type name will be used if not provided)</p> <code>None</code> <code>extra_input_aliases</code> <code>Union[None, Mapping[str, str]]</code> <p>extra output aliases to add to the pipeline config</p> <code>None</code> <code>extra_output_aliases</code> <code>Union[None, Mapping[str, str]]</code> <p>extra output aliases to add to the pipeline config</p> <code>None</code> <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>the (pipeline) module configuration of the filter pipeline</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_filter_pipeline_config(\n    self,\n    data_type: str,\n    filters: Union[str, Iterable[str], Mapping[str, str]],\n    endpoint: Union[None, Manifest, str] = None,\n    endpoint_input_field: Union[str, None] = None,\n    endpoint_step_id: Union[str, None] = None,\n    extra_input_aliases: Union[None, Mapping[str, str]] = None,\n    extra_output_aliases: Union[None, Mapping[str, str]] = None,\n) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n    Optionally, a module that uses the filtered dataset as input can be specified.\n\n    # TODO: document filter names\n    For the 'filters' argument, the accepted inputs are:\n    - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n    - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n    - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n    Arguments:\n        data_type: the type of the data to filter\n        filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n        endpoint: optional module to put as last step in the created pipeline\n        endpoing_input_field: field name of the input that will receive the filtered value\n        endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n        extra_input_aliases: extra output aliases to add to the pipeline config\n        extra_output_aliases: extra output aliases to add to the pipeline config\n\n    Returns:\n        the (pipeline) module configuration of the filter pipeline\n    \"\"\"\n\n    filter_op_type: FilterOperationType = self.context.operation_registry.get_operation_type(\"filter\")  # type: ignore\n    pipeline_config = filter_op_type.assemble_filter_pipeline_config(\n        data_type=data_type,\n        filters=filters,\n        endpoint=endpoint,\n        endpoint_input_field=endpoint_input_field,\n        endpoint_step_id=endpoint_step_id,\n        extra_input_aliases=extra_input_aliases,\n        extra_output_aliases=extra_output_aliases,\n    )\n\n    return pipeline_config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_renderer_infos","title":"<code>retrieve_renderer_infos(source_type: Union[str, None] = None) -&gt; RendererInfos</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_renderer_infos(\n    self, source_type: Union[str, None] = None\n) -&gt; RendererInfos:\n\n    if not source_type:\n        renderers = self.context.render_registry.registered_renderers\n    else:\n        renderers = self.context.render_registry.retrieve_renderers_for_source_type(\n            source_type=source_type\n        )\n\n    group = {k.get_renderer_alias(): k for k in renderers}\n    infos = RendererInfos.create_from_instances(kiara=self.context, instances=group)\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_renderers_for","title":"<code>retrieve_renderers_for(source_type: str) -&gt; List[KiaraRenderer]</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_renderers_for(self, source_type: str) -&gt; List[KiaraRenderer]:\n\n    return self.context.render_registry.retrieve_renderers_for_source_type(\n        source_type=source_type\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.render","title":"<code>render(item: Any, source_type: str, target_type: str, render_config: Union[Mapping[str, Any], None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def render(\n    self,\n    item: Any,\n    source_type: str,\n    target_type: str,\n    render_config: Union[Mapping[str, Any], None] = None,\n) -&gt; Any:\n\n    registry = self.context.render_registry\n    result = registry.render(\n        item=item,\n        source_type=source_type,\n        target_type=target_type,\n        render_config=render_config,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.assemble_render_pipeline","title":"<code>assemble_render_pipeline(data_type: str, target_format: Union[str, Iterable[str]] = 'string', filters: Union[None, str, Iterable[str], Mapping[str, str]] = None, use_pretty_print: bool = False) -&gt; Operation</code>","text":"<p>Create a manifest describing a transformation that renders a value of the specified data type in the target format.</p> <p>If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches the value type of the source value, and the provided target format.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>the value (or value id)</p> required <code>target_format</code> <code>Union[str, Iterable[str]]</code> <p>the format into which to render the value</p> <code>'string'</code> <code>filters</code> <code>Union[None, str, Iterable[str], Mapping[str, str]]</code> <p>a list of filters to apply to the value before rendering it</p> <code>None</code> <code>use_pretty_print</code> <code>bool</code> <p>if True, use a 'pretty_print' operation instead of 'render_value'</p> <code>False</code> <p>Returns:</p> Type Description <code>Operation</code> <p>the manifest for the transformation</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_render_pipeline(\n    self,\n    data_type: str,\n    target_format: Union[str, Iterable[str]] = \"string\",\n    filters: Union[None, str, Iterable[str], Mapping[str, str]] = None,\n    use_pretty_print: bool = False,\n) -&gt; Operation:\n\"\"\"Create a manifest describing a transformation that renders a value of the specified data type in the target format.\n\n    If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n    the value type of the source value, and the provided target format.\n\n    Arguments:\n        value: the value (or value id)\n        target_format: the format into which to render the value\n        filters: a list of filters to apply to the value before rendering it\n        use_pretty_print: if True, use a 'pretty_print' operation instead of 'render_value'\n\n    Returns:\n        the manifest for the transformation\n    \"\"\"\n\n    if data_type not in self.context.data_type_names:\n        raise DataTypeUnknownException(data_type=data_type)\n\n    if use_pretty_print:\n        pretty_print_op_type: PrettyPrintOperationType = (\n            self.context.operation_registry.get_operation_type(\"pretty_print\")\n        )  # type: ignore\n        ops = pretty_print_op_type.get_target_types_for(data_type)\n    else:\n        render_op_type: RenderValueOperationType = self.context.operation_registry.get_operation_type(\n            # type: ignore\n            \"render_value\"\n        )  # type: ignore\n        ops = render_op_type.get_render_operations_for_source_type(data_type)\n\n    if isinstance(target_format, str):\n        target_format = [target_format]\n\n    match = None\n    for _target_type in target_format:\n        if _target_type not in ops.keys():\n            continue\n        match = ops[_target_type]\n        break\n\n    if not match:\n        if not ops:\n            msg = f\"No render operations registered for source type '{data_type}'.\"\n        else:\n            msg = f\"Registered target types for source type '{data_type}': {', '.join(ops.keys())}.\"\n        raise Exception(\n            f\"No render operation for source type '{data_type}' to target type(s) registered: '{', '.join(target_format)}'. {msg}\"\n        )\n\n    if filters:\n        # filter_op_type: FilterOperationType = self._kiara.operation_registry.get_operation_type(\"filter\")  # type: ignore\n        endpoint = Manifest(\n            module_type=match.module_type, module_config=match.module_config\n        )\n        extra_input_aliases = {\"render_value.render_config\": \"render_config\"}\n        extra_output_aliases = {\n            \"render_value.render_value_result\": \"render_value_result\"\n        }\n        pipeline_config = self.assemble_filter_pipeline_config(\n            data_type=data_type,\n            filters=filters,\n            endpoint=endpoint,\n            endpoint_input_field=\"value\",\n            endpoint_step_id=\"render_value\",\n            extra_input_aliases=extra_input_aliases,\n            extra_output_aliases=extra_output_aliases,\n        )\n        manifest = Manifest(\n            module_type=\"pipeline\", module_config=pipeline_config.dict()\n        )\n        module = self.context.module_registry.create_module(manifest=manifest)\n        operation = Operation.create_from_module(module, doc=pipeline_config.doc)\n    else:\n        operation = match\n\n    return operation\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.queue_manifest","title":"<code>queue_manifest(manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None) -&gt; uuid.UUID</code>","text":"<p>Queue a job using the provided manifest to describe the module and config that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the manifest</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the job inputs (can be either references to values, or raw inputs</p> <code>None</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>a result value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def queue_manifest(\n    self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n) -&gt; uuid.UUID:\n\"\"\"Queue a job using the provided manifest to describe the module and config that should be executed.\n\n    Arguments:\n        manifest: the manifest\n        inputs: the job inputs (can be either references to values, or raw inputs\n\n    Returns:\n        a result value map instance\n    \"\"\"\n\n    if inputs is None:\n        inputs = {}\n\n    job_config = self.context.job_registry.prepare_job_config(\n        manifest=manifest, inputs=inputs\n    )\n\n    job_id = self.context.job_registry.execute_job(\n        job_config=job_config, wait=False\n    )\n    return job_id\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.run_manifest","title":"<code>run_manifest(manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None) -&gt; ValueMap</code>","text":"<p>Run a job using the provided manifest to describe the module and config that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the manifest</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the job inputs (can be either references to values, or raw inputs</p> <code>None</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>a result value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def run_manifest(\n    self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n) -&gt; ValueMap:\n\"\"\"Run a job using the provided manifest to describe the module and config that should be executed.\n\n    Arguments:\n        manifest: the manifest\n        inputs: the job inputs (can be either references to values, or raw inputs\n\n    Returns:\n        a result value map instance\n    \"\"\"\n\n    job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n    return self.context.job_registry.retrieve_result(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.queue_job","title":"<code>queue_job(operation: Union[str, Path, Manifest, OperationInfo], inputs: Mapping[str, Any], operation_config: Union[None, Mapping[str, Any]] = None) -&gt; uuid.UUID</code>","text":"<p>Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.</p> <p>This is a convenience method that auto-detects what is meant by the 'operation' string input argument.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[str, Path, Manifest, OperationInfo]</code> <p>a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the operation inputs</p> required <code>operation_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the (optional) module config in case 'operation' is a module name</p> <code>None</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>the queued job id</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def queue_job(\n    self,\n    operation: Union[str, Path, Manifest, OperationInfo],\n    inputs: Mapping[str, Any],\n    operation_config: Union[None, Mapping[str, Any]] = None,\n) -&gt; uuid.UUID:\n\"\"\"Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n    This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n    Arguments:\n        operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n        inputs: the operation inputs\n        operation_config: the (optional) module config in case 'operation' is a module name\n\n    Returns:\n        the queued job id\n    \"\"\"\n\n    if isinstance(operation, Path):\n        if not operation.is_file():\n            raise Exception(\n                f\"Can't queue job from file '{operation.as_posix()}': file does not exist.\"\n            )\n        operation = operation.as_posix()\n    elif isinstance(operation, OperationInfo):\n        operation = operation.operation\n\n    if not isinstance(operation, Manifest):\n        manifest: Manifest = create_operation(\n            module_or_operation=operation,\n            operation_config=operation_config,\n            kiara=self.context,\n        )\n    else:\n        manifest = operation\n\n    job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n    return job_id\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.run_job","title":"<code>run_job(operation: Union[str, Path, Manifest, OperationInfo], inputs: Union[None, Mapping[str, Any]] = None, operation_config: Union[None, Mapping[str, Any]] = None) -&gt; ValueMap</code>","text":"<p>Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.</p> <p>This is a convenience method that auto-detects what is meant by the 'operation' string input argument.</p> <p>In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead, since this is a blocking operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[str, Path, Manifest, OperationInfo]</code> <p>a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the operation inputs</p> <code>None</code> <code>operation_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the (optional) module config in case 'operation' is a module name</p> <code>None</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>the job result value map</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def run_job(\n    self,\n    operation: Union[str, Path, Manifest, OperationInfo],\n    inputs: Union[None, Mapping[str, Any]] = None,\n    operation_config: Union[None, Mapping[str, Any]] = None,\n) -&gt; ValueMap:\n\"\"\"Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n    This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n    In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead,\n    since this is a blocking operation.\n\n    Arguments:\n        operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n        inputs: the operation inputs\n        operation_config: the (optional) module config in case 'operation' is a module name\n\n    Returns:\n        the job result value map\n\n    \"\"\"\n\n    if inputs is None:\n        inputs = {}\n    job_id = self.queue_job(\n        operation=operation, inputs=inputs, operation_config=operation_config\n    )\n    return self.context.job_registry.retrieve_result(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_job","title":"<code>get_job(job_id: Union[str, uuid.UUID]) -&gt; ActiveJob</code>","text":"<p>Retrieve the status of the job with the provided id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_job(self, job_id: Union[str, uuid.UUID]) -&gt; ActiveJob:\n\"\"\"Retrieve the status of the job with the provided id.\"\"\"\n\n    if isinstance(job_id, str):\n        job_id = uuid.UUID(job_id)\n\n    job_status = self.context.job_registry.get_job(job_id=job_id)\n    return job_status\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_job_result","title":"<code>get_job_result(job_id: Union[str, uuid.UUID]) -&gt; ValueMap</code>","text":"<p>Retrieve the result(s) of the specified job.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_job_result(self, job_id: Union[str, uuid.UUID]) -&gt; ValueMap:\n\"\"\"Retrieve the result(s) of the specified job.\"\"\"\n\n    if isinstance(job_id, str):\n        job_id = uuid.UUID(job_id)\n\n    result = self.context.job_registry.retrieve_result(job_id=job_id)\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.render_value","title":"<code>render_value(value: Union[str, uuid.UUID, Value], target_format: Union[str, Iterable[str]] = 'string', filters: Union[None, Iterable[str], Mapping[str, str]] = None, render_config: Union[Mapping[str, str], None] = None, add_root_scenes: bool = True, use_pretty_print: bool = False) -&gt; RenderValueResult</code>","text":"<p>Render a value in the specified target format.</p> <p>If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches the value type of the source value, and the provided target format.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>the value (or value id)</p> required <code>target_format</code> <code>Union[str, Iterable[str]]</code> <p>the format into which to render the value</p> <code>'string'</code> <code>filters</code> <code>Union[None, Iterable[str], Mapping[str, str]]</code> <p>an (optional) list of filters</p> <code>None</code> <code>render_config</code> <code>Union[Mapping[str, str], None]</code> <p>manifest specific render configuration</p> <code>None</code> <code>add_root_scenes</code> <code>bool</code> <p>add root scenes to the result</p> <code>True</code> <code>use_pretty_print</code> <code>bool</code> <p>use 'pretty_print' operation instead of 'render_value'</p> <code>False</code> <p>Returns:</p> Type Description <code>RenderValueResult</code> <p>the rendered value data, and any related scenes, if applicable</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def render_value(\n    self,\n    value: Union[str, uuid.UUID, Value],\n    target_format: Union[str, Iterable[str]] = \"string\",\n    filters: Union[None, Iterable[str], Mapping[str, str]] = None,\n    render_config: Union[Mapping[str, str], None] = None,\n    add_root_scenes: bool = True,\n    use_pretty_print: bool = False,\n) -&gt; RenderValueResult:\n\"\"\"Render a value in the specified target format.\n\n    If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n    the value type of the source value, and the provided target format.\n\n    Arguments:\n        value: the value (or value id)\n        target_format: the format into which to render the value\n        filters: an (optional) list of filters\n        render_config: manifest specific render configuration\n        add_root_scenes: add root scenes to the result\n        use_pretty_print: use 'pretty_print' operation instead of 'render_value'\n\n    Returns:\n        the rendered value data, and any related scenes, if applicable\n    \"\"\"\n\n    _value = self.get_value(value)\n    try:\n        render_operation: Union[None, Operation] = self.assemble_render_pipeline(\n            data_type=_value.data_type_name,\n            target_format=target_format,\n            filters=filters,\n            use_pretty_print=use_pretty_print,\n        )\n\n    except Exception as e:\n\n        log_message(\n            \"create_render_pipeline.failure\",\n            source_type=_value.data_type_name,\n            target_format=target_format,\n            error=e,\n        )\n\n        if use_pretty_print:\n            pretty_print_ops: PrettyPrintOperationType = self.context.operation_registry.get_operation_type(\"pretty_print\")  # type: ignore\n            if not isinstance(target_format, str):\n                raise NotImplementedError(\n                    \"Can't handle multiple target formats for 'render_value' yet.\"\n                )\n            render_operation = (\n                pretty_print_ops.get_operation_for_render_combination(\n                    source_type=\"any\", target_type=target_format\n                )\n            )\n        else:\n            render_ops: RenderValueOperationType = self.context.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n            if not isinstance(target_format, str):\n                raise NotImplementedError(\n                    \"Can't handle multiple target formats for 'render_value' yet.\"\n                )\n            render_operation = render_ops.get_render_operation(\n                source_type=\"any\", target_type=target_format\n            )\n\n    if render_operation is None:\n        raise Exception(\n            f\"Could not find render operation for value: {_value.value_id}\"\n        )\n\n    if render_config and \"render_config\" in render_config.keys():\n        # raise NotImplementedError()\n        # TODO: is this necessary?\n        render_config = render_config[\"render_config\"]  # type: ignore\n        # manifest_hash = render_config[\"manifest_hash\"]\n        # if manifest_hash != render_operation.manifest_hash:\n        #     raise NotImplementedError(\n        #         \"Using a non-default render operation is not supported (yet).\"\n        #     )\n        # render_config = render_config[\"render_config\"]\n\n    if render_config is None:\n        render_config = {}\n    else:\n        render_config = dict(render_config)\n\n    # render_type = render_config.pop(\"render_type\", None)\n    # if not render_type or render_type == \"data\":\n    #     pass\n    # elif render_type == \"metadata\":\n    #     pass\n    # elif render_type == \"properties\":\n    #     pass\n    # elif render_type == \"lineage\":\n    #     pass\n\n    result = render_operation.run(\n        kiara=self.context,\n        inputs={\"value\": _value, \"render_config\": render_config},\n    )\n\n    if use_pretty_print:\n        render_result: Value = result[\"rendered_value\"]\n        value_render_data = render_result.data\n    else:\n        render_result = result[\"render_value_result\"]\n\n        if render_result.data_type_name != \"render_value_result\":\n            raise Exception(\n                f\"Invalid result type for render operation: {render_result.data_type_name}\"\n            )\n\n        value_render_data: RenderValueResult = render_result.data  # type: ignore\n\n    return value_render_data\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_workflow_ids","title":"<code>list_workflow_ids() -&gt; List[uuid.UUID]</code>","text":"<p>List all available workflow ids.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_ids(self) -&gt; List[uuid.UUID]:\n\"\"\"List all available workflow ids.\"\"\"\n\n    return list(self.context.workflow_registry.all_workflow_ids)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_workflow_alias_names","title":"<code>list_workflow_alias_names() -&gt; List[str]</code>","text":"<p>\"List all available workflow aliases.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_alias_names(self) -&gt; List[str]:\n\"\"\" \"List all available workflow aliases.\"\"\"\n\n    return list(self.context.workflow_registry.workflow_aliases.keys())\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.get_workflow","title":"<code>get_workflow(workflow: Union[str, uuid.UUID], create_if_necessary: bool = True) -&gt; Workflow</code>","text":"<p>Retrieve the workflow instance with the specified id or alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_workflow(\n    self, workflow: Union[str, uuid.UUID], create_if_necessary: bool = True\n) -&gt; Workflow:\n\"\"\"Retrieve the workflow instance with the specified id or alias.\"\"\"\n\n    no_such_alias: bool = False\n    workflow_id: Union[uuid.UUID, None] = None\n    workflow_alias: Union[str, None] = None\n\n    if isinstance(workflow, str):\n        try:\n            workflow_id = uuid.UUID(workflow)\n        except Exception:\n            workflow_alias = workflow\n            try:\n                workflow_id = self.context.workflow_registry.get_workflow_id(\n                    workflow_alias=workflow\n                )\n            except NoSuchWorkflowException:\n                no_such_alias = True\n    else:\n        workflow_id = workflow\n\n    if workflow_id is None:\n        raise Exception(f\"Can't retrieve workflow for: {workflow}\")\n\n    if workflow_id in self._workflow_cache.keys():\n        return self._workflow_cache[workflow_id]\n\n    if workflow_id is None and not create_if_necessary:\n        if not no_such_alias:\n            msg = f\"No workflow with id '{workflow}' registered.\"\n        else:\n            msg = f\"No workflow with alias '{workflow}' registered.\"\n\n        raise NoSuchWorkflowException(workflow=workflow, msg=msg)\n\n    if workflow_id:\n        # workflow_metadata = self.context.workflow_registry.get_workflow_metadata(\n        #     workflow=workflow_id\n        # )\n        workflow_obj = Workflow(kiara=self.context, workflow=workflow_id)\n        self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n    else:\n        # means we need to create it\n        workflow_obj = self.create_workflow(workflow_alias=workflow_alias)\n\n    return workflow_obj\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflow_info","title":"<code>retrieve_workflow_info(workflow: Union[str, uuid.UUID, Workflow])</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflow_info(self, workflow: Union[str, uuid.UUID, Workflow]):\n\n    if isinstance(workflow, Workflow):\n        _workflow: Workflow = workflow\n    else:\n        _workflow = self.get_workflow(workflow)\n\n    return WorkflowInfo.create_from_workflow(workflow=_workflow)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_workflows","title":"<code>list_workflows(**matcher_params) -&gt; Mapping[uuid.UUID, Workflow]</code>","text":"<p>List all available workflow sessions, indexed by their unique id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflows(self, **matcher_params) -&gt; Mapping[uuid.UUID, Workflow]:\n\"\"\"List all available workflow sessions, indexed by their unique id.\"\"\"\n\n    workflows = {}\n\n    matcher = WorkflowMatcher(**matcher_params)\n    if matcher.has_alias:\n        for (\n            alias,\n            workflow_id,\n        ) in self.context.workflow_registry.workflow_aliases.items():\n\n            workflow = self.get_workflow(workflow=workflow_id)\n            workflows[workflow.workflow_id] = workflow\n        return workflows\n    else:\n        for workflow_id in self.context.workflow_registry.all_workflow_ids:\n            workflow = self.get_workflow(workflow=workflow_id)\n            workflows[workflow_id] = workflow\n        return workflows\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.list_workflow_aliases","title":"<code>list_workflow_aliases(**matcher_params) -&gt; Dict[str, Workflow]</code>","text":"<p>List all available workflow sessions that have an alias, indexed by alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_aliases(self, **matcher_params) -&gt; Dict[str, Workflow]:\n\"\"\"List all available workflow sessions that have an alias, indexed by alias.\"\"\"\n\n    if matcher_params:\n        matcher_params[\"has_alias\"] = True\n        workflows = self.list_workflows(**matcher_params)\n        result: Dict[str, Workflow] = {}\n        for workflow in workflows.values():\n            aliases = self.context.workflow_registry.get_aliases(\n                workflow_id=workflow.workflow_id\n            )\n            for a in aliases:\n                if a in result.keys():\n                    raise Exception(\n                        f\"Duplicate workflow alias '{a}': this is most likely a bug.\"\n                    )\n                result[a] = workflow\n        result = {k: result[k] for k in sorted(result.keys())}\n    else:\n        # faster if not other matcher params\n        all_aliases = self.context.workflow_registry.workflow_aliases\n        result = {\n            a: self.get_workflow(workflow=all_aliases[a])\n            for a in sorted(all_aliases.keys())\n        }\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflows_info","title":"<code>retrieve_workflows_info(**matcher_params: Any) -&gt; WorkflowGroupInfo</code>","text":"<p>Get a map info instances for all available workflows, indexed by (stringified) workflow-id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflows_info(self, **matcher_params: Any) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by (stringified) workflow-id.\"\"\"\n\n    workflows = self.list_workflows(**matcher_params)\n\n    workflow_infos = WorkflowGroupInfo.create_from_workflows(\n        *workflows.values(),\n        group_title=None,\n        alias_map=self.context.workflow_registry.workflow_aliases,\n    )\n    return workflow_infos\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflow_aliases_info","title":"<code>retrieve_workflow_aliases_info(**matcher_params: Any) -&gt; WorkflowGroupInfo</code>","text":"<p>Get a map info instances for all available workflows, indexed by alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflow_aliases_info(\n    self, **matcher_params: Any\n) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by alias.\"\"\"\n\n    workflows = self.list_workflow_aliases(**matcher_params)\n    workflow_infos = WorkflowGroupInfo.create_from_workflows(\n        *workflows.values(),\n        group_title=None,\n        alias_map=self.context.workflow_registry.workflow_aliases,\n    )\n    return workflow_infos\n</code></pre>"},{"location":"reference/kiara/api/#kiara.interfaces.python_api.KiaraAPI.create_workflow","title":"<code>create_workflow(workflow_alias: Union[None, str] = None, initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None, initial_inputs: Union[None, Mapping[str, Any]] = None, documentation: Union[Any, None] = None, save: bool = False, force_alias: bool = False) -&gt; Workflow</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_workflow(\n    self,\n    workflow_alias: Union[None, str] = None,\n    initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None,\n    initial_inputs: Union[None, Mapping[str, Any]] = None,\n    documentation: Union[Any, None] = None,\n    save: bool = False,\n    force_alias: bool = False,\n) -&gt; Workflow:\n\n    if workflow_alias is not None:\n        try:\n            uuid.UUID(workflow_alias)\n            raise Exception(\n                f\"Can't create workflow, provided alias can't be a uuid: {workflow_alias}.\"\n            )\n        except Exception:\n            pass\n\n    workflow_id = ID_REGISTRY.generate()\n    metadata = WorkflowMetadata(\n        workflow_id=workflow_id, documentation=documentation\n    )\n\n    workflow_obj = Workflow(kiara=self.context, workflow=metadata)\n    if workflow_alias:\n        workflow_obj._pending_aliases.add(workflow_alias)\n\n    if initial_pipeline:\n        operation = self.get_operation(operation=initial_pipeline)\n        if operation.module_type == \"pipeline\":\n            pipeline_details: PipelineOperationDetails = operation.operation_details  # type: ignore\n            workflow_obj.add_steps(*pipeline_details.pipeline_config.steps)\n            input_aliases = pipeline_details.pipeline_config.input_aliases\n            for k, v in input_aliases.items():\n                workflow_obj.set_input_alias(input_field=k, alias=v)\n            output_aliases = pipeline_details.pipeline_config.output_aliases\n            for k, v in output_aliases.items():\n                workflow_obj.set_output_alias(output_field=k, alias=v)\n        else:\n            raise NotImplementedError()\n\n        workflow_obj.set_inputs(**operation.module.config.defaults)\n\n    if initial_inputs:\n        workflow_obj.set_inputs(**initial_inputs)\n\n    self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n\n    if save:\n        if force_alias and workflow_alias:\n            self.context.workflow_registry.unregister_alias(workflow_alias)\n        workflow_obj.save()\n\n    return workflow_obj\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.Kiara","title":"<code>Kiara</code>","text":"<p>         Bases: <code>object</code></p> <p>The core context of a kiara session.</p> <p>The <code>Kiara</code> object holds all information related to the current environment the user does works in. This includes:</p> <ul> <li>available modules, operations &amp; pipelines</li> <li>available value data_types</li> <li>available metadata schemas</li> <li>available data items</li> <li>available controller and processor data_types</li> <li>misc. configuration options</li> </ul> <p>It's possible to use kiara without ever manually touching the 'Kiara' class, by default all relevant classes and functions will use a default instance of this class (available via the <code>Kiara.instance()</code> method.</p> <p>The Kiara class is highly dependent on the Python environment it lives in, because it auto-discovers available sub-classes of its building blocks (modules, value data_types, etc.). So, you can't assume that, for example, a pipeline you create will work the same way (or at all) in a different environment. kiara will always be able to tell you all the details of this environment, though, and it will attach those details to things like data, so there is always a record of how something was created, and in which environment.</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>class Kiara(object):\n\"\"\"The core context of a kiara session.\n\n    The `Kiara` object holds all information related to the current environment the user does works in. This includes:\n\n      - available modules, operations &amp; pipelines\n      - available value data_types\n      - available metadata schemas\n      - available data items\n      - available controller and processor data_types\n      - misc. configuration options\n\n    It's possible to use *kiara* without ever manually touching the 'Kiara' class, by default all relevant classes and functions\n    will use a default instance of this class (available via the `Kiara.instance()` method.\n\n    The Kiara class is highly dependent on the Python environment it lives in, because it auto-discovers available sub-classes\n    of its building blocks (modules, value data_types, etc.). So, you can't assume that, for example, a pipeline you create\n    will work the same way (or at all) in a different environment. *kiara* will always be able to tell you all the details\n    of this environment, though, and it will attach those details to things like data, so there is always a record of\n    how something was created, and in which environment.\n    \"\"\"\n\n    @classmethod\n    def instance(cls) -&gt; \"Kiara\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n        from kiara.interfaces.python_api import KiaraAPI\n\n        return KiaraAPI.instance().context\n\n    def __init__(\n        self,\n        config: Union[KiaraContextConfig, None] = None,\n        runtime_config: Union[KiaraRuntimeConfig, None] = None,\n    ) -&gt; None:\n\n        kc: Union[KiaraConfig, None] = None\n        if not config:\n            kc = KiaraConfig()\n            config = kc.get_context_config()\n\n        if not runtime_config:\n            if kc is None:\n                kc = KiaraConfig()\n            runtime_config = kc.runtime_config\n\n        self._id: uuid.UUID = ID_REGISTRY.generate(\n            id=uuid.UUID(config.context_id), obj=self\n        )\n        ID_REGISTRY.update_metadata(self._id, kiara_id=self._id)\n        self._config: KiaraContextConfig = config\n        self._runtime_config: KiaraRuntimeConfig = runtime_config\n\n        self._event_registry: EventRegistry = EventRegistry(kiara=self)\n        self._type_registry: TypeRegistry = TypeRegistry(self)\n        self._data_registry: DataRegistry = DataRegistry(kiara=self)\n        self._job_registry: JobRegistry = JobRegistry(kiara=self)\n        self._module_registry: ModuleRegistry = ModuleRegistry(kiara=self)\n        self._operation_registry: OperationRegistry = OperationRegistry(kiara=self)\n\n        self._kiara_model_registry: ModelRegistry = ModelRegistry.instance()\n\n        self._alias_registry: AliasRegistry = AliasRegistry(kiara=self)\n        self._destiny_registry: DestinyRegistry = DestinyRegistry(kiara=self)\n\n        self._workflow_registry: WorkflowRegistry = WorkflowRegistry(kiara=self)\n\n        self._render_registry = RenderRegistry(kiara=self)\n\n        self._env_mgmt: Union[EnvironmentRegistry, None] = None\n\n        metadata_augmenter = CreateMetadataDestinies(kiara=self)\n        self._event_registry.add_listener(\n            metadata_augmenter, *metadata_augmenter.supported_event_types()\n        )\n\n        self._context_info: Union[KiaraContextInfo, None] = None\n\n        # initialize stores\n        self._archive_types = find_all_archive_types()\n        self._archives: Dict[str, KiaraArchive] = {}\n\n        for archive_alias, archive in self._config.archives.items():\n            archive_cls = self._archive_types.get(archive.archive_type, None)\n            if archive_cls is None:\n                raise Exception(\n                    f\"Can't create context: no archive type '{archive.archive_type}' available. Available types: {', '.join(self._archive_types.keys())}\"\n                )\n\n            config_cls = archive_cls._config_cls\n            archive_config = config_cls(**archive.config)\n            archive_obj = archive_cls(archive_id=archive.archive_uuid, config=archive_config)  # type: ignore\n            for supported_type in archive_obj.supported_item_types():\n                if supported_type == \"data\":\n                    self.data_registry.register_data_archive(\n                        archive_obj, alias=archive_alias  # type: ignore\n                    )\n                if supported_type == \"job_record\":\n                    self.job_registry.register_job_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"alias\":\n                    self.alias_registry.register_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"destiny\":\n                    self.destiny_registry.register_destiny_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"workflow\":\n                    self.workflow_registry.register_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n    # def _run_alembic_migrations(self):\n    #     script_location = os.path.abspath(KIARA_DB_MIGRATIONS_FOLDER)\n    #     dsn = self._config.db_url\n    #     log_message(\"running migration script\", script=script_location, db_url=dsn)\n    #     from alembic.config import Config\n    #\n    #     alembic_cfg = Config(KIARA_DB_MIGRATIONS_CONFIG)\n    #     alembic_cfg.set_main_option(\"script_location\", script_location)\n    #     alembic_cfg.set_main_option(\"sqlalchemy.url\", dsn)\n    #     command.upgrade(alembic_cfg, \"head\")\n\n    @property\n    def id(self) -&gt; uuid.UUID:\n        return self._id\n\n    @property\n    def context_config(self) -&gt; KiaraContextConfig:\n        return self._config\n\n    @property\n    def runtime_config(self) -&gt; KiaraRuntimeConfig:\n        return self._runtime_config\n\n    def update_runtime_config(self, **settings) -&gt; KiaraRuntimeConfig:\n\n        for k, v in settings.items():\n            setattr(self.runtime_config, k, v)\n\n        return self.runtime_config\n\n    @property\n    def context_info(self) -&gt; \"KiaraContextInfo\":\n\n        if self._context_info is None:\n            self._context_info = KiaraContextInfo.create_from_kiara_instance(kiara=self)\n        return self._context_info\n\n    # ===================================================================================================\n    # registry accessors\n\n    @property\n    def environment_registry(self) -&gt; EnvironmentRegistry:\n        if self._env_mgmt is not None:\n            return self._env_mgmt\n\n        self._env_mgmt = EnvironmentRegistry.instance()\n        return self._env_mgmt\n\n    @property\n    def type_registry(self) -&gt; TypeRegistry:\n        return self._type_registry\n\n    @property\n    def module_registry(self) -&gt; ModuleRegistry:\n        return self._module_registry\n\n    @property\n    def kiara_model_registry(self) -&gt; ModelRegistry:\n        return self._kiara_model_registry\n\n    @property\n    def alias_registry(self) -&gt; AliasRegistry:\n        return self._alias_registry\n\n    @property\n    def destiny_registry(self) -&gt; DestinyRegistry:\n        return self._destiny_registry\n\n    @property\n    def job_registry(self) -&gt; JobRegistry:\n        return self._job_registry\n\n    @property\n    def operation_registry(self) -&gt; OperationRegistry:\n        op_registry = self._operation_registry\n        return op_registry\n\n    @property\n    def data_registry(self) -&gt; DataRegistry:\n        return self._data_registry\n\n    @property\n    def workflow_registry(self) -&gt; WorkflowRegistry:\n        return self._workflow_registry\n\n    @property\n    def event_registry(self) -&gt; EventRegistry:\n        return self._event_registry\n\n    @property\n    def render_registry(self) -&gt; RenderRegistry:\n        return self._render_registry\n\n    # ===================================================================================================\n    # context specific types &amp; instances\n\n    @property\n    def current_environments(self) -&gt; Mapping[str, RuntimeEnvironment]:\n        return self.environment_registry.environments\n\n    @property\n    def data_type_classes(self) -&gt; Mapping[str, Type[DataType]]:\n        return self.type_registry.data_type_classes\n\n    @property\n    def data_type_names(self) -&gt; List[str]:\n        return self.type_registry.data_type_names\n\n    @property\n    def module_type_classes(self) -&gt; Mapping[str, Type[\"KiaraModule\"]]:\n        return self._module_registry.module_types\n\n    @property\n    def module_type_names(self) -&gt; Iterable[str]:\n        return self._module_registry.get_module_type_names()\n\n    # ===================================================================================================\n    # kiara session API methods\n\n    def create_manifest(\n        self, module_or_operation: str, config: Union[Mapping[str, Any], None] = None\n    ) -&gt; Manifest:\n\n        if config is None:\n            config = {}\n\n        if module_or_operation in self.module_type_names:\n\n            manifest: Manifest = Manifest(\n                module_type=module_or_operation, module_config=config\n            )\n\n        elif module_or_operation in self.operation_registry.operation_ids:\n\n            if config:\n                raise Exception(\n                    f\"Specified run target '{module_or_operation}' is an operation, additional module configuration is not allowed (yet).\"\n                )\n            manifest = self.operation_registry.get_operation(module_or_operation)\n\n        elif os.path.isfile(module_or_operation):\n            raise NotImplementedError()\n\n        else:\n            raise Exception(\n                f\"Can't assemble operation, invalid operation/module name: {module_or_operation}. Must be registered module or operation name, or file.\"\n            )\n\n        return manifest\n\n    # def create_module(self, manifest: Union[Manifest, str]) -&gt; \"KiaraModule\":\n    #     \"\"\"Create a [KiaraModule][kiara.module.KiaraModule] object from a module configuration.\n    #\n    #     Arguments:\n    #         manifest: the module configuration\n    #     \"\"\"\n    #\n    #     return self._module_registry.create_module(manifest=manifest)\n\n    def queue(\n        self, manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n        Arguments:\n           manifest: the job manifest\n           inputs: the job inputs\n           wait: whether to wait for the job to be finished before returning\n\n        Returns:\n            the job id that can be used to look up job status &amp; results\n        \"\"\"\n\n        return self.job_registry.execute(manifest=manifest, inputs=inputs, wait=wait)\n\n    def process(self, manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n        Arguments:\n           manifest: the job manifest\n           inputs: the job inputs\n           wait: whether to wait for the job to be finished before returning\n\n        Returns\n        \"\"\"\n\n        return self.job_registry.execute_and_retrieve(manifest=manifest, inputs=inputs)\n\n    def save_values(\n        self, values: ValueMap, alias_map: Mapping[str, Iterable[str]]\n    ) -&gt; StoreValuesResult:\n\n        _values = {}\n        for field_name in values.field_names:\n            value = values.get_value_obj(field_name)\n            _values[field_name] = value\n            self.data_registry.store_value(value=value)\n        stored = {}\n        for field_name, field_aliases in alias_map.items():\n\n            value = _values[field_name]\n            try:\n                if field_aliases:\n                    self.alias_registry.register_aliases(value.value_id, *field_aliases)\n\n                stored[field_name] = StoreValueResult(\n                    value=value,\n                    aliases=sorted(field_aliases),\n                    error=None,\n                    persisted_data=None,\n                )\n\n            except Exception as e:\n                log_exception(e)\n                stored[field_name] = StoreValueResult(\n                    value=value,\n                    aliases=sorted(field_aliases),\n                    error=str(e),\n                    persisted_data=None,\n                )\n\n        return StoreValuesResult.construct(__root__=stored)\n\n    def create_context_summary(self) -&gt; ContextInfo:\n        return ContextInfo.create_from_context(kiara=self)\n\n    def get_all_archives(self) -&gt; Dict[KiaraArchive, Set[str]]:\n\n        result: Dict[KiaraArchive, Set[str]] = {}\n\n        archive: KiaraArchive\n        for alias, archive in self.data_registry.data_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.alias_registry.alias_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.destiny_registry.destiny_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.job_registry.job_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.workflow_registry.workflow_archives.items():\n            result.setdefault(archive, set()).add(alias)\n\n        return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.Kiara-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.id","title":"<code>id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.context_config","title":"<code>context_config: KiaraContextConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.runtime_config","title":"<code>runtime_config: KiaraRuntimeConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.context_info","title":"<code>context_info: KiaraContextInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.environment_registry","title":"<code>environment_registry: EnvironmentRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.type_registry","title":"<code>type_registry: TypeRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.module_registry","title":"<code>module_registry: ModuleRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.kiara_model_registry","title":"<code>kiara_model_registry: ModelRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.alias_registry","title":"<code>alias_registry: AliasRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.destiny_registry","title":"<code>destiny_registry: DestinyRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.job_registry","title":"<code>job_registry: JobRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.operation_registry","title":"<code>operation_registry: OperationRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.data_registry","title":"<code>data_registry: DataRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.workflow_registry","title":"<code>workflow_registry: WorkflowRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.event_registry","title":"<code>event_registry: EventRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.render_registry","title":"<code>render_registry: RenderRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.current_environments","title":"<code>current_environments: Mapping[str, RuntimeEnvironment]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.data_type_classes","title":"<code>data_type_classes: Mapping[str, Type[DataType]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.data_type_names","title":"<code>data_type_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.module_type_classes","title":"<code>module_type_classes: Mapping[str, Type[KiaraModule]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.module_type_names","title":"<code>module_type_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.api.Kiara-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.context.Kiara.instance","title":"<code>instance() -&gt; Kiara</code>  <code>classmethod</code>","text":"<p>The default kiara context. In most cases, it's recommended you create and manage your own, though.</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; \"Kiara\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n    from kiara.interfaces.python_api import KiaraAPI\n\n    return KiaraAPI.instance().context\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.update_runtime_config","title":"<code>update_runtime_config(**settings) -&gt; KiaraRuntimeConfig</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def update_runtime_config(self, **settings) -&gt; KiaraRuntimeConfig:\n\n    for k, v in settings.items():\n        setattr(self.runtime_config, k, v)\n\n    return self.runtime_config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.create_manifest","title":"<code>create_manifest(module_or_operation: str, config: Union[Mapping[str, Any], None] = None) -&gt; Manifest</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def create_manifest(\n    self, module_or_operation: str, config: Union[Mapping[str, Any], None] = None\n) -&gt; Manifest:\n\n    if config is None:\n        config = {}\n\n    if module_or_operation in self.module_type_names:\n\n        manifest: Manifest = Manifest(\n            module_type=module_or_operation, module_config=config\n        )\n\n    elif module_or_operation in self.operation_registry.operation_ids:\n\n        if config:\n            raise Exception(\n                f\"Specified run target '{module_or_operation}' is an operation, additional module configuration is not allowed (yet).\"\n            )\n        manifest = self.operation_registry.get_operation(module_or_operation)\n\n    elif os.path.isfile(module_or_operation):\n        raise NotImplementedError()\n\n    else:\n        raise Exception(\n            f\"Can't assemble operation, invalid operation/module name: {module_or_operation}. Must be registered module or operation name, or file.\"\n        )\n\n    return manifest\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.queue","title":"<code>queue(manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False) -&gt; uuid.UUID</code>","text":"<p>Queue a job with the specified manifest and inputs.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the job manifest</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the job inputs</p> required <code>wait</code> <code>bool</code> <p>whether to wait for the job to be finished before returning</p> <code>False</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>the job id that can be used to look up job status &amp; results</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>def queue(\n    self, manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False\n) -&gt; uuid.UUID:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n    Arguments:\n       manifest: the job manifest\n       inputs: the job inputs\n       wait: whether to wait for the job to be finished before returning\n\n    Returns:\n        the job id that can be used to look up job status &amp; results\n    \"\"\"\n\n    return self.job_registry.execute(manifest=manifest, inputs=inputs, wait=wait)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.process","title":"<code>process(manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap</code>","text":"<p>Queue a job with the specified manifest and inputs.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the job manifest</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the job inputs</p> required <code>wait</code> <p>whether to wait for the job to be finished before returning</p> required <p>Returns</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>def process(self, manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n    Arguments:\n       manifest: the job manifest\n       inputs: the job inputs\n       wait: whether to wait for the job to be finished before returning\n\n    Returns\n    \"\"\"\n\n    return self.job_registry.execute_and_retrieve(manifest=manifest, inputs=inputs)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.save_values","title":"<code>save_values(values: ValueMap, alias_map: Mapping[str, Iterable[str]]) -&gt; StoreValuesResult</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def save_values(\n    self, values: ValueMap, alias_map: Mapping[str, Iterable[str]]\n) -&gt; StoreValuesResult:\n\n    _values = {}\n    for field_name in values.field_names:\n        value = values.get_value_obj(field_name)\n        _values[field_name] = value\n        self.data_registry.store_value(value=value)\n    stored = {}\n    for field_name, field_aliases in alias_map.items():\n\n        value = _values[field_name]\n        try:\n            if field_aliases:\n                self.alias_registry.register_aliases(value.value_id, *field_aliases)\n\n            stored[field_name] = StoreValueResult(\n                value=value,\n                aliases=sorted(field_aliases),\n                error=None,\n                persisted_data=None,\n            )\n\n        except Exception as e:\n            log_exception(e)\n            stored[field_name] = StoreValueResult(\n                value=value,\n                aliases=sorted(field_aliases),\n                error=str(e),\n                persisted_data=None,\n            )\n\n    return StoreValuesResult.construct(__root__=stored)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.create_context_summary","title":"<code>create_context_summary() -&gt; ContextInfo</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def create_context_summary(self) -&gt; ContextInfo:\n    return ContextInfo.create_from_context(kiara=self)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.Kiara.get_all_archives","title":"<code>get_all_archives() -&gt; Dict[KiaraArchive, Set[str]]</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def get_all_archives(self) -&gt; Dict[KiaraArchive, Set[str]]:\n\n    result: Dict[KiaraArchive, Set[str]] = {}\n\n    archive: KiaraArchive\n    for alias, archive in self.data_registry.data_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.alias_registry.alias_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.destiny_registry.destiny_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.job_registry.job_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.workflow_registry.workflow_archives.items():\n        result.setdefault(archive, set()).add(alias)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraConfig","title":"<code>KiaraConfig</code>","text":"<p>         Bases: <code>BaseSettings</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraConfig(BaseSettings):\n    class Config:\n        env_prefix = \"kiara_\"\n        extra = Extra.forbid\n        use_enum_values = True\n\n    @classmethod\n    def create_in_folder(cls, path: Union[Path, str]) -&gt; \"KiaraConfig\":\n\n        if isinstance(path, str):\n            path = Path(path)\n        path = path.absolute()\n        if path.exists():\n            raise Exception(\n                f\"Can't create new kiara config, path exists: {path.as_posix()}\"\n            )\n\n        config = KiaraConfig(base_data_path=path.as_posix())\n        config_file = path / KIARA_CONFIG_FILE_NAME\n\n        config.save(config_file)\n\n        return config\n\n    @classmethod\n    def load_from_file(cls, path: Union[Path, None] = None) -&gt; \"KiaraConfig\":\n\n        if path is None:\n            path = Path(KIARA_MAIN_CONFIG_FILE)\n\n        if not path.exists():\n            raise Exception(\n                f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n            )\n\n        if path.is_dir():\n            path = path / KIARA_CONFIG_FILE_NAME\n            if not path.exists():\n                raise Exception(\n                    f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n                )\n\n        with path.open(\"rt\") as f:\n            data = yaml.load(f)\n\n        config = KiaraConfig(**data)\n        config._config_path = path\n        return config\n\n    context_search_paths: List[str] = Field(\n        description=\"The base path to look for contexts in.\",\n        default=[KIARA_MAIN_CONTEXTS_PATH],\n    )\n    base_data_path: str = Field(\n        description=\"The base path to use for all data (unless otherwise specified.\",\n        default=kiara_app_dirs.user_data_dir,\n    )\n    stores_base_path: str = Field(\n        description=\"The base path for the stores of this context.\"\n    )\n    default_context: str = Field(\n        description=\"The name of the default context to use if none is provided.\",\n        default=DEFAULT_CONTEXT_NAME,\n    )\n    auto_generate_contexts: bool = Field(\n        description=\"Whether to auto-generate requested contexts if they don't exist yet.\",\n        default=True,\n    )\n    runtime_config: KiaraRuntimeConfig = Field(\n        description=\"The kiara runtime config.\", default_factory=KiaraRuntimeConfig\n    )\n\n    _contexts: Dict[uuid.UUID, \"Kiara\"] = PrivateAttr(default_factory=dict)\n    _available_context_files: Dict[str, Path] = PrivateAttr(default=None)\n    _context_data: Dict[str, KiaraContextConfig] = PrivateAttr(default_factory=dict)\n    _config_path: Union[Path, None] = PrivateAttr(default=None)\n\n    @validator(\"context_search_paths\")\n    def validate_context_search_paths(cls, v):\n\n        if not v or not v[0]:\n            v = [KIARA_MAIN_CONTEXTS_PATH]\n\n        return v\n\n    @root_validator(pre=True)\n    def _set_paths(cls, values: Any):\n\n        base_path = values.get(\"base_data_path\", None)\n        if not base_path:\n            base_path = os.path.abspath(kiara_app_dirs.user_data_dir)\n            values[\"base_data_path\"] = base_path\n        elif isinstance(base_path, Path):\n            base_path = base_path.absolute().as_posix()\n            values[\"base_data_path\"] = base_path\n\n        stores_base_path = values.get(\"stores_base_path\", None)\n        if not stores_base_path:\n            stores_base_path = os.path.join(base_path, \"stores\")\n            values[\"stores_base_path\"] = stores_base_path\n\n        context_search_paths = values.get(\"context_search_paths\")\n        if not context_search_paths:\n            context_search_paths = [os.path.join(base_path, \"contexts\")]\n            values[\"context_search_paths\"] = context_search_paths\n\n        return values\n\n    @property\n    def available_context_names(self) -&gt; Iterable[str]:\n\n        if self._available_context_files is not None:\n            return self._available_context_files.keys()\n\n        result = {}\n        for search_path in self.context_search_paths:\n            sp = Path(search_path)\n            for path in sp.rglob(\"*.yaml\"):\n                rel_path = path.relative_to(sp)\n                alias = rel_path.as_posix()[0:-5]\n                alias = alias.replace(os.sep, \".\")\n                result[alias] = path\n        self._available_context_files = result\n        return self._available_context_files.keys()\n\n    @property\n    def context_configs(self) -&gt; Mapping[str, KiaraContextConfig]:\n\n        return {a: self.get_context_config(a) for a in self.available_context_names}\n\n    def get_context_config(\n        self,\n        context_name: Union[str, None] = None,\n        auto_generate: Union[bool, None] = None,\n    ) -&gt; KiaraContextConfig:\n\n        if auto_generate is None:\n            auto_generate = self.auto_generate_contexts\n\n        if context_name is None:\n            context_name = self.default_context\n\n        if context_name not in self.available_context_names:\n            if not auto_generate and not context_name == DEFAULT_CONTEXT_NAME:\n                raise Exception(\n                    f\"No kiara context with name '{context_name}' available.\"\n                )\n            else:\n                return self.create_context_config(context_alias=context_name)\n\n        if context_name in self._context_data.keys():\n            return self._context_data[context_name]\n\n        context_file = self._available_context_files[context_name]\n        context_data = get_data_from_file(context_file, content_type=\"yaml\")\n\n        changed = False\n        if \"extra_pipeline_folders\" in context_data.keys():\n            epf = context_data.pop(\"extra_pipeline_folders\")\n            context_data.setdefault(\"extra_pipelines\", []).extend(epf)\n            changed = True\n\n        context = KiaraContextConfig(**context_data)\n\n        if not changed:\n            changed = self._validate_context(context_config=context)\n\n        if changed:\n            logger.debug(\n                \"write.context_file\",\n                context_config_file=context_file.as_posix(),\n                context_name=context_name,\n                reason=\"context changed after validation\",\n            )\n            context_file.parent.mkdir(parents=True, exist_ok=True)\n            with open(context_file, \"wt\") as f:\n                yaml.dump(context.dict(), f)\n\n        context._context_config_path = context_file\n\n        self._context_data[context_name] = context\n        return context\n\n    def _validate_context(self, context_config: KiaraContextConfig) -&gt; bool:\n\n        env_registry = EnvironmentRegistry.instance()\n        from kiara.models.runtime_environment.kiara import KiaraTypesRuntimeEnvironment\n\n        kiara_types: KiaraTypesRuntimeEnvironment = env_registry.environments[\"kiara_types\"]  # type: ignore\n        available_archives = kiara_types.archive_types\n\n        changed = False\n        if DEFAULT_DATA_STORE_MARKER not in context_config.archives.keys():\n            data_store_type = \"filesystem_data_store\"\n            assert data_store_type in available_archives.item_infos.keys()\n\n            data_store_id = ID_REGISTRY.generate(comment=\"default data store id\")\n            data_archive_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, data_store_type, str(data_store_id)\n                    )\n                )\n            }\n            data_store = KiaraArchiveConfig.construct(\n                archive_id=str(data_store_id),\n                archive_type=data_store_type,\n                config=data_archive_config,\n            )\n            context_config.archives[DEFAULT_DATA_STORE_MARKER] = data_store\n\n            changed = True\n\n        if DEFAULT_JOB_STORE_MARKER not in context_config.archives.keys():\n            job_store_type = \"filesystem_job_store\"\n            assert job_store_type in available_archives.item_infos.keys()\n\n            job_store_id = ID_REGISTRY.generate(comment=\"default job store id\")\n            job_archive_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, job_store_type, str(job_store_id)\n                    )\n                )\n            }\n            job_store = KiaraArchiveConfig.construct(\n                archive_id=str(job_store_id),\n                archive_type=job_store_type,\n                config=job_archive_config,\n            )\n            context_config.archives[DEFAULT_JOB_STORE_MARKER] = job_store\n\n            changed = True\n\n        if DEFAULT_ALIAS_STORE_MARKER not in context_config.archives.keys():\n\n            alias_store_type = \"filesystem_alias_store\"\n            assert alias_store_type in available_archives.item_infos.keys()\n            alias_store_id = ID_REGISTRY.generate(comment=\"default alias store id\")\n            alias_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, alias_store_type, str(alias_store_id)\n                    )\n                )\n            }\n            alias_store = KiaraArchiveConfig.construct(\n                archive_id=str(alias_store_id),\n                archive_type=alias_store_type,\n                config=alias_store_config,\n            )\n            context_config.archives[DEFAULT_ALIAS_STORE_MARKER] = alias_store\n\n            changed = True\n\n        if DEFAULT_WORKFLOW_STORE_MARKER not in context_config.archives.keys():\n\n            workflow_store_type = \"filesystem_workflow_store\"\n            assert workflow_store_type in available_archives.item_infos.keys()\n            workflow_store_id = ID_REGISTRY.generate(\n                comment=\"default workflow store id\"\n            )\n            workflow_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path,\n                        workflow_store_type,\n                        str(workflow_store_id),\n                    )\n                )\n            }\n            workflow_store = KiaraArchiveConfig.construct(\n                archive_id=str(workflow_store_id),\n                archive_type=workflow_store_type,\n                config=workflow_store_config,\n            )\n            context_config.archives[DEFAULT_WORKFLOW_STORE_MARKER] = workflow_store\n\n            changed = True\n\n        if METADATA_DESTINY_STORE_MARKER not in context_config.archives.keys():\n            destiny_store_type = \"filesystem_destiny_store\"\n            assert destiny_store_type in available_archives.item_infos.keys()\n            destiny_store_id = ID_REGISTRY.generate(comment=\"default destiny store id\")\n            destiny_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, destiny_store_type, str(destiny_store_id)\n                    )\n                )\n            }\n            destiny_store = KiaraArchiveConfig.construct(\n                archive_id=str(destiny_store_id),\n                archive_type=destiny_store_type,\n                config=destiny_store_config,\n            )\n            context_config.archives[METADATA_DESTINY_STORE_MARKER] = destiny_store\n\n            changed = True\n\n        return changed\n\n    def create_context_config(\n        self, context_alias: Union[str, None] = None\n    ) -&gt; KiaraContextConfig:\n\n        if not context_alias:\n            context_alias = DEFAULT_CONTEXT_NAME\n        if context_alias in self.available_context_names:\n            raise Exception(\n                f\"Can't create kiara context '{context_alias}': context with that alias already registered.\"\n            )\n\n        if os.path.sep in context_alias:\n            raise Exception(\n                f\"Can't create context with alias '{context_alias}': no special characters allowed.\"\n            )\n\n        context_file = (\n            Path(os.path.join(self.context_search_paths[0])) / f\"{context_alias}.yaml\"\n        )\n\n        archives: Dict[str, KiaraArchiveConfig] = {}\n        # create_default_archives(kiara_config=self)\n        context_id = ID_REGISTRY.generate(\n            obj_type=KiaraContextConfig, comment=f\"new kiara context '{context_alias}'\"\n        )\n\n        context_config = KiaraContextConfig(\n            context_id=str(context_id), archives=archives, extra_pipelines=[]\n        )\n\n        self._validate_context(context_config=context_config)\n\n        context_file.parent.mkdir(parents=True, exist_ok=True)\n        with open(context_file, \"wt\") as f:\n            yaml.dump(context_config.dict(), f)\n\n        context_config._context_config_path = context_file\n\n        self._available_context_files[context_alias] = context_file\n        self._context_data[context_alias] = context_config\n\n        return context_config\n\n    def create_context(\n        self,\n        context: Union[None, str, uuid.UUID, Path] = None,\n        extra_pipelines: Union[None, str, Iterable[str]] = None,\n    ) -&gt; \"Kiara\":\n\n        if not context:\n            context = self.default_context\n        else:\n            with contextlib.suppress(Exception):\n                context = uuid.UUID(context)  # type: ignore\n\n        if isinstance(context, str) and os.path.exists(context):\n            context = Path(context)\n\n        if isinstance(context, Path):\n            with context.open(\"rt\") as f:\n                data = yaml.load(f)\n            context_config = KiaraContextConfig(**data)\n        elif isinstance(context, str):\n            context_config = self.get_context_config(context_name=context)\n        elif isinstance(context, uuid.UUID):\n            context_config = self.find_context_config(context_id=context)\n        else:\n            raise Exception(\n                f\"Can't retrieve context, invalid context config type '{type(context)}'.\"\n            )\n\n        assert context_config.context_id not in self._contexts.keys()\n\n        if extra_pipelines:\n            if isinstance(extra_pipelines, str):\n                extra_pipelines = [extra_pipelines]\n            context_config.add_pipelines(*extra_pipelines)\n\n        from kiara.context import Kiara\n\n        kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n        assert kiara.id == uuid.UUID(context_config.context_id)\n        self._contexts[kiara.id] = kiara\n\n        return kiara\n\n    def find_context_config(self, context_id: uuid.UUID) -&gt; KiaraContextConfig:\n        raise NotImplementedError()\n\n    def save(self, path: Union[Path, None] = None):\n        if path is None:\n            path = Path(KIARA_MAIN_CONFIG_FILE)\n\n        if path.exists():\n            raise Exception(\n                f\"Can't save config file, path already exists: {path.as_posix()}\"\n            )\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with path.open(\"wt\") as f:\n            yaml.dump(\n                self.dict(\n                    exclude={\n                        \"context\",\n                        \"auto_generate_contexts\",\n                        \"stores_base_path\",\n                        \"context_search_paths\",\n                        \"default_context\",\n                        \"runtime_config\",\n                    }\n                ),\n                f,\n            )\n\n        self._config_path = path\n\n    def delete(\n        self, context_name: Union[str, None] = None, dry_run: bool = True\n    ) -&gt; \"ContextInfo\":\n\n        if context_name is None:\n            context_name = self.default_context\n\n        from kiara.context import Kiara\n        from kiara.models.context import ContextInfo\n\n        context_config = self.get_context_config(\n            context_name=context_name, auto_generate=False\n        )\n        kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n\n        context_summary = ContextInfo.create_from_context(\n            kiara=kiara, context_name=context_name\n        )\n\n        if dry_run:\n            return context_summary\n\n        for archive in kiara.get_all_archives().keys():\n            archive.delete_archive(archive_id=archive.archive_id)\n\n        if context_config._context_config_path is not None:\n            os.unlink(context_config._context_config_path)\n\n        return context_summary\n\n    def create_renderable(self, **render_config: Any):\n        from kiara.utils.output import create_recursive_table_from_model_object\n\n        return create_recursive_table_from_model_object(\n            self, render_config=render_config\n        )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.context_search_paths","title":"<code>context_search_paths: List[str] = Field(description='The base path to look for contexts in.', default=[KIARA_MAIN_CONTEXTS_PATH])</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.base_data_path","title":"<code>base_data_path: str = Field(description='The base path to use for all data (unless otherwise specified.', default=kiara_app_dirs.user_data_dir)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.stores_base_path","title":"<code>stores_base_path: str = Field(description='The base path for the stores of this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.default_context","title":"<code>default_context: str = Field(description='The name of the default context to use if none is provided.', default=DEFAULT_CONTEXT_NAME)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.auto_generate_contexts","title":"<code>auto_generate_contexts: bool = Field(description=\"Whether to auto-generate requested contexts if they don't exist yet.\", default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.runtime_config","title":"<code>runtime_config: KiaraRuntimeConfig = Field(description='The kiara runtime config.', default_factory=KiaraRuntimeConfig)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.available_context_names","title":"<code>available_context_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.context_configs","title":"<code>context_configs: Mapping[str, KiaraContextConfig]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.api.KiaraConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>class Config:\n    env_prefix = \"kiara_\"\n    extra = Extra.forbid\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.Config-attributes","title":"Attributes","text":"<code>env_prefix = 'kiara_'</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/api/#kiara.api.KiaraConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.create_in_folder","title":"<code>create_in_folder(path: Union[Path, str]) -&gt; KiaraConfig</code>  <code>classmethod</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@classmethod\ndef create_in_folder(cls, path: Union[Path, str]) -&gt; \"KiaraConfig\":\n\n    if isinstance(path, str):\n        path = Path(path)\n    path = path.absolute()\n    if path.exists():\n        raise Exception(\n            f\"Can't create new kiara config, path exists: {path.as_posix()}\"\n        )\n\n    config = KiaraConfig(base_data_path=path.as_posix())\n    config_file = path / KIARA_CONFIG_FILE_NAME\n\n    config.save(config_file)\n\n    return config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.load_from_file","title":"<code>load_from_file(path: Union[Path, None] = None) -&gt; KiaraConfig</code>  <code>classmethod</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@classmethod\ndef load_from_file(cls, path: Union[Path, None] = None) -&gt; \"KiaraConfig\":\n\n    if path is None:\n        path = Path(KIARA_MAIN_CONFIG_FILE)\n\n    if not path.exists():\n        raise Exception(\n            f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n        )\n\n    if path.is_dir():\n        path = path / KIARA_CONFIG_FILE_NAME\n        if not path.exists():\n            raise Exception(\n                f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n            )\n\n    with path.open(\"rt\") as f:\n        data = yaml.load(f)\n\n    config = KiaraConfig(**data)\n    config._config_path = path\n    return config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.validate_context_search_paths","title":"<code>validate_context_search_paths(v)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@validator(\"context_search_paths\")\ndef validate_context_search_paths(cls, v):\n\n    if not v or not v[0]:\n        v = [KIARA_MAIN_CONTEXTS_PATH]\n\n    return v\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.get_context_config","title":"<code>get_context_config(context_name: Union[str, None] = None, auto_generate: Union[bool, None] = None) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def get_context_config(\n    self,\n    context_name: Union[str, None] = None,\n    auto_generate: Union[bool, None] = None,\n) -&gt; KiaraContextConfig:\n\n    if auto_generate is None:\n        auto_generate = self.auto_generate_contexts\n\n    if context_name is None:\n        context_name = self.default_context\n\n    if context_name not in self.available_context_names:\n        if not auto_generate and not context_name == DEFAULT_CONTEXT_NAME:\n            raise Exception(\n                f\"No kiara context with name '{context_name}' available.\"\n            )\n        else:\n            return self.create_context_config(context_alias=context_name)\n\n    if context_name in self._context_data.keys():\n        return self._context_data[context_name]\n\n    context_file = self._available_context_files[context_name]\n    context_data = get_data_from_file(context_file, content_type=\"yaml\")\n\n    changed = False\n    if \"extra_pipeline_folders\" in context_data.keys():\n        epf = context_data.pop(\"extra_pipeline_folders\")\n        context_data.setdefault(\"extra_pipelines\", []).extend(epf)\n        changed = True\n\n    context = KiaraContextConfig(**context_data)\n\n    if not changed:\n        changed = self._validate_context(context_config=context)\n\n    if changed:\n        logger.debug(\n            \"write.context_file\",\n            context_config_file=context_file.as_posix(),\n            context_name=context_name,\n            reason=\"context changed after validation\",\n        )\n        context_file.parent.mkdir(parents=True, exist_ok=True)\n        with open(context_file, \"wt\") as f:\n            yaml.dump(context.dict(), f)\n\n    context._context_config_path = context_file\n\n    self._context_data[context_name] = context\n    return context\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.create_context_config","title":"<code>create_context_config(context_alias: Union[str, None] = None) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_context_config(\n    self, context_alias: Union[str, None] = None\n) -&gt; KiaraContextConfig:\n\n    if not context_alias:\n        context_alias = DEFAULT_CONTEXT_NAME\n    if context_alias in self.available_context_names:\n        raise Exception(\n            f\"Can't create kiara context '{context_alias}': context with that alias already registered.\"\n        )\n\n    if os.path.sep in context_alias:\n        raise Exception(\n            f\"Can't create context with alias '{context_alias}': no special characters allowed.\"\n        )\n\n    context_file = (\n        Path(os.path.join(self.context_search_paths[0])) / f\"{context_alias}.yaml\"\n    )\n\n    archives: Dict[str, KiaraArchiveConfig] = {}\n    # create_default_archives(kiara_config=self)\n    context_id = ID_REGISTRY.generate(\n        obj_type=KiaraContextConfig, comment=f\"new kiara context '{context_alias}'\"\n    )\n\n    context_config = KiaraContextConfig(\n        context_id=str(context_id), archives=archives, extra_pipelines=[]\n    )\n\n    self._validate_context(context_config=context_config)\n\n    context_file.parent.mkdir(parents=True, exist_ok=True)\n    with open(context_file, \"wt\") as f:\n        yaml.dump(context_config.dict(), f)\n\n    context_config._context_config_path = context_file\n\n    self._available_context_files[context_alias] = context_file\n    self._context_data[context_alias] = context_config\n\n    return context_config\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.create_context","title":"<code>create_context(context: Union[None, str, uuid.UUID, Path] = None, extra_pipelines: Union[None, str, Iterable[str]] = None) -&gt; Kiara</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_context(\n    self,\n    context: Union[None, str, uuid.UUID, Path] = None,\n    extra_pipelines: Union[None, str, Iterable[str]] = None,\n) -&gt; \"Kiara\":\n\n    if not context:\n        context = self.default_context\n    else:\n        with contextlib.suppress(Exception):\n            context = uuid.UUID(context)  # type: ignore\n\n    if isinstance(context, str) and os.path.exists(context):\n        context = Path(context)\n\n    if isinstance(context, Path):\n        with context.open(\"rt\") as f:\n            data = yaml.load(f)\n        context_config = KiaraContextConfig(**data)\n    elif isinstance(context, str):\n        context_config = self.get_context_config(context_name=context)\n    elif isinstance(context, uuid.UUID):\n        context_config = self.find_context_config(context_id=context)\n    else:\n        raise Exception(\n            f\"Can't retrieve context, invalid context config type '{type(context)}'.\"\n        )\n\n    assert context_config.context_id not in self._contexts.keys()\n\n    if extra_pipelines:\n        if isinstance(extra_pipelines, str):\n            extra_pipelines = [extra_pipelines]\n        context_config.add_pipelines(*extra_pipelines)\n\n    from kiara.context import Kiara\n\n    kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n    assert kiara.id == uuid.UUID(context_config.context_id)\n    self._contexts[kiara.id] = kiara\n\n    return kiara\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.find_context_config","title":"<code>find_context_config(context_id: uuid.UUID) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def find_context_config(self, context_id: uuid.UUID) -&gt; KiaraContextConfig:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.save","title":"<code>save(path: Union[Path, None] = None)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def save(self, path: Union[Path, None] = None):\n    if path is None:\n        path = Path(KIARA_MAIN_CONFIG_FILE)\n\n    if path.exists():\n        raise Exception(\n            f\"Can't save config file, path already exists: {path.as_posix()}\"\n        )\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    with path.open(\"wt\") as f:\n        yaml.dump(\n            self.dict(\n                exclude={\n                    \"context\",\n                    \"auto_generate_contexts\",\n                    \"stores_base_path\",\n                    \"context_search_paths\",\n                    \"default_context\",\n                    \"runtime_config\",\n                }\n            ),\n            f,\n        )\n\n    self._config_path = path\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.delete","title":"<code>delete(context_name: Union[str, None] = None, dry_run: bool = True) -&gt; ContextInfo</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def delete(\n    self, context_name: Union[str, None] = None, dry_run: bool = True\n) -&gt; \"ContextInfo\":\n\n    if context_name is None:\n        context_name = self.default_context\n\n    from kiara.context import Kiara\n    from kiara.models.context import ContextInfo\n\n    context_config = self.get_context_config(\n        context_name=context_name, auto_generate=False\n    )\n    kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n\n    context_summary = ContextInfo.create_from_context(\n        kiara=kiara, context_name=context_name\n    )\n\n    if dry_run:\n        return context_summary\n\n    for archive in kiara.get_all_archives().keys():\n        archive.delete_archive(archive_id=archive.archive_id)\n\n    if context_config._context_config_path is not None:\n        os.unlink(context_config._context_config_path)\n\n    return context_summary\n</code></pre>"},{"location":"reference/kiara/api/#kiara.context.config.KiaraConfig.create_renderable","title":"<code>create_renderable(**render_config: Any)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_renderable(self, **render_config: Any):\n    from kiara.utils.output import create_recursive_table_from_model_object\n\n    return create_recursive_table_from_model_object(\n        self, render_config=render_config\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraModule","title":"<code>KiaraModule</code>","text":"<p>         Bases: <code>InputOutputObject</code>, <code>Generic[KIARA_CONFIG]</code></p> <p>The base class that every custom module in Kiara needs to inherit from.</p> <p>The core of every <code>KiaraModule</code> is a <code>process</code> method, which should be a 'pure',  idempotent function that creates one or several output values from the given input(s), and its purpose is to transfor  a set of inputs into a set of outputs.</p> <p>Every module can be configured. The module configuration schema can differ, but every one such configuration needs to  subclass the KiaraModuleConfig class and set as the value to the  <code>_config_cls</code> attribute of the module class. This is useful, because it allows for some modules to serve a much  larger variety of use-cases than non-configurable modules would be, which would mean more code duplication because  of very simlilar, but slightly different module data_types.</p> <p>Each module class (type) has a unique -- within a kiara context -- module type id which can be accessed via the  <code>_module_type_name</code> class attribute.</p> <p>Examples:</p> <p>A simple example would be an 'addition' module, with <code>a</code> and <code>b</code> configured as inputs, and <code>z</code> as the output field name.</p> <p>An implementing class would look something like this:</p> <p>TODO</p> <p>Parameters:</p> Name Type Description Default <code>module_config</code> <code>Union[None, KIARA_CONFIG, Mapping[str, Any]]</code> <p>the configuation for this module</p> <code>None</code> Source code in <code>kiara/modules/__init__.py</code> <pre><code>class KiaraModule(InputOutputObject, Generic[KIARA_CONFIG]):\n\"\"\"The base class that every custom module in *Kiara* needs to inherit from.\n\n    The core of every ``KiaraModule`` is a ``process`` method, which should be a 'pure',\n     idempotent function that creates one or several output values from the given input(s), and its purpose is to transfor\n     a set of inputs into a set of outputs.\n\n     Every module can be configured. The module configuration schema can differ, but every one such configuration needs to\n     subclass the [KiaraModuleConfig][kiara.module_config.KiaraModuleConfig] class and set as the value to the\n     ``_config_cls`` attribute of the module class. This is useful, because it allows for some modules to serve a much\n     larger variety of use-cases than non-configurable modules would be, which would mean more code duplication because\n     of very simlilar, but slightly different module data_types.\n\n     Each module class (type) has a unique -- within a *kiara* context -- module type id which can be accessed via the\n     ``_module_type_name`` class attribute.\n\n    Examples:\n\n        A simple example would be an 'addition' module, with ``a`` and ``b`` configured as inputs, and ``z`` as the output field name.\n\n        An implementing class would look something like this:\n\n        TODO\n\n    Arguments:\n        module_config: the configuation for this module\n    \"\"\"\n\n    # TODO: not quite sure about this generic type here, mypy doesn't seem to like it\n    _config_cls: Type[KIARA_CONFIG] = KiaraModuleConfig  # type: ignore\n\n    @classmethod\n    def is_pipeline(cls) -&gt; bool:\n\"\"\"Check whether this module type is a pipeline, or not.\"\"\"\n        return False\n\n    @classmethod\n    def _calculate_module_cid(\n        cls, module_type_config: Union[Mapping[str, Any], KIARA_CONFIG]\n    ) -&gt; CID:\n\n        if isinstance(module_type_config, Mapping):\n            module_type_config = cls._resolve_module_config(**module_type_config)\n\n        obj = {\n            \"module_type\": cls._module_type_name,  # type: ignore\n            \"module_type_config\": module_type_config.dict(),\n        }\n        _, cid = compute_cid(data=obj)\n        return cid\n\n    @classmethod\n    def _resolve_module_config(cls, **config: Any) -&gt; KIARA_CONFIG:\n\n        _config = cls._config_cls(**config)  # type: ignore\n\n        return _config\n\n    def __init__(\n        self,\n        module_config: Union[None, KIARA_CONFIG, Mapping[str, Any]] = None,\n    ):\n        self._id: uuid.UUID = uuid.uuid4()\n\n        if isinstance(module_config, KiaraModuleConfig):\n            self._config: KIARA_CONFIG = module_config  # type: ignore\n        elif module_config is None:\n            self._config = self.__class__._config_cls()\n        elif isinstance(module_config, Mapping):\n            try:\n                self._config = self.__class__._config_cls(**module_config)\n            except ValidationError as ve:\n                raise KiaraModuleConfigException(\n                    f\"Error creating module '{id}'. {ve}\",\n                    self.__class__,\n                    module_config,\n                    ve,\n                )\n        else:\n            raise TypeError(f\"Invalid type for module config: {type(module_config)}\")\n\n        self._module_cid: Union[CID, None] = None\n        self._characteristics: Union[ModuleCharacteristics, None] = None\n\n        self._doc: Union[None, DocumentationMetadataModel] = None\n        super().__init__(alias=self.__class__._module_type_name, config=self._config)  # type: ignore\n\n        self._operation: Union[Operation, None] = None\n        # self._merged_input_schemas: typing.Mapping[str, ValueSchema] = None  # type: ignore\n        self._manifest_cache: Union[None, Manifest] = None\n\n    @property\n    def manifest(self) -&gt; \"Manifest\":\n        if self._manifest_cache is None:\n            self._manifest_cache = Manifest(\n                module_type=self.module_type_name,\n                module_config=self.config.dict(),\n                is_resolved=True,\n            )\n        return self._manifest_cache\n\n    @property\n    def doc(self) -&gt; \"DocumentationMetadataModel\":\n        if self._doc is None:\n\n            self._doc = DocumentationMetadataModel.from_class_doc(self.__class__)\n        return self._doc\n\n    @property\n    def module_id(self) -&gt; uuid.UUID:\n\"\"\"The id of this module.\"\"\"\n        return self._id\n\n    @property\n    def module_type_name(self) -&gt; str:\n        if not self._module_type_name:  # type: ignore\n            raise Exception(\n                f\"Module class '{self.__class__.__name__}' does not have a '_module_type_name' attribute. This is a bug.\"\n            )\n        return self._module_type_name  # type: ignore\n\n    @property\n    def config(self) -&gt; KIARA_CONFIG:\n\"\"\"Retrieve the configuration object for this module.\n\n        Returns:\n            the module-class-specific config object\n        \"\"\"\n        return self._config\n\n    @property\n    def module_instance_cid(self) -&gt; CID:\n\n        if self._module_cid is None:\n            self._module_cid = self.__class__._calculate_module_cid(self._config)\n        return self._module_cid\n\n    @property\n    def characteristics(self) -&gt; ModuleCharacteristics:\n        if self._characteristics is not None:\n            return self._characteristics\n\n        self._characteristics = self._retrieve_module_characteristics()\n        return self._characteristics\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n\n        return DEFAULT_IDEMPOTENT_MODULE_CHARACTERISTICS\n\n    def get_config_value(self, key: str) -&gt; Any:\n\"\"\"Retrieve the value for a specific configuration option.\n\n        Arguments:\n            key: the config key\n\n        Returns:\n            the value for the provided key\n        \"\"\"\n\n        try:\n            return self.config.get(key)\n        except Exception:\n            raise Exception(\n                f\"Error accessing config value '{key}' in module {self.__class__._module_type_name}.\"  # type: ignore\n            )\n\n    def run(self, kiara: \"Kiara\", **inputs: Any) -&gt; \"ValueMap\":\n\"\"\"Run the module ad-hoc.\n\n        This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.\n\n        Arguments:\n            kiara: the kiara context\n            inputs: the inputs for this module\n\n        Returns:\n            the outputs of this module run as a ValueMap instance\n        \"\"\"\n\n        from kiara.models.values.value import ValueMap, ValueMapWritable, ValuePedigree\n\n        _inputs: ValueMap = kiara.data_registry.create_valuemap(\n            data=inputs, schema=self.inputs_schema\n        )\n\n        if _inputs.check_invalid():\n            raise InvalidValuesException(\n                msg=f\"Invalid inputs for module '{self.module_type_name}'.\",\n                invalid_values=_inputs.check_invalid(),\n            )\n        environments = {\n            env_name: env.instance_id\n            for env_name, env in kiara.current_environments.items()\n        }\n\n        result_pedigree = ValuePedigree(\n            kiara_id=kiara.id,\n            module_type=self.module_type_name,\n            module_config=self.config.dict(),\n            inputs={k: v.value_id for k, v in _inputs.items()},\n            environments=environments,\n        )\n\n        unique_result_values = self.characteristics.unique_result_values\n\n        outputs = ValueMapWritable.create_from_schema(\n            kiara=kiara,\n            schema=self.outputs_schema,\n            pedigree=result_pedigree,\n            unique_value_ids=unique_result_values,\n        )\n        job_log = JobLog()\n        self.process_step(inputs=_inputs, outputs=outputs, job_log=job_log)\n\n        return outputs\n\n    def process_step(\n        self, inputs: \"ValueMap\", outputs: \"ValueMap\", job_log: JobLog\n    ) -&gt; None:\n\"\"\"Kick off processing for a specific set of input/outputs.\n\n        This method calls the implemented [process][kiara.module.KiaraModule.process] method of the inheriting class,\n        as well as wrapping input/output-data related functionality.\n\n        Arguments:\n            inputs: the input value set\n            outputs: the output value set\n        \"\"\"\n\n        signature = inspect.signature(self.process)  # type: ignore\n\n        process_inputs: Dict[str, Any] = {\n            \"inputs\": inputs,\n            \"outputs\": outputs,\n        }\n\n        if \"job_log\" in signature.parameters.keys():\n            process_inputs[\"job_log\"] = job_log\n\n        try:\n            self.process(**process_inputs)  # type: ignore\n        except KiaraProcessingException as kpe:\n            log_exception(kpe)\n            raise kpe\n        except Exception as e:\n            log_exception(e)\n            raise KiaraProcessingException(e, module=self, inputs=inputs)\n\n    def __eq__(self, other):\n        if self.__class__ != other.__class__:\n            return False\n        return self.module_instance_cid == other.module_instance_cid\n\n    def __hash__(self):\n        return int.from_bytes(self.module_instance_cid.digest, \"big\")\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(id={self.module_id} module_type={self.module_type_name} input_names={list(self.input_names)} output_names={list(self.output_names)})\"\n\n    @property\n    def operation(self) -&gt; \"Operation\":\n\n        if self._operation is not None:\n            return self._operation\n\n        from kiara.models.module.operation import Operation\n\n        self._operation = Operation.create_from_module(self)\n        return self._operation\n\n    def create_renderable(self, **config) -&gt; RenderableType:\n\n        return self.operation.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.KiaraModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule._config_cls","title":"<code>_config_cls: Type[KIARA_CONFIG] = KiaraModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.manifest","title":"<code>manifest: Manifest</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.doc","title":"<code>doc: DocumentationMetadataModel</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.module_id","title":"<code>module_id: uuid.UUID</code>  <code>property</code>","text":"<p>The id of this module.</p>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.module_type_name","title":"<code>module_type_name: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.config","title":"<code>config: KIARA_CONFIG</code>  <code>property</code>","text":"<p>Retrieve the configuration object for this module.</p> <p>Returns:</p> Type Description <code>KIARA_CONFIG</code> <p>the module-class-specific config object</p>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.module_instance_cid","title":"<code>module_instance_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.characteristics","title":"<code>characteristics: ModuleCharacteristics</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.operation","title":"<code>operation: Operation</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.api.KiaraModule-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.is_pipeline","title":"<code>is_pipeline() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check whether this module type is a pipeline, or not.</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>@classmethod\ndef is_pipeline(cls) -&gt; bool:\n\"\"\"Check whether this module type is a pipeline, or not.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.get_config_value","title":"<code>get_config_value(key: str) -&gt; Any</code>","text":"<p>Retrieve the value for a specific configuration option.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the config key</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the value for the provided key</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>def get_config_value(self, key: str) -&gt; Any:\n\"\"\"Retrieve the value for a specific configuration option.\n\n    Arguments:\n        key: the config key\n\n    Returns:\n        the value for the provided key\n    \"\"\"\n\n    try:\n        return self.config.get(key)\n    except Exception:\n        raise Exception(\n            f\"Error accessing config value '{key}' in module {self.__class__._module_type_name}.\"  # type: ignore\n        )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.run","title":"<code>run(kiara: Kiara, **inputs: Any) -&gt; ValueMap</code>","text":"<p>Run the module ad-hoc.</p> <p>This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>kiara</code> <code>Kiara</code> <p>the kiara context</p> required <code>inputs</code> <code>Any</code> <p>the inputs for this module</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>the outputs of this module run as a ValueMap instance</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>def run(self, kiara: \"Kiara\", **inputs: Any) -&gt; \"ValueMap\":\n\"\"\"Run the module ad-hoc.\n\n    This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.\n\n    Arguments:\n        kiara: the kiara context\n        inputs: the inputs for this module\n\n    Returns:\n        the outputs of this module run as a ValueMap instance\n    \"\"\"\n\n    from kiara.models.values.value import ValueMap, ValueMapWritable, ValuePedigree\n\n    _inputs: ValueMap = kiara.data_registry.create_valuemap(\n        data=inputs, schema=self.inputs_schema\n    )\n\n    if _inputs.check_invalid():\n        raise InvalidValuesException(\n            msg=f\"Invalid inputs for module '{self.module_type_name}'.\",\n            invalid_values=_inputs.check_invalid(),\n        )\n    environments = {\n        env_name: env.instance_id\n        for env_name, env in kiara.current_environments.items()\n    }\n\n    result_pedigree = ValuePedigree(\n        kiara_id=kiara.id,\n        module_type=self.module_type_name,\n        module_config=self.config.dict(),\n        inputs={k: v.value_id for k, v in _inputs.items()},\n        environments=environments,\n    )\n\n    unique_result_values = self.characteristics.unique_result_values\n\n    outputs = ValueMapWritable.create_from_schema(\n        kiara=kiara,\n        schema=self.outputs_schema,\n        pedigree=result_pedigree,\n        unique_value_ids=unique_result_values,\n    )\n    job_log = JobLog()\n    self.process_step(inputs=_inputs, outputs=outputs, job_log=job_log)\n\n    return outputs\n</code></pre>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.process_step","title":"<code>process_step(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"<p>Kick off processing for a specific set of input/outputs.</p> <p>This method calls the implemented process method of the inheriting class, as well as wrapping input/output-data related functionality.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ValueMap</code> <p>the input value set</p> required <code>outputs</code> <code>ValueMap</code> <p>the output value set</p> required Source code in <code>kiara/modules/__init__.py</code> <pre><code>def process_step(\n    self, inputs: \"ValueMap\", outputs: \"ValueMap\", job_log: JobLog\n) -&gt; None:\n\"\"\"Kick off processing for a specific set of input/outputs.\n\n    This method calls the implemented [process][kiara.module.KiaraModule.process] method of the inheriting class,\n    as well as wrapping input/output-data related functionality.\n\n    Arguments:\n        inputs: the input value set\n        outputs: the output value set\n    \"\"\"\n\n    signature = inspect.signature(self.process)  # type: ignore\n\n    process_inputs: Dict[str, Any] = {\n        \"inputs\": inputs,\n        \"outputs\": outputs,\n    }\n\n    if \"job_log\" in signature.parameters.keys():\n        process_inputs[\"job_log\"] = job_log\n\n    try:\n        self.process(**process_inputs)  # type: ignore\n    except KiaraProcessingException as kpe:\n        log_exception(kpe)\n        raise kpe\n    except Exception as e:\n        log_exception(e)\n        raise KiaraProcessingException(e, module=self, inputs=inputs)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.modules.KiaraModule.create_renderable","title":"<code>create_renderable(**config) -&gt; RenderableType</code>","text":"Source code in <code>kiara/modules/__init__.py</code> <pre><code>def create_renderable(self, **config) -&gt; RenderableType:\n\n    return self.operation.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.Value","title":"<code>Value</code>","text":"<p>         Bases: <code>ValueDetails</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class Value(ValueDetails):\n\n    _kiara_model_id = \"instance.value\"\n\n    _value_data: Any = PrivateAttr(default=SpecialValue.NOT_SET)\n    _serialized_data: Union[None, str, SerializedData] = PrivateAttr(default=None)\n    _data_retrieved: bool = PrivateAttr(default=False)\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n    # _data_type: \"DataType\" = PrivateAttr(default=None)\n    _is_stored: bool = PrivateAttr(default=False)\n    _cached_properties: Union[\"ValueMap\", None] = PrivateAttr(default=None)\n    _lineage: Union[\"ValueLineage\", None] = PrivateAttr(default=None)\n\n    environment_hashes: Mapping[str, Mapping[str, str]] = Field(\n        description=\"Hashes for the environments this value was created in.\"\n    )\n    enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(\n        description=\"Information about the environments this value was created in.\",\n        default=None,\n    )\n    property_links: Mapping[str, uuid.UUID] = Field(\n        description=\"Links to values that are properties of this value.\",\n        default_factory=dict,\n    )\n    destiny_backlinks: Mapping[uuid.UUID, str] = Field(\n        description=\"Backlinks to values that this value acts as destiny/or property for.\",\n        default_factory=dict,\n    )\n\n    def add_property(\n        self,\n        value_id: Union[uuid.UUID, \"Value\"],\n        property_path: str,\n        add_origin_to_property_value: bool = True,\n    ):\n\n        value = None\n        try:\n            value_temp = value\n            value_id = value_id.value_id  # type: ignore\n            value = value_temp\n        except Exception:\n            # in case a Value object was provided\n            pass\n        finally:\n            del value_temp\n\n        if add_origin_to_property_value:\n            if value is None:\n                value = self._data_registry.get_value(value=value_id)  # type: ignore\n\n            if value._is_stored:\n                raise Exception(\n                    f\"Can't add property to value '{self.value_id}': referenced value '{value.value_id}' already locked, so it's not possible to add the property backlink (as requested).\"\n                )\n\n        assert value is not None\n\n        if self._is_stored:\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': value already locked.\"\n            )\n\n        if property_path in self.property_links.keys():\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': property '{property_path}' already set.\"\n            )\n\n        self.property_links[property_path] = value_id  # type: ignore\n\n        if add_origin_to_property_value:\n            value.add_destiny_details(\n                value_id=self.value_id, destiny_alias=property_path\n            )\n\n        self._cached_properties = None\n\n    def add_destiny_details(self, value_id: uuid.UUID, destiny_alias: str):\n\n        if self._is_stored:\n            raise Exception(\n                f\"Can't set destiny_refs to value '{self.value_id}': value already locked.\"\n            )\n\n        self.destiny_backlinks[value_id] = destiny_alias  # type: ignore\n\n    @property\n    def is_serializable(self) -&gt; bool:\n\n        try:\n            if self._serialized_data == NO_SERIALIZATION_MARKER:\n                return False\n            self.serialized_data\n            return True\n        except Exception:\n            pass\n\n        return False\n\n    # @property\n    # def data_type_class(self) -&gt; \"PythonClass\":\n    #     \"\"\"Return the (Python) type of the underlying 'DataType' subclass.\"\"\"\n    #     return self.data_type_info.data_type_class\n\n    @property\n    def serialized_data(self) -&gt; SerializedData:\n\n        # if not self.is_set:\n        #     raise Exception(f\"Can't retrieve serialized data: value not set.\")\n\n        if self._serialized_data is not None:\n            if isinstance(self._serialized_data, str):\n                raise Exception(\n                    f\"Data type '{self.data_type_name}' does not support serializing: {self._serialized_data}\"\n                )\n\n            return self._serialized_data\n\n        self._serialized_data = self._data_registry.retrieve_persisted_value_details(\n            self.value_id\n        )\n        return self._serialized_data\n\n    @property\n    def data(self) -&gt; Any:\n        if not self.is_initialized:\n            raise Exception(\n                f\"Can't retrieve data for value '{self.value_id}': value not initialized yet. This is most likely a bug.\"\n            )\n        try:\n            return self._retrieve_data()\n        except DataTypeUnknownException as dtue:\n            dtue._value = self\n            raise dtue\n\n    def _retrieve_data(self) -&gt; Any:\n\n        if self._value_data is not SpecialValue.NOT_SET:\n            return self._value_data\n\n        if self.value_status in [ValueStatus.NOT_SET, ValueStatus.NONE]:\n            self._value_data = None\n            return self._value_data\n        elif self.value_status not in [ValueStatus.SET, ValueStatus.DEFAULT]:\n            raise Exception(f\"Invalid internal state of value '{self.value_id}'.\")\n\n        retrieved = self._data_registry.retrieve_value_data(value=self)\n\n        if retrieved is None or isinstance(retrieved, SpecialValue):\n            raise Exception(\n                f\"Can't set value data, invalid data type: {type(retrieved)}\"\n            )\n\n        self._value_data = retrieved\n        self._data_retrieved = True\n        return self._value_data\n\n    # def retrieve_load_config(self) -&gt; Optional[LoadConfig]:\n    #     return self._data_registry.retrieve_persisted_value_details(\n    #         value_id=self.value_id\n    #     )\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(id={self.value_id}, type={self.data_type_name}, status={self.value_status.value}, initialized={self.is_initialized} optional={self.value_schema.optional})\"\n\n    def _set_registry(self, data_registry: \"DataRegistry\") -&gt; None:\n        self._data_registry = data_registry\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        result = not self.is_set or self._data_registry is not None\n        return result\n\n    @property\n    def is_stored(self) -&gt; bool:\n        return self._is_stored\n\n    @property\n    def data_type(self) -&gt; \"DataType\":\n\n        return self.data_type_info.data_type_instance\n\n    @property\n    def lineage(self) -&gt; \"ValueLineage\":\n        if self._lineage is not None:\n            return self._lineage\n\n        from kiara.models.values.lineage import ValueLineage\n\n        self._lineage = ValueLineage(kiara=self._data_registry._kiara, value=self)\n        return self._lineage\n\n    @property\n    def property_values(self) -&gt; \"ValueMap\":\n\n        if self._cached_properties is not None:\n            return self._cached_properties\n\n        self._cached_properties = self._data_registry.load_values(self.property_links)\n        return self._cached_properties\n\n    @property\n    def property_names(self) -&gt; Iterable[str]:\n        return self.property_links.keys()\n\n    def get_property_value(self, property_key) -&gt; \"Value\":\n\n        if property_key not in self.property_links.keys():\n            raise Exception(\n                f\"Value '{self.value_id}' has no property with key '{property_key}.\"\n            )\n\n        return self._data_registry.get_value(self.property_links[property_key])\n\n    def get_property_data(self, property_key: str) -&gt; Any:\n\n        try:\n            return self.get_property_value(property_key=property_key).data\n        except Exception as e:\n            log_exception(e)\n            return None\n\n    def get_all_property_data(self) -&gt; Mapping[str, Any]:\n\n        return {k: self.get_property_data(k) for k in self.property_names}\n\n    def lookup_self_aliases(self) -&gt; Set[str]:\n\n        if not self._data_registry:\n            raise Exception(\n                f\"Can't lookup aliases for value '{self.value_id}': data registry not set (yet).\"\n            )\n\n        return self._data_registry.lookup_aliases(self)\n\n    def create_info(self) -&gt; \"ValueInfo\":\n\n        if not self._data_registry:\n            raise Exception(\n                f\"Can't create info object for value '{self.value_id}': data registry not set (yet).\"\n            )\n\n        return self._data_registry.create_value_info(value=self.value_id)\n\n    def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n        show_pedigree = config.get(\"show_pedigree\", False)\n        show_lineage = config.get(\"show_lineage\", False)\n        show_properties = config.get(\"show_properties\", False)\n        # show_destinies = config.get(\"show_destinies\", False)\n        # show_destiny_backlinks = config.get(\"show_destiny_backlinks\", False)\n        # show_data = config.get(\"show_data_preview\", False)\n        show_serialized = config.get(\"show_serialized\", False)\n        show_env_data_hashes = config.get(\"show_environment_hashes\", False)\n        show_env_data = config.get(\"show_environment_data\", False)\n\n        ignore_fields = config.get(\"ignore_fields\", [])\n\n        table: Dict[str, Any] = {}\n\n        if \"value_id\" not in ignore_fields:\n            table[\"value_id\"] = self.value_id\n        if \"aliases\" not in ignore_fields:\n            if hasattr(self, \"aliases\"):\n                table[\"aliases\"] = self.aliases  # type: ignore\n\n        if \"kiara_id\" not in ignore_fields:\n            table[\"kiara_id\"] = self.kiara_id\n\n        for k in sorted(self.__fields__.keys()):\n\n            if (\n                k\n                in [\n                    \"serialized\",\n                    \"value_id\",\n                    \"aliases\",\n                    \"kiara_id\",\n                    \"environments\",\n                    \"lineage\",\n                    \"environment_hashes\",\n                ]\n                or k in ignore_fields\n            ):\n                continue\n\n            attr = getattr(self, k)\n            if k in [\"pedigree_output_name\", \"pedigree\"]:\n                continue\n            else:\n                v = attr\n\n            table[k] = v\n\n        if show_pedigree:\n            pedigree = getattr(self, \"pedigree\")\n\n            table[\"pedigree\"] = pedigree\n            if pedigree == ORPHAN:\n                pedigree_output_name: Union[Any, None] = None\n            else:\n                pedigree_output_name = getattr(self, \"pedigree_output_name\")\n\n            table[\"pedigree_output_name\"] = pedigree_output_name\n\n        if show_lineage:\n            table[\"lineage\"] = self.lineage\n\n        if show_serialized:\n            serialized = self._data_registry.retrieve_persisted_value_details(\n                self.value_id\n            )\n            table[\"serialized\"] = serialized\n\n        if show_env_data_hashes:\n            env_hashes = Syntax(\n                orjson_dumps(self.environment_hashes, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            table[\"environment_hashes\"] = env_hashes\n\n        if show_env_data:\n            raise NotImplementedError()\n\n        if show_properties:\n            if not self.property_links:\n                table[\"properties\"] = {}\n            else:\n                properties = self._data_registry.load_values(self.property_links)\n                table[\"properties\"] = properties\n\n        # if hasattr(self, \"destiny_links\") and show_destinies:\n        #     if not self.destiny_links:  # type: ignore\n        #         table[\"destinies\"] = {}\n        #     else:\n        #         destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n        #         table[\"destinies\"] = destinies\n        #\n        # if show_destiny_backlinks:\n        #     if not self.destiny_backlinks:\n        #         table[\"destiny backlinks\"] = {}\n        #     else:\n        #         destiny_items: List[Any] = []\n        #         for v_id, alias in self.destiny_backlinks.items():\n        #             destiny_items.append(\n        #                 f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n        #             )\n        #             rendered = self._data_registry.pretty_print_data(\n        #                 value_id=v_id, **config\n        #             )\n        #             destiny_items.append(rendered)\n        #         table[\"destiny backlinks\"] = destiny_items\n        #\n        # if show_data:\n        #     rendered = self._data_registry.pretty_print_data(\n        #         self.value_id, target_type=\"terminal_renderable\"\n        #     )\n        #     table[\"data preview\"] = rendered\n\n        return table\n\n    def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n        from kiara.utils.output import extract_renderable\n\n        show_pedigree = render_config.get(\"show_pedigree\", False)\n        show_lineage = render_config.get(\"show_lineage\", False)\n        show_properties = render_config.get(\"show_properties\", False)\n        show_destinies = render_config.get(\"show_destinies\", False)\n        show_destiny_backlinks = render_config.get(\"show_destiny_backlinks\", False)\n        show_data = render_config.get(\"show_data_preview\", False)\n        show_serialized = render_config.get(\"show_serialized\", False)\n        show_env_data_hashes = render_config.get(\"show_environment_hashes\", False)\n        show_env_data = render_config.get(\"show_environment_data\", False)\n\n        ignore_fields = render_config.get(\"ignore_fields\", [])\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n\n        info_data = self.create_info_data(**render_config)\n\n        if \"value_id\" not in ignore_fields:\n            table.add_row(\"value_id\", str(info_data[\"value_id\"]))\n        if \"aliases\" not in ignore_fields:\n            if info_data.get(\"aliases\", None):\n                aliases_str = \", \".join(info_data[\"aliases\"])  # type: ignore\n                table.add_row(\"aliases\", aliases_str)\n            # else:\n            #     aliases_str = \"-- n/a --\"\n            #     table.add_row(\"aliases\", aliases_str)\n\n        if \"kiara_id\" not in ignore_fields:\n            table.add_row(\"kiara_id\", str(info_data[\"kiara_id\"]))\n\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        for k in sorted(info_data.keys()):\n\n            if (\n                k\n                in [\n                    \"serialized\",\n                    \"value_id\",\n                    \"aliases\",\n                    \"kiara_id\",\n                    \"lineage\",\n                    \"environments\",\n                    \"environment_hashes\",\n                ]\n                or k in ignore_fields\n            ):\n                continue\n\n            attr = info_data[k]\n            if k in [\"pedigree_output_name\", \"pedigree\"]:\n                continue\n\n            elif k == \"value_status\":\n                v: RenderableType = f\"[i]-- {attr.value} --[/i]\"\n            elif k == \"value_size\":\n                v = format_size(attr)\n            else:\n                v = extract_renderable(attr)\n\n            table.add_row(k, v)\n\n        if (\n            show_pedigree\n            or show_lineage\n            or show_serialized\n            or show_properties\n            or show_destinies\n            or show_destiny_backlinks\n            or show_env_data_hashes\n            or show_env_data\n        ):\n            table.add_row(\"\", \"\")\n            table.add_row(\"\", Rule())\n            table.add_row(\"\", \"\")\n\n        if show_pedigree:\n            pedigree = info_data[\"pedigree\"]\n\n            if pedigree == ORPHAN:\n                v = \"[i]-- external data --[/i]\"\n                pedigree_output_name: Union[Any, None] = None\n            else:\n                v = extract_renderable(pedigree)\n                pedigree_output_name = info_data[\"pedigree_output_name\"]\n\n            row = [\"pedigree\", v]\n            table.add_row(*row)\n            if pedigree_output_name:\n                row = [\"pedigree_output_name\", pedigree_output_name]\n                table.add_row(*row)\n\n        if show_lineage:\n            table.add_row(\n                \"lineage\", info_data[\"lineage\"].create_renderable(include_ids=True)\n            )\n\n        if show_serialized:\n            serialized = info_data[\"serialized\"]\n            table.add_row(\"serialized\", serialized.create_renderable())\n\n        if show_env_data_hashes:\n            env_hashes = Syntax(\n                orjson_dumps(\n                    info_data[\"environment_hashes\"], option=orjson.OPT_INDENT_2\n                ),\n                \"json\",\n                background_color=\"default\",\n            )\n            table.add_row(\"environment_hashes\", env_hashes)\n\n        if show_env_data:\n            raise NotImplementedError()\n\n        if show_properties:\n            if not info_data[\"properties\"]:\n                table.add_row(\"properties\", \"{}\")\n            else:\n                properties = info_data[\"properties\"]\n                pr = properties.create_renderable(show_header=False)\n                table.add_row(\"properties\", pr)\n\n        if hasattr(self, \"destiny_links\") and show_destinies:\n            if not self.destiny_links:  # type: ignore\n                table.add_row(\"destinies\", \"{}\")\n            else:\n                destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n                dr = destinies.create_renderable(show_header=False)\n                table.add_row(\"destinies\", dr)\n\n        if show_destiny_backlinks:\n            if not self.destiny_backlinks:\n                table.add_row(\"destiny backlinks\", \"{}\")\n            else:\n                destiny_items: List[Any] = []\n                for v_id, alias in self.destiny_backlinks.items():\n                    destiny_items.append(Rule())\n                    destiny_items.append(\n                        f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n                    )\n                    rendered = self._data_registry.pretty_print_data(\n                        value_id=v_id, **render_config\n                    )\n                    destiny_items.append(rendered)\n                table.add_row(\"destiny backlinks\", Group(*destiny_items))\n\n        if show_data:\n            rendered = self._data_registry.pretty_print_data(\n                self.value_id, target_type=\"terminal_renderable\"\n            )\n            table.add_row(\"\", \"\")\n            table.add_row(\"\", Rule())\n            table.add_row(\"data preview\", rendered)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.Value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.environment_hashes","title":"<code>environment_hashes: Mapping[str, Mapping[str, str]] = Field(description='Hashes for the environments this value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.enviroments","title":"<code>enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(description='Information about the environments this value was created in.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.property_links","title":"<code>property_links: Mapping[str, uuid.UUID] = Field(description='Links to values that are properties of this value.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.destiny_backlinks","title":"<code>destiny_backlinks: Mapping[uuid.UUID, str] = Field(description='Backlinks to values that this value acts as destiny/or property for.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.is_serializable","title":"<code>is_serializable: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.serialized_data","title":"<code>serialized_data: SerializedData</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.data","title":"<code>data: Any</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.is_initialized","title":"<code>is_initialized: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.is_stored","title":"<code>is_stored: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.data_type","title":"<code>data_type: DataType</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.lineage","title":"<code>lineage: ValueLineage</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.property_values","title":"<code>property_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.property_names","title":"<code>property_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.api.Value-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.Value.add_property","title":"<code>add_property(value_id: Union[uuid.UUID, Value], property_path: str, add_origin_to_property_value: bool = True)</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def add_property(\n    self,\n    value_id: Union[uuid.UUID, \"Value\"],\n    property_path: str,\n    add_origin_to_property_value: bool = True,\n):\n\n    value = None\n    try:\n        value_temp = value\n        value_id = value_id.value_id  # type: ignore\n        value = value_temp\n    except Exception:\n        # in case a Value object was provided\n        pass\n    finally:\n        del value_temp\n\n    if add_origin_to_property_value:\n        if value is None:\n            value = self._data_registry.get_value(value=value_id)  # type: ignore\n\n        if value._is_stored:\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': referenced value '{value.value_id}' already locked, so it's not possible to add the property backlink (as requested).\"\n            )\n\n    assert value is not None\n\n    if self._is_stored:\n        raise Exception(\n            f\"Can't add property to value '{self.value_id}': value already locked.\"\n        )\n\n    if property_path in self.property_links.keys():\n        raise Exception(\n            f\"Can't add property to value '{self.value_id}': property '{property_path}' already set.\"\n        )\n\n    self.property_links[property_path] = value_id  # type: ignore\n\n    if add_origin_to_property_value:\n        value.add_destiny_details(\n            value_id=self.value_id, destiny_alias=property_path\n        )\n\n    self._cached_properties = None\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.add_destiny_details","title":"<code>add_destiny_details(value_id: uuid.UUID, destiny_alias: str)</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def add_destiny_details(self, value_id: uuid.UUID, destiny_alias: str):\n\n    if self._is_stored:\n        raise Exception(\n            f\"Can't set destiny_refs to value '{self.value_id}': value already locked.\"\n        )\n\n    self.destiny_backlinks[value_id] = destiny_alias  # type: ignore\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.get_property_value","title":"<code>get_property_value(property_key) -&gt; Value</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_property_value(self, property_key) -&gt; \"Value\":\n\n    if property_key not in self.property_links.keys():\n        raise Exception(\n            f\"Value '{self.value_id}' has no property with key '{property_key}.\"\n        )\n\n    return self._data_registry.get_value(self.property_links[property_key])\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.get_property_data","title":"<code>get_property_data(property_key: str) -&gt; Any</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_property_data(self, property_key: str) -&gt; Any:\n\n    try:\n        return self.get_property_value(property_key=property_key).data\n    except Exception as e:\n        log_exception(e)\n        return None\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.get_all_property_data","title":"<code>get_all_property_data() -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_property_data(self) -&gt; Mapping[str, Any]:\n\n    return {k: self.get_property_data(k) for k in self.property_names}\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.lookup_self_aliases","title":"<code>lookup_self_aliases() -&gt; Set[str]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def lookup_self_aliases(self) -&gt; Set[str]:\n\n    if not self._data_registry:\n        raise Exception(\n            f\"Can't lookup aliases for value '{self.value_id}': data registry not set (yet).\"\n        )\n\n    return self._data_registry.lookup_aliases(self)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.create_info","title":"<code>create_info() -&gt; ValueInfo</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_info(self) -&gt; \"ValueInfo\":\n\n    if not self._data_registry:\n        raise Exception(\n            f\"Can't create info object for value '{self.value_id}': data registry not set (yet).\"\n        )\n\n    return self._data_registry.create_value_info(value=self.value_id)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.create_info_data","title":"<code>create_info_data(**config: Any) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n    show_pedigree = config.get(\"show_pedigree\", False)\n    show_lineage = config.get(\"show_lineage\", False)\n    show_properties = config.get(\"show_properties\", False)\n    # show_destinies = config.get(\"show_destinies\", False)\n    # show_destiny_backlinks = config.get(\"show_destiny_backlinks\", False)\n    # show_data = config.get(\"show_data_preview\", False)\n    show_serialized = config.get(\"show_serialized\", False)\n    show_env_data_hashes = config.get(\"show_environment_hashes\", False)\n    show_env_data = config.get(\"show_environment_data\", False)\n\n    ignore_fields = config.get(\"ignore_fields\", [])\n\n    table: Dict[str, Any] = {}\n\n    if \"value_id\" not in ignore_fields:\n        table[\"value_id\"] = self.value_id\n    if \"aliases\" not in ignore_fields:\n        if hasattr(self, \"aliases\"):\n            table[\"aliases\"] = self.aliases  # type: ignore\n\n    if \"kiara_id\" not in ignore_fields:\n        table[\"kiara_id\"] = self.kiara_id\n\n    for k in sorted(self.__fields__.keys()):\n\n        if (\n            k\n            in [\n                \"serialized\",\n                \"value_id\",\n                \"aliases\",\n                \"kiara_id\",\n                \"environments\",\n                \"lineage\",\n                \"environment_hashes\",\n            ]\n            or k in ignore_fields\n        ):\n            continue\n\n        attr = getattr(self, k)\n        if k in [\"pedigree_output_name\", \"pedigree\"]:\n            continue\n        else:\n            v = attr\n\n        table[k] = v\n\n    if show_pedigree:\n        pedigree = getattr(self, \"pedigree\")\n\n        table[\"pedigree\"] = pedigree\n        if pedigree == ORPHAN:\n            pedigree_output_name: Union[Any, None] = None\n        else:\n            pedigree_output_name = getattr(self, \"pedigree_output_name\")\n\n        table[\"pedigree_output_name\"] = pedigree_output_name\n\n    if show_lineage:\n        table[\"lineage\"] = self.lineage\n\n    if show_serialized:\n        serialized = self._data_registry.retrieve_persisted_value_details(\n            self.value_id\n        )\n        table[\"serialized\"] = serialized\n\n    if show_env_data_hashes:\n        env_hashes = Syntax(\n            orjson_dumps(self.environment_hashes, option=orjson.OPT_INDENT_2),\n            \"json\",\n            background_color=\"default\",\n        )\n        table[\"environment_hashes\"] = env_hashes\n\n    if show_env_data:\n        raise NotImplementedError()\n\n    if show_properties:\n        if not self.property_links:\n            table[\"properties\"] = {}\n        else:\n            properties = self._data_registry.load_values(self.property_links)\n            table[\"properties\"] = properties\n\n    # if hasattr(self, \"destiny_links\") and show_destinies:\n    #     if not self.destiny_links:  # type: ignore\n    #         table[\"destinies\"] = {}\n    #     else:\n    #         destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n    #         table[\"destinies\"] = destinies\n    #\n    # if show_destiny_backlinks:\n    #     if not self.destiny_backlinks:\n    #         table[\"destiny backlinks\"] = {}\n    #     else:\n    #         destiny_items: List[Any] = []\n    #         for v_id, alias in self.destiny_backlinks.items():\n    #             destiny_items.append(\n    #                 f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n    #             )\n    #             rendered = self._data_registry.pretty_print_data(\n    #                 value_id=v_id, **config\n    #             )\n    #             destiny_items.append(rendered)\n    #         table[\"destiny backlinks\"] = destiny_items\n    #\n    # if show_data:\n    #     rendered = self._data_registry.pretty_print_data(\n    #         self.value_id, target_type=\"terminal_renderable\"\n    #     )\n    #     table[\"data preview\"] = rendered\n\n    return table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.Value.create_renderable","title":"<code>create_renderable(**render_config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n    from kiara.utils.output import extract_renderable\n\n    show_pedigree = render_config.get(\"show_pedigree\", False)\n    show_lineage = render_config.get(\"show_lineage\", False)\n    show_properties = render_config.get(\"show_properties\", False)\n    show_destinies = render_config.get(\"show_destinies\", False)\n    show_destiny_backlinks = render_config.get(\"show_destiny_backlinks\", False)\n    show_data = render_config.get(\"show_data_preview\", False)\n    show_serialized = render_config.get(\"show_serialized\", False)\n    show_env_data_hashes = render_config.get(\"show_environment_hashes\", False)\n    show_env_data = render_config.get(\"show_environment_data\", False)\n\n    ignore_fields = render_config.get(\"ignore_fields\", [])\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Key\", style=\"i\")\n    table.add_column(\"Value\")\n\n    info_data = self.create_info_data(**render_config)\n\n    if \"value_id\" not in ignore_fields:\n        table.add_row(\"value_id\", str(info_data[\"value_id\"]))\n    if \"aliases\" not in ignore_fields:\n        if info_data.get(\"aliases\", None):\n            aliases_str = \", \".join(info_data[\"aliases\"])  # type: ignore\n            table.add_row(\"aliases\", aliases_str)\n        # else:\n        #     aliases_str = \"-- n/a --\"\n        #     table.add_row(\"aliases\", aliases_str)\n\n    if \"kiara_id\" not in ignore_fields:\n        table.add_row(\"kiara_id\", str(info_data[\"kiara_id\"]))\n\n    table.add_row(\"\", \"\")\n    table.add_row(\"\", Rule())\n    for k in sorted(info_data.keys()):\n\n        if (\n            k\n            in [\n                \"serialized\",\n                \"value_id\",\n                \"aliases\",\n                \"kiara_id\",\n                \"lineage\",\n                \"environments\",\n                \"environment_hashes\",\n            ]\n            or k in ignore_fields\n        ):\n            continue\n\n        attr = info_data[k]\n        if k in [\"pedigree_output_name\", \"pedigree\"]:\n            continue\n\n        elif k == \"value_status\":\n            v: RenderableType = f\"[i]-- {attr.value} --[/i]\"\n        elif k == \"value_size\":\n            v = format_size(attr)\n        else:\n            v = extract_renderable(attr)\n\n        table.add_row(k, v)\n\n    if (\n        show_pedigree\n        or show_lineage\n        or show_serialized\n        or show_properties\n        or show_destinies\n        or show_destiny_backlinks\n        or show_env_data_hashes\n        or show_env_data\n    ):\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        table.add_row(\"\", \"\")\n\n    if show_pedigree:\n        pedigree = info_data[\"pedigree\"]\n\n        if pedigree == ORPHAN:\n            v = \"[i]-- external data --[/i]\"\n            pedigree_output_name: Union[Any, None] = None\n        else:\n            v = extract_renderable(pedigree)\n            pedigree_output_name = info_data[\"pedigree_output_name\"]\n\n        row = [\"pedigree\", v]\n        table.add_row(*row)\n        if pedigree_output_name:\n            row = [\"pedigree_output_name\", pedigree_output_name]\n            table.add_row(*row)\n\n    if show_lineage:\n        table.add_row(\n            \"lineage\", info_data[\"lineage\"].create_renderable(include_ids=True)\n        )\n\n    if show_serialized:\n        serialized = info_data[\"serialized\"]\n        table.add_row(\"serialized\", serialized.create_renderable())\n\n    if show_env_data_hashes:\n        env_hashes = Syntax(\n            orjson_dumps(\n                info_data[\"environment_hashes\"], option=orjson.OPT_INDENT_2\n            ),\n            \"json\",\n            background_color=\"default\",\n        )\n        table.add_row(\"environment_hashes\", env_hashes)\n\n    if show_env_data:\n        raise NotImplementedError()\n\n    if show_properties:\n        if not info_data[\"properties\"]:\n            table.add_row(\"properties\", \"{}\")\n        else:\n            properties = info_data[\"properties\"]\n            pr = properties.create_renderable(show_header=False)\n            table.add_row(\"properties\", pr)\n\n    if hasattr(self, \"destiny_links\") and show_destinies:\n        if not self.destiny_links:  # type: ignore\n            table.add_row(\"destinies\", \"{}\")\n        else:\n            destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n            dr = destinies.create_renderable(show_header=False)\n            table.add_row(\"destinies\", dr)\n\n    if show_destiny_backlinks:\n        if not self.destiny_backlinks:\n            table.add_row(\"destiny backlinks\", \"{}\")\n        else:\n            destiny_items: List[Any] = []\n            for v_id, alias in self.destiny_backlinks.items():\n                destiny_items.append(Rule())\n                destiny_items.append(\n                    f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n                )\n                rendered = self._data_registry.pretty_print_data(\n                    value_id=v_id, **render_config\n                )\n                destiny_items.append(rendered)\n            table.add_row(\"destiny backlinks\", Group(*destiny_items))\n\n    if show_data:\n        rendered = self._data_registry.pretty_print_data(\n            self.value_id, target_type=\"terminal_renderable\"\n        )\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        table.add_row(\"data preview\", rendered)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.ValueMap","title":"<code>ValueMap</code>","text":"<p>         Bases: <code>KiaraModel</code>, <code>MutableMapping[str, Value]</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValueMap(KiaraModel, MutableMapping[str, Value]):  # type: ignore\n\n    values_schema: Dict[str, ValueSchema] = Field(\n        description=\"The schemas for all the values in this set.\"\n    )\n\n    @property\n    def field_names(self) -&gt; Iterable[str]:\n        return sorted(self.values_schema.keys())\n\n    @abc.abstractmethod\n    def get_value_obj(self, field_name: str) -&gt; Value:\n        pass\n\n    @property\n    def all_items_valid(self) -&gt; bool:\n        for field_name in self.values_schema.keys():\n            item = self.get_value_obj(field_name)\n            if not item.is_valid:\n                return False\n        return True\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            k: self.get_value_obj(k).instance_cid for k in self.values_schema.keys()\n        }\n\n    def check_invalid(self) -&gt; Dict[str, str]:\n\"\"\"Check whether the value set is invalid, if it is, return a description of what's wrong.\"\"\"\n\n        invalid: Dict[str, str] = {}\n        for field_name in self.values_schema.keys():\n\n            item = self.get_value_obj(field_name)\n            field_schema = self.values_schema[field_name]\n            if not field_schema.optional:\n                msg: Union[str, None] = None\n                if not item.value_status == ValueStatus.SET:\n\n                    item_schema = self.values_schema[field_name]\n                    if item_schema.is_required():\n\n                        if not item.is_set:\n                            msg = \"not set\"\n                        elif item.value_status == ValueStatus.NONE:\n                            msg = \"no value\"\n                if msg:\n                    invalid[field_name] = msg\n\n        return invalid\n\n    def get_value_data_for_fields(\n        self, *field_names: str, raise_exception_when_unset: bool = False\n    ) -&gt; Dict[str, Any]:\n\"\"\"Return the data for a one or several fields of this ValueMap.\n\n        If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True',\n        in which case an Exception will be raised (obviously).\n        \"\"\"\n\n        if raise_exception_when_unset:\n            unset: List[str] = []\n            for k in field_names:\n                v = self.get_value_obj(k)\n                if not v.is_set:\n                    if raise_exception_when_unset:\n                        unset.append(k)\n            if unset:\n                raise Exception(\n                    f\"Can't get data for fields, one or several of the requested fields are not set yet: {', '.join(unset)}.\"\n                )\n\n        result: Dict[str, Any] = {}\n        for k in field_names:\n            v = self.get_value_obj(k)\n            if not v.is_set:\n                result[k] = None\n            else:\n                result[k] = v.data\n        return result\n\n    def get_value_data(\n        self, field_name: str, raise_exception_when_unset: bool = False\n    ) -&gt; Any:\n        return self.get_value_data_for_fields(\n            field_name, raise_exception_when_unset=raise_exception_when_unset\n        )[field_name]\n\n    def get_all_value_ids(self) -&gt; Dict[str, uuid.UUID]:\n        return {k: self.get_value_obj(k).value_id for k in self.field_names}\n\n    def get_all_value_data(\n        self, raise_exception_when_unset: bool = False\n    ) -&gt; Dict[str, Any]:\n        return self.get_value_data_for_fields(\n            *self.field_names,\n            raise_exception_when_unset=raise_exception_when_unset,\n        )\n\n    def set_values(self, **values) -&gt; None:\n\n        for k, v in values.items():\n            self.set_value(k, v)\n\n    def set_value(self, field_name: str, data: Any) -&gt; None:\n        raise Exception(\n            f\"The value set implementation '{self.__class__.__name__}' is read-only, and does not support the setting or changing of values.\"\n        )\n\n    def __getitem__(self, item: str) -&gt; Value:\n\n        return self.get_value_obj(item)\n\n    def __setitem__(self, key: str, value):\n\n        raise NotImplementedError()\n        # self.set_value(key, value)\n\n    def __delitem__(self, key: str):\n\n        raise Exception(f\"Removing items not supported: {key}\")\n\n    def __iter__(self):\n        return iter(self.field_names)\n\n    def __len__(self):\n        return len(list(self.values_schema))\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(field_names={self.field_names})\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def create_invalid_renderable(self, **config) -&gt; Union[RenderableType, None]:\n\n        inv = self.check_invalid()\n        if not inv:\n            return None\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"field name\", style=\"i\")\n        table.add_column(\"details\", style=\"b red\")\n\n        for field, err in inv.items():\n            table.add_row(field, err)\n\n        return table\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        in_panel = config.get(\"in_panel\", None)\n        if in_panel is None:\n            if is_jupyter():\n                in_panel = True\n            else:\n                in_panel = False\n\n        render_value_data = config.get(\"render_value_data\", True)\n        field_title = config.get(\"field_title\", \"field\")\n        value_title = config.get(\"value_title\", \"value\")\n        show_header = config.get(\"show_header\", True)\n        show_type = config.get(\"show_data_type\", False)\n\n        table = Table(show_lines=False, show_header=show_header, box=box.SIMPLE)\n        table.add_column(field_title, style=\"b\")\n        if show_type:\n            table.add_column(\"data_type\")\n        table.add_column(value_title, style=\"i\")\n\n        for field_name in self.field_names:\n\n            value = self.get_value_obj(field_name=field_name)\n            if render_value_data:\n                rendered = value._data_registry.pretty_print_data(\n                    value_id=value.value_id, target_type=\"terminal_renderable\", **config\n                )\n            else:\n                rendered = value.create_renderable(**config)\n\n            if show_type:\n                table.add_row(field_name, value.value_schema.type, rendered)\n            else:\n                table.add_row(field_name, rendered)\n\n        if in_panel:\n            return Panel(table)\n        else:\n            return table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.api.ValueMap-attributes","title":"Attributes","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.values_schema","title":"<code>values_schema: Dict[str, ValueSchema] = Field(description='The schemas for all the values in this set.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.field_names","title":"<code>field_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.all_items_valid","title":"<code>all_items_valid: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/api/#kiara.api.ValueMap-functions","title":"Functions","text":""},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.get_value_obj","title":"<code>get_value_obj(field_name: str) -&gt; Value</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_value_obj(self, field_name: str) -&gt; Value:\n    pass\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.check_invalid","title":"<code>check_invalid() -&gt; Dict[str, str]</code>","text":"<p>Check whether the value set is invalid, if it is, return a description of what's wrong.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def check_invalid(self) -&gt; Dict[str, str]:\n\"\"\"Check whether the value set is invalid, if it is, return a description of what's wrong.\"\"\"\n\n    invalid: Dict[str, str] = {}\n    for field_name in self.values_schema.keys():\n\n        item = self.get_value_obj(field_name)\n        field_schema = self.values_schema[field_name]\n        if not field_schema.optional:\n            msg: Union[str, None] = None\n            if not item.value_status == ValueStatus.SET:\n\n                item_schema = self.values_schema[field_name]\n                if item_schema.is_required():\n\n                    if not item.is_set:\n                        msg = \"not set\"\n                    elif item.value_status == ValueStatus.NONE:\n                        msg = \"no value\"\n            if msg:\n                invalid[field_name] = msg\n\n    return invalid\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.get_value_data_for_fields","title":"<code>get_value_data_for_fields(*field_names: str, raise_exception_when_unset: bool = False) -&gt; Dict[str, Any]</code>","text":"<p>Return the data for a one or several fields of this ValueMap.</p> <p>If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True', in which case an Exception will be raised (obviously).</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_data_for_fields(\n    self, *field_names: str, raise_exception_when_unset: bool = False\n) -&gt; Dict[str, Any]:\n\"\"\"Return the data for a one or several fields of this ValueMap.\n\n    If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True',\n    in which case an Exception will be raised (obviously).\n    \"\"\"\n\n    if raise_exception_when_unset:\n        unset: List[str] = []\n        for k in field_names:\n            v = self.get_value_obj(k)\n            if not v.is_set:\n                if raise_exception_when_unset:\n                    unset.append(k)\n        if unset:\n            raise Exception(\n                f\"Can't get data for fields, one or several of the requested fields are not set yet: {', '.join(unset)}.\"\n            )\n\n    result: Dict[str, Any] = {}\n    for k in field_names:\n        v = self.get_value_obj(k)\n        if not v.is_set:\n            result[k] = None\n        else:\n            result[k] = v.data\n    return result\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.get_value_data","title":"<code>get_value_data(field_name: str, raise_exception_when_unset: bool = False) -&gt; Any</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_data(\n    self, field_name: str, raise_exception_when_unset: bool = False\n) -&gt; Any:\n    return self.get_value_data_for_fields(\n        field_name, raise_exception_when_unset=raise_exception_when_unset\n    )[field_name]\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.get_all_value_ids","title":"<code>get_all_value_ids() -&gt; Dict[str, uuid.UUID]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_value_ids(self) -&gt; Dict[str, uuid.UUID]:\n    return {k: self.get_value_obj(k).value_id for k in self.field_names}\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.get_all_value_data","title":"<code>get_all_value_data(raise_exception_when_unset: bool = False) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_value_data(\n    self, raise_exception_when_unset: bool = False\n) -&gt; Dict[str, Any]:\n    return self.get_value_data_for_fields(\n        *self.field_names,\n        raise_exception_when_unset=raise_exception_when_unset,\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.set_values","title":"<code>set_values(**values) -&gt; None</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def set_values(self, **values) -&gt; None:\n\n    for k, v in values.items():\n        self.set_value(k, v)\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.set_value","title":"<code>set_value(field_name: str, data: Any) -&gt; None</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def set_value(self, field_name: str, data: Any) -&gt; None:\n    raise Exception(\n        f\"The value set implementation '{self.__class__.__name__}' is read-only, and does not support the setting or changing of values.\"\n    )\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.create_invalid_renderable","title":"<code>create_invalid_renderable(**config) -&gt; Union[RenderableType, None]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_invalid_renderable(self, **config) -&gt; Union[RenderableType, None]:\n\n    inv = self.check_invalid()\n    if not inv:\n        return None\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"field name\", style=\"i\")\n    table.add_column(\"details\", style=\"b red\")\n\n    for field, err in inv.items():\n        table.add_row(field, err)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/api/#kiara.models.values.value.ValueMap.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    in_panel = config.get(\"in_panel\", None)\n    if in_panel is None:\n        if is_jupyter():\n            in_panel = True\n        else:\n            in_panel = False\n\n    render_value_data = config.get(\"render_value_data\", True)\n    field_title = config.get(\"field_title\", \"field\")\n    value_title = config.get(\"value_title\", \"value\")\n    show_header = config.get(\"show_header\", True)\n    show_type = config.get(\"show_data_type\", False)\n\n    table = Table(show_lines=False, show_header=show_header, box=box.SIMPLE)\n    table.add_column(field_title, style=\"b\")\n    if show_type:\n        table.add_column(\"data_type\")\n    table.add_column(value_title, style=\"i\")\n\n    for field_name in self.field_names:\n\n        value = self.get_value_obj(field_name=field_name)\n        if render_value_data:\n            rendered = value._data_registry.pretty_print_data(\n                value_id=value.value_id, target_type=\"terminal_renderable\", **config\n            )\n        else:\n            rendered = value.create_renderable(**config)\n\n        if show_type:\n            table.add_row(field_name, value.value_schema.type, rendered)\n        else:\n            table.add_row(field_name, rendered)\n\n    if in_panel:\n        return Panel(table)\n    else:\n        return table\n</code></pre>"},{"location":"reference/kiara/defaults/","title":"defaults","text":""},{"location":"reference/kiara/defaults/#kiara.defaults-attributes","title":"Attributes","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.kiara_app_dirs","title":"<code>kiara_app_dirs = AppDirs('kiara', 'DHARPA')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_CONFIG_FILE_NAME","title":"<code>KIARA_CONFIG_FILE_NAME = 'kiara.config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_DEV_CONFIG_FILE_NAME","title":"<code>KIARA_DEV_CONFIG_FILE_NAME = 'dev.config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_MAIN_CONFIG_FILE","title":"<code>KIARA_MAIN_CONFIG_FILE = os.path.join(kiara_app_dirs.user_config_dir, KIARA_CONFIG_FILE_NAME)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_DEV_CONFIG_FILE","title":"<code>KIARA_DEV_CONFIG_FILE = os.path.join(kiara_app_dirs.user_config_dir, KIARA_DEV_CONFIG_FILE_NAME)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_MAIN_CONTEXTS_PATH","title":"<code>KIARA_MAIN_CONTEXTS_PATH = os.path.join(kiara_app_dirs.user_config_dir, 'contexts')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_TYPE_KEY","title":"<code>MODULE_TYPE_KEY = 'module_type'</code>  <code>module-attribute</code>","text":"<p>The key to specify the type of a module.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.STEP_ID_KEY","title":"<code>STEP_ID_KEY = 'step_id'</code>  <code>module-attribute</code>","text":"<p>The key to specify the step id.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.INVALID_VALUE_NAMES","title":"<code>INVALID_VALUE_NAMES = ['kiara', 'callbacks']</code>  <code>module-attribute</code>","text":"<p>List of reserved names, inputs/outputs can't use those.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_DATA_STORE_MARKER","title":"<code>DEFAULT_DATA_STORE_MARKER = 'default_data_store'</code>  <code>module-attribute</code>","text":"<p>Name for the default context data store.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_JOB_STORE_MARKER","title":"<code>DEFAULT_JOB_STORE_MARKER = 'default_job_store'</code>  <code>module-attribute</code>","text":"<p>Name for the default context job store.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_ALIAS_STORE_MARKER","title":"<code>DEFAULT_ALIAS_STORE_MARKER = 'default_alias_store'</code>  <code>module-attribute</code>","text":"<p>Name for the default context alias store.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_WORKFLOW_STORE_MARKER","title":"<code>DEFAULT_WORKFLOW_STORE_MARKER = 'default_workflow_store'</code>  <code>module-attribute</code>","text":"<p>Name for the default context workflow store.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.METADATA_DESTINY_STORE_MARKER","title":"<code>METADATA_DESTINY_STORE_MARKER = 'metadata'</code>  <code>module-attribute</code>","text":"<p>Name for the default context destiny store.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_PARENT_MARKER","title":"<code>PIPELINE_PARENT_MARKER = '__pipeline__'</code>  <code>module-attribute</code>","text":"<p>Marker string in the pipeline structure that indicates a parent pipeline element.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_EXCLUDE_DIRS","title":"<code>DEFAULT_EXCLUDE_DIRS = ['.git', '.tox', '.cache']</code>  <code>module-attribute</code>","text":"<p>List of directory names to exclude by default when walking a folder recursively.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_EXCLUDE_FILES","title":"<code>DEFAULT_EXCLUDE_FILES = ['.DS_Store']</code>  <code>module-attribute</code>","text":"<p>List of file names to exclude by default when reading folders.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.VALID_PIPELINE_FILE_EXTENSIONS","title":"<code>VALID_PIPELINE_FILE_EXTENSIONS = ['yaml', 'yml', 'json']</code>  <code>module-attribute</code>","text":"<p>File extensions a kiara pipeline/workflow file can have.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_TYPE_NAME_KEY","title":"<code>MODULE_TYPE_NAME_KEY = 'module_type_name'</code>  <code>module-attribute</code>","text":"<p>The string for the module type name in a module configuration dict.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_PIPELINE_PARENT_ID","title":"<code>DEFAULT_PIPELINE_PARENT_ID = '__kiara__'</code>  <code>module-attribute</code>","text":"<p>Default parent id for pipeline objects that are not associated with a workflow.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_NO_DESC_VALUE","title":"<code>DEFAULT_NO_DESC_VALUE = '-- n/a --'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NOT_AVAILBLE_MARKER","title":"<code>NOT_AVAILBLE_MARKER = '-- n/a --'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_MODULE_METADATA_ATTRIBUTE","title":"<code>KIARA_MODULE_METADATA_ATTRIBUTE = 'KIARA_METADATA'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_DEFAULT_ROOT_NODE_ID","title":"<code>KIARA_DEFAULT_ROOT_NODE_ID = '__self__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_PRETTY_PRINT_CONFIG","title":"<code>DEFAULT_PRETTY_PRINT_CONFIG = {'max_no_rows': 32, 'max_row_height': 1, 'max_cell_length': 80}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NO_HASH_MARKER","title":"<code>NO_HASH_MARKER = '--no-hash--'</code>  <code>module-attribute</code>","text":"<p>Marker string to indicate no hash was calculated.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.NO_VALUE_ID_MARKER","title":"<code>NO_VALUE_ID_MARKER = '--no-value-id--'</code>  <code>module-attribute</code>","text":"<p>Marker string to indicate no value id exists.</p>"},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_TO_JSON_CONFIG","title":"<code>DEFAULT_TO_JSON_CONFIG: typing.Mapping[str, typing.Any] = {'indent': 2}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.COLOR_LIST","title":"<code>COLOR_LIST = ['green', 'blue', 'bright_magenta', 'dark_red', 'gold3', 'cyan', 'orange1', 'light_yellow3', 'light_slate_grey', 'deep_pink4']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VOID_KIARA_ID","title":"<code>VOID_KIARA_ID = uuid.UUID('00000000-0000-0000-0000-000000000000')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NOT_SET_VALUE_ID","title":"<code>NOT_SET_VALUE_ID = uuid.UUID('00000000-0000-0000-0000-000000000001')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NONE_VALUE_ID","title":"<code>NONE_VALUE_ID = uuid.UUID('00000000-0000-0000-0000-000000000002')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NONE_STORE_ID","title":"<code>NONE_STORE_ID = uuid.UUID('00000000-0000-0000-0000-000000000003')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.ORPHAN_PEDIGREE_OUTPUT_NAME","title":"<code>ORPHAN_PEDIGREE_OUTPUT_NAME = '__orphan__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NO_MODULE_TYPE","title":"<code>NO_MODULE_TYPE = 'EXTERNAL_DATA'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.INVALID_HASH_MARKER","title":"<code>INVALID_HASH_MARKER = ''</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.INVALID_SIZE_MARKER","title":"<code>INVALID_SIZE_MARKER = -1</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.NO_SERIALIZATION_MARKER","title":"<code>NO_SERIALIZATION_MARKER = '-- serialization not supported --'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_ROOT_TYPE_NAME","title":"<code>KIARA_ROOT_TYPE_NAME = '__kiara__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.SERIALIZED_DATA_TYPE_NAME","title":"<code>SERIALIZED_DATA_TYPE_NAME = 'serialized_data'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.LOAD_CONFIG_DATA_TYPE_NAME","title":"<code>LOAD_CONFIG_DATA_TYPE_NAME = 'load_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PYDANTIC_USE_CONSTRUCT","title":"<code>PYDANTIC_USE_CONSTRUCT: bool = False</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.STRICT_CHECKS","title":"<code>STRICT_CHECKS: bool = False</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.KIARA_HASH_FUNCTION","title":"<code>KIARA_HASH_FUNCTION = mmh3.hash</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.ANY_TYPE_NAME","title":"<code>ANY_TYPE_NAME = 'any'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_ENV_HASH_KEY","title":"<code>DEFAULT_ENV_HASH_KEY = 'default'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.LOAD_CONFIG_PLACEHOLDER","title":"<code>LOAD_CONFIG_PLACEHOLDER = '__placeholder__'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DATA_TYPE_CATEGORY_ID","title":"<code>DATA_TYPE_CATEGORY_ID = 'metadata.type'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DATA_TYPES_CATEGORY_ID","title":"<code>DATA_TYPES_CATEGORY_ID = 'data_types'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DATA_TYPE_CLASS_CATEGORY_ID","title":"<code>DATA_TYPE_CLASS_CATEGORY_ID = 'data_type_class'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DATA_WRAP_CATEGORY_ID","title":"<code>DATA_WRAP_CATEGORY_ID = 'instance.datawrap'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.UNOLOADABLE_DATA_CATEGORY_ID","title":"<code>UNOLOADABLE_DATA_CATEGORY_ID = 'instance.unloadable_data'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VALUE_CATEGORY_ID","title":"<code>VALUE_CATEGORY_ID = 'instance.value'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VALUES_CATEGORY_ID","title":"<code>VALUES_CATEGORY_ID = 'instance.values'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VALUE_METADATA_CATEGORY_ID","title":"<code>VALUE_METADATA_CATEGORY_ID = 'instance.value_metadata'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_CONFIG_SCHEMA_CATEGORY_ID","title":"<code>MODULE_CONFIG_SCHEMA_CATEGORY_ID = 'module_config_schema'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_CONFIG_CATEGORY_ID","title":"<code>MODULE_CONFIG_CATEGORY_ID = 'module_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_CONFIG_METADATA_CATEGORY_ID","title":"<code>MODULE_CONFIG_METADATA_CATEGORY_ID = 'metadata.module_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_TYPE_CATEGORY_ID","title":"<code>MODULE_TYPE_CATEGORY_ID = 'metadata.module'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.MODULE_TYPES_CATEGORY_ID","title":"<code>MODULE_TYPES_CATEGORY_ID = 'modules'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.BATCH_CONFIG_TYPE_CATEGORY_ID","title":"<code>BATCH_CONFIG_TYPE_CATEGORY_ID = 'instance.batch_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_TYPE_CATEGORY_ID","title":"<code>PIPELINE_TYPE_CATEGORY_ID = 'metadata.pipeline'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_TYPES_CATEGORY_ID","title":"<code>PIPELINE_TYPES_CATEGORY_ID = 'pipelines'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_STEP_TYPE_CATEGORY_ID","title":"<code>PIPELINE_STEP_TYPE_CATEGORY_ID = 'instance.pipeline_step'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_CONFIG_TYPE_CATEGORY_ID","title":"<code>PIPELINE_CONFIG_TYPE_CATEGORY_ID = 'instance.pipeline_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_STRUCTURE_TYPE_CATEGORY_ID","title":"<code>PIPELINE_STRUCTURE_TYPE_CATEGORY_ID = 'instance.pipeline_structure'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.PIPELINE_STEP_DETAILS_CATEGORY_ID","title":"<code>PIPELINE_STEP_DETAILS_CATEGORY_ID = 'instance.pipeline_step_details'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_TYPE_CATEGORY_ID","title":"<code>OPERATION_TYPE_CATEGORY_ID = 'metadata.operation_type'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_TYPES_CATEGORY_ID","title":"<code>OPERATION_TYPES_CATEGORY_ID = 'operation_types'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATIONS_CATEGORY_ID","title":"<code>OPERATIONS_CATEGORY_ID = 'operations'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_CATEOGORY_ID","title":"<code>OPERATION_CATEOGORY_ID = 'instance.operation'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_CONFIG_CATEOGORY_ID","title":"<code>OPERATION_CONFIG_CATEOGORY_ID = 'instance.operation_config'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_DETAILS_CATEOGORY_ID","title":"<code>OPERATION_DETAILS_CATEOGORY_ID = 'instance.operation_details'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_INPUTS_SCHEMA_CATEOGORY_ID","title":"<code>OPERATION_INPUTS_SCHEMA_CATEOGORY_ID = 'instance.operation_input_schema'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OPERATION_OUTPUTS_SCHEMA_CATEOGORY_ID","title":"<code>OPERATION_OUTPUTS_SCHEMA_CATEOGORY_ID = 'instance.operation_output_schema'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.ENVIRONMENT_TYPE_CATEGORY_ID","title":"<code>ENVIRONMENT_TYPE_CATEGORY_ID = 'instance.environment'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DOCUMENTATION_CATEGORY_ID","title":"<code>DOCUMENTATION_CATEGORY_ID = 'documentation'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VALUE_SCHEMA_CATEGORY_ID","title":"<code>VALUE_SCHEMA_CATEGORY_ID = 'value_schema'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.JOB_CATEGORY_ID","title":"<code>JOB_CATEGORY_ID = 'instance.job'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.JOB_LOG_CATEGORY_ID","title":"<code>JOB_LOG_CATEGORY_ID = 'job_log'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DESTINY_CATEGORY_ID","title":"<code>DESTINY_CATEGORY_ID = 'instance.destiny'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.CONTEXT_INFO_CATEGORY_ID","title":"<code>CONTEXT_INFO_CATEGORY_ID = 'info.context'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.CONTEXT_METADATA_CATEOGORY_ID","title":"<code>CONTEXT_METADATA_CATEOGORY_ID = 'metadata.context'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.AUTHORS_METADATA_CATEGORY_ID","title":"<code>AUTHORS_METADATA_CATEGORY_ID = 'metadata.authors'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.JOB_CONFIG_TYPE_CATEGORY_ID","title":"<code>JOB_CONFIG_TYPE_CATEGORY_ID = 'instance.job'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.JOB_RECORD_TYPE_CATEGORY_ID","title":"<code>JOB_RECORD_TYPE_CATEGORY_ID = 'instance.job_record'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.VALUE_PEDIGREE_TYPE_CATEGORY_ID","title":"<code>VALUE_PEDIGREE_TYPE_CATEGORY_ID = 'instance.value_pedigree'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.FILE_MODEL_CATEOGORY_ID","title":"<code>FILE_MODEL_CATEOGORY_ID = 'instance.model.file'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.FILE_BUNDLE_MODEL_CATEOGORY_ID","title":"<code>FILE_BUNDLE_MODEL_CATEOGORY_ID = 'instance.model.file_bundle'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.ARRAY_MODEL_CATEOGORY_ID","title":"<code>ARRAY_MODEL_CATEOGORY_ID = 'instance.model.array'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.TABLE_MODEL_CATEOGORY_ID","title":"<code>TABLE_MODEL_CATEOGORY_ID = 'instance.model.table'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.DEFAULT_CONTEXT_NAME","title":"<code>DEFAULT_CONTEXT_NAME = 'default'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.SYMLINK_ISSUE_MSG","title":"<code>SYMLINK_ISSUE_MSG = \"Your operating system does not support symlinks, which is a requirement for kiara to work.\\n\\nYou can enable developer mode to fix this issue:\\n\\n- open 'Settings'\\n- click 'Updates &amp; Security'\\n- click 'For developers'\\n- make sure 'Developer Mode' is turned on\\n- log out of your Windows session, and log back in again\\n\\nFor more information, please visit:\\n- https://dharpa.org/kiara.documentation/latest/installation/#enable-developer-mode\\n- https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development\\n\"</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.OFFICIAL_KIARA_PLUGINS","title":"<code>OFFICIAL_KIARA_PLUGINS = ['core_types', 'tabular', 'onboarding', 'network_analysis', 'language_processing']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults-classes","title":"Classes","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.SpecialValue","title":"<code>SpecialValue</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/defaults.py</code> <pre><code>class SpecialValue(Enum):\n\n    NOT_SET = \"__not_set__\"\n    NO_VALUE = \"__no_value__\"\n</code></pre>"},{"location":"reference/kiara/defaults/#kiara.defaults.SpecialValue-attributes","title":"Attributes","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.SpecialValue.NOT_SET","title":"<code>NOT_SET = '__not_set__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/defaults/#kiara.defaults.SpecialValue.NO_VALUE","title":"<code>NO_VALUE = '__no_value__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/exceptions/","title":"exceptions","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions-classes","title":"Classes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException","title":"<code>KiaraException</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class KiaraException(Exception):\n    @classmethod\n    def get_root_details(cls, e: Exception) -&gt; Union[str, None]:\n\n        if isinstance(e, KiaraException):\n            return e.root_details()\n        else:\n            return str(e)\n\n    def __init__(self, msg: str, parent: Union[Exception, None] = None, **kwargs):\n\n        self._parent: Union[Exception, None] = parent\n        self._properties = kwargs\n        super().__init__(msg)\n\n    @property\n    def details(self) -&gt; Union[str, None]:\n\n        return self._properties.get(\"details\", None)\n\n    @property\n    def parent(self) -&gt; Union[Exception, None]:\n        return self._parent\n\n    @property\n    def root_cause(self) -&gt; Exception:\n\n        current: Exception = self\n        while hasattr(current, \"parent\") and current.parent is not None:  # type: ignore\n            current = current.parent  # type: ignore\n\n        return current\n\n    def root_details(self) -&gt; Union[str, None]:\n\n        current: Exception = self\n        if hasattr(self, \"details\"):\n            current_details = self.details  # type: ignore\n        else:\n            current_details = None\n        while hasattr(current, \"parent\") and current.parent is not None:  # type: ignore\n            current = current.parent  # type: ignore\n\n            if hasattr(current, \"details\") and current.details:  # type: ignore\n                current_details = current.details  # type: ignore\n            else:\n                current_details = str(current)\n\n        return current_details\n\n    def create_renderable(self, **config) -&gt; \"RenderableType\":\n\n        from rich.console import Group\n\n        rows: List[RenderableType] = [f\"[red]Error[/red]: {str(self)}\"]\n        root_details = self.root_details()\n        if root_details:\n            rows.append(\"\")\n            rows.append(Markdown(root_details))\n\n        return Group(*rows)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.details","title":"<code>details: Union[str, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.parent","title":"<code>parent: Union[Exception, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.root_cause","title":"<code>root_cause: Exception</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException-functions","title":"Functions","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.get_root_details","title":"<code>get_root_details(e: Exception) -&gt; Union[str, None]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>@classmethod\ndef get_root_details(cls, e: Exception) -&gt; Union[str, None]:\n\n    if isinstance(e, KiaraException):\n        return e.root_details()\n    else:\n        return str(e)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.root_details","title":"<code>root_details() -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>def root_details(self) -&gt; Union[str, None]:\n\n    current: Exception = self\n    if hasattr(self, \"details\"):\n        current_details = self.details  # type: ignore\n    else:\n        current_details = None\n    while hasattr(current, \"parent\") and current.parent is not None:  # type: ignore\n        current = current.parent  # type: ignore\n\n        if hasattr(current, \"details\") and current.details:  # type: ignore\n            current_details = current.details  # type: ignore\n        else:\n            current_details = str(current)\n\n    return current_details\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraException.create_renderable","title":"<code>create_renderable(**config) -&gt; RenderableType</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>def create_renderable(self, **config) -&gt; \"RenderableType\":\n\n    from rich.console import Group\n\n    rows: List[RenderableType] = [f\"[red]Error[/red]: {str(self)}\"]\n    root_details = self.root_details()\n    if root_details:\n        rows.append(\"\")\n        rows.append(Markdown(root_details))\n\n    return Group(*rows)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraModuleConfigException","title":"<code>KiaraModuleConfigException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class KiaraModuleConfigException(KiaraException):\n    def __init__(\n        self,\n        msg: str,\n        module_cls: Type[\"KiaraModule\"],\n        config: Mapping[str, Any],\n        parent: Union[Exception, None] = None,\n    ):\n\n        self._module_cls = module_cls\n        self._config = config\n\n        if not msg.endswith(\".\"):\n            _msg = msg + \".\"\n        else:\n            _msg = msg\n\n        super().__init__(_msg, parent=parent)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidManifestException","title":"<code>InvalidManifestException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class InvalidManifestException(KiaraException):\n    def __init__(\n        self,\n        msg: str,\n        module_type: str,\n        module_config: Union[None, Mapping[str, Any]] = None,\n        available_module_types: Union[None, Iterable[str]] = None,\n        parent: Union[Exception, None] = None,\n    ):\n\n        self._module_type = module_type\n        self._module_config = module_config\n        self._available_module_types = available_module_types\n        super().__init__(msg, parent=parent)\n\n    @property\n    def details(self) -&gt; Union[str, None]:\n\n        if not self._available_module_types:\n            return None\n\n        else:\n            msg = \"Available module types:\\n\\n\"\n            for module_type in self._available_module_types:\n                msg += f\"- {module_type}\\n\"\n            return msg\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidManifestException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidManifestException.details","title":"<code>details: Union[str, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.ValueTypeConfigException","title":"<code>ValueTypeConfigException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class ValueTypeConfigException(KiaraException):\n    def __init__(\n        self,\n        msg: str,\n        type_cls: Type[\"DataType\"],\n        config: Mapping[str, Any],\n        parent: Union[Exception, None] = None,\n    ):\n\n        self._type_cls = type_cls\n        self._config = config\n\n        if not msg.endswith(\".\"):\n            _msg = msg + \".\"\n        else:\n            _msg = msg\n\n        super().__init__(_msg, parent=parent)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException","title":"<code>DataTypeUnknownException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class DataTypeUnknownException(KiaraException):\n    def __init__(\n        self,\n        data_type: str,\n        msg: Union[str, None] = None,\n        value: Union[None, \"Value\"] = None,\n    ):\n\n        self._data_type = data_type\n        if msg is None:\n            msg = f\"Data type '{data_type}' not registered in current context.\"\n        self._msg = msg\n        self._value = value\n\n        super().__init__(msg)\n\n    @property\n    def data_type(self) -&gt; str:\n        return self._data_type\n\n    @property\n    def value(self) -&gt; Union[None, \"Value\"]:\n        return self._value\n\n    def create_renderable(self, **config: Any) -&gt; \"Table\":\n\n        from rich import box\n        from rich.table import Table\n\n        table = Table(box=box.SIMPLE, show_header=False)\n\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        table.add_row(\"error\", self._msg)\n        table.add_row(\"data type\", self._data_type)\n        table.add_row(\n            \"solution\", \"Install the Python package that provides this data type.\"\n        )\n\n        if self._value is not None:\n            table.add_row(\"value\", self._value.create_renderable())\n\n        return table\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException.data_type","title":"<code>data_type: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException.value","title":"<code>value: Union[None, Value]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException-functions","title":"Functions","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.DataTypeUnknownException.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; Table</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; \"Table\":\n\n    from rich import box\n    from rich.table import Table\n\n    table = Table(box=box.SIMPLE, show_header=False)\n\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"error\", self._msg)\n    table.add_row(\"data type\", self._data_type)\n    table.add_row(\n        \"solution\", \"Install the Python package that provides this data type.\"\n    )\n\n    if self._value is not None:\n        table.add_row(\"value\", self._value.create_renderable())\n\n    return table\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraValueException","title":"<code>KiaraValueException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class KiaraValueException(KiaraException):\n    def __init__(\n        self,\n        data_type: Type[\"DataType\"],\n        value_data: Any,\n        parent: Exception,\n    ):\n        self._data_type: Type[\"DataType\"] = data_type\n        self._value_data: Any = value_data\n\n        exc_msg = str(parent)\n        if not exc_msg:\n            exc_msg = \"no details available\"\n\n        super().__init__(f\"Invalid value of type '{data_type._data_type_name}': {exc_msg}\", parent=parent)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchExecutionTargetException","title":"<code>NoSuchExecutionTargetException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchExecutionTargetException(KiaraException):\n    def __init__(\n        self,\n        selected_target: str,\n        available_targets: Iterable[str],\n        msg: Union[str, None] = None,\n    ):\n\n        if msg is None:\n            msg = f\"Specified run target '{selected_target}' is an operation, additional module configuration is not allowed.\"\n\n        self.avaliable_targets: Iterable[str] = available_targets\n        super().__init__(msg)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchExecutionTargetException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchExecutionTargetException.avaliable_targets","title":"<code>avaliable_targets: Iterable[str] = available_targets</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraProcessingException","title":"<code>KiaraProcessingException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class KiaraProcessingException(KiaraException):\n    def __init__(\n        self,\n        msg: Union[str, Exception],\n        module: Union[\"KiaraModule\", None] = None,\n        inputs: Union[Mapping[str, \"Value\"], None] = None,\n    ):\n        self._module: Union[\"KiaraModule\", None] = module\n        self._inputs: Union[Mapping[str, Value], None] = inputs\n        if isinstance(msg, Exception):\n            self._parent: Union[Exception, None] = msg\n            _msg = str(msg)\n        else:\n            self._parent = None\n            _msg = msg\n        super().__init__(_msg)\n\n    @property\n    def module(self) -&gt; \"KiaraModule\":\n        return self._module  # type: ignore\n\n    @property\n    def inputs(self) -&gt; Mapping[str, \"Value\"]:\n        return self._inputs  # type: ignore\n\n    @property\n    def parent_exception(self) -&gt; Union[Exception, None]:\n        return self._parent\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraProcessingException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraProcessingException.module","title":"<code>module: KiaraModule</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraProcessingException.inputs","title":"<code>inputs: Mapping[str, Value]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.KiaraProcessingException.parent_exception","title":"<code>parent_exception: Union[Exception, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException","title":"<code>InvalidValuesException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class InvalidValuesException(KiaraException):\n    def __init__(\n        self,\n        msg: Union[None, str, Exception] = None,\n        invalid_values: Union[Mapping[str, str], None] = None,\n    ):\n\n        if invalid_values is None:\n            invalid_values = {}\n\n        self.invalid_inputs: Mapping[str, str] = invalid_values\n\n        if msg is None:\n            if not self.invalid_inputs:\n                _msg = \"Invalid values. No details available.\"\n            else:\n                msg_parts = []\n                for k, v in invalid_values.items():\n                    msg_parts.append(f\"{k}: {v}\")\n                _msg = f\"Invalid values: {', '.join(msg_parts)}\"\n        elif isinstance(msg, Exception):\n            self._parent: Union[Exception, None] = msg\n            _msg = str(msg)\n        else:\n            self._parent = None\n            _msg = msg\n\n        super().__init__(_msg)\n\n    @property\n    def details(self) -&gt; str:\n        result = \"\"\n        for k, v in self.invalid_inputs.items():\n            result += f\" - {k}: {v}\"\n\n        return result\n\n    def create_renderable(self, **config: Any) -&gt; \"Table\":\n\n        from rich import box\n        from rich.console import RenderableType\n        from rich.table import Table\n\n        table = Table(box=box.SIMPLE, show_header=True)\n\n        table.add_column(\"field name\", style=\"i\")\n        table.add_column(\"[red]error[/red]\")\n\n        for field_name, error in self.invalid_inputs.items():\n\n            row: List[RenderableType] = [field_name]\n            row.append(error)\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException.invalid_inputs","title":"<code>invalid_inputs: Mapping[str, str] = invalid_values</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException.details","title":"<code>details: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException-functions","title":"Functions","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidValuesException.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; Table</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; \"Table\":\n\n    from rich import box\n    from rich.console import RenderableType\n    from rich.table import Table\n\n    table = Table(box=box.SIMPLE, show_header=True)\n\n    table.add_column(\"field name\", style=\"i\")\n    table.add_column(\"[red]error[/red]\")\n\n    for field_name, error in self.invalid_inputs.items():\n\n        row: List[RenderableType] = [field_name]\n        row.append(error)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.JobConfigException","title":"<code>JobConfigException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class JobConfigException(KiaraException):\n    def __init__(\n        self,\n        msg: Union[str, Exception],\n        manifest: \"Manifest\",\n        inputs: Mapping[str, Any],\n    ):\n\n        self._manifest: Manifest = manifest\n        self._inputs: Mapping[str, Any] = inputs\n\n        if isinstance(msg, Exception):\n            self._parent: Union[Exception, None] = msg\n            _msg = str(msg)\n        else:\n            self._parent = None\n            _msg = msg\n\n        super().__init__(_msg)\n\n    @property\n    def manifest(self) -&gt; \"Manifest\":\n        return self._manifest\n\n    @property\n    def inputs(self) -&gt; Mapping[str, Any]:\n        return self._inputs\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.JobConfigException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.JobConfigException.manifest","title":"<code>manifest: Manifest</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.JobConfigException.inputs","title":"<code>inputs: Mapping[str, Any]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException","title":"<code>FailedJobException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class FailedJobException(KiaraException):\n    def __init__(\n        self,\n        job: \"ActiveJob\",\n        msg: Union[str, None] = None,\n        parent: Union[Exception, None] = None,\n    ):\n\n        self.job: ActiveJob = job\n        if msg is None:\n            msg = \"Job failed.\"\n        self.msg = msg\n        super().__init__(msg, parent=parent)\n\n    @property\n    def details(self) -&gt; Union[str, None]:\n        return None\n\n    def create_renderable(self, **config: Any):\n\n        from rich import box\n        from rich.console import Group\n        from rich.panel import Panel\n        from rich.table import Table\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        table.add_row(\"job_id\", str(self.job.job_id))\n        table.add_row(\"module_type\", self.job.job_config.module_type)\n\n        group = Group(\n            Panel(f\"[red]Error[/red]: [i]{self.msg}[i]\", box=box.SIMPLE), table\n        )\n        return group\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException.job","title":"<code>job: ActiveJob = job</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException.msg","title":"<code>msg = msg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException.details","title":"<code>details: Union[str, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException-functions","title":"Functions","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.FailedJobException.create_renderable","title":"<code>create_renderable(**config: Any)</code>","text":"Source code in <code>kiara/exceptions.py</code> <pre><code>def create_renderable(self, **config: Any):\n\n    from rich import box\n    from rich.console import Group\n    from rich.panel import Panel\n    from rich.table import Table\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"job_id\", str(self.job.job_id))\n    table.add_row(\"module_type\", self.job.job_config.module_type)\n\n    group = Group(\n        Panel(f\"[red]Error[/red]: [i]{self.msg}[i]\", box=box.SIMPLE), table\n    )\n    return group\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueException","title":"<code>NoSuchValueException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchValueException(KiaraException):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueIdException","title":"<code>NoSuchValueIdException</code>","text":"<p>         Bases: <code>NoSuchValueException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchValueIdException(NoSuchValueException):\n    def __init__(self, value_id: uuid.UUID, msg: Union[str, None] = None):\n        self.value_id: uuid.UUID\n        if not msg:\n            msg = f\"No value with id: {value_id}.\"\n        super().__init__(msg)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueIdException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueIdException.value_id","title":"<code>value_id: uuid.UUID</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueAliasException","title":"<code>NoSuchValueAliasException</code>","text":"<p>         Bases: <code>NoSuchValueException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchValueAliasException(NoSuchValueException):\n    def __init__(self, alias: str, msg: Union[str, None] = None):\n        self.value_id: uuid.UUID\n        if not msg:\n            msg = f\"No value with alias: {alias}.\"\n        super().__init__(msg)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueAliasException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchValueAliasException.value_id","title":"<code>value_id: uuid.UUID</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchWorkflowException","title":"<code>NoSuchWorkflowException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchWorkflowException(KiaraException):\n    def __init__(self, workflow: Union[uuid.UUID, str], msg: Union[str, None] = None):\n        self._workflow: Union[str, uuid.UUID] = workflow\n        if not msg:\n            msg = f\"No such workflow: {workflow}\"\n        super().__init__(msg)\n\n    @property\n    def alias_requested(self) -&gt; bool:\n\n        if isinstance(self._workflow, str):\n            try:\n                uuid.UUID(self._workflow)\n                return False\n            except Exception:\n                return True\n        else:\n            return False\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchWorkflowException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchWorkflowException.alias_requested","title":"<code>alias_requested: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchOperationException","title":"<code>NoSuchOperationException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class NoSuchOperationException(KiaraException):\n    def __init__(\n        self,\n        operation_id: str,\n        available_operations: Iterable[str],\n        msg: Union[None, str] = None,\n    ):\n\n        self._operation_id: str = operation_id\n        self._available_operations: Iterable[str] = available_operations\n\n        if not msg:\n            msg = f\"No operation with id '{operation_id}' available.\"\n\n        super().__init__(msg)\n\n    @property\n    def available_operations(self) -&gt; Iterable[str]:\n        return self._available_operations\n\n    @property\n    def operation_id(self) -&gt; str:\n        return self._operation_id\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchOperationException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchOperationException.available_operations","title":"<code>available_operations: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.NoSuchOperationException.operation_id","title":"<code>operation_id: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidOperationException","title":"<code>InvalidOperationException</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class InvalidOperationException(KiaraException):\n    def __init__(self, operation_details: Mapping[str, Any]):\n\n        self._all_details: Mapping[str, Any] = operation_details\n        msg = operation_details.get(\"operation_id\", None)\n        if msg is None:\n            msg = operation_details.get(\"pipeline_name\", None)\n        parent = operation_details.get(\"parent\", None)\n        super().__init__(f\"Invalid operation: {msg}\", parent=parent)\n\n    @property\n    def module_id(self) -&gt; str:\n        return self._all_details.get(\"module_id\", NOT_AVAILBLE_MARKER)\n\n    @property\n    def module_config(self) -&gt; Union[Mapping[str, Any], str]:\n        return self._all_details.get(\"module_config\", {})\n\n    @property\n    def details(self) -&gt; Union[str, None]:\n        if self.parent:\n            if hasattr(self.parent, \"details\"):\n                return self.parent.details  # type: ignore\n            else:\n                return None\n        else:\n            return self._all_details.get(\"details\", None)\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidOperationException-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidOperationException.module_id","title":"<code>module_id: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidOperationException.module_config","title":"<code>module_config: Union[Mapping[str, Any], str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidOperationException.details","title":"<code>details: Union[str, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineStepConfig","title":"<code>InvalidPipelineStepConfig</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class InvalidPipelineStepConfig(KiaraException):\n    def __init__(self, msg: str, step_config: Mapping[str, Any]):\n\n        self._step_config: Mapping[str, Any] = step_config\n        super().__init__(msg)\n\n    @property\n    def details(self) -&gt; str:\n        config = orjson_dumps(self._step_config, option=orjson.OPT_INDENT_2)\n\n        details = f\"Invalid step config:\\n\\n```\\n{config}\\n```\"\n        return details\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineStepConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineStepConfig.details","title":"<code>details: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineConfig","title":"<code>InvalidPipelineConfig</code>","text":"<p>         Bases: <code>KiaraException</code></p> Source code in <code>kiara/exceptions.py</code> <pre><code>class InvalidPipelineConfig(KiaraException):\n    def __init__(self, msg: str, config: \"PipelineConfig\", details: str):\n\n        self._config = config\n        self._details = details\n        super().__init__(msg)\n\n    @property\n    def pipeline_config(self) -&gt; \"PipelineConfig\":\n        return self._config\n\n    @property\n    def details(self) -&gt; Union[str, None]:\n\n        return self._details\n</code></pre>"},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineConfig.pipeline_config","title":"<code>pipeline_config: PipelineConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions.InvalidPipelineConfig.details","title":"<code>details: Union[str, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/exceptions/#kiara.exceptions-functions","title":"Functions","text":""},{"location":"reference/kiara/context/__init__/","title":"context","text":""},{"location":"reference/kiara/context/__init__/#kiara.context-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context-classes","title":"Classes","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara","title":"<code>Kiara</code>","text":"<p>         Bases: <code>object</code></p> <p>The core context of a kiara session.</p> <p>The <code>Kiara</code> object holds all information related to the current environment the user does works in. This includes:</p> <ul> <li>available modules, operations &amp; pipelines</li> <li>available value data_types</li> <li>available metadata schemas</li> <li>available data items</li> <li>available controller and processor data_types</li> <li>misc. configuration options</li> </ul> <p>It's possible to use kiara without ever manually touching the 'Kiara' class, by default all relevant classes and functions will use a default instance of this class (available via the <code>Kiara.instance()</code> method.</p> <p>The Kiara class is highly dependent on the Python environment it lives in, because it auto-discovers available sub-classes of its building blocks (modules, value data_types, etc.). So, you can't assume that, for example, a pipeline you create will work the same way (or at all) in a different environment. kiara will always be able to tell you all the details of this environment, though, and it will attach those details to things like data, so there is always a record of how something was created, and in which environment.</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>class Kiara(object):\n\"\"\"The core context of a kiara session.\n\n    The `Kiara` object holds all information related to the current environment the user does works in. This includes:\n\n      - available modules, operations &amp; pipelines\n      - available value data_types\n      - available metadata schemas\n      - available data items\n      - available controller and processor data_types\n      - misc. configuration options\n\n    It's possible to use *kiara* without ever manually touching the 'Kiara' class, by default all relevant classes and functions\n    will use a default instance of this class (available via the `Kiara.instance()` method.\n\n    The Kiara class is highly dependent on the Python environment it lives in, because it auto-discovers available sub-classes\n    of its building blocks (modules, value data_types, etc.). So, you can't assume that, for example, a pipeline you create\n    will work the same way (or at all) in a different environment. *kiara* will always be able to tell you all the details\n    of this environment, though, and it will attach those details to things like data, so there is always a record of\n    how something was created, and in which environment.\n    \"\"\"\n\n    @classmethod\n    def instance(cls) -&gt; \"Kiara\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n        from kiara.interfaces.python_api import KiaraAPI\n\n        return KiaraAPI.instance().context\n\n    def __init__(\n        self,\n        config: Union[KiaraContextConfig, None] = None,\n        runtime_config: Union[KiaraRuntimeConfig, None] = None,\n    ) -&gt; None:\n\n        kc: Union[KiaraConfig, None] = None\n        if not config:\n            kc = KiaraConfig()\n            config = kc.get_context_config()\n\n        if not runtime_config:\n            if kc is None:\n                kc = KiaraConfig()\n            runtime_config = kc.runtime_config\n\n        self._id: uuid.UUID = ID_REGISTRY.generate(\n            id=uuid.UUID(config.context_id), obj=self\n        )\n        ID_REGISTRY.update_metadata(self._id, kiara_id=self._id)\n        self._config: KiaraContextConfig = config\n        self._runtime_config: KiaraRuntimeConfig = runtime_config\n\n        self._event_registry: EventRegistry = EventRegistry(kiara=self)\n        self._type_registry: TypeRegistry = TypeRegistry(self)\n        self._data_registry: DataRegistry = DataRegistry(kiara=self)\n        self._job_registry: JobRegistry = JobRegistry(kiara=self)\n        self._module_registry: ModuleRegistry = ModuleRegistry(kiara=self)\n        self._operation_registry: OperationRegistry = OperationRegistry(kiara=self)\n\n        self._kiara_model_registry: ModelRegistry = ModelRegistry.instance()\n\n        self._alias_registry: AliasRegistry = AliasRegistry(kiara=self)\n        self._destiny_registry: DestinyRegistry = DestinyRegistry(kiara=self)\n\n        self._workflow_registry: WorkflowRegistry = WorkflowRegistry(kiara=self)\n\n        self._render_registry = RenderRegistry(kiara=self)\n\n        self._env_mgmt: Union[EnvironmentRegistry, None] = None\n\n        metadata_augmenter = CreateMetadataDestinies(kiara=self)\n        self._event_registry.add_listener(\n            metadata_augmenter, *metadata_augmenter.supported_event_types()\n        )\n\n        self._context_info: Union[KiaraContextInfo, None] = None\n\n        # initialize stores\n        self._archive_types = find_all_archive_types()\n        self._archives: Dict[str, KiaraArchive] = {}\n\n        for archive_alias, archive in self._config.archives.items():\n            archive_cls = self._archive_types.get(archive.archive_type, None)\n            if archive_cls is None:\n                raise Exception(\n                    f\"Can't create context: no archive type '{archive.archive_type}' available. Available types: {', '.join(self._archive_types.keys())}\"\n                )\n\n            config_cls = archive_cls._config_cls\n            archive_config = config_cls(**archive.config)\n            archive_obj = archive_cls(archive_id=archive.archive_uuid, config=archive_config)  # type: ignore\n            for supported_type in archive_obj.supported_item_types():\n                if supported_type == \"data\":\n                    self.data_registry.register_data_archive(\n                        archive_obj, alias=archive_alias  # type: ignore\n                    )\n                if supported_type == \"job_record\":\n                    self.job_registry.register_job_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"alias\":\n                    self.alias_registry.register_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"destiny\":\n                    self.destiny_registry.register_destiny_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n                if supported_type == \"workflow\":\n                    self.workflow_registry.register_archive(archive_obj, alias=archive_alias)  # type: ignore\n\n    # def _run_alembic_migrations(self):\n    #     script_location = os.path.abspath(KIARA_DB_MIGRATIONS_FOLDER)\n    #     dsn = self._config.db_url\n    #     log_message(\"running migration script\", script=script_location, db_url=dsn)\n    #     from alembic.config import Config\n    #\n    #     alembic_cfg = Config(KIARA_DB_MIGRATIONS_CONFIG)\n    #     alembic_cfg.set_main_option(\"script_location\", script_location)\n    #     alembic_cfg.set_main_option(\"sqlalchemy.url\", dsn)\n    #     command.upgrade(alembic_cfg, \"head\")\n\n    @property\n    def id(self) -&gt; uuid.UUID:\n        return self._id\n\n    @property\n    def context_config(self) -&gt; KiaraContextConfig:\n        return self._config\n\n    @property\n    def runtime_config(self) -&gt; KiaraRuntimeConfig:\n        return self._runtime_config\n\n    def update_runtime_config(self, **settings) -&gt; KiaraRuntimeConfig:\n\n        for k, v in settings.items():\n            setattr(self.runtime_config, k, v)\n\n        return self.runtime_config\n\n    @property\n    def context_info(self) -&gt; \"KiaraContextInfo\":\n\n        if self._context_info is None:\n            self._context_info = KiaraContextInfo.create_from_kiara_instance(kiara=self)\n        return self._context_info\n\n    # ===================================================================================================\n    # registry accessors\n\n    @property\n    def environment_registry(self) -&gt; EnvironmentRegistry:\n        if self._env_mgmt is not None:\n            return self._env_mgmt\n\n        self._env_mgmt = EnvironmentRegistry.instance()\n        return self._env_mgmt\n\n    @property\n    def type_registry(self) -&gt; TypeRegistry:\n        return self._type_registry\n\n    @property\n    def module_registry(self) -&gt; ModuleRegistry:\n        return self._module_registry\n\n    @property\n    def kiara_model_registry(self) -&gt; ModelRegistry:\n        return self._kiara_model_registry\n\n    @property\n    def alias_registry(self) -&gt; AliasRegistry:\n        return self._alias_registry\n\n    @property\n    def destiny_registry(self) -&gt; DestinyRegistry:\n        return self._destiny_registry\n\n    @property\n    def job_registry(self) -&gt; JobRegistry:\n        return self._job_registry\n\n    @property\n    def operation_registry(self) -&gt; OperationRegistry:\n        op_registry = self._operation_registry\n        return op_registry\n\n    @property\n    def data_registry(self) -&gt; DataRegistry:\n        return self._data_registry\n\n    @property\n    def workflow_registry(self) -&gt; WorkflowRegistry:\n        return self._workflow_registry\n\n    @property\n    def event_registry(self) -&gt; EventRegistry:\n        return self._event_registry\n\n    @property\n    def render_registry(self) -&gt; RenderRegistry:\n        return self._render_registry\n\n    # ===================================================================================================\n    # context specific types &amp; instances\n\n    @property\n    def current_environments(self) -&gt; Mapping[str, RuntimeEnvironment]:\n        return self.environment_registry.environments\n\n    @property\n    def data_type_classes(self) -&gt; Mapping[str, Type[DataType]]:\n        return self.type_registry.data_type_classes\n\n    @property\n    def data_type_names(self) -&gt; List[str]:\n        return self.type_registry.data_type_names\n\n    @property\n    def module_type_classes(self) -&gt; Mapping[str, Type[\"KiaraModule\"]]:\n        return self._module_registry.module_types\n\n    @property\n    def module_type_names(self) -&gt; Iterable[str]:\n        return self._module_registry.get_module_type_names()\n\n    # ===================================================================================================\n    # kiara session API methods\n\n    def create_manifest(\n        self, module_or_operation: str, config: Union[Mapping[str, Any], None] = None\n    ) -&gt; Manifest:\n\n        if config is None:\n            config = {}\n\n        if module_or_operation in self.module_type_names:\n\n            manifest: Manifest = Manifest(\n                module_type=module_or_operation, module_config=config\n            )\n\n        elif module_or_operation in self.operation_registry.operation_ids:\n\n            if config:\n                raise Exception(\n                    f\"Specified run target '{module_or_operation}' is an operation, additional module configuration is not allowed (yet).\"\n                )\n            manifest = self.operation_registry.get_operation(module_or_operation)\n\n        elif os.path.isfile(module_or_operation):\n            raise NotImplementedError()\n\n        else:\n            raise Exception(\n                f\"Can't assemble operation, invalid operation/module name: {module_or_operation}. Must be registered module or operation name, or file.\"\n            )\n\n        return manifest\n\n    # def create_module(self, manifest: Union[Manifest, str]) -&gt; \"KiaraModule\":\n    #     \"\"\"Create a [KiaraModule][kiara.module.KiaraModule] object from a module configuration.\n    #\n    #     Arguments:\n    #         manifest: the module configuration\n    #     \"\"\"\n    #\n    #     return self._module_registry.create_module(manifest=manifest)\n\n    def queue(\n        self, manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n        Arguments:\n           manifest: the job manifest\n           inputs: the job inputs\n           wait: whether to wait for the job to be finished before returning\n\n        Returns:\n            the job id that can be used to look up job status &amp; results\n        \"\"\"\n\n        return self.job_registry.execute(manifest=manifest, inputs=inputs, wait=wait)\n\n    def process(self, manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n        Arguments:\n           manifest: the job manifest\n           inputs: the job inputs\n           wait: whether to wait for the job to be finished before returning\n\n        Returns\n        \"\"\"\n\n        return self.job_registry.execute_and_retrieve(manifest=manifest, inputs=inputs)\n\n    def save_values(\n        self, values: ValueMap, alias_map: Mapping[str, Iterable[str]]\n    ) -&gt; StoreValuesResult:\n\n        _values = {}\n        for field_name in values.field_names:\n            value = values.get_value_obj(field_name)\n            _values[field_name] = value\n            self.data_registry.store_value(value=value)\n        stored = {}\n        for field_name, field_aliases in alias_map.items():\n\n            value = _values[field_name]\n            try:\n                if field_aliases:\n                    self.alias_registry.register_aliases(value.value_id, *field_aliases)\n\n                stored[field_name] = StoreValueResult(\n                    value=value,\n                    aliases=sorted(field_aliases),\n                    error=None,\n                    persisted_data=None,\n                )\n\n            except Exception as e:\n                log_exception(e)\n                stored[field_name] = StoreValueResult(\n                    value=value,\n                    aliases=sorted(field_aliases),\n                    error=str(e),\n                    persisted_data=None,\n                )\n\n        return StoreValuesResult.construct(__root__=stored)\n\n    def create_context_summary(self) -&gt; ContextInfo:\n        return ContextInfo.create_from_context(kiara=self)\n\n    def get_all_archives(self) -&gt; Dict[KiaraArchive, Set[str]]:\n\n        result: Dict[KiaraArchive, Set[str]] = {}\n\n        archive: KiaraArchive\n        for alias, archive in self.data_registry.data_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.alias_registry.alias_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.destiny_registry.destiny_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.job_registry.job_archives.items():\n            result.setdefault(archive, set()).add(alias)\n        for alias, archive in self.workflow_registry.workflow_archives.items():\n            result.setdefault(archive, set()).add(alias)\n\n        return result\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.id","title":"<code>id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.context_config","title":"<code>context_config: KiaraContextConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.runtime_config","title":"<code>runtime_config: KiaraRuntimeConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.context_info","title":"<code>context_info: KiaraContextInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.environment_registry","title":"<code>environment_registry: EnvironmentRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.type_registry","title":"<code>type_registry: TypeRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.module_registry","title":"<code>module_registry: ModuleRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.kiara_model_registry","title":"<code>kiara_model_registry: ModelRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.alias_registry","title":"<code>alias_registry: AliasRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.destiny_registry","title":"<code>destiny_registry: DestinyRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.job_registry","title":"<code>job_registry: JobRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.operation_registry","title":"<code>operation_registry: OperationRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.data_registry","title":"<code>data_registry: DataRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.workflow_registry","title":"<code>workflow_registry: WorkflowRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.event_registry","title":"<code>event_registry: EventRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.render_registry","title":"<code>render_registry: RenderRegistry</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.current_environments","title":"<code>current_environments: Mapping[str, RuntimeEnvironment]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.data_type_classes","title":"<code>data_type_classes: Mapping[str, Type[DataType]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.data_type_names","title":"<code>data_type_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.module_type_classes","title":"<code>module_type_classes: Mapping[str, Type[KiaraModule]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.module_type_names","title":"<code>module_type_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara-functions","title":"Functions","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.instance","title":"<code>instance() -&gt; Kiara</code>  <code>classmethod</code>","text":"<p>The default kiara context. In most cases, it's recommended you create and manage your own, though.</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; \"Kiara\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n    from kiara.interfaces.python_api import KiaraAPI\n\n    return KiaraAPI.instance().context\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.update_runtime_config","title":"<code>update_runtime_config(**settings) -&gt; KiaraRuntimeConfig</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def update_runtime_config(self, **settings) -&gt; KiaraRuntimeConfig:\n\n    for k, v in settings.items():\n        setattr(self.runtime_config, k, v)\n\n    return self.runtime_config\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.create_manifest","title":"<code>create_manifest(module_or_operation: str, config: Union[Mapping[str, Any], None] = None) -&gt; Manifest</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def create_manifest(\n    self, module_or_operation: str, config: Union[Mapping[str, Any], None] = None\n) -&gt; Manifest:\n\n    if config is None:\n        config = {}\n\n    if module_or_operation in self.module_type_names:\n\n        manifest: Manifest = Manifest(\n            module_type=module_or_operation, module_config=config\n        )\n\n    elif module_or_operation in self.operation_registry.operation_ids:\n\n        if config:\n            raise Exception(\n                f\"Specified run target '{module_or_operation}' is an operation, additional module configuration is not allowed (yet).\"\n            )\n        manifest = self.operation_registry.get_operation(module_or_operation)\n\n    elif os.path.isfile(module_or_operation):\n        raise NotImplementedError()\n\n    else:\n        raise Exception(\n            f\"Can't assemble operation, invalid operation/module name: {module_or_operation}. Must be registered module or operation name, or file.\"\n        )\n\n    return manifest\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.queue","title":"<code>queue(manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False) -&gt; uuid.UUID</code>","text":"<p>Queue a job with the specified manifest and inputs.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the job manifest</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the job inputs</p> required <code>wait</code> <code>bool</code> <p>whether to wait for the job to be finished before returning</p> <code>False</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>the job id that can be used to look up job status &amp; results</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>def queue(\n    self, manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False\n) -&gt; uuid.UUID:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n    Arguments:\n       manifest: the job manifest\n       inputs: the job inputs\n       wait: whether to wait for the job to be finished before returning\n\n    Returns:\n        the job id that can be used to look up job status &amp; results\n    \"\"\"\n\n    return self.job_registry.execute(manifest=manifest, inputs=inputs, wait=wait)\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.process","title":"<code>process(manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap</code>","text":"<p>Queue a job with the specified manifest and inputs.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the job manifest</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the job inputs</p> required <code>wait</code> <p>whether to wait for the job to be finished before returning</p> required <p>Returns</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>def process(self, manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap:\n\"\"\"Queue a job with the specified manifest and inputs.\n\n    Arguments:\n       manifest: the job manifest\n       inputs: the job inputs\n       wait: whether to wait for the job to be finished before returning\n\n    Returns\n    \"\"\"\n\n    return self.job_registry.execute_and_retrieve(manifest=manifest, inputs=inputs)\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.save_values","title":"<code>save_values(values: ValueMap, alias_map: Mapping[str, Iterable[str]]) -&gt; StoreValuesResult</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def save_values(\n    self, values: ValueMap, alias_map: Mapping[str, Iterable[str]]\n) -&gt; StoreValuesResult:\n\n    _values = {}\n    for field_name in values.field_names:\n        value = values.get_value_obj(field_name)\n        _values[field_name] = value\n        self.data_registry.store_value(value=value)\n    stored = {}\n    for field_name, field_aliases in alias_map.items():\n\n        value = _values[field_name]\n        try:\n            if field_aliases:\n                self.alias_registry.register_aliases(value.value_id, *field_aliases)\n\n            stored[field_name] = StoreValueResult(\n                value=value,\n                aliases=sorted(field_aliases),\n                error=None,\n                persisted_data=None,\n            )\n\n        except Exception as e:\n            log_exception(e)\n            stored[field_name] = StoreValueResult(\n                value=value,\n                aliases=sorted(field_aliases),\n                error=str(e),\n                persisted_data=None,\n            )\n\n    return StoreValuesResult.construct(__root__=stored)\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.create_context_summary","title":"<code>create_context_summary() -&gt; ContextInfo</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def create_context_summary(self) -&gt; ContextInfo:\n    return ContextInfo.create_from_context(kiara=self)\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.Kiara.get_all_archives","title":"<code>get_all_archives() -&gt; Dict[KiaraArchive, Set[str]]</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def get_all_archives(self) -&gt; Dict[KiaraArchive, Set[str]]:\n\n    result: Dict[KiaraArchive, Set[str]] = {}\n\n    archive: KiaraArchive\n    for alias, archive in self.data_registry.data_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.alias_registry.alias_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.destiny_registry.destiny_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.job_registry.job_archives.items():\n        result.setdefault(archive, set()).add(alias)\n    for alias, archive in self.workflow_registry.workflow_archives.items():\n        result.setdefault(archive, set()).add(alias)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo","title":"<code>KiaraContextInfo</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/context/__init__.py</code> <pre><code>class KiaraContextInfo(KiaraModel):\n    @classmethod\n    def create_from_kiara_instance(\n        cls, kiara: \"Kiara\", package_filter: Union[str, None] = None\n    ):\n\n        data_types = kiara.type_registry.get_context_metadata(\n            only_for_package=package_filter\n        )\n        modules = kiara.module_registry.get_context_metadata(\n            only_for_package=package_filter\n        )\n        operation_types = kiara.operation_registry.get_context_metadata(\n            only_for_package=package_filter\n        )\n        operations = filter_operations(\n            kiara=kiara, pkg_name=package_filter, **kiara.operation_registry.operations\n        )\n\n        model_registry = kiara.kiara_model_registry\n        if package_filter:\n            kiara_models = model_registry.get_models_for_package(\n                package_name=package_filter\n            )\n        else:\n            kiara_models = model_registry.all_models\n\n        # metadata_types = find_metadata_models(only_for_package=package_filter)\n\n        return KiaraContextInfo.construct(\n            kiara_id=kiara.id,\n            package_filter=package_filter,\n            data_types=data_types,\n            module_types=modules,\n            kiara_model_types=kiara_models,\n            # metadata_types=metadata_types,\n            operation_types=operation_types,\n            operations=operations,\n        )\n\n    kiara_id: uuid.UUID = Field(description=\"The id of the kiara context.\")\n    package_filter: Union[str, None] = Field(\n        description=\"Whether this context is filtered to only include information included in a specific Python package.\"\n    )\n    data_types: DataTypeClassesInfo = Field(description=\"The included data types.\")\n    module_types: ModuleTypesInfo = Field(\n        description=\"The included kiara module types.\"\n    )\n    kiara_model_types: KiaraModelClassesInfo = Field(\n        description=\"The included model classes.\"\n    )\n    # metadata_types: MetadataTypeClassesInfo = Field(\n    #     description=\"The included value metadata types.\"\n    # )\n    operation_types: OperationTypeClassesInfo = Field(\n        description=\"The included operation types.\"\n    )\n    operations: OperationGroupInfo = Field(description=\"The included operations.\")\n\n    def _retrieve_id(self) -&gt; str:\n        if not self.package_filter:\n            return str(self.kiara_id)\n        else:\n            return f\"{self.kiara_id}.package_{self.package_filter}\"\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\"kiara_id\": self.kiara_id, \"package\": self.package_filter}\n\n    def get_info(self, item_type: str, item_id: str) -&gt; ItemInfo:\n\n        if item_type == \"data_type\" or item_type == \"data_types\":\n            group_info: InfoItemGroup = self.data_types\n        elif \"module\" in item_type:\n            group_info = self.module_types\n        # elif \"metadata\" in item_type:\n        #     group_info = self.metadata_types\n        elif \"operation_type\" in item_type or \"operation_types\" in item_type:\n            group_info = self.operation_types\n        elif \"operation\" in item_type:\n            group_info = self.operations\n        elif \"kiara_model\" in item_type:\n            group_info = self.kiara_model_types\n        else:\n            item_types = [\n                \"data_type\",\n                \"module_type\",\n                \"kiara_model_type\",\n                \"operation_type\",\n                \"operation\",\n            ]\n            raise Exception(\n                f\"Can't determine item type '{item_type}', use one of: {', '.join(item_types)}\"\n            )\n        return group_info[item_id]\n\n    def get_all_info(self, skip_empty_types: bool = True) -&gt; Dict[str, InfoItemGroup]:\n\n        result: Dict[str, InfoItemGroup] = {}\n        if self.data_types or not skip_empty_types:\n            result[\"data_types\"] = self.data_types\n        if self.module_types or not skip_empty_types:\n            result[\"module_types\"] = self.module_types\n        if self.kiara_model_types or not skip_empty_types:\n            result[\"kiara_model_types\"] = self.kiara_model_types\n        # if self.metadata_types or not skip_empty_types:\n        #     result[\"metadata_types\"] = self.metadata_types\n        if self.operation_types or not skip_empty_types:\n            result[\"operation_types\"] = self.operation_types\n        if self.operations or not skip_empty_types:\n            result[\"operations\"] = self.operations\n\n        return result\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.package_filter","title":"<code>package_filter: Union[str, None] = Field(description='Whether this context is filtered to only include information included in a specific Python package.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.data_types","title":"<code>data_types: DataTypeClassesInfo = Field(description='The included data types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.module_types","title":"<code>module_types: ModuleTypesInfo = Field(description='The included kiara module types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.kiara_model_types","title":"<code>kiara_model_types: KiaraModelClassesInfo = Field(description='The included model classes.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.operation_types","title":"<code>operation_types: OperationTypeClassesInfo = Field(description='The included operation types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.operations","title":"<code>operations: OperationGroupInfo = Field(description='The included operations.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.create_from_kiara_instance","title":"<code>create_from_kiara_instance(kiara: Kiara, package_filter: Union[str, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>@classmethod\ndef create_from_kiara_instance(\n    cls, kiara: \"Kiara\", package_filter: Union[str, None] = None\n):\n\n    data_types = kiara.type_registry.get_context_metadata(\n        only_for_package=package_filter\n    )\n    modules = kiara.module_registry.get_context_metadata(\n        only_for_package=package_filter\n    )\n    operation_types = kiara.operation_registry.get_context_metadata(\n        only_for_package=package_filter\n    )\n    operations = filter_operations(\n        kiara=kiara, pkg_name=package_filter, **kiara.operation_registry.operations\n    )\n\n    model_registry = kiara.kiara_model_registry\n    if package_filter:\n        kiara_models = model_registry.get_models_for_package(\n            package_name=package_filter\n        )\n    else:\n        kiara_models = model_registry.all_models\n\n    # metadata_types = find_metadata_models(only_for_package=package_filter)\n\n    return KiaraContextInfo.construct(\n        kiara_id=kiara.id,\n        package_filter=package_filter,\n        data_types=data_types,\n        module_types=modules,\n        kiara_model_types=kiara_models,\n        # metadata_types=metadata_types,\n        operation_types=operation_types,\n        operations=operations,\n    )\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.get_info","title":"<code>get_info(item_type: str, item_id: str) -&gt; ItemInfo</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def get_info(self, item_type: str, item_id: str) -&gt; ItemInfo:\n\n    if item_type == \"data_type\" or item_type == \"data_types\":\n        group_info: InfoItemGroup = self.data_types\n    elif \"module\" in item_type:\n        group_info = self.module_types\n    # elif \"metadata\" in item_type:\n    #     group_info = self.metadata_types\n    elif \"operation_type\" in item_type or \"operation_types\" in item_type:\n        group_info = self.operation_types\n    elif \"operation\" in item_type:\n        group_info = self.operations\n    elif \"kiara_model\" in item_type:\n        group_info = self.kiara_model_types\n    else:\n        item_types = [\n            \"data_type\",\n            \"module_type\",\n            \"kiara_model_type\",\n            \"operation_type\",\n            \"operation\",\n        ]\n        raise Exception(\n            f\"Can't determine item type '{item_type}', use one of: {', '.join(item_types)}\"\n        )\n    return group_info[item_id]\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context.KiaraContextInfo.get_all_info","title":"<code>get_all_info(skip_empty_types: bool = True) -&gt; Dict[str, InfoItemGroup]</code>","text":"Source code in <code>kiara/context/__init__.py</code> <pre><code>def get_all_info(self, skip_empty_types: bool = True) -&gt; Dict[str, InfoItemGroup]:\n\n    result: Dict[str, InfoItemGroup] = {}\n    if self.data_types or not skip_empty_types:\n        result[\"data_types\"] = self.data_types\n    if self.module_types or not skip_empty_types:\n        result[\"module_types\"] = self.module_types\n    if self.kiara_model_types or not skip_empty_types:\n        result[\"kiara_model_types\"] = self.kiara_model_types\n    # if self.metadata_types or not skip_empty_types:\n    #     result[\"metadata_types\"] = self.metadata_types\n    if self.operation_types or not skip_empty_types:\n        result[\"operation_types\"] = self.operation_types\n    if self.operations or not skip_empty_types:\n        result[\"operations\"] = self.operations\n\n    return result\n</code></pre>"},{"location":"reference/kiara/context/__init__/#kiara.context-functions","title":"Functions","text":""},{"location":"reference/kiara/context/__init__/#kiara.context.explain","title":"<code>explain(item: Any, kiara: Union[None, Kiara] = None)</code>","text":"<p>Pretty print information about an item on the terminal.</p> Source code in <code>kiara/context/__init__.py</code> <pre><code>def explain(item: Any, kiara: Union[None, \"Kiara\"] = None):\n\"\"\"Pretty print information about an item on the terminal.\"\"\"\n\n    if isinstance(item, type):\n        from kiara.modules import KiaraModule\n\n        if issubclass(item, KiaraModule):\n            if kiara is None:\n                kiara = Kiara.instance()\n            item = ModuleTypeInfo.create_from_type_class(type_cls=item, kiara=kiara)\n\n    console = get_console()\n    console.print(item)\n</code></pre>"},{"location":"reference/kiara/context/config/","title":"config","text":""},{"location":"reference/kiara/context/config/#kiara.context.config-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.yaml","title":"<code>yaml = r_yaml.YAML(typ='safe', pure=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KIARA_SETTINGS","title":"<code>KIARA_SETTINGS = KiaraSettings()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config-classes","title":"Classes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig","title":"<code>KiaraArchiveConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraArchiveConfig(BaseModel):\n\n    archive_id: str = Field(description=\"The unique archive id.\")\n    archive_type: str = Field(description=\"The archive type.\")\n    config: Mapping[str, Any] = Field(\n        description=\"Archive type specific config.\", default_factory=dict\n    )\n\n    @property\n    def archive_uuid(self) -&gt; uuid.UUID:\n        return uuid.UUID(self.archive_id)\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig.archive_id","title":"<code>archive_id: str = Field(description='The unique archive id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig.archive_type","title":"<code>archive_type: str = Field(description='The archive type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig.config","title":"<code>config: Mapping[str, Any] = Field(description='Archive type specific config.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraArchiveConfig.archive_uuid","title":"<code>archive_uuid: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig","title":"<code>KiaraContextConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraContextConfig(BaseModel):\n    class Config:\n        extra = Extra.forbid\n\n    context_id: str = Field(description=\"A globally unique id for this kiara context.\")\n\n    archives: Dict[str, KiaraArchiveConfig] = Field(\n        description=\"All the archives this kiara context can use and the aliases they are registered with.\"\n    )\n    extra_pipelines: List[str] = Field(\n        description=\"Paths to local folders that contain kiara pipelines.\",\n        default_factory=list,\n    )\n    _context_config_path: Union[Path, None] = PrivateAttr(default=None)\n\n    def add_pipelines(self, *pipelines: str):\n\n        for pipeline in pipelines:\n            if os.path.exists(pipeline):\n                self.extra_pipelines.append(pipeline)\n            else:\n                logger.info(\n                    \"ignore.pipeline\", reason=\"path does not exist\", path=pipeline\n                )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.context_id","title":"<code>context_id: str = Field(description='A globally unique id for this kiara context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.archives","title":"<code>archives: Dict[str, KiaraArchiveConfig] = Field(description='All the archives this kiara context can use and the aliases they are registered with.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.extra_pipelines","title":"<code>extra_pipelines: List[str] = Field(description='Paths to local folders that contain kiara pipelines.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraContextConfig.add_pipelines","title":"<code>add_pipelines(*pipelines: str)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def add_pipelines(self, *pipelines: str):\n\n    for pipeline in pipelines:\n        if os.path.exists(pipeline):\n            self.extra_pipelines.append(pipeline)\n        else:\n            logger.info(\n                \"ignore.pipeline\", reason=\"path does not exist\", path=pipeline\n            )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.JobCacheStrategy","title":"<code>JobCacheStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class JobCacheStrategy(Enum):\n\n    no_cache = \"no_cache\"\n    value_id = \"value_id\"\n    data_hash = \"data_hash\"\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.JobCacheStrategy-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.JobCacheStrategy.no_cache","title":"<code>no_cache = 'no_cache'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.JobCacheStrategy.value_id","title":"<code>value_id = 'value_id'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.JobCacheStrategy.data_hash","title":"<code>data_hash = 'data_hash'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings","title":"<code>KiaraSettings</code>","text":"<p>         Bases: <code>BaseSettings</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraSettings(BaseSettings):\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n        env_prefix = \"kiara_setting_\"\n\n    syntax_highlight_background: str = Field(\n        description=\"The background color for code blocks when rendering to terminal, Jupyter, etc.\",\n        default=\"default\",\n    )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings.syntax_highlight_background","title":"<code>syntax_highlight_background: str = Field(description='The background color for code blocks when rendering to terminal, Jupyter, etc.', default='default')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings-classes","title":"Classes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n    env_prefix = \"kiara_setting_\"\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraSettings.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>env_prefix = 'kiara_setting_'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig","title":"<code>KiaraRuntimeConfig</code>","text":"<p>         Bases: <code>BaseSettings</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraRuntimeConfig(BaseSettings):\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n        env_prefix = \"kiara_runtime_\"\n\n    job_cache: JobCacheStrategy = Field(\n        description=\"Name of the strategy that determines when to re-run jobs or use cached results.\",\n        default=JobCacheStrategy.data_hash,\n    )\n    allow_external: bool = Field(\n        description=\"Whether to allow external external pipelines.\", default=True\n    )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig.job_cache","title":"<code>job_cache: JobCacheStrategy = Field(description='Name of the strategy that determines when to re-run jobs or use cached results.', default=JobCacheStrategy.data_hash)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig.allow_external","title":"<code>allow_external: bool = Field(description='Whether to allow external external pipelines.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n    env_prefix = \"kiara_runtime_\"\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraRuntimeConfig.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>env_prefix = 'kiara_runtime_'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig","title":"<code>KiaraConfig</code>","text":"<p>         Bases: <code>BaseSettings</code></p> Source code in <code>kiara/context/config.py</code> <pre><code>class KiaraConfig(BaseSettings):\n    class Config:\n        env_prefix = \"kiara_\"\n        extra = Extra.forbid\n        use_enum_values = True\n\n    @classmethod\n    def create_in_folder(cls, path: Union[Path, str]) -&gt; \"KiaraConfig\":\n\n        if isinstance(path, str):\n            path = Path(path)\n        path = path.absolute()\n        if path.exists():\n            raise Exception(\n                f\"Can't create new kiara config, path exists: {path.as_posix()}\"\n            )\n\n        config = KiaraConfig(base_data_path=path.as_posix())\n        config_file = path / KIARA_CONFIG_FILE_NAME\n\n        config.save(config_file)\n\n        return config\n\n    @classmethod\n    def load_from_file(cls, path: Union[Path, None] = None) -&gt; \"KiaraConfig\":\n\n        if path is None:\n            path = Path(KIARA_MAIN_CONFIG_FILE)\n\n        if not path.exists():\n            raise Exception(\n                f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n            )\n\n        if path.is_dir():\n            path = path / KIARA_CONFIG_FILE_NAME\n            if not path.exists():\n                raise Exception(\n                    f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n                )\n\n        with path.open(\"rt\") as f:\n            data = yaml.load(f)\n\n        config = KiaraConfig(**data)\n        config._config_path = path\n        return config\n\n    context_search_paths: List[str] = Field(\n        description=\"The base path to look for contexts in.\",\n        default=[KIARA_MAIN_CONTEXTS_PATH],\n    )\n    base_data_path: str = Field(\n        description=\"The base path to use for all data (unless otherwise specified.\",\n        default=kiara_app_dirs.user_data_dir,\n    )\n    stores_base_path: str = Field(\n        description=\"The base path for the stores of this context.\"\n    )\n    default_context: str = Field(\n        description=\"The name of the default context to use if none is provided.\",\n        default=DEFAULT_CONTEXT_NAME,\n    )\n    auto_generate_contexts: bool = Field(\n        description=\"Whether to auto-generate requested contexts if they don't exist yet.\",\n        default=True,\n    )\n    runtime_config: KiaraRuntimeConfig = Field(\n        description=\"The kiara runtime config.\", default_factory=KiaraRuntimeConfig\n    )\n\n    _contexts: Dict[uuid.UUID, \"Kiara\"] = PrivateAttr(default_factory=dict)\n    _available_context_files: Dict[str, Path] = PrivateAttr(default=None)\n    _context_data: Dict[str, KiaraContextConfig] = PrivateAttr(default_factory=dict)\n    _config_path: Union[Path, None] = PrivateAttr(default=None)\n\n    @validator(\"context_search_paths\")\n    def validate_context_search_paths(cls, v):\n\n        if not v or not v[0]:\n            v = [KIARA_MAIN_CONTEXTS_PATH]\n\n        return v\n\n    @root_validator(pre=True)\n    def _set_paths(cls, values: Any):\n\n        base_path = values.get(\"base_data_path\", None)\n        if not base_path:\n            base_path = os.path.abspath(kiara_app_dirs.user_data_dir)\n            values[\"base_data_path\"] = base_path\n        elif isinstance(base_path, Path):\n            base_path = base_path.absolute().as_posix()\n            values[\"base_data_path\"] = base_path\n\n        stores_base_path = values.get(\"stores_base_path\", None)\n        if not stores_base_path:\n            stores_base_path = os.path.join(base_path, \"stores\")\n            values[\"stores_base_path\"] = stores_base_path\n\n        context_search_paths = values.get(\"context_search_paths\")\n        if not context_search_paths:\n            context_search_paths = [os.path.join(base_path, \"contexts\")]\n            values[\"context_search_paths\"] = context_search_paths\n\n        return values\n\n    @property\n    def available_context_names(self) -&gt; Iterable[str]:\n\n        if self._available_context_files is not None:\n            return self._available_context_files.keys()\n\n        result = {}\n        for search_path in self.context_search_paths:\n            sp = Path(search_path)\n            for path in sp.rglob(\"*.yaml\"):\n                rel_path = path.relative_to(sp)\n                alias = rel_path.as_posix()[0:-5]\n                alias = alias.replace(os.sep, \".\")\n                result[alias] = path\n        self._available_context_files = result\n        return self._available_context_files.keys()\n\n    @property\n    def context_configs(self) -&gt; Mapping[str, KiaraContextConfig]:\n\n        return {a: self.get_context_config(a) for a in self.available_context_names}\n\n    def get_context_config(\n        self,\n        context_name: Union[str, None] = None,\n        auto_generate: Union[bool, None] = None,\n    ) -&gt; KiaraContextConfig:\n\n        if auto_generate is None:\n            auto_generate = self.auto_generate_contexts\n\n        if context_name is None:\n            context_name = self.default_context\n\n        if context_name not in self.available_context_names:\n            if not auto_generate and not context_name == DEFAULT_CONTEXT_NAME:\n                raise Exception(\n                    f\"No kiara context with name '{context_name}' available.\"\n                )\n            else:\n                return self.create_context_config(context_alias=context_name)\n\n        if context_name in self._context_data.keys():\n            return self._context_data[context_name]\n\n        context_file = self._available_context_files[context_name]\n        context_data = get_data_from_file(context_file, content_type=\"yaml\")\n\n        changed = False\n        if \"extra_pipeline_folders\" in context_data.keys():\n            epf = context_data.pop(\"extra_pipeline_folders\")\n            context_data.setdefault(\"extra_pipelines\", []).extend(epf)\n            changed = True\n\n        context = KiaraContextConfig(**context_data)\n\n        if not changed:\n            changed = self._validate_context(context_config=context)\n\n        if changed:\n            logger.debug(\n                \"write.context_file\",\n                context_config_file=context_file.as_posix(),\n                context_name=context_name,\n                reason=\"context changed after validation\",\n            )\n            context_file.parent.mkdir(parents=True, exist_ok=True)\n            with open(context_file, \"wt\") as f:\n                yaml.dump(context.dict(), f)\n\n        context._context_config_path = context_file\n\n        self._context_data[context_name] = context\n        return context\n\n    def _validate_context(self, context_config: KiaraContextConfig) -&gt; bool:\n\n        env_registry = EnvironmentRegistry.instance()\n        from kiara.models.runtime_environment.kiara import KiaraTypesRuntimeEnvironment\n\n        kiara_types: KiaraTypesRuntimeEnvironment = env_registry.environments[\"kiara_types\"]  # type: ignore\n        available_archives = kiara_types.archive_types\n\n        changed = False\n        if DEFAULT_DATA_STORE_MARKER not in context_config.archives.keys():\n            data_store_type = \"filesystem_data_store\"\n            assert data_store_type in available_archives.item_infos.keys()\n\n            data_store_id = ID_REGISTRY.generate(comment=\"default data store id\")\n            data_archive_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, data_store_type, str(data_store_id)\n                    )\n                )\n            }\n            data_store = KiaraArchiveConfig.construct(\n                archive_id=str(data_store_id),\n                archive_type=data_store_type,\n                config=data_archive_config,\n            )\n            context_config.archives[DEFAULT_DATA_STORE_MARKER] = data_store\n\n            changed = True\n\n        if DEFAULT_JOB_STORE_MARKER not in context_config.archives.keys():\n            job_store_type = \"filesystem_job_store\"\n            assert job_store_type in available_archives.item_infos.keys()\n\n            job_store_id = ID_REGISTRY.generate(comment=\"default job store id\")\n            job_archive_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, job_store_type, str(job_store_id)\n                    )\n                )\n            }\n            job_store = KiaraArchiveConfig.construct(\n                archive_id=str(job_store_id),\n                archive_type=job_store_type,\n                config=job_archive_config,\n            )\n            context_config.archives[DEFAULT_JOB_STORE_MARKER] = job_store\n\n            changed = True\n\n        if DEFAULT_ALIAS_STORE_MARKER not in context_config.archives.keys():\n\n            alias_store_type = \"filesystem_alias_store\"\n            assert alias_store_type in available_archives.item_infos.keys()\n            alias_store_id = ID_REGISTRY.generate(comment=\"default alias store id\")\n            alias_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, alias_store_type, str(alias_store_id)\n                    )\n                )\n            }\n            alias_store = KiaraArchiveConfig.construct(\n                archive_id=str(alias_store_id),\n                archive_type=alias_store_type,\n                config=alias_store_config,\n            )\n            context_config.archives[DEFAULT_ALIAS_STORE_MARKER] = alias_store\n\n            changed = True\n\n        if DEFAULT_WORKFLOW_STORE_MARKER not in context_config.archives.keys():\n\n            workflow_store_type = \"filesystem_workflow_store\"\n            assert workflow_store_type in available_archives.item_infos.keys()\n            workflow_store_id = ID_REGISTRY.generate(\n                comment=\"default workflow store id\"\n            )\n            workflow_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path,\n                        workflow_store_type,\n                        str(workflow_store_id),\n                    )\n                )\n            }\n            workflow_store = KiaraArchiveConfig.construct(\n                archive_id=str(workflow_store_id),\n                archive_type=workflow_store_type,\n                config=workflow_store_config,\n            )\n            context_config.archives[DEFAULT_WORKFLOW_STORE_MARKER] = workflow_store\n\n            changed = True\n\n        if METADATA_DESTINY_STORE_MARKER not in context_config.archives.keys():\n            destiny_store_type = \"filesystem_destiny_store\"\n            assert destiny_store_type in available_archives.item_infos.keys()\n            destiny_store_id = ID_REGISTRY.generate(comment=\"default destiny store id\")\n            destiny_store_config = {\n                \"archive_path\": os.path.abspath(\n                    os.path.join(\n                        self.stores_base_path, destiny_store_type, str(destiny_store_id)\n                    )\n                )\n            }\n            destiny_store = KiaraArchiveConfig.construct(\n                archive_id=str(destiny_store_id),\n                archive_type=destiny_store_type,\n                config=destiny_store_config,\n            )\n            context_config.archives[METADATA_DESTINY_STORE_MARKER] = destiny_store\n\n            changed = True\n\n        return changed\n\n    def create_context_config(\n        self, context_alias: Union[str, None] = None\n    ) -&gt; KiaraContextConfig:\n\n        if not context_alias:\n            context_alias = DEFAULT_CONTEXT_NAME\n        if context_alias in self.available_context_names:\n            raise Exception(\n                f\"Can't create kiara context '{context_alias}': context with that alias already registered.\"\n            )\n\n        if os.path.sep in context_alias:\n            raise Exception(\n                f\"Can't create context with alias '{context_alias}': no special characters allowed.\"\n            )\n\n        context_file = (\n            Path(os.path.join(self.context_search_paths[0])) / f\"{context_alias}.yaml\"\n        )\n\n        archives: Dict[str, KiaraArchiveConfig] = {}\n        # create_default_archives(kiara_config=self)\n        context_id = ID_REGISTRY.generate(\n            obj_type=KiaraContextConfig, comment=f\"new kiara context '{context_alias}'\"\n        )\n\n        context_config = KiaraContextConfig(\n            context_id=str(context_id), archives=archives, extra_pipelines=[]\n        )\n\n        self._validate_context(context_config=context_config)\n\n        context_file.parent.mkdir(parents=True, exist_ok=True)\n        with open(context_file, \"wt\") as f:\n            yaml.dump(context_config.dict(), f)\n\n        context_config._context_config_path = context_file\n\n        self._available_context_files[context_alias] = context_file\n        self._context_data[context_alias] = context_config\n\n        return context_config\n\n    def create_context(\n        self,\n        context: Union[None, str, uuid.UUID, Path] = None,\n        extra_pipelines: Union[None, str, Iterable[str]] = None,\n    ) -&gt; \"Kiara\":\n\n        if not context:\n            context = self.default_context\n        else:\n            with contextlib.suppress(Exception):\n                context = uuid.UUID(context)  # type: ignore\n\n        if isinstance(context, str) and os.path.exists(context):\n            context = Path(context)\n\n        if isinstance(context, Path):\n            with context.open(\"rt\") as f:\n                data = yaml.load(f)\n            context_config = KiaraContextConfig(**data)\n        elif isinstance(context, str):\n            context_config = self.get_context_config(context_name=context)\n        elif isinstance(context, uuid.UUID):\n            context_config = self.find_context_config(context_id=context)\n        else:\n            raise Exception(\n                f\"Can't retrieve context, invalid context config type '{type(context)}'.\"\n            )\n\n        assert context_config.context_id not in self._contexts.keys()\n\n        if extra_pipelines:\n            if isinstance(extra_pipelines, str):\n                extra_pipelines = [extra_pipelines]\n            context_config.add_pipelines(*extra_pipelines)\n\n        from kiara.context import Kiara\n\n        kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n        assert kiara.id == uuid.UUID(context_config.context_id)\n        self._contexts[kiara.id] = kiara\n\n        return kiara\n\n    def find_context_config(self, context_id: uuid.UUID) -&gt; KiaraContextConfig:\n        raise NotImplementedError()\n\n    def save(self, path: Union[Path, None] = None):\n        if path is None:\n            path = Path(KIARA_MAIN_CONFIG_FILE)\n\n        if path.exists():\n            raise Exception(\n                f\"Can't save config file, path already exists: {path.as_posix()}\"\n            )\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with path.open(\"wt\") as f:\n            yaml.dump(\n                self.dict(\n                    exclude={\n                        \"context\",\n                        \"auto_generate_contexts\",\n                        \"stores_base_path\",\n                        \"context_search_paths\",\n                        \"default_context\",\n                        \"runtime_config\",\n                    }\n                ),\n                f,\n            )\n\n        self._config_path = path\n\n    def delete(\n        self, context_name: Union[str, None] = None, dry_run: bool = True\n    ) -&gt; \"ContextInfo\":\n\n        if context_name is None:\n            context_name = self.default_context\n\n        from kiara.context import Kiara\n        from kiara.models.context import ContextInfo\n\n        context_config = self.get_context_config(\n            context_name=context_name, auto_generate=False\n        )\n        kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n\n        context_summary = ContextInfo.create_from_context(\n            kiara=kiara, context_name=context_name\n        )\n\n        if dry_run:\n            return context_summary\n\n        for archive in kiara.get_all_archives().keys():\n            archive.delete_archive(archive_id=archive.archive_id)\n\n        if context_config._context_config_path is not None:\n            os.unlink(context_config._context_config_path)\n\n        return context_summary\n\n    def create_renderable(self, **render_config: Any):\n        from kiara.utils.output import create_recursive_table_from_model_object\n\n        return create_recursive_table_from_model_object(\n            self, render_config=render_config\n        )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.context_search_paths","title":"<code>context_search_paths: List[str] = Field(description='The base path to look for contexts in.', default=[KIARA_MAIN_CONTEXTS_PATH])</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.base_data_path","title":"<code>base_data_path: str = Field(description='The base path to use for all data (unless otherwise specified.', default=kiara_app_dirs.user_data_dir)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.stores_base_path","title":"<code>stores_base_path: str = Field(description='The base path for the stores of this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.default_context","title":"<code>default_context: str = Field(description='The name of the default context to use if none is provided.', default=DEFAULT_CONTEXT_NAME)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.auto_generate_contexts","title":"<code>auto_generate_contexts: bool = Field(description=\"Whether to auto-generate requested contexts if they don't exist yet.\", default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.runtime_config","title":"<code>runtime_config: KiaraRuntimeConfig = Field(description='The kiara runtime config.', default_factory=KiaraRuntimeConfig)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.available_context_names","title":"<code>available_context_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.context_configs","title":"<code>context_configs: Mapping[str, KiaraContextConfig]</code>  <code>property</code>","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>class Config:\n    env_prefix = \"kiara_\"\n    extra = Extra.forbid\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.Config-attributes","title":"Attributes","text":"<code>env_prefix = 'kiara_'</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.create_in_folder","title":"<code>create_in_folder(path: Union[Path, str]) -&gt; KiaraConfig</code>  <code>classmethod</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@classmethod\ndef create_in_folder(cls, path: Union[Path, str]) -&gt; \"KiaraConfig\":\n\n    if isinstance(path, str):\n        path = Path(path)\n    path = path.absolute()\n    if path.exists():\n        raise Exception(\n            f\"Can't create new kiara config, path exists: {path.as_posix()}\"\n        )\n\n    config = KiaraConfig(base_data_path=path.as_posix())\n    config_file = path / KIARA_CONFIG_FILE_NAME\n\n    config.save(config_file)\n\n    return config\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.load_from_file","title":"<code>load_from_file(path: Union[Path, None] = None) -&gt; KiaraConfig</code>  <code>classmethod</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@classmethod\ndef load_from_file(cls, path: Union[Path, None] = None) -&gt; \"KiaraConfig\":\n\n    if path is None:\n        path = Path(KIARA_MAIN_CONFIG_FILE)\n\n    if not path.exists():\n        raise Exception(\n            f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n        )\n\n    if path.is_dir():\n        path = path / KIARA_CONFIG_FILE_NAME\n        if not path.exists():\n            raise Exception(\n                f\"Can't load kiara config, path does not exist: {path.as_posix()}\"\n            )\n\n    with path.open(\"rt\") as f:\n        data = yaml.load(f)\n\n    config = KiaraConfig(**data)\n    config._config_path = path\n    return config\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.validate_context_search_paths","title":"<code>validate_context_search_paths(v)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>@validator(\"context_search_paths\")\ndef validate_context_search_paths(cls, v):\n\n    if not v or not v[0]:\n        v = [KIARA_MAIN_CONTEXTS_PATH]\n\n    return v\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.get_context_config","title":"<code>get_context_config(context_name: Union[str, None] = None, auto_generate: Union[bool, None] = None) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def get_context_config(\n    self,\n    context_name: Union[str, None] = None,\n    auto_generate: Union[bool, None] = None,\n) -&gt; KiaraContextConfig:\n\n    if auto_generate is None:\n        auto_generate = self.auto_generate_contexts\n\n    if context_name is None:\n        context_name = self.default_context\n\n    if context_name not in self.available_context_names:\n        if not auto_generate and not context_name == DEFAULT_CONTEXT_NAME:\n            raise Exception(\n                f\"No kiara context with name '{context_name}' available.\"\n            )\n        else:\n            return self.create_context_config(context_alias=context_name)\n\n    if context_name in self._context_data.keys():\n        return self._context_data[context_name]\n\n    context_file = self._available_context_files[context_name]\n    context_data = get_data_from_file(context_file, content_type=\"yaml\")\n\n    changed = False\n    if \"extra_pipeline_folders\" in context_data.keys():\n        epf = context_data.pop(\"extra_pipeline_folders\")\n        context_data.setdefault(\"extra_pipelines\", []).extend(epf)\n        changed = True\n\n    context = KiaraContextConfig(**context_data)\n\n    if not changed:\n        changed = self._validate_context(context_config=context)\n\n    if changed:\n        logger.debug(\n            \"write.context_file\",\n            context_config_file=context_file.as_posix(),\n            context_name=context_name,\n            reason=\"context changed after validation\",\n        )\n        context_file.parent.mkdir(parents=True, exist_ok=True)\n        with open(context_file, \"wt\") as f:\n            yaml.dump(context.dict(), f)\n\n    context._context_config_path = context_file\n\n    self._context_data[context_name] = context\n    return context\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.create_context_config","title":"<code>create_context_config(context_alias: Union[str, None] = None) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_context_config(\n    self, context_alias: Union[str, None] = None\n) -&gt; KiaraContextConfig:\n\n    if not context_alias:\n        context_alias = DEFAULT_CONTEXT_NAME\n    if context_alias in self.available_context_names:\n        raise Exception(\n            f\"Can't create kiara context '{context_alias}': context with that alias already registered.\"\n        )\n\n    if os.path.sep in context_alias:\n        raise Exception(\n            f\"Can't create context with alias '{context_alias}': no special characters allowed.\"\n        )\n\n    context_file = (\n        Path(os.path.join(self.context_search_paths[0])) / f\"{context_alias}.yaml\"\n    )\n\n    archives: Dict[str, KiaraArchiveConfig] = {}\n    # create_default_archives(kiara_config=self)\n    context_id = ID_REGISTRY.generate(\n        obj_type=KiaraContextConfig, comment=f\"new kiara context '{context_alias}'\"\n    )\n\n    context_config = KiaraContextConfig(\n        context_id=str(context_id), archives=archives, extra_pipelines=[]\n    )\n\n    self._validate_context(context_config=context_config)\n\n    context_file.parent.mkdir(parents=True, exist_ok=True)\n    with open(context_file, \"wt\") as f:\n        yaml.dump(context_config.dict(), f)\n\n    context_config._context_config_path = context_file\n\n    self._available_context_files[context_alias] = context_file\n    self._context_data[context_alias] = context_config\n\n    return context_config\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.create_context","title":"<code>create_context(context: Union[None, str, uuid.UUID, Path] = None, extra_pipelines: Union[None, str, Iterable[str]] = None) -&gt; Kiara</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_context(\n    self,\n    context: Union[None, str, uuid.UUID, Path] = None,\n    extra_pipelines: Union[None, str, Iterable[str]] = None,\n) -&gt; \"Kiara\":\n\n    if not context:\n        context = self.default_context\n    else:\n        with contextlib.suppress(Exception):\n            context = uuid.UUID(context)  # type: ignore\n\n    if isinstance(context, str) and os.path.exists(context):\n        context = Path(context)\n\n    if isinstance(context, Path):\n        with context.open(\"rt\") as f:\n            data = yaml.load(f)\n        context_config = KiaraContextConfig(**data)\n    elif isinstance(context, str):\n        context_config = self.get_context_config(context_name=context)\n    elif isinstance(context, uuid.UUID):\n        context_config = self.find_context_config(context_id=context)\n    else:\n        raise Exception(\n            f\"Can't retrieve context, invalid context config type '{type(context)}'.\"\n        )\n\n    assert context_config.context_id not in self._contexts.keys()\n\n    if extra_pipelines:\n        if isinstance(extra_pipelines, str):\n            extra_pipelines = [extra_pipelines]\n        context_config.add_pipelines(*extra_pipelines)\n\n    from kiara.context import Kiara\n\n    kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n    assert kiara.id == uuid.UUID(context_config.context_id)\n    self._contexts[kiara.id] = kiara\n\n    return kiara\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.find_context_config","title":"<code>find_context_config(context_id: uuid.UUID) -&gt; KiaraContextConfig</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def find_context_config(self, context_id: uuid.UUID) -&gt; KiaraContextConfig:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.save","title":"<code>save(path: Union[Path, None] = None)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def save(self, path: Union[Path, None] = None):\n    if path is None:\n        path = Path(KIARA_MAIN_CONFIG_FILE)\n\n    if path.exists():\n        raise Exception(\n            f\"Can't save config file, path already exists: {path.as_posix()}\"\n        )\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    with path.open(\"wt\") as f:\n        yaml.dump(\n            self.dict(\n                exclude={\n                    \"context\",\n                    \"auto_generate_contexts\",\n                    \"stores_base_path\",\n                    \"context_search_paths\",\n                    \"default_context\",\n                    \"runtime_config\",\n                }\n            ),\n            f,\n        )\n\n    self._config_path = path\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.delete","title":"<code>delete(context_name: Union[str, None] = None, dry_run: bool = True) -&gt; ContextInfo</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def delete(\n    self, context_name: Union[str, None] = None, dry_run: bool = True\n) -&gt; \"ContextInfo\":\n\n    if context_name is None:\n        context_name = self.default_context\n\n    from kiara.context import Kiara\n    from kiara.models.context import ContextInfo\n\n    context_config = self.get_context_config(\n        context_name=context_name, auto_generate=False\n    )\n    kiara = Kiara(config=context_config, runtime_config=self.runtime_config)\n\n    context_summary = ContextInfo.create_from_context(\n        kiara=kiara, context_name=context_name\n    )\n\n    if dry_run:\n        return context_summary\n\n    for archive in kiara.get_all_archives().keys():\n        archive.delete_archive(archive_id=archive.archive_id)\n\n    if context_config._context_config_path is not None:\n        os.unlink(context_config._context_config_path)\n\n    return context_summary\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config.KiaraConfig.create_renderable","title":"<code>create_renderable(**render_config: Any)</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def create_renderable(self, **render_config: Any):\n    from kiara.utils.output import create_recursive_table_from_model_object\n\n    return create_recursive_table_from_model_object(\n        self, render_config=render_config\n    )\n</code></pre>"},{"location":"reference/kiara/context/config/#kiara.context.config-functions","title":"Functions","text":""},{"location":"reference/kiara/context/config/#kiara.context.config.config_file_settings_source","title":"<code>config_file_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/context/config.py</code> <pre><code>def config_file_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]:\n    if os.path.isfile(KIARA_MAIN_CONFIG_FILE):\n        config = get_data_from_file(KIARA_MAIN_CONFIG_FILE, content_type=\"yaml\")\n        if not isinstance(config, Mapping):\n            raise ValueError(\n                f\"Invalid config file format, can't parse file: {KIARA_MAIN_CONFIG_FILE}\"\n            )\n    else:\n        config = {}\n    return config\n</code></pre>"},{"location":"reference/kiara/context/orm/","title":"orm","text":""},{"location":"reference/kiara/data_types/__init__/","title":"data_types","text":"<p>This is the base module that contains everything data type-related in kiara.</p> <p>I'm still not 100% sure how to best implement the kiara type system, there are several ways it could be done, for example based on Python type-hints, using JSON-schema, Avro (which is my 2nd favourite option), as well as by implementing a custom type-class hierarchy. Which is what I have choosen to try first. For now, it looks like it'll work out, but there is a chance requirements I haven't forseen will crop up that could make this become ugly.</p> <p>Anyway, the way it works (for now) is that kiara comes with a set of often used data_types (the standard set of: scalars, list, dict, table &amp; array, etc.) which each come with 2 functions that can serialize and deserialize values of that type in a persistant fashion -- which could be storing as a file on disk, or as a cell/row in a database. Those functions will most likley be kiara modules themselves, with even more restricted input/output type options.</p> <p>In addition, packages that contain modules can implement their own, custom data_types, if suitable ones are not available in core-kiara. Those can either be 'serialized/deserialized' into kiara-native data_types (which in turn will serialize them using their own serializing functions), or will have to implement custom serializing functionality (which will probably be discouraged, since this might not be trivial and there are quite a few things to consider).</p>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.TYPE_PYTHON_CLS","title":"<code>TYPE_PYTHON_CLS = TypeVar('TYPE_PYTHON_CLS')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.TYPE_CONFIG_CLS","title":"<code>TYPE_CONFIG_CLS = TypeVar('TYPE_CONFIG_CLS', bound=DataTypeConfig)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig","title":"<code>DataTypeConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Base class that describes the configuration a <code>DataType</code> class accepts.</p> <p>This is stored in the <code>_config_cls</code> class attribute in each <code>DataType</code> class. By default, a <code>DataType</code> is not configurable, unless the <code>_config_cls</code> class attribute points to a sub-class of this class.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>class DataTypeConfig(BaseModel):\n\"\"\"Base class that describes the configuration a [``DataType``][kiara.data.data_types.DataType] class accepts.\n\n    This is stored in the ``_config_cls`` class attribute in each ``DataType`` class. By default,\n    a ``DataType`` is not configurable, unless the ``_config_cls`` class attribute points to a sub-class of this class.\n    \"\"\"\n\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n        extra = Extra.forbid\n\n    @classmethod\n    def requires_config(cls) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n        for field_name, field in cls.__fields__.items():\n            if field.required and field.default is None:\n                return True\n        return False\n\n    _config_hash: Union[int, None] = PrivateAttr(default=None)\n\n    def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n        if key not in self.__fields__:\n            raise Exception(\n                f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n            )\n\n        return getattr(self, key)\n\n    @property\n    def config_hash(self) -&gt; int:\n\n        if self._config_hash is None:\n            _d = self.dict()\n            hashes = DeepHash(_d)\n            self._config_hash = hashes[_d]\n        return self._config_hash\n\n    def __eq__(self, other):\n\n        if self.__class__ != other.__class__:\n            return False\n\n        return self.dict() == other.dict()\n\n    def __hash__(self):\n\n        return self.config_hash\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n\n        my_table = Table(box=box.MINIMAL, show_header=False)\n        my_table.add_column(\"Field name\", style=\"i\")\n        my_table.add_column(\"Value\")\n        for field in self.__fields__:\n            my_table.add_row(field, getattr(self, field))\n\n        yield my_table\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig.config_hash","title":"<code>config_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig.requires_config","title":"<code>requires_config() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Return whether this class can be used as-is, or requires configuration before an instance can be created.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>@classmethod\ndef requires_config(cls) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n    for field_name, field in cls.__fields__.items():\n        if field.required and field.default is None:\n            return True\n    return False\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataTypeConfig.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Get the value for the specified configuation key.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n    if key not in self.__fields__:\n        raise Exception(\n            f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n        )\n\n    return getattr(self, key)\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType","title":"<code>DataType</code>","text":"<p>         Bases: <code>abc.ABC</code>, <code>Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]</code></p> <p>Base class that all kiara data_types must inherit from.</p> <p>kiara data_types have 3 main responsibilities:</p> <ul> <li>serialize into / deserialize from persistent state</li> <li>data validation</li> <li>metadata extraction</li> </ul> <p>Serializing being the arguably most important of those, because without most of the data management features of  kiara would be impossible. Validation should not require any explanation. Metadata extraction is important, because  that metadata will be available to other components of kiara (or frontends for it), without them having to request  the actual data. That will hopefully make kiara very efficient in terms of memory management, as well as data  transfer and I/O. Ideally, the actual data (bytes) will only be requested at the last possible moment. For example when a  module needs the input data to do processing on it -- and even then it might be that it only requests a part of the  data, say a single column of a table. Or when a frontend needs to display/visualize the data.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>class DataType(abc.ABC, Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]):\n\"\"\"Base class that all *kiara* data_types must inherit from.\n\n    *kiara* data_types have 3 main responsibilities:\n\n     - serialize into / deserialize from persistent state\n     - data validation\n     - metadata extraction\n\n     Serializing being the arguably most important of those, because without most of the data management features of\n     *kiara* would be impossible. Validation should not require any explanation. Metadata extraction is important, because\n     that metadata will be available to other components of *kiara* (or frontends for it), without them having to request\n     the actual data. That will hopefully make *kiara* very efficient in terms of memory management, as well as data\n     transfer and I/O. Ideally, the actual data (bytes) will only be requested at the last possible moment. For example when a\n     module needs the input data to do processing on it -- and even then it might be that it only requests a part of the\n     data, say a single column of a table. Or when a frontend needs to display/visualize the data.\n    \"\"\"\n\n    @classmethod\n    def retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n        return {}\n\n    @classmethod\n    @abc.abstractmethod\n    def python_class(cls) -&gt; Type[TYPE_PYTHON_CLS]:\n        pass\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[TYPE_CONFIG_CLS]:\n        return DataTypeConfig  # type: ignore\n\n    @classmethod\n    def _calculate_data_type_hash(\n        cls, data_type_config: Union[Mapping[str, Any], DataTypeConfig]\n    ) -&gt; int:\n\n        if isinstance(data_type_config, Mapping):\n            data_type_config = cls.data_type_config_class()(**data_type_config)  # type: ignore\n\n        obj = {\n            \"type\": cls._data_type_name,  # type: ignore\n            \"type_config\": data_type_config.config_hash,\n        }\n        h = DeepHash(obj, hasher=KIARA_HASH_FUNCTION)\n        return h[obj]\n\n    def __init__(self, **type_config: Any):\n\n        try:\n            self._type_config: TYPE_CONFIG_CLS = self.__class__.data_type_config_class()(**type_config)  # type: ignore  # TODO: double-check this is only a mypy issue\n        except ValidationError as ve:\n            raise ValueTypeConfigException(\n                f\"Error creating object for type: {ve}\",\n                self.__class__,\n                type_config,\n                ve,\n            )\n\n        self._data_type_hash: Union[int, None] = None\n        self._characteristics: Union[DataTypeCharacteristics, None] = None\n        self._info: Union[DataTypeInfo, None] = None\n\n    @property\n    def data_type_name(self) -&gt; str:\n        return self._data_type_name  # type: ignore\n\n    @property\n    def data_type_hash(self) -&gt; int:\n        if self._data_type_hash is None:\n            self._data_type_hash = self.__class__._calculate_data_type_hash(\n                self._type_config\n            )\n        return self._data_type_hash\n\n    @property\n    def info(self) -&gt; \"DataTypeInfo\":\n\n        if self._info is not None:\n            return self._info\n\n        from kiara.models.values.value import DataTypeInfo\n\n        self._info = DataTypeInfo(\n            data_type_name=self.data_type_name,\n            data_type_config=self.type_config.dict(),\n            characteristics=self.characteristics,\n            data_type_class=PythonClass.from_class(self.__class__),\n        )\n        self._info._data_type_instance = self\n        return self._info\n\n    @property\n    def characteristics(self) -&gt; DataTypeCharacteristics:\n        if self._characteristics is not None:\n            return self._characteristics\n\n        self._characteristics = self._retrieve_characteristics()\n        return self._characteristics\n\n    def _retrieve_characteristics(self) -&gt; DataTypeCharacteristics:\n        return DataTypeCharacteristics()\n\n    # @abc.abstractmethod\n    # def is_immutable(self) -&gt; bool:\n    #     pass\n\n    def calculate_hash(self, data: \"SerializedData\") -&gt; str:\n\"\"\"Calculate the hash of the value.\"\"\"\n\n        return data.instance_id\n\n    def calculate_size(self, data: \"SerializedData\") -&gt; int:\n\"\"\"Calculate the size of the value.\"\"\"\n\n        return data.data_size\n\n    def serialize_as_json(self, data: Any) -&gt; \"SerializedData\":\n\n        _data = {\"data\": {\"type\": \"inline-json\", \"inline_data\": data, \"codec\": \"json\"}}\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"json\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"deserialize.from_json\",\n                        \"module_config\": {\"result_path\": \"data\"},\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def serialize(self, data: TYPE_PYTHON_CLS) -&gt; Union[None, str, \"SerializedData\"]:\n\n        logger.debug(\n            \"ignore.serialize_request\",\n            data_type=self.data_type_name,\n            reason=\"no 'serialize' method imnplemented\",\n        )\n        return NO_SERIALIZATION_MARKER\n        # raise NotImplementedError(f\"Data type '{self.data_type_name}' does not support serialization.\")\n        #\n        # try:\n        #     import pickle5 as pickle\n        # except Exception:\n        #     import pickle  # type: ignore\n        #\n        # pickled = pickle.dumps(data, protocol=5)\n        # _data = {\"python_object\": {\"type\": \"chunk\", \"chunk\": pickled, \"codec\": \"raw\"}}\n        #\n        # serialized_data = {\n        #     \"data_type\": self.data_type_name,\n        #     \"data_type_config\": self.type_config.dict(),\n        #     \"data\": _data,\n        #     \"serialization_profile\": \"pickle\",\n        #     \"serialization_metadata\": {\n        #         \"profile\": \"pickle\",\n        #         \"environment\": {},\n        #         \"deserialize\": {\n        #             \"object\": {\n        #                 \"module_name\": \"value.unpickle\",\n        #                 \"module_config\": {\n        #                     \"value_type\": \"any\",\n        #                     \"target_profile\": \"object\",\n        #                     \"serialization_profile\": \"pickle\",\n        #                 },\n        #             }\n        #         },\n        #     },\n        # }\n        # from kiara.models.values.value import SerializationResult\n        #\n        # serialized = SerializationResult(**serialized_data)\n        # return serialized\n\n    @property\n    def type_config(self) -&gt; TYPE_CONFIG_CLS:\n        return self._type_config\n\n    def _pre_examine_data(\n        self, data: Any, schema: ValueSchema\n    ) -&gt; Tuple[Any, Union[str, \"SerializedData\"], ValueStatus, str, int]:\n\n        assert data is not None\n\n        if data is SpecialValue.NOT_SET:\n            status = ValueStatus.NOT_SET\n            data = None\n        elif data is SpecialValue.NO_VALUE:\n            status = ValueStatus.NONE\n            data = None\n        else:\n            status = ValueStatus.SET\n\n        # if data is None and schema.default not in [\n        #     None,\n        #     SpecialValue.NO_VALUE,\n        #     SpecialValue.NOT_SET,\n        # ]:\n        #\n        #     status = ValueStatus.DEFAULT\n        #     if callable(schema.default):\n        #         data = schema.default()\n        #     else:\n        #         data = copy.deepcopy(schema.default)\n\n        if data is None or data is SpecialValue.NOT_SET:\n            # if schema.default in [None, SpecialValue.NO_VALUE]:\n            #     data = SpecialValue.NO_VALUE\n            #     status = ValueStatus.NONE\n            # elif schema.default == SpecialValue.NOT_SET:\n            #     data = SpecialValue.NOT_SET\n            #     status = ValueStatus.NOT_SET\n\n            size = 0\n            value_hash = INVALID_HASH_MARKER\n            serialized: Union[None, str, \"SerializedData\"] = NO_SERIALIZATION_MARKER\n        else:\n\n            from kiara.models.values.value import SerializedData\n\n            if isinstance(data, SerializedData):\n                # TODO: assert value is in schema lineage\n                # assert data.data_type == schema.type\n                # assert data.data_type_config == schema.type_config\n                serialized = data\n                not_serialized: bool = False\n            else:\n                data = self.parse_python_obj(data)\n                if data is None:\n                    raise Exception(\n                        f\"Invalid data, can't parse into a value of type '{schema.type}'.\"\n                    )\n                self._validate(data)\n\n                serialized = self.serialize(data)\n                if serialized is None:\n                    serialized = NO_SERIALIZATION_MARKER\n\n                if isinstance(serialized, str):\n                    not_serialized = True\n                else:\n                    not_serialized = False\n\n            if not_serialized:\n                size = INVALID_SIZE_MARKER\n                value_hash = INVALID_HASH_MARKER\n            else:\n                size = serialized.data_size  # type: ignore\n                value_hash = serialized.instance_id  # type: ignore\n\n        assert serialized is not None\n        result = (data, serialized, status, value_hash, size)\n        return result\n\n    def assemble_value(\n        self,\n        value_id: uuid.UUID,\n        data: Any,\n        schema: ValueSchema,\n        environment_hashes: Mapping[str, Mapping[str, str]],\n        serialized: Union[str, \"SerializedData\"],\n        status: Union[ValueStatus, str],\n        value_hash: str,\n        value_size: int,\n        pedigree: \"ValuePedigree\",\n        kiara_id: uuid.UUID,\n        pedigree_output_name: str,\n    ) -&gt; Tuple[\"Value\", Any]:\n\n        from kiara.models.values.value import Value\n\n        if isinstance(status, str):\n            status = ValueStatus(status).name\n\n        if status in [ValueStatus.SET, ValueStatus.DEFAULT]:\n            try:\n\n                value = Value(\n                    value_id=value_id,\n                    kiara_id=kiara_id,\n                    value_status=status,\n                    value_size=value_size,\n                    value_hash=value_hash,\n                    value_schema=schema,\n                    environment_hashes=environment_hashes,\n                    pedigree=pedigree,\n                    pedigree_output_name=pedigree_output_name,\n                    data_type_info=self.info,\n                )\n\n            except Exception as e:\n                raise KiaraValueException(\n                    data_type=self.__class__, value_data=data, parent=e\n                )\n        else:\n            value = Value(\n                value_id=value_id,\n                kiara_id=kiara_id,\n                value_status=status,\n                value_size=value_size,\n                value_hash=value_hash,\n                value_schema=schema,\n                environment_hashes=environment_hashes,\n                pedigree=pedigree,\n                pedigree_output_name=pedigree_output_name,\n                data_type_info=self.info,\n            )\n\n        value._value_data = data\n        value._serialized_data = serialized\n        return value, data\n\n    def parse_python_obj(self, data: Any) -&gt; TYPE_PYTHON_CLS:\n\"\"\"Parse a value into a supported python type.\n\n        This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object).\n        If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to\n        avoid adding or removing information from the data (e.g. by changing the resolution of a date).\n\n        Arguments:\n            v: the value\n\n        Returns:\n            'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object\n        \"\"\"\n\n        return data\n\n    def _validate(self, value: TYPE_PYTHON_CLS) -&gt; None:\n\"\"\"Validate the value. This expects an instance of the defined Python class (from 'backing_python_type).\"\"\"\n\n        if not isinstance(value, self.__class__.python_class()):\n            raise ValueError(\n                f\"Invalid python type '{type(value)}', must be: {self.__class__.python_class()}\"\n            )\n\n    def create_renderable(self, **config):\n\n        show_type_info = config.get(\"show_type_info\", False)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\")\n        table.add_column(\"value\", style=\"i\")\n        table.add_row(\"type_name\", self.data_type_name)\n        config_json = self.type_config.json(\n            exclude_unset=True, option=orjson.OPT_INDENT_2\n        )\n        config = Syntax(config_json, \"json\", background_color=\"default\")\n        table.add_row(\"type_config\", config)\n\n        if show_type_info:\n            from kiara.interfaces.python_api.models.info import DataTypeClassInfo\n\n            info = DataTypeClassInfo.create_from_type_class(self.__class__)\n            table.add_row(\"\", \"\")\n            table.add_row(\"\", Rule())\n            table.add_row(\"type_info\", info)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.data_type_name","title":"<code>data_type_name: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.data_type_hash","title":"<code>data_type_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.info","title":"<code>info: DataTypeInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.characteristics","title":"<code>characteristics: DataTypeCharacteristics</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.type_config","title":"<code>type_config: TYPE_CONFIG_CLS</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.retrieve_available_type_profiles","title":"<code>retrieve_available_type_profiles() -&gt; Mapping[str, Mapping[str, Any]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>@classmethod\ndef retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n    return {}\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.python_class","title":"<code>python_class() -&gt; Type[TYPE_PYTHON_CLS]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef python_class(cls) -&gt; Type[TYPE_PYTHON_CLS]:\n    pass\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[TYPE_CONFIG_CLS]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[TYPE_CONFIG_CLS]:\n    return DataTypeConfig  # type: ignore\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.calculate_hash","title":"<code>calculate_hash(data: SerializedData) -&gt; str</code>","text":"<p>Calculate the hash of the value.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def calculate_hash(self, data: \"SerializedData\") -&gt; str:\n\"\"\"Calculate the hash of the value.\"\"\"\n\n    return data.instance_id\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.calculate_size","title":"<code>calculate_size(data: SerializedData) -&gt; int</code>","text":"<p>Calculate the size of the value.</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def calculate_size(self, data: \"SerializedData\") -&gt; int:\n\"\"\"Calculate the size of the value.\"\"\"\n\n    return data.data_size\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.serialize_as_json","title":"<code>serialize_as_json(data: Any) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def serialize_as_json(self, data: Any) -&gt; \"SerializedData\":\n\n    _data = {\"data\": {\"type\": \"inline-json\", \"inline_data\": data, \"codec\": \"json\"}}\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"json\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"deserialize.from_json\",\n                    \"module_config\": {\"result_path\": \"data\"},\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.serialize","title":"<code>serialize(data: TYPE_PYTHON_CLS) -&gt; Union[None, str, SerializedData]</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def serialize(self, data: TYPE_PYTHON_CLS) -&gt; Union[None, str, \"SerializedData\"]:\n\n    logger.debug(\n        \"ignore.serialize_request\",\n        data_type=self.data_type_name,\n        reason=\"no 'serialize' method imnplemented\",\n    )\n    return NO_SERIALIZATION_MARKER\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.assemble_value","title":"<code>assemble_value(value_id: uuid.UUID, data: Any, schema: ValueSchema, environment_hashes: Mapping[str, Mapping[str, str]], serialized: Union[str, SerializedData], status: Union[ValueStatus, str], value_hash: str, value_size: int, pedigree: ValuePedigree, kiara_id: uuid.UUID, pedigree_output_name: str) -&gt; Tuple[Value, Any]</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def assemble_value(\n    self,\n    value_id: uuid.UUID,\n    data: Any,\n    schema: ValueSchema,\n    environment_hashes: Mapping[str, Mapping[str, str]],\n    serialized: Union[str, \"SerializedData\"],\n    status: Union[ValueStatus, str],\n    value_hash: str,\n    value_size: int,\n    pedigree: \"ValuePedigree\",\n    kiara_id: uuid.UUID,\n    pedigree_output_name: str,\n) -&gt; Tuple[\"Value\", Any]:\n\n    from kiara.models.values.value import Value\n\n    if isinstance(status, str):\n        status = ValueStatus(status).name\n\n    if status in [ValueStatus.SET, ValueStatus.DEFAULT]:\n        try:\n\n            value = Value(\n                value_id=value_id,\n                kiara_id=kiara_id,\n                value_status=status,\n                value_size=value_size,\n                value_hash=value_hash,\n                value_schema=schema,\n                environment_hashes=environment_hashes,\n                pedigree=pedigree,\n                pedigree_output_name=pedigree_output_name,\n                data_type_info=self.info,\n            )\n\n        except Exception as e:\n            raise KiaraValueException(\n                data_type=self.__class__, value_data=data, parent=e\n            )\n    else:\n        value = Value(\n            value_id=value_id,\n            kiara_id=kiara_id,\n            value_status=status,\n            value_size=value_size,\n            value_hash=value_hash,\n            value_schema=schema,\n            environment_hashes=environment_hashes,\n            pedigree=pedigree,\n            pedigree_output_name=pedigree_output_name,\n            data_type_info=self.info,\n        )\n\n    value._value_data = data\n    value._serialized_data = serialized\n    return value, data\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; TYPE_PYTHON_CLS</code>","text":"<p>Parse a value into a supported python type.</p> <p>This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object). If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to avoid adding or removing information from the data (e.g. by changing the resolution of a date).</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <p>the value</p> required <p>Returns:</p> Type Description <code>TYPE_PYTHON_CLS</code> <p>'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object</p> Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; TYPE_PYTHON_CLS:\n\"\"\"Parse a value into a supported python type.\n\n    This exists to make it easier to do trivial conversions (e.g. from a date string to a datetime object).\n    If you choose to overwrite this method, make 100% sure that you don't change the meaning of the value, and try to\n    avoid adding or removing information from the data (e.g. by changing the resolution of a date).\n\n    Arguments:\n        v: the value\n\n    Returns:\n        'None', if no parsing was done and the original value should be used, otherwise return the parsed Python object\n    \"\"\"\n\n    return data\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types.DataType.create_renderable","title":"<code>create_renderable(**config)</code>","text":"Source code in <code>kiara/data_types/__init__.py</code> <pre><code>def create_renderable(self, **config):\n\n    show_type_info = config.get(\"show_type_info\", False)\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\")\n    table.add_column(\"value\", style=\"i\")\n    table.add_row(\"type_name\", self.data_type_name)\n    config_json = self.type_config.json(\n        exclude_unset=True, option=orjson.OPT_INDENT_2\n    )\n    config = Syntax(config_json, \"json\", background_color=\"default\")\n    table.add_row(\"type_config\", config)\n\n    if show_type_info:\n        from kiara.interfaces.python_api.models.info import DataTypeClassInfo\n\n        info = DataTypeClassInfo.create_from_type_class(self.__class__)\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        table.add_row(\"type_info\", info)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/data_types/__init__/#kiara.data_types-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/","title":"included_core_types","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.SCALAR_CHARACTERISTICS","title":"<code>SCALAR_CHARACTERISTICS = DataTypeCharacteristics(is_scalar=True, is_json_serializable=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KIARA_MODEL_CLS","title":"<code>KIARA_MODEL_CLS = TypeVar('KIARA_MODEL_CLS', bound=KiaraModel)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType","title":"<code>NoneType</code>","text":"<p>         Bases: <code>DataType[SpecialValue, DataTypeConfig]</code></p> <p>Type indicating a 'None' value</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class NoneType(DataType[SpecialValue, DataTypeConfig]):\n\"\"\"Type indicating a 'None' value\"\"\"\n\n    _data_type_name = \"none\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return SpecialValue\n\n    # def is_immutable(self) -&gt; bool:\n    #     return False\n\n    def calculate_hash(self, data: Any) -&gt; str:\n        return INVALID_HASH_MARKER\n\n    def calculate_size(self, data: Any) -&gt; int:\n        return 0\n\n    def parse_python_obj(self, data: Any) -&gt; SpecialValue:\n        return SpecialValue.NO_VALUE\n\n    def pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        return \"None\"\n\n    def pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n\n        return \"None\"\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return SpecialValue\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.calculate_hash","title":"<code>calculate_hash(data: Any) -&gt; str</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def calculate_hash(self, data: Any) -&gt; str:\n    return INVALID_HASH_MARKER\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.calculate_size","title":"<code>calculate_size(data: Any) -&gt; int</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def calculate_size(self, data: Any) -&gt; int:\n    return 0\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; SpecialValue</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; SpecialValue:\n    return SpecialValue.NO_VALUE\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.pretty_print_as__string","title":"<code>pretty_print_as__string(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def pretty_print_as__string(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    return \"None\"\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.NoneType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n):\n\n    return \"None\"\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType","title":"<code>AnyType</code>","text":"<p>         Bases: <code>DataType[TYPE_PYTHON_CLS, DataTypeConfig]</code>, <code>Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]</code></p> <p>'Any' type, the parent type for most other types.</p> <p>This type acts as the parents for all (or at least most) non-internal value types. There are some generic operations (like 'persist_value', or 'pretty_print') which are implemented for this type, so it's descendents have a fallback option in case no subtype-specific operations are implemented for it. In general, it is not recommended to use the 'any' type as module input or output, but it is possible. Values of type 'any' are not allowed to be persisted (at the moment, this might or might not change).</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class AnyType(\n    DataType[TYPE_PYTHON_CLS, DataTypeConfig], Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]\n):\n\"\"\"'Any' type, the parent type for most other types.\n\n    This type acts as the parents for all (or at least most) non-internal value types. There are some generic operations\n    (like 'persist_value', or 'pretty_print') which are implemented for this type, so it's descendents have a fallback\n    option in case no subtype-specific operations are implemented for it. In general, it is not recommended to use the 'any'\n    type as module input or output, but it is possible. Values of type 'any' are not allowed to be persisted (at the moment,\n    this might or might not change).\n    \"\"\"\n\n    _data_type_name = \"any\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return object\n\n    def pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        if hasattr(self, \"_pretty_print_as__string\"):\n            return self._pretty_print_as__string(value=value, render_config=render_config)  # type: ignore\n\n        try:\n            return str(value.data)\n        except DataTypeUnknownException as dtue:\n            return str(dtue)\n\n    def pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n\n        if hasattr(self, \"_pretty_print_as__terminal_renderable\"):\n            return self._pretty_print_as__terminal_renderable(value=value, render_config=render_config)  # type: ignore\n\n        try:\n            data = value.data\n        except DataTypeUnknownException as dtue:\n            rendered: RenderableType = dtue.create_renderable(**render_config)\n            from rich.panel import Panel\n\n            return Panel(\n                rendered,\n                title=f\"Unsupported data type: {dtue.data_type}\",\n                title_align=\"left\",\n            )\n        except Exception as e:\n            raise KiaraProcessingException(\n                f\"Error getting data for value '{value.value_id}': {e}\"\n            )\n\n        from pydantic import BaseModel\n\n        if isinstance(data, BaseModel):\n            from kiara.utils.output import create_table_from_model_object\n\n            rendered = create_table_from_model_object(\n                model=data, render_config=render_config\n            )\n        elif isinstance(data, Iterable):\n            import pprint\n\n            rendered = pprint.pformat(data)\n        else:\n            rendered = str(data)\n        return rendered\n\n    def render_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n    ):\n        if hasattr(self, \"_render_as__string\"):\n            return self._render_as__string(value=value, render_scene=render_config, manifest=manifest)  # type: ignore\n        else:\n            return self.pretty_print_as__string(value=value, render_config={})\n\n    def render_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n    ) -&gt; RenderableType:\n\n        if not hasattr(self, \"_render_as__terminal_renderable\"):\n\n            try:\n                value.data\n                return self.render_as__string(\n                    value=value, render_config=render_config, manifest=manifest\n                )\n            except DataTypeUnknownException:\n                return self.pretty_print_as__terminal_renderable(\n                    value=value, render_config=render_config\n                )\n\n        else:\n            return self._render_as__terminal_renderable(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return object\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType.pretty_print_as__string","title":"<code>pretty_print_as__string(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def pretty_print_as__string(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    if hasattr(self, \"_pretty_print_as__string\"):\n        return self._pretty_print_as__string(value=value, render_config=render_config)  # type: ignore\n\n    try:\n        return str(value.data)\n    except DataTypeUnknownException as dtue:\n        return str(dtue)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n):\n\n    if hasattr(self, \"_pretty_print_as__terminal_renderable\"):\n        return self._pretty_print_as__terminal_renderable(value=value, render_config=render_config)  # type: ignore\n\n    try:\n        data = value.data\n    except DataTypeUnknownException as dtue:\n        rendered: RenderableType = dtue.create_renderable(**render_config)\n        from rich.panel import Panel\n\n        return Panel(\n            rendered,\n            title=f\"Unsupported data type: {dtue.data_type}\",\n            title_align=\"left\",\n        )\n    except Exception as e:\n        raise KiaraProcessingException(\n            f\"Error getting data for value '{value.value_id}': {e}\"\n        )\n\n    from pydantic import BaseModel\n\n    if isinstance(data, BaseModel):\n        from kiara.utils.output import create_table_from_model_object\n\n        rendered = create_table_from_model_object(\n            model=data, render_config=render_config\n        )\n    elif isinstance(data, Iterable):\n        import pprint\n\n        rendered = pprint.pformat(data)\n    else:\n        rendered = str(data)\n    return rendered\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType.render_as__string","title":"<code>render_as__string(value: Value, render_config: Mapping[str, Any], manifest: Manifest)</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def render_as__string(\n    self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n):\n    if hasattr(self, \"_render_as__string\"):\n        return self._render_as__string(value=value, render_scene=render_config, manifest=manifest)  # type: ignore\n    else:\n        return self.pretty_print_as__string(value=value, render_config={})\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.AnyType.render_as__terminal_renderable","title":"<code>render_as__terminal_renderable(value: Value, render_config: Mapping[str, Any], manifest: Manifest) -&gt; RenderableType</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def render_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n) -&gt; RenderableType:\n\n    if not hasattr(self, \"_render_as__terminal_renderable\"):\n\n        try:\n            value.data\n            return self.render_as__string(\n                value=value, render_config=render_config, manifest=manifest\n            )\n        except DataTypeUnknownException:\n            return self.pretty_print_as__terminal_renderable(\n                value=value, render_config=render_config\n            )\n\n    else:\n        return self._render_as__terminal_renderable(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BytesType","title":"<code>BytesType</code>","text":"<p>         Bases: <code>AnyType[bytes, DataTypeConfig]</code></p> <p>An array of bytes.</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class BytesType(AnyType[bytes, DataTypeConfig]):\n\"\"\"An array of bytes.\"\"\"\n\n    _data_type_name = \"bytes\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return bytes\n\n    def serialize(self, data: bytes) -&gt; \"SerializedData\":\n\n        _data = {\"bytes\": {\"type\": \"chunk\", \"chunk\": data, \"codec\": \"raw\"}}\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"raw\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_name\": \"load.bytes\",\n                        \"module_config\": {\n                            \"value_type\": \"bytes\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"raw\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def _pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        data: bytes = value.data\n        return data.decode()\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BytesType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BytesType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return bytes\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BytesType.serialize","title":"<code>serialize(data: bytes) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def serialize(self, data: bytes) -&gt; \"SerializedData\":\n\n    _data = {\"bytes\": {\"type\": \"chunk\", \"chunk\": data, \"codec\": \"raw\"}}\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"raw\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_name\": \"load.bytes\",\n                    \"module_config\": {\n                        \"value_type\": \"bytes\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"raw\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.StringType","title":"<code>StringType</code>","text":"<p>         Bases: <code>AnyType[str, DataTypeConfig]</code></p> <p>A string.</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class StringType(AnyType[str, DataTypeConfig]):\n\"\"\"A string.\"\"\"\n\n    _data_type_name = \"string\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return str\n\n    def serialize(self, data: str) -&gt; \"SerializedData\":\n\n        _data = {\n            \"string\": {\"type\": \"chunk\", \"chunk\": data.encode(\"utf-8\"), \"codec\": \"raw\"}\n        }\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"raw\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"load.string\",\n                        \"module_config\": {\n                            \"value_type\": \"string\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"raw\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def _retrieve_characteristics(self) -&gt; DataTypeCharacteristics:\n        return SCALAR_CHARACTERISTICS\n\n    def _validate(cls, value: Any) -&gt; None:\n\n        if not isinstance(value, str):\n            raise ValueError(f\"Invalid type '{type(value)}': string required\")\n\n    def pretty_print_as__bytes(self, value: \"Value\", render_config: Mapping[str, Any]):\n        value_str: str = value.data\n        return value_str.encode()\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.StringType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.StringType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return str\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.StringType.serialize","title":"<code>serialize(data: str) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def serialize(self, data: str) -&gt; \"SerializedData\":\n\n    _data = {\n        \"string\": {\"type\": \"chunk\", \"chunk\": data.encode(\"utf-8\"), \"codec\": \"raw\"}\n    }\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"raw\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"load.string\",\n                    \"module_config\": {\n                        \"value_type\": \"string\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"raw\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.StringType.pretty_print_as__bytes","title":"<code>pretty_print_as__bytes(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def pretty_print_as__bytes(self, value: \"Value\", render_config: Mapping[str, Any]):\n    value_str: str = value.data\n    return value_str.encode()\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType","title":"<code>BooleanType</code>","text":"<p>         Bases: <code>AnyType[bool, DataTypeConfig]</code></p> <p>A boolean.</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class BooleanType(AnyType[bool, DataTypeConfig]):\n    \"A boolean.\"\n\n    _data_type_name = \"boolean\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return bool\n\n    def serialize(self, data: bool) -&gt; \"SerializedData\":\n        result = self.serialize_as_json(data)\n        return result\n\n    def _retrieve_characteristics(self) -&gt; DataTypeCharacteristics:\n        return SCALAR_CHARACTERISTICS\n\n    # def calculate_size(self, data: bool) -&gt; int:\n    #     return 24\n    #\n    # def calculate_hash(cls, data: bool) -&gt; int:\n    #     return 1 if data else 0\n\n    def parse_python_obj(self, data: Any) -&gt; bool:\n\n        if data is True or data is False:\n            return data\n        elif data == 0:\n            return False\n        elif data == 1:\n            return True\n        elif isinstance(data, str):\n            if data.lower() == \"true\":\n                return True\n            elif data.lower() == \"false\":\n                return False\n        raise Exception(f\"Can't parse value '{data}' as boolean.\")\n\n    def validate(cls, value: Any):\n        pass\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return bool\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType.serialize","title":"<code>serialize(data: bool) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def serialize(self, data: bool) -&gt; \"SerializedData\":\n    result = self.serialize_as_json(data)\n    return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; bool</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; bool:\n\n    if data is True or data is False:\n        return data\n    elif data == 0:\n        return False\n    elif data == 1:\n        return True\n    elif isinstance(data, str):\n        if data.lower() == \"true\":\n            return True\n        elif data.lower() == \"false\":\n            return False\n    raise Exception(f\"Can't parse value '{data}' as boolean.\")\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.BooleanType.validate","title":"<code>validate(value: Any)</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def validate(cls, value: Any):\n    pass\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType","title":"<code>DictValueType</code>","text":"<p>         Bases: <code>AnyType[DictModel, DataTypeConfig]</code></p> <p>A dictionary.</p> <p>In addition to the actual dictionary value, this value type comes also with an optional schema, describing the dictionary. In case no schema was attached, a simple generic one is attached. This data type is backed by the DictModel class.</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class DictValueType(AnyType[DictModel, DataTypeConfig]):\n\"\"\"A dictionary.\n\n    In addition to the actual dictionary value, this value type comes also with an optional schema, describing the\n    dictionary. In case no schema was attached, a simple generic one is attached. This data type is backed by the\n    [DictModel][kiara_plugin.core_types.models.DictModel] class.\n    \"\"\"\n\n    _data_type_name = \"dict\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return DictModel\n\n    # def calculate_size(self, data: DictModel) -&gt; int:\n    #     return data.size\n    #\n    # def calculate_hash(self, data: DictModel) -&gt; int:\n    #     return data.value_hash\n\n    def _retrieve_characteristics(self) -&gt; DataTypeCharacteristics:\n        return DataTypeCharacteristics(is_scalar=False, is_json_serializable=True)\n\n    def parse_python_obj(self, data: Any) -&gt; DictModel:\n\n        python_cls = data.__class__\n        dict_data = None\n        schema = None\n\n        if isinstance(data, Mapping):\n\n            if (\n                len(data) == 3\n                and \"dict_data\" in data.keys()\n                and \"data_schema\" in data.keys()\n                and \"python_class\" in data.keys()\n            ):\n                dict_model = DictModel(\n                    dict_data=data[\"dict_data\"],\n                    data_schema=data[\"data_schema\"],\n                    python_class=data[\"python_class\"],\n                )\n                return dict_model\n\n            schema = {\"title\": \"dict\", \"type\": \"object\"}\n            dict_data = data\n        elif isinstance(data, BaseModel):\n            dict_data = data.dict()\n            schema = data.schema()\n        elif isinstance(data, str):\n            try:\n                dict_data = orjson.loads(data)\n                schema = {\"title\": \"dict\", \"type\": \"object\"}\n            except Exception:\n                pass\n\n        if dict_data is None or schema is None:\n            raise Exception(f\"Invalid data for value type 'dict': {data}\")\n\n        result = {\n            \"dict_data\": dict_data,\n            \"data_schema\": schema,\n            \"python_class\": PythonClass.from_class(python_cls).dict(),\n        }\n        return DictModel(**result)\n\n    def _validate(self, data: DictModel) -&gt; None:\n\n        if not isinstance(data, DictModel):\n            raise Exception(f\"Invalid type: {type(data)}.\")\n\n    # def render_as__string(self, value: Value, render_config: Mapping[str, Any]) -&gt; str:\n    #\n    #     data: DictModel = value.data\n    #     return orjson_dumps(data.dict_data, option=orjson.OPT_INDENT_2)\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n\n        show_schema = render_config.get(\"show_schema\", True)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        data: DictModel = value.data\n        data_json = orjson_dumps(data.dict_data, option=orjson.OPT_INDENT_2)\n        table.add_row(\n            \"dict data\", Syntax(data_json, \"json\", background_color=\"default\")\n        )\n\n        if show_schema:\n            schema_json = orjson_dumps(data.data_schema, option=orjson.OPT_INDENT_2)\n            table.add_row(\n                \"dict schema\", Syntax(schema_json, \"json\", background_color=\"default\")\n            )\n\n        return table\n\n    def serialize(self, data: DictModel) -&gt; \"SerializedData\":\n\n        result = self.serialize_as_json(data.dict())\n        return result\n\n    def render_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n    ) -&gt; RenderableType:\n\n        render_item = render_config.get(\"render_item\", \"data\")\n        width = render_config.get(\"display_width\", 0)\n\n        related_scenes: Dict[str, Union[None, RenderScene]] = {}\n        if render_item == \"data\":\n            dict_data = value.data.dict_data\n            json_string = orjson_dumps(dict_data, option=orjson.OPT_INDENT_2)\n\n            if width &gt; 0:\n                new_lines = []\n                for line in json_string.split(\"\\n\"):\n                    if len(line) &gt; width:\n                        new_lines.append(line[0 : width - 3] + \"...\")\n                    else:\n                        new_lines.append(line)\n\n            json_string = \"\\n\".join(new_lines)\n\n            rendered = Syntax(json_string, \"json\")\n            related_scenes[\"data\"] = None\n            related_scenes[\"schema\"] = RenderScene.construct(\n                title=\"schema\",\n                description=\"The (json) schema for the data.\",\n                manifest_hash=manifest.manifest_hash,\n                render_config={\"render_item\": \"schema\"},\n            )\n\n        elif render_item == \"schema\":\n            schema = value.data.data_schema\n            json_string = orjson_dumps(schema, option=orjson.OPT_INDENT_2)\n\n            rendered = Syntax(json_string, \"json\")\n            related_scenes[\"data\"] = RenderScene.construct(\n                title=\"data\",\n                description=\"The actual data of the dictionary.\",\n                manifest_hash=manifest.manifest_hash,\n                render_config={\"render_item\": \"data\"},\n            )\n            related_scenes[\"schema\"] = None\n\n        else:\n            raise KiaraProcessingException(\n                f\"Invalid render item '{render_item}', allowed: 'data', 'schema'.\"\n            )\n\n        result = RenderValueResult(\n            value_id=value.value_id,\n            render_config=render_config,\n            render_manifest=manifest.manifest_hash,\n            related_scenes=related_scenes,\n            manifest_lookup={manifest.manifest_hash: manifest},\n            rendered=rendered,\n        )\n\n        return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return DictModel\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; DictModel</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; DictModel:\n\n    python_cls = data.__class__\n    dict_data = None\n    schema = None\n\n    if isinstance(data, Mapping):\n\n        if (\n            len(data) == 3\n            and \"dict_data\" in data.keys()\n            and \"data_schema\" in data.keys()\n            and \"python_class\" in data.keys()\n        ):\n            dict_model = DictModel(\n                dict_data=data[\"dict_data\"],\n                data_schema=data[\"data_schema\"],\n                python_class=data[\"python_class\"],\n            )\n            return dict_model\n\n        schema = {\"title\": \"dict\", \"type\": \"object\"}\n        dict_data = data\n    elif isinstance(data, BaseModel):\n        dict_data = data.dict()\n        schema = data.schema()\n    elif isinstance(data, str):\n        try:\n            dict_data = orjson.loads(data)\n            schema = {\"title\": \"dict\", \"type\": \"object\"}\n        except Exception:\n            pass\n\n    if dict_data is None or schema is None:\n        raise Exception(f\"Invalid data for value type 'dict': {data}\")\n\n    result = {\n        \"dict_data\": dict_data,\n        \"data_schema\": schema,\n        \"python_class\": PythonClass.from_class(python_cls).dict(),\n    }\n    return DictModel(**result)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType.serialize","title":"<code>serialize(data: DictModel) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def serialize(self, data: DictModel) -&gt; \"SerializedData\":\n\n    result = self.serialize_as_json(data.dict())\n    return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.DictValueType.render_as__terminal_renderable","title":"<code>render_as__terminal_renderable(value: Value, render_config: Mapping[str, Any], manifest: Manifest) -&gt; RenderableType</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def render_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any], manifest: \"Manifest\"\n) -&gt; RenderableType:\n\n    render_item = render_config.get(\"render_item\", \"data\")\n    width = render_config.get(\"display_width\", 0)\n\n    related_scenes: Dict[str, Union[None, RenderScene]] = {}\n    if render_item == \"data\":\n        dict_data = value.data.dict_data\n        json_string = orjson_dumps(dict_data, option=orjson.OPT_INDENT_2)\n\n        if width &gt; 0:\n            new_lines = []\n            for line in json_string.split(\"\\n\"):\n                if len(line) &gt; width:\n                    new_lines.append(line[0 : width - 3] + \"...\")\n                else:\n                    new_lines.append(line)\n\n        json_string = \"\\n\".join(new_lines)\n\n        rendered = Syntax(json_string, \"json\")\n        related_scenes[\"data\"] = None\n        related_scenes[\"schema\"] = RenderScene.construct(\n            title=\"schema\",\n            description=\"The (json) schema for the data.\",\n            manifest_hash=manifest.manifest_hash,\n            render_config={\"render_item\": \"schema\"},\n        )\n\n    elif render_item == \"schema\":\n        schema = value.data.data_schema\n        json_string = orjson_dumps(schema, option=orjson.OPT_INDENT_2)\n\n        rendered = Syntax(json_string, \"json\")\n        related_scenes[\"data\"] = RenderScene.construct(\n            title=\"data\",\n            description=\"The actual data of the dictionary.\",\n            manifest_hash=manifest.manifest_hash,\n            render_config={\"render_item\": \"data\"},\n        )\n        related_scenes[\"schema\"] = None\n\n    else:\n        raise KiaraProcessingException(\n            f\"Invalid render item '{render_item}', allowed: 'data', 'schema'.\"\n        )\n\n    result = RenderValueResult(\n        value_id=value.value_id,\n        render_config=render_config,\n        render_manifest=manifest.manifest_hash,\n        related_scenes=related_scenes,\n        manifest_lookup={manifest.manifest_hash: manifest},\n        rendered=rendered,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KiaraModelValueType","title":"<code>KiaraModelValueType</code>","text":"<p>         Bases: <code>AnyType[KIARA_MODEL_CLS, TYPE_CONFIG_CLS]</code>, <code>Generic[KIARA_MODEL_CLS, TYPE_CONFIG_CLS]</code></p> <p>A value type that is used internally.</p> <p>This type should not be used by user-facing modules and/or operations.</p> Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>class KiaraModelValueType(\n    AnyType[KIARA_MODEL_CLS, TYPE_CONFIG_CLS], Generic[KIARA_MODEL_CLS, TYPE_CONFIG_CLS]\n):\n\"\"\"A value type that is used internally.\n\n    This type should not be used by user-facing modules and/or operations.\n    \"\"\"\n\n    _data_type_name = None  # type: ignore\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[DataTypeConfig]:\n        return DataTypeConfig\n\n    @abc.abstractmethod\n    def create_model_from_python_obj(self, data: Any) -&gt; KIARA_MODEL_CLS:\n        pass\n\n    def parse_python_obj(self, data: Any) -&gt; KIARA_MODEL_CLS:\n\n        if isinstance(data, self.__class__.python_class()):\n            return data  # type: ignore\n\n        data = self.create_model_from_python_obj(data)\n        return data\n\n    def _validate(self, data: KiaraModel) -&gt; None:\n\n        if not isinstance(data, self.__class__.python_class()):\n            raise Exception(\n                f\"Invalid type '{type(data)}', must be: {self.__class__.python_class().__name__}, or subclass.\"\n            )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KiaraModelValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KiaraModelValueType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[DataTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[DataTypeConfig]:\n    return DataTypeConfig\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KiaraModelValueType.create_model_from_python_obj","title":"<code>create_model_from_python_obj(data: Any) -&gt; KIARA_MODEL_CLS</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>@abc.abstractmethod\ndef create_model_from_python_obj(self, data: Any) -&gt; KIARA_MODEL_CLS:\n    pass\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types.KiaraModelValueType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; KIARA_MODEL_CLS</code>","text":"Source code in <code>kiara/data_types/included_core_types/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; KIARA_MODEL_CLS:\n\n    if isinstance(data, self.__class__.python_class()):\n        return data  # type: ignore\n\n    data = self.create_model_from_python_obj(data)\n    return data\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/__init__/#kiara.data_types.included_core_types-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/","title":"filesystem","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.SUPPORTED_FILE_TYPES","title":"<code>SUPPORTED_FILE_TYPES = ['csv', 'json', 'text', 'binary']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileTypeConfig","title":"<code>FileTypeConfig</code>","text":"<p>         Bases: <code>DataTypeConfig</code></p> Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>class FileTypeConfig(DataTypeConfig):\n\n    content_type: Union[str, None] = Field(\n        description=\"The content type of this file.\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileTypeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileTypeConfig.content_type","title":"<code>content_type: Union[str, None] = Field(description='The content type of this file.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType","title":"<code>FileValueType</code>","text":"<p>         Bases: <code>KiaraModelValueType[FileModel, FileTypeConfig]</code></p> <p>A file.</p> Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>class FileValueType(KiaraModelValueType[FileModel, FileTypeConfig]):\n\"\"\"A file.\"\"\"\n\n    _data_type_name = \"file\"\n\n    @classmethod\n    def retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n        result = {}\n        for ft in SUPPORTED_FILE_TYPES:\n            result[f\"{ft}_file\"] = {\"content_type\": ft}\n        return result\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return FileModel\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[FileTypeConfig]:\n        return FileTypeConfig\n\n    def serialize(self, data: FileModel) -&gt; \"SerializedData\":\n\n        _data = {\n            data.file_name: {\n                \"type\": \"file\",\n                \"codec\": \"raw\",\n                \"file\": data.path,\n            },\n            \"__file_metadata__\": {\n                \"type\": \"inline-json\",\n                \"codec\": \"json\",\n                \"inline_data\": {\n                    \"file_name\": data.file_name,\n                    # \"import_time\": data.import_time,\n                },\n            },\n        }\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"copy\",\n            \"metadata\": {\n                # \"profile\": \"\",\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"deserialize.file\",\n                        \"module_config\": {\n                            \"value_type\": \"file\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"copy\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def create_model_from_python_obj(self, data: Any) -&gt; FileModel:\n\n        if isinstance(data, Mapping):\n            return FileModel(**data)\n        if isinstance(data, str):\n            return FileModel.load_file(source=data)\n        else:\n            raise Exception(f\"Can't create FileModel from data of type '{type(data)}'.\")\n\n    def _pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        data: Any = value.data\n        max_lines = render_config.get(\"max_lines\", 34)\n        try:\n            lines = []\n            with open(data.path, \"r\", encoding=\"utf-8\") as f:\n                for idx, line in enumerate(f):\n                    if idx &gt; max_lines:\n                        lines.append(\"...\\n\")\n                        lines.append(\"...\")\n                        break\n                    lines.append(line)\n\n            # TODO: syntax highlighting\n            return \"\\n\".join(lines)\n        except UnicodeDecodeError:\n            # found non-text data\n            lines = [\n                \"Binary file or non-utf8 enconding, not printing content...\",\n                \"\",\n                \"[b]File metadata:[/b]\",\n                \"\",\n                data.json(option=orjson.OPT_INDENT_2),\n            ]\n            return \"\\n\".join(\"lines\")\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        data: FileModel = value.data\n        max_lines = render_config.get(\"max_lines\", 34)\n        try:\n            lines = []\n            with open(data.path, \"r\", encoding=\"utf-8\") as f:\n                for idx, line in enumerate(f):\n                    if idx &gt; max_lines:\n                        lines.append(\"...\\n\")\n                        lines.append(\"...\")\n                        break\n                    lines.append(line.rstrip())\n\n            return Group(*lines)\n        except UnicodeDecodeError:\n            # found non-text data\n            lines = [\n                \"Binary file or non-utf8 enconding, not printing content...\",\n                \"\",\n                \"[b]File metadata:[/b]\",\n                \"\",\n                data.json(option=orjson.OPT_INDENT_2),\n            ]\n            return Group(*lines)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType.retrieve_available_type_profiles","title":"<code>retrieve_available_type_profiles() -&gt; Mapping[str, Mapping[str, Any]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n    result = {}\n    for ft in SUPPORTED_FILE_TYPES:\n        result[f\"{ft}_file\"] = {\"content_type\": ft}\n    return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return FileModel\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[FileTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[FileTypeConfig]:\n    return FileTypeConfig\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType.serialize","title":"<code>serialize(data: FileModel) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>def serialize(self, data: FileModel) -&gt; \"SerializedData\":\n\n    _data = {\n        data.file_name: {\n            \"type\": \"file\",\n            \"codec\": \"raw\",\n            \"file\": data.path,\n        },\n        \"__file_metadata__\": {\n            \"type\": \"inline-json\",\n            \"codec\": \"json\",\n            \"inline_data\": {\n                \"file_name\": data.file_name,\n                # \"import_time\": data.import_time,\n            },\n        },\n    }\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"copy\",\n        \"metadata\": {\n            # \"profile\": \"\",\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"deserialize.file\",\n                    \"module_config\": {\n                        \"value_type\": \"file\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"copy\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileValueType.create_model_from_python_obj","title":"<code>create_model_from_python_obj(data: Any) -&gt; FileModel</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>def create_model_from_python_obj(self, data: Any) -&gt; FileModel:\n\n    if isinstance(data, Mapping):\n        return FileModel(**data)\n    if isinstance(data, str):\n        return FileModel.load_file(source=data)\n    else:\n        raise Exception(f\"Can't create FileModel from data of type '{type(data)}'.\")\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType","title":"<code>FileBundleValueType</code>","text":"<p>         Bases: <code>AnyType[FileBundle, FileTypeConfig]</code></p> <p>A bundle of files (like a folder, zip archive, etc.).</p> Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>class FileBundleValueType(AnyType[FileBundle, FileTypeConfig]):\n\"\"\"A bundle of files (like a folder, zip archive, etc.).\"\"\"\n\n    _data_type_name = \"file_bundle\"\n\n    @classmethod\n    def retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n        result = {}\n        for ft in SUPPORTED_FILE_TYPES:\n            result[f\"{ft}_file_bundle\"] = {\"content_type\": ft}\n        return result\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return FileBundle\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[FileTypeConfig]:\n        return FileTypeConfig\n\n    def serialize(self, data: FileBundle) -&gt; \"SerializedData\":\n\n        file_data: Dict[str, Any] = {}\n        file_metadata = {}\n        for rel_path, file in data.included_files.items():\n            file_data[rel_path] = {\"type\": \"file\", \"codec\": \"raw\", \"file\": file.path}\n            file_metadata[rel_path] = {\n                \"file_name\": file.file_name,\n                # \"import_time\": file.import_time,\n            }\n\n        metadata: Dict[str, Any] = {\n            \"included_files\": file_metadata,\n            \"bundle_name\": data.bundle_name,\n            # \"import_time\": data.import_time,\n            \"size\": data.size,\n            \"number_of_files\": data.number_of_files,\n        }\n\n        assert \"__file_metadata__\" not in file_data\n        file_data[\"__file_metadata__\"] = {\n            \"type\": \"inline-json\",\n            \"codec\": \"json\",\n            \"inline_data\": metadata,\n        }\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": file_data,\n            \"serialization_profile\": \"copy\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"deserialize.file_bundle\",\n                        \"module_config\": {\n                            \"value_type\": \"file_bundle\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"copy\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def parse_python_obj(self, data: Any) -&gt; FileBundle:\n\n        if isinstance(data, FileBundle):\n            return data\n        elif isinstance(data, str):\n            return FileBundle.import_folder(source=data)\n        else:\n            raise Exception(\n                f\"Can't create FileBundle from data of type '{type(data)}'.\"\n            )\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        bundle: FileBundle = value.data\n        renderable = bundle.create_renderable(**render_config)\n        return renderable\n\n    def _pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        bundle: FileBundle = value.data\n        result = []\n        result.append(f\"File bundle '{bundle.bundle_name}\")\n        result.append(f\"  size: {humanfriendly.format_size(bundle.size)}\")\n        result.append(\"  contents:\")\n        for rel_path, file in bundle.included_files.items():\n            result.append(f\"    - {rel_path}: {file.file_name}\")\n\n        return \"\\n\".join(result)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType.retrieve_available_type_profiles","title":"<code>retrieve_available_type_profiles() -&gt; Mapping[str, Mapping[str, Any]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n    result = {}\n    for ft in SUPPORTED_FILE_TYPES:\n        result[f\"{ft}_file_bundle\"] = {\"content_type\": ft}\n    return result\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return FileBundle\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[FileTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[FileTypeConfig]:\n    return FileTypeConfig\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType.serialize","title":"<code>serialize(data: FileBundle) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>def serialize(self, data: FileBundle) -&gt; \"SerializedData\":\n\n    file_data: Dict[str, Any] = {}\n    file_metadata = {}\n    for rel_path, file in data.included_files.items():\n        file_data[rel_path] = {\"type\": \"file\", \"codec\": \"raw\", \"file\": file.path}\n        file_metadata[rel_path] = {\n            \"file_name\": file.file_name,\n            # \"import_time\": file.import_time,\n        }\n\n    metadata: Dict[str, Any] = {\n        \"included_files\": file_metadata,\n        \"bundle_name\": data.bundle_name,\n        # \"import_time\": data.import_time,\n        \"size\": data.size,\n        \"number_of_files\": data.number_of_files,\n    }\n\n    assert \"__file_metadata__\" not in file_data\n    file_data[\"__file_metadata__\"] = {\n        \"type\": \"inline-json\",\n        \"codec\": \"json\",\n        \"inline_data\": metadata,\n    }\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": file_data,\n        \"serialization_profile\": \"copy\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"deserialize.file_bundle\",\n                    \"module_config\": {\n                        \"value_type\": \"file_bundle\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"copy\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/filesystem/#kiara.data_types.included_core_types.filesystem.FileBundleValueType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; FileBundle</code>","text":"Source code in <code>kiara/data_types/included_core_types/filesystem.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; FileBundle:\n\n    if isinstance(data, FileBundle):\n        return data\n    elif isinstance(data, str):\n        return FileBundle.import_folder(source=data)\n    else:\n        raise Exception(\n            f\"Can't create FileBundle from data of type '{type(data)}'.\"\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/","title":"metadata","text":""},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.Metadata","title":"<code>Metadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>class Metadata(KiaraModel):\n\n    _kiara_model_id = \"instance.metadata\"\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataTypeConfig","title":"<code>MetadataTypeConfig</code>","text":"<p>         Bases: <code>DataTypeConfig</code></p> Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>class MetadataTypeConfig(DataTypeConfig):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType","title":"<code>MetadataValueType</code>","text":"<p>         Bases: <code>KiaraModelValueType[Metadata, MetadataTypeConfig]</code></p> <p>A file.</p> Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>class MetadataValueType(KiaraModelValueType[Metadata, MetadataTypeConfig]):\n\"\"\"A file.\"\"\"\n\n    _data_type_name = \"file\"\n\n    @classmethod\n    def retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n        return {}\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return Metadata\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[MetadataTypeConfig]:\n        return MetadataTypeConfig\n\n    def serialize(self, data: Metadata) -&gt; \"SerializedData\":\n\n        # _data = {\n        #     data.file_name: {\n        #         \"type\": \"file\",\n        #         \"codec\": \"raw\",\n        #         \"file\": data.path,\n        #     },\n        #     \"__file_metadata__\": {\n        #         \"type\": \"inline-json\",\n        #         \"codec\": \"json\",\n        #         \"inline_data\": {\n        #             \"file_name\": data.file_name,\n        #             # \"import_time\": data.import_time,\n        #         },\n        #     },\n        # }\n        _data: Dict[str, Any] = {}\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"copy\",\n            \"metadata\": {\n                # \"profile\": \"\",\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"deserialize.file\",\n                        \"module_config\": {\n                            \"value_type\": \"file\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"copy\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    def create_model_from_python_obj(self, data: Any) -&gt; Metadata:\n\n        # if isinstance(data, Mapping):\n        #     return Metadata(**data)\n        # if isinstance(data, str):\n        #     return Metadata.load_file(source=data)\n        # else:\n        raise Exception(\n            f\"Can't create Metadata instance from data of type '{type(data)}'.\"\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType.retrieve_available_type_profiles","title":"<code>retrieve_available_type_profiles() -&gt; Mapping[str, Mapping[str, Any]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>@classmethod\ndef retrieve_available_type_profiles(cls) -&gt; Mapping[str, Mapping[str, Any]]:\n    return {}\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return Metadata\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[MetadataTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[MetadataTypeConfig]:\n    return MetadataTypeConfig\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType.serialize","title":"<code>serialize(data: Metadata) -&gt; SerializedData</code>","text":"Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>def serialize(self, data: Metadata) -&gt; \"SerializedData\":\n\n    # _data = {\n    #     data.file_name: {\n    #         \"type\": \"file\",\n    #         \"codec\": \"raw\",\n    #         \"file\": data.path,\n    #     },\n    #     \"__file_metadata__\": {\n    #         \"type\": \"inline-json\",\n    #         \"codec\": \"json\",\n    #         \"inline_data\": {\n    #             \"file_name\": data.file_name,\n    #             # \"import_time\": data.import_time,\n    #         },\n    #     },\n    # }\n    _data: Dict[str, Any] = {}\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"copy\",\n        \"metadata\": {\n            # \"profile\": \"\",\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"deserialize.file\",\n                    \"module_config\": {\n                        \"value_type\": \"file\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"copy\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/metadata/#kiara.data_types.included_core_types.metadata.MetadataValueType.create_model_from_python_obj","title":"<code>create_model_from_python_obj(data: Any) -&gt; Metadata</code>","text":"Source code in <code>kiara/data_types/included_core_types/metadata.py</code> <pre><code>def create_model_from_python_obj(self, data: Any) -&gt; Metadata:\n\n    # if isinstance(data, Mapping):\n    #     return Metadata(**data)\n    # if isinstance(data, str):\n    #     return Metadata.load_file(source=data)\n    # else:\n    raise Exception(\n        f\"Can't create Metadata instance from data of type '{type(data)}'.\"\n    )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/serialization/","title":"serialization","text":""},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType","title":"<code>PythonObjectType</code>","text":"<p>         Bases: <code>InternalType[object, DataTypeConfig]</code></p> <p>A 'plain' Python object.</p> <p>This data type is mostly used internally, for hading over data in (de-)serialization operations.</p> Source code in <code>kiara/data_types/included_core_types/serialization.py</code> <pre><code>class PythonObjectType(InternalType[object, DataTypeConfig]):\n\"\"\"A 'plain' Python object.\n\n    This data type is mostly used internally, for hading over data in (de-)serialization operations.\n    \"\"\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return object\n\n    def parse_python_obj(self, data: Any) -&gt; object:\n        return data\n\n    def calculate_hash(self, data: SerializedData) -&gt; str:\n\"\"\"Calculate the hash of the value.\"\"\"\n        return INVALID_HASH_MARKER\n\n    def calculate_size(self, data: SerializedData) -&gt; int:\n        return INVALID_SIZE_MARKER\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ):\n\n        return str(value.data)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/serialization.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return object\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; object</code>","text":"Source code in <code>kiara/data_types/included_core_types/serialization.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; object:\n    return data\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType.calculate_hash","title":"<code>calculate_hash(data: SerializedData) -&gt; str</code>","text":"<p>Calculate the hash of the value.</p> Source code in <code>kiara/data_types/included_core_types/serialization.py</code> <pre><code>def calculate_hash(self, data: SerializedData) -&gt; str:\n\"\"\"Calculate the hash of the value.\"\"\"\n    return INVALID_HASH_MARKER\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/serialization/#kiara.data_types.included_core_types.serialization.PythonObjectType.calculate_size","title":"<code>calculate_size(data: SerializedData) -&gt; int</code>","text":"Source code in <code>kiara/data_types/included_core_types/serialization.py</code> <pre><code>def calculate_size(self, data: SerializedData) -&gt; int:\n    return INVALID_SIZE_MARKER\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/","title":"internal","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType","title":"<code>InternalType</code>","text":"<p>         Bases: <code>DataType[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]</code>, <code>Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS]</code></p> <p>'A 'marker' base data type for data types that are (mainly) used internally in kiara..</p> Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>class InternalType(\n    DataType[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS],\n    Generic[TYPE_PYTHON_CLS, TYPE_CONFIG_CLS],\n):\n\"\"\"'A 'marker' base data type for data types that are (mainly) used internally in kiara..\"\"\"\n\n    _data_type_name = \"internal\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return object\n\n    def pretty_print_as__string(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        if hasattr(self, \"_pretty_print_as__string\"):\n            return self._pretty_print_as_string(value=value, render_config=render_config)  # type: ignore\n\n        return str(value.data)\n\n    def pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n\n        if hasattr(self, \"_pretty_print_as__terminal_renderable\"):\n            return self._pretty_print_as__terminal_renderable(value=value, render_config=render_config)  # type: ignore\n\n        data = value.data\n\n        from pydantic import BaseModel\n\n        if isinstance(data, BaseModel):\n            from kiara.utils.output import create_table_from_model_object\n\n            rendered = create_table_from_model_object(\n                model=data, render_config=render_config\n            )\n        elif isinstance(data, Iterable):\n            import pprint\n\n            rendered = pprint.pformat(data)\n        else:\n            rendered = str(data)\n        return rendered\n\n    def render_as__string(\n        self, value: \"Value\", render_config: \"RenderScene\", manifest: \"Manifest\"\n    ):\n\n        if hasattr(self, \"_render_as__string\"):\n            return self._render_as__string(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n        else:\n            return self.pretty_print_as__string(value=value, render_config={})\n\n    def render_as__terminal_renderable(\n        self, value: \"Value\", render_config: \"RenderScene\", manifest: \"Manifest\"\n    ):\n\n        if hasattr(self, \"_render_as__terminal_renderable\"):\n            return self._render_as__terminal(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n        return self.render_as__string(\n            value=value, render_config=render_config, manifest=manifest\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return object\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType.pretty_print_as__string","title":"<code>pretty_print_as__string(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def pretty_print_as__string(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n) -&gt; Any:\n\n    if hasattr(self, \"_pretty_print_as__string\"):\n        return self._pretty_print_as_string(value=value, render_config=render_config)  # type: ignore\n\n    return str(value.data)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: \"Value\", render_config: Mapping[str, Any]\n):\n\n    if hasattr(self, \"_pretty_print_as__terminal_renderable\"):\n        return self._pretty_print_as__terminal_renderable(value=value, render_config=render_config)  # type: ignore\n\n    data = value.data\n\n    from pydantic import BaseModel\n\n    if isinstance(data, BaseModel):\n        from kiara.utils.output import create_table_from_model_object\n\n        rendered = create_table_from_model_object(\n            model=data, render_config=render_config\n        )\n    elif isinstance(data, Iterable):\n        import pprint\n\n        rendered = pprint.pformat(data)\n    else:\n        rendered = str(data)\n    return rendered\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType.render_as__string","title":"<code>render_as__string(value: Value, render_config: RenderScene, manifest: Manifest)</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def render_as__string(\n    self, value: \"Value\", render_config: \"RenderScene\", manifest: \"Manifest\"\n):\n\n    if hasattr(self, \"_render_as__string\"):\n        return self._render_as__string(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n    else:\n        return self.pretty_print_as__string(value=value, render_config={})\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalType.render_as__terminal_renderable","title":"<code>render_as__terminal_renderable(value: Value, render_config: RenderScene, manifest: Manifest)</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def render_as__terminal_renderable(\n    self, value: \"Value\", render_config: \"RenderScene\", manifest: \"Manifest\"\n):\n\n    if hasattr(self, \"_render_as__terminal_renderable\"):\n        return self._render_as__terminal(value=value, render_config=render_config, manifest=manifest)  # type: ignore\n    return self.render_as__string(\n        value=value, render_config=render_config, manifest=manifest\n    )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.TerminalRenderable","title":"<code>TerminalRenderable</code>","text":"<p>         Bases: <code>InternalType[object, DataTypeConfig]</code></p> <p>A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter.</p> <p>Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'.</p> Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>class TerminalRenderable(InternalType[object, DataTypeConfig]):\n\"\"\"A list of renderable objects, used in the 'rich' Python library, to print to the terminal or in Jupyter.\n\n    Internally, the result list items can be either a string, a 'rich.console.ConsoleRenderable', or a 'rich.console.RichCast'.\n    \"\"\"\n\n    _data_type_name = \"terminal_renderable\"\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return object\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        renderable = value.data\n\n        table = Table(show_header=False, show_lines=False, box=box.SIMPLE)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n        cls = PythonClass.from_class(renderable.__class__)\n        table.add_row(\"python class\", cls)\n        table.add_row(\"preview\", Panel(renderable, height=20))\n\n        return table\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.TerminalRenderable-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.TerminalRenderable.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return object\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelTypeConfig","title":"<code>InternalModelTypeConfig</code>","text":"<p>         Bases: <code>DataTypeConfig</code></p> Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>class InternalModelTypeConfig(DataTypeConfig):\n\n    kiara_model_id: Union[str, None] = Field(\n        description=\"The Python class backing this model (must sub-class 'KiaraModel').\"\n    )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelTypeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelTypeConfig.kiara_model_id","title":"<code>kiara_model_id: Union[str, None] = Field(description=\"The Python class backing this model (must sub-class 'KiaraModel').\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType","title":"<code>InternalModelValueType</code>","text":"<p>         Bases: <code>InternalType[KiaraModel, InternalModelTypeConfig]</code></p> <p>A value type that is used internally.</p> <p>This type should not be used by user-facing modules and/or operations.</p> Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>class InternalModelValueType(InternalType[KiaraModel, InternalModelTypeConfig]):\n\"\"\"A value type that is used internally.\n\n    This type should not be used by user-facing modules and/or operations.\n    \"\"\"\n\n    _data_type_name = \"internal_model\"\n    _cls_cache: Union[Type[KiaraModel], None] = PrivateAttr(default=None)\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[InternalModelTypeConfig]:\n        return InternalModelTypeConfig  # type: ignore\n\n    def serialize(self, data: KiaraModel) -&gt; Union[str, SerializedData]:\n\n        if self.type_config.kiara_model_id is None:\n            logger.debug(\n                \"ignore.serialize_request\",\n                data_type=\"internal_model\",\n                cls=data.__class__.__name__,\n                reason=\"no model id in module config\",\n            )\n            return NO_SERIALIZATION_MARKER\n\n        _data = {\n            \"data\": {\n                \"type\": \"inline-json\",\n                \"inline_data\": data.dict(),\n                \"codec\": \"json\",\n            },\n        }\n\n        serialized_data = {\n            \"data_type\": self.data_type_name,\n            \"data_type_config\": self.type_config.dict(),\n            \"data\": _data,\n            \"serialization_profile\": \"json\",\n            \"metadata\": {\n                \"environment\": {},\n                \"deserialize\": {\n                    \"python_object\": {\n                        \"module_type\": \"load.internal_model\",\n                        \"module_config\": {\n                            \"value_type\": \"internal_model\",\n                            \"target_profile\": \"python_object\",\n                            \"serialization_profile\": \"json\",\n                        },\n                    }\n                },\n            },\n        }\n        from kiara.models.values.value import SerializationResult\n\n        serialized = SerializationResult(**serialized_data)\n        return serialized\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return KiaraModel\n\n    @property\n    def model_cls(self) -&gt; Type[KiaraModel]:\n\n        if self._cls_cache is not None:\n            return self._cls_cache\n\n        model_type_id = self.type_config.kiara_model_id\n        assert model_type_id is not None\n\n        model_registry = ModelRegistry.instance()\n\n        model_cls = model_registry.get_model_cls(\n            model_type_id, required_subclass=KiaraModel\n        )\n\n        self._cls_cache = model_cls\n        return self._cls_cache\n\n    def parse_python_obj(self, data: Any) -&gt; KiaraModel:\n\n        if isinstance(data, KiaraModel):\n            return data\n        elif isinstance(data, Mapping):\n            return self.model_cls(**data)\n        else:\n            raise ValueError(\n                f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'KiaraModel' or Mapping.\"\n            )\n\n    def _validate(self, value: KiaraModel) -&gt; None:\n\n        if not isinstance(value, KiaraModel):\n            raise Exception(f\"Invalid type: {type(value)}.\")\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n        json_str = value.data.json(option=orjson.OPT_INDENT_2)\n        return Syntax(json_str, \"json\", background_color=\"default\")\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType.model_cls","title":"<code>model_cls: Type[KiaraModel]</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[InternalModelTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[InternalModelTypeConfig]:\n    return InternalModelTypeConfig  # type: ignore\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType.serialize","title":"<code>serialize(data: KiaraModel) -&gt; Union[str, SerializedData]</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def serialize(self, data: KiaraModel) -&gt; Union[str, SerializedData]:\n\n    if self.type_config.kiara_model_id is None:\n        logger.debug(\n            \"ignore.serialize_request\",\n            data_type=\"internal_model\",\n            cls=data.__class__.__name__,\n            reason=\"no model id in module config\",\n        )\n        return NO_SERIALIZATION_MARKER\n\n    _data = {\n        \"data\": {\n            \"type\": \"inline-json\",\n            \"inline_data\": data.dict(),\n            \"codec\": \"json\",\n        },\n    }\n\n    serialized_data = {\n        \"data_type\": self.data_type_name,\n        \"data_type_config\": self.type_config.dict(),\n        \"data\": _data,\n        \"serialization_profile\": \"json\",\n        \"metadata\": {\n            \"environment\": {},\n            \"deserialize\": {\n                \"python_object\": {\n                    \"module_type\": \"load.internal_model\",\n                    \"module_config\": {\n                        \"value_type\": \"internal_model\",\n                        \"target_profile\": \"python_object\",\n                        \"serialization_profile\": \"json\",\n                    },\n                }\n            },\n        },\n    }\n    from kiara.models.values.value import SerializationResult\n\n    serialized = SerializationResult(**serialized_data)\n    return serialized\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return KiaraModel\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.InternalModelValueType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; KiaraModel</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; KiaraModel:\n\n    if isinstance(data, KiaraModel):\n        return data\n    elif isinstance(data, Mapping):\n        return self.model_cls(**data)\n    else:\n        raise ValueError(\n            f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'KiaraModel' or Mapping.\"\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.DocumentationModelValueType","title":"<code>DocumentationModelValueType</code>","text":"<p>         Bases: <code>InternalModelValueType</code></p> <p>Documentation for an internal entity.</p> Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>class DocumentationModelValueType(InternalModelValueType):\n\"\"\"Documentation for an internal entity.\"\"\"\n\n    _data_type_name = \"doc\"\n\n    def parse_python_obj(self, data: Any) -&gt; DocumentationMetadataModel:\n\n        return DocumentationMetadataModel.create(data)\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return DocumentationMetadataModel\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ):\n        json_str = value.data.json(option=orjson.OPT_INDENT_2)\n        return Syntax(json_str, \"json\", background_color=\"default\")\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.DocumentationModelValueType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.DocumentationModelValueType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; DocumentationMetadataModel</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; DocumentationMetadataModel:\n\n    return DocumentationMetadataModel.create(data)\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/__init__/#kiara.data_types.included_core_types.internal.DocumentationModelValueType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/__init__.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return DocumentationMetadataModel\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/","title":"render_value","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value-classes","title":"Classes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneTypeConfig","title":"<code>RenderSceneTypeConfig</code>","text":"<p>         Bases: <code>DataTypeConfig</code></p> Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>class RenderSceneTypeConfig(DataTypeConfig):\n\n    kiara_model_id: Union[str, None] = Field(\n        description=\"The id of the model backing this render (Python class must sub-class 'RenderScene').\",\n        default=None,\n    )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneTypeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneTypeConfig.kiara_model_id","title":"<code>kiara_model_id: Union[str, None] = Field(description=\"The id of the model backing this render (Python class must sub-class 'RenderScene').\", default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType","title":"<code>RenderSceneDataType</code>","text":"<p>         Bases: <code>InternalType[RenderScene, RenderSceneTypeConfig]</code></p> <p>A value type to contain information about how to render a value in a specific render scenario.</p> Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>class RenderSceneDataType(InternalType[RenderScene, RenderSceneTypeConfig]):\n\"\"\"A value type to contain information about how to render a value in a specific render scenario.\"\"\"\n\n    _data_type_name = \"render_scene\"\n\n    def __init__(self, **type_config: Any):\n\n        self._cls_cache: Union[Type[RenderScene], None] = None\n        super().__init__(**type_config)\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return RenderScene\n\n    @classmethod\n    def data_type_config_class(cls) -&gt; Type[RenderSceneTypeConfig]:\n        return RenderSceneTypeConfig\n\n    @property\n    def model_cls(self) -&gt; Type[RenderScene]:\n\n        if self._cls_cache is not None:\n            return self._cls_cache\n\n        kiara_model_id = self.type_config.kiara_model_id\n        if not kiara_model_id:\n            kiara_model_id = RenderScene._kiara_model_id\n\n        if kiara_model_id == RenderScene._kiara_model_id:\n            model_cls = RenderScene\n        else:\n            all_models = find_all_kiara_model_classes()\n            if kiara_model_id not in all_models.keys():\n                raise Exception(f\"Invalid model id: {kiara_model_id}\")\n            # TODO: check type is right?\n            model_cls = all_models[kiara_model_id]  # type: ignore\n\n        assert issubclass(model_cls, RenderScene)\n        self._cls_cache = model_cls\n        return self._cls_cache\n\n    def parse_python_obj(self, data: Any) -&gt; RenderScene:\n\n        if isinstance(data, RenderScene):\n            return data\n        elif isinstance(data, Mapping):\n            return self.model_cls(**data)\n        else:\n            raise ValueError(\n                f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'KiaraModel' or Mapping.\"\n            )\n\n    def _validate(self, value: RenderScene) -&gt; None:\n\n        if not isinstance(value, RenderScene):\n            raise Exception(f\"Invalid type: {type(value)}.\")\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        data: RenderScene = value.data\n\n        ri_json = data.json(option=orjson.orjson.OPT_INDENT_2)\n        return Syntax(ri_json, \"json\", background_color=\"default\")\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType.model_cls","title":"<code>model_cls: Type[RenderScene]</code>  <code>property</code>","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return RenderScene\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType.data_type_config_class","title":"<code>data_type_config_class() -&gt; Type[RenderSceneTypeConfig]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>@classmethod\ndef data_type_config_class(cls) -&gt; Type[RenderSceneTypeConfig]:\n    return RenderSceneTypeConfig\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderSceneDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; RenderScene</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; RenderScene:\n\n    if isinstance(data, RenderScene):\n        return data\n    elif isinstance(data, Mapping):\n        return self.model_cls(**data)\n    else:\n        raise ValueError(\n            f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'KiaraModel' or Mapping.\"\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType","title":"<code>RenderValueResultDataType</code>","text":"<p>         Bases: <code>InternalType[RenderValueResult, DataTypeConfig]</code></p> <p>A value type to contain information about how to render a value in a specific render scenario.</p> Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>class RenderValueResultDataType(InternalType[RenderValueResult, DataTypeConfig]):\n\"\"\"A value type to contain information about how to render a value in a specific render scenario.\"\"\"\n\n    _data_type_name = \"render_value_result\"\n\n    def __init__(self, **type_config: Any):\n\n        self._cls_cache: Union[Type[RenderValueResult], None] = None\n        super().__init__(**type_config)\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return RenderValueResult\n\n    def parse_python_obj(self, data: Any) -&gt; RenderValueResult:\n\n        if data is None:\n            raise ValueError(\n                \"Can't parse render_scene_result data: no source data provided (None).\"\n            )\n        elif isinstance(data, RenderValueResult):\n            return data\n        elif isinstance(data, Mapping):\n            return RenderValueResult(**data)\n        else:\n            raise ValueError(\n                f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'RenderValueResult' or Mapping.\"\n            )\n\n    def _validate(self, value: Any) -&gt; None:\n\n        if not isinstance(value, RenderValueResult):\n            raise Exception(f\"Invalid type: {type(value)}.\")\n\n    def _pretty_print_as__terminal_renderable(\n        self, value: \"Value\", render_config: Mapping[str, Any]\n    ) -&gt; Any:\n\n        data: RenderValueResult = value.data\n\n        ri_json = data.json(option=orjson.orjson.OPT_INDENT_2, exclude={\"rendered\"})\n        rendered = extract_renderable(data.rendered)\n\n        metadata = Syntax(ri_json, \"json\", background_color=\"default\")\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"Rendered item\")\n        table.add_column(\"Render metadata\")\n        table.add_row(rendered, metadata)\n        return table\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType-functions","title":"Functions","text":""},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return RenderValueResult\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; RenderValueResult</code>","text":"Source code in <code>kiara/data_types/included_core_types/internal/render_value.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; RenderValueResult:\n\n    if data is None:\n        raise ValueError(\n            \"Can't parse render_scene_result data: no source data provided (None).\"\n        )\n    elif isinstance(data, RenderValueResult):\n        return data\n    elif isinstance(data, Mapping):\n        return RenderValueResult(**data)\n    else:\n        raise ValueError(\n            f\"Can't parse data, invalid type '{type(data)}': must be subclass of 'RenderValueResult' or Mapping.\"\n        )\n</code></pre>"},{"location":"reference/kiara/data_types/included_core_types/internal/render_value/#kiara.data_types.included_core_types.internal.render_value-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/__init__/","title":"doc","text":"<p>Main module for code that helps with documentation auto-generation in supported projects.</p>"},{"location":"reference/kiara/doc/__init__/#kiara.doc-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin","title":"<code>FrklDocumentationPlugin</code>","text":"<p>         Bases: <code>BasePlugin</code></p> <p>mkdocs plugin to render API documentation for a project.</p> <p>To add to a project, add this to the 'plugins' section of a mkdocs config file:</p> <pre><code>- frkl-docgen:\nmain_module: \"module_name\"\n</code></pre> <p>This will add an <code>API reference</code> navigation item to your page navigation, with auto-generated entries for every Python module in your package.</p> Source code in <code>kiara/doc/__init__.py</code> <pre><code>class FrklDocumentationPlugin(BasePlugin):\n\"\"\"[mkdocs](https://www.mkdocs.org/) plugin to render API documentation for a project.\n\n    To add to a project, add this to the 'plugins' section of a mkdocs config file:\n\n    ```yaml\n    - frkl-docgen:\n        main_module: \"module_name\"\n    ```\n\n    This will add an ``API reference`` navigation item to your page navigation, with auto-generated entries for every\n    Python module in your package.\n    \"\"\"\n\n    config_scheme = ((\"main_module\", mkdocs.config.config_options.Type(str)),)\n\n    def __init__(self):\n        self._doc_paths = None\n        self._dir = tempfile.TemporaryDirectory(prefix=\"frkl_doc_gen_\")\n        self._doc_files = None\n        super().__init__()\n\n    def on_files(self, files: Files, config: Config) -&gt; Files:\n\n        self._doc_paths = gen_pages_for_module(self.config[\"main_module\"])\n        self._doc_files = {}\n\n        for k in sorted(self._doc_paths, key=lambda x: os.path.splitext(x)[0]):\n            content = self._doc_paths[k][\"content\"]\n            _file = File(\n                k,\n                src_dir=self._dir.name,\n                dest_dir=config[\"site_dir\"],\n                use_directory_urls=config[\"use_directory_urls\"],\n            )\n\n            os.makedirs(os.path.dirname(_file.abs_src_path), exist_ok=True)\n\n            with open(_file.abs_src_path, \"w\") as f:\n                f.write(content)\n\n            self._doc_files[k] = _file\n            files.append(_file)\n\n        return files\n\n    def on_page_content(self, html, page: Page, config: Config, files: Files):\n\n        repo_url = config.get(\"repo_url\", None)\n        python_src = config.get(\"edit_uri\", None)\n\n        if page.file.src_path in self._doc_paths.keys():\n            src_path = self._doc_paths.get(page.file.src_path)[\"python_src\"][\"rel_path\"]\n            rel_base = urllib.parse.urljoin(repo_url, f\"{python_src}/../src/{src_path}\")\n            page.edit_url = rel_base\n\n        return html\n\n    def on_nav(self, nav: Navigation, config: Config, files: Files):\n\n        for item in nav.items:\n            if item.title and \"Api reference\" in item.title:\n                return nav\n\n        pages = []\n        for _file in self._doc_files.values():\n            pages.append(_file.page)\n\n        section = Section(title=\"API reference\", children=pages)\n        nav.items.append(section)\n        nav.pages.extend(pages)\n\n        _add_previous_and_next_links(nav.pages)\n        _add_parent_links(nav.items)\n\n        return nav\n\n    def on_post_build(self, config: Config):\n\n        self._dir.cleanup()\n</code></pre>"},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin.config_scheme","title":"<code>config_scheme = (('main_module', mkdocs.config.config_options.Type(str)))</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin.on_files","title":"<code>on_files(files: Files, config: Config) -&gt; Files</code>","text":"Source code in <code>kiara/doc/__init__.py</code> <pre><code>def on_files(self, files: Files, config: Config) -&gt; Files:\n\n    self._doc_paths = gen_pages_for_module(self.config[\"main_module\"])\n    self._doc_files = {}\n\n    for k in sorted(self._doc_paths, key=lambda x: os.path.splitext(x)[0]):\n        content = self._doc_paths[k][\"content\"]\n        _file = File(\n            k,\n            src_dir=self._dir.name,\n            dest_dir=config[\"site_dir\"],\n            use_directory_urls=config[\"use_directory_urls\"],\n        )\n\n        os.makedirs(os.path.dirname(_file.abs_src_path), exist_ok=True)\n\n        with open(_file.abs_src_path, \"w\") as f:\n            f.write(content)\n\n        self._doc_files[k] = _file\n        files.append(_file)\n\n    return files\n</code></pre>"},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin.on_page_content","title":"<code>on_page_content(html, page: Page, config: Config, files: Files)</code>","text":"Source code in <code>kiara/doc/__init__.py</code> <pre><code>def on_page_content(self, html, page: Page, config: Config, files: Files):\n\n    repo_url = config.get(\"repo_url\", None)\n    python_src = config.get(\"edit_uri\", None)\n\n    if page.file.src_path in self._doc_paths.keys():\n        src_path = self._doc_paths.get(page.file.src_path)[\"python_src\"][\"rel_path\"]\n        rel_base = urllib.parse.urljoin(repo_url, f\"{python_src}/../src/{src_path}\")\n        page.edit_url = rel_base\n\n    return html\n</code></pre>"},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin.on_nav","title":"<code>on_nav(nav: Navigation, config: Config, files: Files)</code>","text":"Source code in <code>kiara/doc/__init__.py</code> <pre><code>def on_nav(self, nav: Navigation, config: Config, files: Files):\n\n    for item in nav.items:\n        if item.title and \"Api reference\" in item.title:\n            return nav\n\n    pages = []\n    for _file in self._doc_files.values():\n        pages.append(_file.page)\n\n    section = Section(title=\"API reference\", children=pages)\n    nav.items.append(section)\n    nav.pages.extend(pages)\n\n    _add_previous_and_next_links(nav.pages)\n    _add_parent_links(nav.items)\n\n    return nav\n</code></pre>"},{"location":"reference/kiara/doc/__init__/#kiara.doc.FrklDocumentationPlugin.on_post_build","title":"<code>on_post_build(config: Config)</code>","text":"Source code in <code>kiara/doc/__init__.py</code> <pre><code>def on_post_build(self, config: Config):\n\n    self._dir.cleanup()\n</code></pre>"},{"location":"reference/kiara/doc/__init__/#kiara.doc-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/gen_info_pages/","title":"gen_info_pages","text":""},{"location":"reference/kiara/doc/gen_info_pages/#kiara.doc.gen_info_pages-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/gen_info_pages/#kiara.doc.gen_info_pages-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/gen_info_pages/#kiara.doc.gen_info_pages.get_jina_env","title":"<code>get_jina_env()</code>","text":"Source code in <code>kiara/doc/gen_info_pages.py</code> <pre><code>def get_jina_env():\n\n    global _jinja_env\n    if _jinja_env is None:\n        from jinja2 import Environment\n\n        _loader = PackageLoader(\n            package_name=\"kiara\",\n            package_path=os.path.join(\"resources\", \"templates\", \"doc_gen\"),\n            encoding=\"utf8\",\n        )\n        _jinja_env = Environment(loader=_loader, autoescape=True)\n        # _jinja_env = Environment(\n        #     loader=FileSystemLoader(\n        #         os.path.join(KIARA_RESOURCES_FOLDER, \"templates\", \"doc_gen\"),\n        #         encoding=\"utf8\",\n        #     )\n        # )\n    return _jinja_env\n</code></pre>"},{"location":"reference/kiara/doc/gen_info_pages/#kiara.doc.gen_info_pages.render_item_listing","title":"<code>render_item_listing(item_type: str, items: Mapping[str, ItemInfo], sub_path: str = 'info')</code>","text":"Source code in <code>kiara/doc/gen_info_pages.py</code> <pre><code>def render_item_listing(\n    item_type: str, items: Mapping[str, ItemInfo], sub_path: str = \"info\"\n):\n\n    list_template = get_jina_env().get_template(\"info_listing.j2\")\n\n    render_args = {\"items\": items, \"item_type\": item_type}\n    rendered = list_template.render(**render_args)\n\n    path = f\"{sub_path}/{item_type}.md\"\n    with mkdocs_gen_files.open(path, \"w\") as f:\n        f.write(rendered)\n\n    return path\n</code></pre>"},{"location":"reference/kiara/doc/gen_info_pages/#kiara.doc.gen_info_pages.generate_detail_pages","title":"<code>generate_detail_pages(context_info: KiaraContextInfo, sub_path: str = 'info', add_summary_page: bool = False)</code>","text":"Source code in <code>kiara/doc/gen_info_pages.py</code> <pre><code>def generate_detail_pages(\n    context_info: KiaraContextInfo,\n    sub_path: str = \"info\",\n    add_summary_page: bool = False,\n):\n\n    pages = {}\n    summary = []\n\n    all_info = context_info.get_all_info(skip_empty_types=True)\n\n    for item_type, items_info in all_info.items():\n        summary.append(f\"* [{item_type}]({item_type}.md)\")\n        path = render_item_listing(\n            item_type=item_type, items=items_info.item_infos, sub_path=sub_path\n        )\n        pages[item_type] = path\n\n    if summary:\n        if add_summary_page:\n            summary.insert(0, \"* [Summary](index.md)\")\n\n        with mkdocs_gen_files.open(f\"{sub_path}/SUMMARY.md\", \"w\") as f:\n            f.write(\"\\n\".join(summary))\n\n    return pages\n</code></pre>"},{"location":"reference/kiara/doc/generate_api_doc/","title":"generate_api_doc","text":""},{"location":"reference/kiara/doc/generate_api_doc/#kiara.doc.generate_api_doc-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/generate_api_doc/#kiara.doc.generate_api_doc.gen_pages_for_module","title":"<code>gen_pages_for_module(module: typing.Union[str, ModuleType], prefix: str = 'api_reference')</code>","text":"<p>Generate modules for a set of modules (using the mkdocstring package.</p> Source code in <code>kiara/doc/generate_api_doc.py</code> <pre><code>def gen_pages_for_module(\n    module: typing.Union[str, ModuleType], prefix: str = \"api_reference\"\n):\n\"\"\"Generate modules for a set of modules (using the [mkdocstring](https://github.com/mkdocstrings/mkdocstrings) package.\"\"\"\n\n    result = {}\n    modules_info = get_source_tree(module)\n    for module_name, path in modules_info.items():\n\n        page_name = module_name\n\n        if page_name.endswith(\"__init__\"):\n            page_name = page_name[0:-9]\n        if page_name.endswith(\"._frkl\"):\n            continue\n\n        doc_path = f\"{prefix}{os.path.sep}{page_name}.md\"\n        p = Path(\"..\", path[\"abs_path\"])\n        if not p.read_text().strip():\n            continue\n\n        main_module = path[\"main_module\"]\n        if page_name == main_module:\n            title = page_name\n        else:\n            title = page_name.replace(f\"{main_module}.\", \"\u279c\u2007\")  # noqa\n\n        result[doc_path] = {\n            \"python_src\": path,\n            \"content\": f\"---\\ntitle: {title}\\n---\\n# {page_name}\\n\\n::: {module_name}\",\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara/doc/generate_api_doc/#kiara.doc.generate_api_doc.get_source_tree","title":"<code>get_source_tree(module: typing.Union[str, ModuleType])</code>","text":"<p>Find all python source files for a module.</p> Source code in <code>kiara/doc/generate_api_doc.py</code> <pre><code>def get_source_tree(module: typing.Union[str, ModuleType]):\n\"\"\"Find all python source files for a module.\"\"\"\n\n    if isinstance(module, str):\n        module = importlib.import_module(module)\n\n    if not isinstance(module, ModuleType):\n        raise TypeError(\n            f\"Invalid type '{type(module)}', input needs to be a string or module.\"\n        )\n\n    module_file = module.__file__\n    assert module_file is not None\n    module_root = os.path.dirname(module_file)\n    module_name = module.__name__\n\n    src = {}\n\n    for path in Path(module_root).glob(\"**/*.py\"):\n\n        rel = os.path.relpath(path, module_root)\n        mod_name = f\"{module_name}.{rel[0:-3].replace(os.path.sep, '.')}\"\n        rel_path = f\"{module_name}{os.path.sep}{rel}\"\n        src[mod_name] = {\n            \"rel_path\": rel_path,\n            \"abs_path\": path,\n            \"main_module\": module_name,\n        }\n\n    return src\n</code></pre>"},{"location":"reference/kiara/doc/mkdocs_macros_cli/","title":"mkdocs_macros_cli","text":""},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.KIARA_DOC_BUILD_CACHE_DIR","title":"<code>KIARA_DOC_BUILD_CACHE_DIR = os.path.join(kiara_app_dirs.user_cache_dir, 'doc_gen')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.os_env_vars","title":"<code>os_env_vars = copy.deepcopy(os.environ)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.log_msg","title":"<code>log_msg(msg: str)</code>","text":"Source code in <code>kiara/doc/mkdocs_macros_cli.py</code> <pre><code>def log_msg(msg: str):\n    print(msg)  # noqa\n</code></pre>"},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.define_env","title":"<code>define_env(env)</code>","text":"<p>Helper macros for Python project documentation.</p> <p>Currently, those macros are available (check the source code for more details):</p>"},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.define_env--cli","title":"<code>cli</code>","text":"<p>Execute a command on the command-line, capture the output and return it to be used in a documentation page.</p>"},{"location":"reference/kiara/doc/mkdocs_macros_cli/#kiara.doc.mkdocs_macros_cli.define_env--inline_file_as_codeblock","title":"<code>inline_file_as_codeblock</code>","text":"<p>Read an external file, and return its content as a markdown code block.</p> Source code in <code>kiara/doc/mkdocs_macros_cli.py</code> <pre><code>def define_env(env):\n\"\"\"\n    Helper macros for Python project documentation.\n\n    Currently, those macros are available (check the source code for more details):\n\n    ## ``cli``\n\n    Execute a command on the command-line, capture the output and return it to be used in a documentation page.\n\n    ## ``inline_file_as_codeblock``\n\n    Read an external file, and return its content as a markdown code block.\n    \"\"\"\n\n    # env.variables[\"baz\"] = \"John Doe\"\n\n    @env.macro\n    def cli(\n        *command,\n        print_command: bool = True,\n        code_block: bool = True,\n        split_command_and_output: bool = True,\n        max_height: Union[int, None] = None,\n        cache_key: Union[str, None] = None,\n        extra_env: Union[Dict[str, str], None] = None,\n        fake_command: Union[str, None] = None,\n        fail_ok: bool = False,\n        repl_dict: Union[Mapping[str, str], None] = None,\n    ):\n\"\"\"Execute the provided command, save the output and return it to be used in documentation modules.\"\"\"\n\n        hashes = DeepHash(command)\n        hash_str = hashes[command]\n        hashes_env = DeepHash(extra_env)\n        hashes_env_str = hashes_env[extra_env]\n\n        hash_str = hash_str + \"_\" + hashes_env_str\n        if cache_key:\n            hash_str = hash_str + \"_\" + cache_key\n\n        cache_file: Path = Path(os.path.join(KIARA_DOC_BUILD_CACHE_DIR, str(hash_str)))\n        failed_cache_file: Path = Path(\n            os.path.join(KIARA_DOC_BUILD_CACHE_DIR, f\"{hash_str}.failed\")\n        )\n        cache_info_file: Path = Path(\n            os.path.join(KIARA_DOC_BUILD_CACHE_DIR), f\"{hash_str}.command\"\n        )\n\n        _run_env = dict(os_env_vars)\n        if extra_env:\n            _run_env.update(extra_env)\n\n        if cache_file.is_file():\n            stdout_str = cache_file.read_text()\n            if repl_dict:\n                for k, v in repl_dict.items():\n                    stdout_str = stdout_str.replace(k, v)\n        else:\n            start = timer()\n\n            cache_info = {\n                \"command\": command,\n                \"extra_env\": extra_env,\n                \"cmd_hash\": hash_str,\n                \"cache_key\": cache_key,\n                \"fail_ok\": fail_ok,\n                \"started\": start,\n                \"repl_dict\": repl_dict,\n            }\n\n            log_msg(f\"RUNNING: {' '.join(command)}\")\n\n            p = Popen(command, stdout=PIPE, stderr=PIPE, env=_run_env)\n            stdout, stderr = p.communicate()\n\n            stdout_str = stdout.decode(\"utf-8\")\n            stderr_str = stderr.decode(\"utf-8\")\n\n            if repl_dict:\n                for k, v in repl_dict.items():\n                    stdout_str = stdout_str.replace(k, v)\n                    stderr_str = stderr_str.replace(k, v)\n\n            log_msg(\"stdout:\")\n            log_msg(stdout_str)\n            log_msg(\"stderr:\")\n            log_msg(stderr_str)\n\n            cache_info[\"exit_code\"] = p.returncode\n\n            end = timer()\n            if p.returncode == 0:\n\n                # result = subprocess.check_output(command, env=_run_env)\n\n                # stdout = result.decode()\n                cache_file.write_bytes(stdout)\n                cache_info[\"size\"] = len(stdout)\n                cache_info[\"duration\"] = end - start\n                cache_info[\"success\"] = True\n                cache_info[\"output_file\"] = cache_file.as_posix()\n                cache_info_file.write_bytes(orjson.dumps(cache_info))\n\n                if failed_cache_file.exists():\n                    failed_cache_file.unlink()\n            else:\n\n                cache_info[\"duration\"] = end - start\n\n                if fail_ok:\n                    cache_info[\"size\"] = len(stdout)\n                    cache_info[\"success\"] = True\n                    cache_file.write_bytes(stdout)\n                    cache_info[\"output_file\"] = cache_file.as_posix()\n                    cache_info_file.write_bytes(orjson.dumps(cache_info))\n                    if failed_cache_file.exists():\n                        failed_cache_file.unlink()\n                else:\n                    cache_info[\"size\"] = len(stdout)\n                    cache_info[\"success\"] = False\n                    failed_cache_file.write_bytes(stdout)\n                    cache_info[\"output_file\"] = failed_cache_file.as_posix()\n                    cache_info_file.write_bytes(orjson.dumps(cache_info))\n                    # stdout = f\"Error: {e}\\n\\nStdout: {e.stdout}\\n\\nStderr: {e.stderr}\"\n                    # cache_info[\"size\"] = len(stdout)\n                    # cache_info[\"success\"] = False\n                    # print(\"stdout:\")\n                    # print(e.stdout)\n                    # print(\"stderr:\")\n                    # print(e.stderr)\n                    # failed_cache_file.write_text(stdout)\n                    # cache_info[\"output_file\"] = failed_cache_file.as_posix()\n                    # cache_info_file.write_bytes(orjson.dumps(cache_info))\n                    if os.getenv(\"FAIL_DOC_BUILD_ON_ERROR\") == \"true\":\n                        sys.exit(1)\n\n        if fake_command:\n            command_str = fake_command\n        else:\n            command_str = \" \".join(command)\n\n        if split_command_and_output and print_command:\n            _c = f\"\\n```bash\\n{command_str}\\n```\\n\"\n            _output = \"```\\n\" + stdout_str + \"\\n```\\n\"\n            if max_height is not None and max_height &gt; 0:\n                _output = f\"&lt;div style='max-height:{max_height}px;overflow:auto'&gt;\\n{_output}\\n&lt;/div&gt;\"\n            _stdout = _c + _output\n        else:\n            if print_command:\n                _stdout = f\"&gt; {command_str}\\n{stdout_str}\"\n            if code_block:\n                _stdout = \"```\\n\" + _stdout + \"\\n```\\n\"\n\n            if max_height is not None and max_height &gt; 0:\n                _stdout = f\"&lt;div style='max-height:{max_height}px;overflow:auto'&gt;\\n{_stdout}\\n&lt;/div&gt;\"\n\n        return _stdout\n\n    @env.macro\n    def inline_file_as_codeblock(path, format: str = \"\"):\n\"\"\"Import external file and return its content as a markdown code block.\"\"\"\n\n        f = Path(path)\n        return f\"```{format}\\n{f.read_text()}\\n```\"\n</code></pre>"},{"location":"reference/kiara/doc/mkdocs_macros_kiara/","title":"mkdocs_macros_kiara","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara.yaml","title":"<code>yaml = StringYAML()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara.kiara_obj","title":"<code>kiara_obj = Kiara.instance()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocs_macros_kiara/#kiara.doc.mkdocs_macros_kiara.define_env","title":"<code>define_env(env)</code>","text":"<p>This is the hook for defining variables, macros and filters</p> <ul> <li>variables: the dictionary that contains the environment variables</li> <li>macro: a decorator function, to declare a macro.</li> </ul> Source code in <code>kiara/doc/mkdocs_macros_kiara.py</code> <pre><code>def define_env(env):\n\"\"\"\n    This is the hook for defining variables, macros and filters\n\n    - variables: the dictionary that contains the environment variables\n    - macro: a decorator function, to declare a macro.\n    \"\"\"\n\n    # env.variables[\"baz\"] = \"John Doe\"\n\n    @env.macro\n    def get_schema_for_model(model_class: Union[str, Type[BaseModel]]):\n\n        if isinstance(model_class, str):\n            _class: Type[BaseModel] = locate(model_class)  # type: ignore\n        else:\n            _class = model_class\n\n        schema_json = _class.schema_json(indent=2)\n\n        return schema_json\n\n    @env.macro\n    def get_src_of_object(obj: Union[str, Any]):\n\n        try:\n            if isinstance(obj, str):\n                _obj: Type[BaseModel] = locate(obj)  # type: ignore\n            else:\n                _obj = obj\n\n            src = inspect.getsource(_obj)\n            return src\n        except Exception as e:\n            return f\"Can't render object source: {str(e)}\"\n\n    @env.macro\n    def get_context_info() -&gt; KiaraContextInfo:\n\n        return builtins.plugin_package_context_info  # type: ignore\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/__init__/","title":"mkdocstrings","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/","title":"collector","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.logger","title":"<code>logger = get_logger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector","title":"<code>KiaraCollector</code>","text":"<p>         Bases: <code>BaseCollector</code></p> <p>The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the <code>render</code> method, and overrides the <code>update_env</code> method of the <code>BaseRenderer</code> class.</p> Source code in <code>kiara/doc/mkdocstrings/collector.py</code> <pre><code>class KiaraCollector(BaseCollector):\n\"\"\"The class responsible for loading Jinja templates and rendering them.\n    It defines some configuration options, implements the `render` method,\n    and overrides the `update_env` method of the [`BaseRenderer` class][mkdocstrings.handlers.base.BaseRenderer].\n    \"\"\"\n\n    default_config: dict = {\"docstring_style\": \"google\", \"docstring_options\": {}}\n\"\"\"The default selection options.\n    Option | Type | Description | Default\n    ------ | ---- | ----------- | -------\n    **`docstring_style`** | `\"google\" | \"numpy\" | \"sphinx\" | None` | The docstring style to use. | `\"google\"`\n    **`docstring_options`** | `dict[str, Any]` | The options for the docstring parser. | `{}`\n    \"\"\"\n\n    fallback_config: dict = {\"fallback\": True}\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize the collector.\"\"\"\n\n        self._kiara: Kiara = Kiara.instance()\n\n    def collect(self, identifier: str, config: dict) -&gt; CollectorItem:\n\"\"\"Collect the documentation tree given an identifier and selection options.\n        Arguments:\n            identifier: The dotted-path of a Python object available in the Python path.\n            config: Selection options, used to alter the data collection done by `pytkdocs`.\n        Raises:\n            CollectionError: When there was a problem collecting the object documentation.\n        Returns:\n            The collected object-tree.\n        \"\"\"\n\n        tokens = identifier.split(\".\")\n\n        if tokens[0] != \"kiara_info\":\n            return None\n\n        item_type = tokens[1]\n        item_id = \".\".join(tokens[2:])\n        if not item_id:\n            raise CollectionError(f\"Invalid id: {identifier}\")\n\n        ctx: KiaraContextInfo = builtins.plugin_package_context_info  # type: ignore\n        try:\n            item: ItemInfo = ctx.get_info(item_type=item_type, item_id=item_id)\n        except Exception as e:\n            log_exception(e)\n            raise CollectionError(f\"Invalid id: {identifier}\")\n\n        return {\"obj\": item, \"identifier\": identifier}\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector.default_config","title":"<code>default_config: dict = {'docstring_style': 'google', 'docstring_options': {}}</code>  <code>class-attribute</code>","text":"<p>The default selection options. Option | Type | Description | Default ------ | ---- | ----------- | ------- <code>docstring_style</code> | <code>\"google\" | \"numpy\" | \"sphinx\" | None</code> | The docstring style to use. | <code>\"google\"</code> <code>docstring_options</code> | <code>dict[str, Any]</code> | The options for the docstring parser. | <code>{}</code></p>"},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector.fallback_config","title":"<code>fallback_config: dict = {'fallback': True}</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector.KiaraCollector.collect","title":"<code>collect(identifier: str, config: dict) -&gt; CollectorItem</code>","text":"<p>Collect the documentation tree given an identifier and selection options.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The dotted-path of a Python object available in the Python path.</p> required <code>config</code> <code>dict</code> <p>Selection options, used to alter the data collection done by <code>pytkdocs</code>.</p> required <p>Raises:</p> Type Description <code>CollectionError</code> <p>When there was a problem collecting the object documentation.</p> <p>Returns:</p> Type Description <code>CollectorItem</code> <p>The collected object-tree.</p> Source code in <code>kiara/doc/mkdocstrings/collector.py</code> <pre><code>def collect(self, identifier: str, config: dict) -&gt; CollectorItem:\n\"\"\"Collect the documentation tree given an identifier and selection options.\n    Arguments:\n        identifier: The dotted-path of a Python object available in the Python path.\n        config: Selection options, used to alter the data collection done by `pytkdocs`.\n    Raises:\n        CollectionError: When there was a problem collecting the object documentation.\n    Returns:\n        The collected object-tree.\n    \"\"\"\n\n    tokens = identifier.split(\".\")\n\n    if tokens[0] != \"kiara_info\":\n        return None\n\n    item_type = tokens[1]\n    item_id = \".\".join(tokens[2:])\n    if not item_id:\n        raise CollectionError(f\"Invalid id: {identifier}\")\n\n    ctx: KiaraContextInfo = builtins.plugin_package_context_info  # type: ignore\n    try:\n        item: ItemInfo = ctx.get_info(item_type=item_type, item_id=item_id)\n    except Exception as e:\n        log_exception(e)\n        raise CollectionError(f\"Invalid id: {identifier}\")\n\n    return {\"obj\": item, \"identifier\": identifier}\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/collector/#kiara.doc.mkdocstrings.collector-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/","title":"handler","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler.KiaraHandler","title":"<code>KiaraHandler</code>","text":"<p>         Bases: <code>BaseHandler</code></p> <p>The kiara handler class.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>The cross-documentation domain/language for this handler.</p> <code>enable_inventory</code> <code>bool</code> <p>Whether this handler is interested in enabling the creation of the <code>objects.inv</code> Sphinx inventory file.</p> Source code in <code>kiara/doc/mkdocstrings/handler.py</code> <pre><code>class KiaraHandler(BaseHandler):\n\"\"\"The kiara handler class.\n    Attributes:\n        domain: The cross-documentation domain/language for this handler.\n        enable_inventory: Whether this handler is interested in enabling the creation\n            of the `objects.inv` Sphinx inventory file.\n    \"\"\"\n\n    domain: str = \"kiara\"\n    enable_inventory: bool = True\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler.KiaraHandler-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler.KiaraHandler.domain","title":"<code>domain: str = 'kiara'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler.KiaraHandler.enable_inventory","title":"<code>enable_inventory: bool = True</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocstrings/handler/#kiara.doc.mkdocstrings.handler.get_handler","title":"<code>get_handler(theme: str, custom_templates: typing.Union[str, None] = None, **config: typing.Any) -&gt; KiaraHandler</code>","text":"<p>Simply return an instance of <code>PythonHandler</code>.</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>str</code> <p>The theme to use when rendering contents.</p> required <code>custom_templates</code> <code>typing.Union[str, None]</code> <p>Directory containing custom templates.</p> <code>None</code> <code>**config</code> <code>typing.Any</code> <p>Configuration passed to the handler.</p> <code>{}</code> <p>Returns:</p> Type Description <code>KiaraHandler</code> <p>An instance of <code>PythonHandler</code>.</p> Source code in <code>kiara/doc/mkdocstrings/handler.py</code> <pre><code>def get_handler(\n    theme: str,\n    custom_templates: typing.Union[str, None] = None,\n    **config: typing.Any,\n) -&gt; KiaraHandler:\n\"\"\"Simply return an instance of `PythonHandler`.\n    Arguments:\n        theme: The theme to use when rendering contents.\n        custom_templates: Directory containing custom templates.\n        **config: Configuration passed to the handler.\n    Returns:\n        An instance of `PythonHandler`.\n    \"\"\"\n\n    if custom_templates is not None:\n        raise Exception(\"Custom templates are not supported for the kiara renderer.\")\n\n    # custom_templates = os.path.join(\n    #     KIARA_RESOURCES_FOLDER, \"templates\", \"info_templates\"\n    # )\n\n    return KiaraHandler(\n        collector=KiaraCollector(),\n        # renderer=KiaraInfoRenderer(\"kiara\", theme, custom_templates),\n        renderer=KiaraInfoRenderer(\"kiara\", theme),\n    )\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/renderer/","title":"renderer","text":""},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer-classes","title":"Classes","text":""},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.AliasResolutionError","title":"<code>AliasResolutionError</code>","text":"Source code in <code>kiara/doc/mkdocstrings/renderer.py</code> <pre><code>class AliasResolutionError:\n    pass\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer","title":"<code>KiaraInfoRenderer</code>","text":"<p>         Bases: <code>BaseRenderer</code></p> Source code in <code>kiara/doc/mkdocstrings/renderer.py</code> <pre><code>class KiaraInfoRenderer(BaseRenderer):\n\n    default_config: dict = {}\n\n    def get_anchors(self, data: CollectorItem) -&gt; typing.List[str]:\n\n        if data is None:\n            return []\n\n        return [data[\"identifier\"], data[\"kiara_id\"], data[\"obj\"].get_id()]\n\n    def render(self, data: typing.Dict[str, typing.Any], config: dict) -&gt; str:\n\n        # final_config = ChainMap(config, self.default_config)\n\n        obj = data[\"obj\"]\n        html = obj.create_html()\n        return html\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer-attributes","title":"Attributes","text":""},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer.default_config","title":"<code>default_config: dict = {}</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer.get_anchors","title":"<code>get_anchors(data: CollectorItem) -&gt; typing.List[str]</code>","text":"Source code in <code>kiara/doc/mkdocstrings/renderer.py</code> <pre><code>def get_anchors(self, data: CollectorItem) -&gt; typing.List[str]:\n\n    if data is None:\n        return []\n\n    return [data[\"identifier\"], data[\"kiara_id\"], data[\"obj\"].get_id()]\n</code></pre>"},{"location":"reference/kiara/doc/mkdocstrings/renderer/#kiara.doc.mkdocstrings.renderer.KiaraInfoRenderer.render","title":"<code>render(data: typing.Dict[str, typing.Any], config: dict) -&gt; str</code>","text":"Source code in <code>kiara/doc/mkdocstrings/renderer.py</code> <pre><code>def render(self, data: typing.Dict[str, typing.Any], config: dict) -&gt; str:\n\n    # final_config = ChainMap(config, self.default_config)\n\n    obj = data[\"obj\"]\n    html = obj.create_html()\n    return html\n</code></pre>"},{"location":"reference/kiara/interfaces/__init__/","title":"interfaces","text":"<p>Implementation of interfaces for Kiara.</p>"},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap","title":"<code>KiaraAPIWrap</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/interfaces/__init__.py</code> <pre><code>class KiaraAPIWrap(object):\n    def __init__(\n        self,\n        config: Union[str, None],\n        context: Union[str, None],\n        pipelines: Union[None, Iterable[str]] = None,\n        ensure_plugins: Union[str, Iterable[str], None] = None,\n    ):\n\n        if not context:\n            context = os.environ.get(\"KIARA_CONTEXT\", None)\n\n        self._config: Union[str, None] = config\n        self._context: Union[str, None] = context\n\n        self._pipelines: Union[None, Iterable[str]] = pipelines\n        self._ensure_plugins: Union[str, Iterable[str], None] = ensure_plugins\n\n        self._kiara_config: Union[\"KiaraConfig\", None] = None\n        self._api: Union[KiaraAPI, None] = None\n\n        self._reload_process_if_plugins_installed = True\n\n    @property\n    def kiara_context_name(self) -&gt; str:\n\n        context = self._context\n        if not context:\n            context = self.kiara_config.default_context\n        return context\n\n    @property\n    def kiara(self) -&gt; \"Kiara\":\n        return self.kiara_api.context\n\n    @property\n    def kiara_config(self) -&gt; \"KiaraConfig\":\n\n        if self._kiara_config is not None:\n            return self._kiara_config\n        from kiara.context.config import KiaraConfig\n\n        # kiara_config: Optional[KiaraConfig] = None\n        exists = False\n        create = False\n        if self._config:\n            config_path = Path(self._config)\n            if config_path.exists():\n                if config_path.is_file():\n                    config_file_path = config_path\n                    exists = True\n                else:\n                    config_file_path = config_path / KIARA_CONFIG_FILE_NAME\n                    if config_file_path.exists():\n                        exists = True\n            else:\n                config_path.parent.mkdir(parents=True, exist_ok=True)\n                config_file_path = config_path\n\n        else:\n            config_file_path = Path(KIARA_MAIN_CONFIG_FILE)\n            if not config_file_path.exists():\n                create = True\n                exists = False\n            else:\n                exists = True\n\n        if not exists:\n            if not create:\n                from kiara.utils.cli import terminal_print\n\n                terminal_print()\n                terminal_print(\n                    f\"Can't create kiara context, specified config file does not exist: {self._config}.\"\n                )\n                sys.exit(1)\n\n            kiara_config = KiaraConfig()\n            kiara_config.save(config_file_path)\n        else:\n            kiara_config = KiaraConfig.load_from_file(config_file_path)\n\n        self._kiara_config = kiara_config\n        return self._kiara_config\n\n    @property\n    def kiara_api(self) -&gt; \"KiaraAPI\":\n\n        if self._api is not None:\n            return self._api\n\n        from kiara.utils import log_message\n\n        context = self._context\n        if not context:\n            context = self.kiara_config.default_context\n\n        from kiara.interfaces.python_api import KiaraAPI\n\n        api = KiaraAPI(kiara_config=self.kiara_config)\n        if self._ensure_plugins:\n            installed = api.ensure_plugin_packages(self._ensure_plugins, update=False)\n            if installed and self._reload_process_if_plugins_installed:\n                log_message(\n                    \"replacing.process\",\n                    reason=\"reloading this process, in order to pick up new plugin packages\",\n                )\n                os.execvp(sys.executable, (sys.executable,) + tuple(sys.argv))  # noqa\n\n        api.set_active_context(context, create=True)\n\n        if self._pipelines:\n            for pipeline in self._pipelines:\n                ops = api.context.operation_registry.register_pipelines(pipeline)\n                for op_id in ops.keys():\n                    log_message(\"register.pipeline\", operation_id=op_id)\n\n        self._api = api\n        return self._api\n</code></pre>"},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap.kiara_context_name","title":"<code>kiara_context_name: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap.kiara","title":"<code>kiara: Kiara</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap.kiara_config","title":"<code>kiara_config: KiaraConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.KiaraAPIWrap.kiara_api","title":"<code>kiara_api: KiaraAPI</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.get_console","title":"<code>get_console() -&gt; Console</code>","text":"<p>Get a global Console instance.</p> <p>Returns:</p> Name Type Description <code>Console</code> <code>Console</code> <p>A console instance.</p> Source code in <code>kiara/interfaces/__init__.py</code> <pre><code>def get_console() -&gt; \"Console\":\n\"\"\"Get a global Console instance.\n\n    Returns:\n        Console: A console instance.\n    \"\"\"\n    global _console\n    if _console is None:\n        console_width = os.environ.get(\"CONSOLE_WIDTH\", None)\n        width = None\n\n        if console_width:\n            try:\n                width = int(console_width)\n            except Exception:\n                pass\n\n        from rich.console import Console\n\n        _console = Console(width=width)\n\n    return _console\n</code></pre>"},{"location":"reference/kiara/interfaces/__init__/#kiara.interfaces.set_console_width","title":"<code>set_console_width(width: Union[int, None] = None, prefer_env: bool = True)</code>","text":"Source code in <code>kiara/interfaces/__init__.py</code> <pre><code>def set_console_width(width: Union[int, None] = None, prefer_env: bool = True):\n\n    global _console\n    if prefer_env or not width:\n        _width: Union[None, int] = None\n        try:\n            _width = int(os.environ.get(\"CONSOLE_WIDTH\", None))  # type: ignore\n        except Exception:\n            pass\n        if _width:\n            width = _width\n\n    if width:\n        try:\n            width = int(width)\n        except Exception as e:\n            import structlog\n\n            log = structlog.getLogger()\n            log.debug(\"invalid.console_width\", error=str(e))\n\n    from rich.console import Console\n\n    _console = Console(width=width)\n\n    if not width:\n        if \"google.colab\" in sys.modules or \"jupyter_client\" in sys.modules:\n            width = 140\n\n    if width:\n        import rich\n\n        con = rich.get_console()\n        con.width = width\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/__init__/","title":"cli","text":"<p>A command-line interface for Kiara.</p>"},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli.logger","title":"<code>logger = structlog.get_logger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli.CLICK_CONTEXT_SETTINGS","title":"<code>CLICK_CONTEXT_SETTINGS = {'help_option_names': ['-h', '--help']}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/__init__/#kiara.interfaces.cli.cli","title":"<code>cli(ctx, config: Union[str, None], context: Union[str, None], pipelines: Tuple[str], plugin: Union[str, None])</code>","text":"<p>[i b]kiara[/b i] ia a data-orchestration framework; this is the command-line frontend for it.</p> <p>For more information, visit the ikiara[/b] homepage[/i]: https://dharpa.org/kiara.documentation .</p> Source code in <code>kiara/interfaces/cli/__init__.py</code> <pre><code>@click.group(context_settings=CLICK_CONTEXT_SETTINGS)\n@click.option(\n    \"--config\",\n    \"-cnf\",\n    help=\"A kiara config file (or folder containing one named 'kiara.config').\",\n    required=False,\n)\n@click.option(\n    \"--context\",\n    \"-ctx\",\n    \"-c\",\n    help=\"The name of the kiara context to use (or the path to a context file).\",\n    required=False,\n)\n@click.option(\n    \"--pipelines\",\n    \"-p\",\n    help=\"File(s) and folder(s) that contain extra pipeline definitions.\",\n    multiple=True,\n    required=False,\n)\n@click.option(\n    \"--plugin\",\n    \"-P\",\n    help=\"Ensure the provided plugin package(s) are installed in the virtual environment.\",\n)\n@click.pass_context\ndef cli(\n    ctx,\n    config: Union[str, None],\n    context: Union[str, None],\n    pipelines: Tuple[str],\n    plugin: Union[str, None],\n):\n\"\"\"[i b]kiara[/b i] ia a data-orchestration framework; this is the command-line frontend for it.\n\n\n\n    For more information, visit the [i][b]kiara[/b] homepage[/i]: https://dharpa.org/kiara.documentation .\n    \"\"\"\n\n    # check if windows symlink work\n    from kiara.utils.windows import check_symlink_works\n\n    if not check_symlink_works():\n\n        terminal_print()\n        from rich.markdown import Markdown\n\n        terminal_print(Markdown(SYMLINK_ISSUE_MSG))\n        sys.exit(1)\n\n    ctx.obj = {}\n\n    lazy_wrapper = KiaraAPIWrap(config, context, pipelines, plugin)\n    ctx.obj = lazy_wrapper\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/run/","title":"run","text":"<p>The 'run' subcommand for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/run/#kiara.interfaces.cli.run-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/run/#kiara.interfaces.cli.run-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/run/#kiara.interfaces.cli.run.run","title":"<code>run(ctx, module_or_operation: str, module_config: Iterable[str], inputs: Iterable[str], output: Iterable[str], explain: bool, save: Iterable[str], help: bool)</code>","text":"<p>Run a kiara operation.</p> Source code in <code>kiara/interfaces/cli/run.py</code> <pre><code>@click.command()\n@click.argument(\"module_or_operation\", nargs=1, metavar=\"MODULE_OR_OPERATION\")\n@click.argument(\"inputs\", nargs=-1, required=False)\n@click.option(\n    \"--module-config\",\n    \"-c\",\n    required=False,\n    help=\"(Optional) module configuration, only valid when run target is a module name.\",\n    multiple=True,\n)\n@click.option(\n    \"--explain\",\n    \"-e\",\n    help=\"Display information about the selected operation and exit.\",\n    is_flag=True,\n)\n@click.option(\n    \"--output\", \"-o\", help=\"The output format and configuration.\", multiple=True\n)\n@click.option(\n    \"--save\",\n    \"-s\",\n    help=\"Save one or several of the outputs of this run. If the argument contains a '=', the format is [output_name]=[alias], if not, the values will be saved as '[alias]-[output_name]'.\",\n    required=False,\n    multiple=True,\n)\n@click.option(\"--help\", \"-h\", help=\"Show this message and exit.\", is_flag=True)\n@click.pass_context\n@handle_exception()\ndef run(\n    ctx,\n    module_or_operation: str,\n    module_config: Iterable[str],\n    inputs: Iterable[str],\n    output: Iterable[str],\n    explain: bool,\n    save: Iterable[str],\n    help: bool,\n):\n\"\"\"Run a kiara operation.\"\"\"\n\n    from kiara.utils.cli.run import (\n        _validate_save_option,\n        calculate_aliases,\n        execute_job,\n        set_and_validate_inputs,\n        validate_operation_in_terminal,\n    )\n    from kiara.utils.output import OutputDetails\n\n    # =========================================================================\n    # initialize a few variables\n\n    if module_config:\n        module_config = dict_from_cli_args(*module_config)\n    else:\n        module_config = {}\n\n    save_results = _validate_save_option(save)\n\n    output_details = OutputDetails.from_data(output)\n    silent = False\n    if output_details.format == \"silent\":\n        silent = True\n\n    force_overwrite = output_details.config.get(\"force\", False)\n\n    if output_details.target != \"terminal\":\n        if output_details.target == \"file\":\n            target_dir = Path.cwd()\n            target_file = target_dir / f\"{module_or_operation}.{output_details.format}\"\n        else:\n            target_file = Path(\n                os.path.realpath(os.path.expanduser(output_details.target))\n            )\n\n        if target_file.exists() and not force_overwrite:\n            terminal_print()\n            terminal_print(\n                f\"Can't run workflow, the target files already exist, and '--output force=true' not specified: {target_file}\"\n            )\n            sys.exit(1)\n\n    api: KiaraAPI = ctx.obj.kiara_api  # type: ignore\n\n    cmd_arg = ctx.params[\"module_or_operation\"]\n    cmd_help = f\"[yellow bold]Usage: [/yellow bold][bold]kiara run [OPTIONS] [i]{cmd_arg}[/i] [INPUTS][/bold]\"\n\n    if module_config:\n        op: Union[str, Mapping[str, Any]] = {\n            \"module_type\": module_or_operation,\n            \"module_config\": module_config,\n        }\n    else:\n        op = module_or_operation\n\n    kiara_op = validate_operation_in_terminal(api=api, module_or_operation=op)\n    final_aliases = calculate_aliases(operation=kiara_op, alias_tokens=save)\n\n    inputs_value_map = set_and_validate_inputs(\n        api=api,\n        operation=kiara_op,\n        inputs=inputs,\n        explain=explain,\n        print_help=help,\n        click_context=ctx,\n        cmd_help=cmd_help,\n    )\n    execute_job(\n        api=api,\n        operation=kiara_op,\n        inputs=inputs_value_map,\n        silent=silent,\n        save_results=save_results,\n        aliases=final_aliases,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/config/__init__/","title":"config","text":""},{"location":"reference/kiara/interfaces/cli/config/commands/","title":"commands","text":""},{"location":"reference/kiara/interfaces/cli/config/commands/#kiara.interfaces.cli.config.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/config/commands/#kiara.interfaces.cli.config.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/config/commands/#kiara.interfaces.cli.config.commands.config","title":"<code>config(ctx)</code>","text":"<p>Kiara config related sub-commands.</p> Source code in <code>kiara/interfaces/cli/config/commands.py</code> <pre><code>@click.group(\"config\")\n@click.pass_context\ndef config(ctx):\n\"\"\"Kiara config related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/config/commands/#kiara.interfaces.cli.config.commands.print_config","title":"<code>print_config(ctx, format: str)</code>","text":"Source code in <code>kiara/interfaces/cli/config/commands.py</code> <pre><code>@config.command(\"print\")\n@output_format_option()\n@click.pass_context\ndef print_config(ctx, format: str):\n\n    from kiara.context import KiaraConfig\n\n    wrap: \"KiaraAPIWrap\" = ctx.obj\n    config: KiaraConfig = wrap.kiara_config\n    title = \"kiara config\"\n    if config._config_path:\n        title = f\"{title} - [i]{config._config_path}[/i]\"\n\n    terminal_print_model(config, format=format, in_panel=title)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/__init__/","title":"context","text":""},{"location":"reference/kiara/interfaces/cli/context/commands/","title":"commands","text":""},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.context","title":"<code>context(ctx)</code>","text":"<p>Kiara context related sub-commands.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@click.group(\"context\")\n@click.pass_context\ndef context(ctx):\n\"\"\"Kiara context related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.list_contexts","title":"<code>list_contexts(ctx) -&gt; None</code>","text":"<p>List existing contexts.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.command(\"list\")\n@click.pass_context\ndef list_contexts(ctx) -&gt; None:\n\"\"\"List existing contexts.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    summaries = kiara_api.retrieve_context_infos()\n\n    terminal_print(summaries)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.explain_context","title":"<code>explain_context(ctx, format: str, value_ids: bool, context_name: Union[Tuple[str], None] = None)</code>","text":"<p>Print details for one or several contexts.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.command(\"explain\")\n@click.argument(\"context_name\", nargs=-1, required=False)\n@click.option(\"--value-ids\", \"-i\", help=\"Show value ids.\", is_flag=True, default=False)\n@output_format_option()\n@click.pass_context\ndef explain_context(\n    ctx, format: str, value_ids: bool, context_name: Union[Tuple[str], None] = None\n):\n\"\"\"Print details for one or several contexts.\"\"\"\n\n    kiara_config: KiaraConfig = ctx.obj.kiara_config\n\n    if not context_name:\n        cn = ctx.obj.kiara_context_name\n        contexts = [cn]\n    else:\n        contexts = list(context_name)\n\n    from kiara.models.context import ContextInfo\n\n    if len(contexts) == 1:\n\n        kcc = kiara_config.get_context_config(contexts[0])\n\n        cs = ContextInfo.create_from_context_config(\n            kcc, context_name=contexts[0], runtime_config=kiara_config.runtime_config\n        )\n        terminal_print_model(\n            cs, format=format, full_details=True, show_value_ids=value_ids\n        )\n\n    else:\n        summaries = []\n        for c in contexts:\n            cc = kiara_config.get_context_config(c)\n            cs = ContextInfo.create_from_context_config(\n                cc, context_name=c, runtime_config=kiara_config.runtime_config\n            )\n            summaries.append(cs)\n        terminal_print_model(\n            *summaries, format=format, full_details=True, show_value_ids=value_ids\n        )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.delete_context","title":"<code>delete_context(ctx, context_name: Union[str, None] = None, force: bool = False, all_contexts: bool = False)</code>","text":"<p>Delete a context and all its stored values.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.command(\"delete\")\n@click.argument(\"context_name\", nargs=1, required=False)\n@click.option(\n    \"--force\", \"-f\", help=\"Delete without prompt.\", is_flag=True, default=False\n)\n@click.option(\n    \"--all-contexts\", \"-a\", help=\"Delete all contexts.\", is_flag=True, default=False\n)\n@click.pass_context\ndef delete_context(\n    ctx,\n    context_name: Union[str, None] = None,\n    force: bool = False,\n    all_contexts: bool = False,\n):\n\"\"\"Delete a context and all its stored values.\"\"\"\n\n    kiara_config: KiaraConfig = ctx.kiara_config\n\n    if not context_name:\n        if all_contexts:\n            _context_name = \"ALL_CONTEXTS\"\n        else:\n            _context_name = ctx.obj.kiara_context_name\n    else:\n        if all_contexts:\n            if context_name != \"ALL_CONTEXTS\":\n                terminal_print()\n                terminal_print(\n                    f\"Context name '{context_name}' specified, as well as '--all-contexts', this is not valid.\"\n                )\n                sys.exit(1)\n        _context_name = context_name\n\n    confirmed = False\n\n    if _context_name == \"ALL_CONTEXTS\":\n        if not force:\n            from kiara.models.context import ContextInfos\n\n            summaries = ContextInfos.create_context_infos(\n                contexts=kiara_config.context_configs\n            )\n            terminal_print_model(summaries, in_panel=\"All contexts:\")\n            user_input = get_console().input(\n                f\"Deleting all contexts, are you sure? \\[yes/no]: \"  # noqa\n            )\n\n            if user_input.lower() == \"yes\":\n                confirmed = True\n        else:\n            confirmed = True\n\n        if not confirmed:\n            terminal_print(\"\\nDoing nothing...\")\n            sys.exit(0)\n\n        terminal_print(\"Deleting contexts...\")\n        for _context_name in kiara_config.context_configs.keys():\n            terminal_print(f\"  - {_context_name}\")\n            kiara_config.delete(context_name=_context_name, dry_run=False)\n\n        terminal_print(\"Done.\")\n\n    else:\n\n        if not force:\n\n            context_summary = kiara_config.delete(\n                context_name=_context_name, dry_run=True\n            )\n            terminal_print_model(\n                context_summary,\n                full_details=True,\n                in_panel=f\"Context details: {_context_name}\",\n            )\n            terminal_print()\n            user_input = get_console().input(\n                f\"Deleting context '[b i]{_context_name}[/b i]', are you sure? \\[yes/no]: \"\n            )\n\n            if user_input.lower() == \"yes\":\n                confirmed = True\n        else:\n            confirmed = True\n\n        if not confirmed:\n            terminal_print(\"\\nDoing nothing...\")\n            sys.exit(0)\n\n        terminal_print(\"Deleting context...\")\n        kiara_config.delete(context_name=_context_name, dry_run=False)\n\n        terminal_print(\"Done.\")\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.config","title":"<code>config(ctx)</code>","text":"<p>Config-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.group(\"config\")\n@click.pass_context\ndef config(ctx):\n\"\"\"Config-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.print_config","title":"<code>print_config(ctx, format) -&gt; None</code>","text":"<p>Print the (current) kiara context configuration.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@config.command(\"print\")\n@output_format_option()\n@click.pass_context\ndef print_config(ctx, format) -&gt; None:\n\"\"\"Print the (current) kiara context configuration.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    terminal_print_model(\n        kiara_obj.context_config,\n        format=format,\n        in_panel=f\"kiara context config: [b i]{kiara_obj.context_config.context_id}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.config_help","title":"<code>config_help(ctx)</code>","text":"<p>Print available configuration options and information about them.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@config.command(\"help\")\n@click.pass_context\ndef config_help(ctx):\n\"\"\"Print available configuration options and information about them.\"\"\"\n\n    from kiara.context import KiaraContextConfig\n    from kiara.utils.output import create_table_from_base_model_cls\n\n    table = create_table_from_base_model_cls(model_cls=KiaraContextConfig)\n    terminal_print()\n    terminal_print(Panel(table))\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.runtime","title":"<code>runtime(ctx)</code>","text":"<p>Information about runtime models, etc.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.group(name=\"runtime-info\")\n@click.pass_context\ndef runtime(ctx):\n\"\"\"Information about runtime models, etc.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.print_context","title":"<code>print_context(ctx, format: str)</code>","text":"<p>Print all relevant models within the current runtime environment.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@runtime.command(\"print\")\n@output_format_option()\n@click.pass_context\ndef print_context(ctx, format: str):\n\"\"\"Print all relevant models within the current runtime environment.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    terminal_print_model(\n        kiara_obj.context_info,\n        format=format,\n        in_panel=f\"Context info for kiara id: {kiara_obj.id}\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.env_group","title":"<code>env_group(ctx)</code>","text":"<p>Environment-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.group(name=\"environment\")\n@click.pass_context\ndef env_group(ctx):\n\"\"\"Environment-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.list_envs","title":"<code>list_envs(ctx)</code>","text":"<p>List available runtime environment information.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@env_group.command(\"list\")\n@click.pass_context\ndef list_envs(ctx):\n\"\"\"List available runtime environment information.\"\"\"\n\n    from kiara.registries.environment import EnvironmentRegistry\n\n    env_reg = EnvironmentRegistry.instance()\n\n    terminal_print(env_reg)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.explain_env","title":"<code>explain_env(ctx, env_type: str, format: str) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@env_group.command(\"explain\")\n@click.argument(\"env_type\", metavar=\"ENVIRONMENT_TYPE\", nargs=1, required=True)\n@output_format_option()\n@click.pass_context\ndef explain_env(ctx, env_type: str, format: str) -&gt; None:\n\n    from kiara.registries.environment import EnvironmentRegistry\n\n    env_reg = EnvironmentRegistry.instance()\n\n    env = env_reg.environments.get(env_type, None)\n    if env is None:\n        terminal_print()\n        terminal_print(\n            f\"No environment with name '{env_type}' available. Available types: {', '.join(env_reg.environments.keys())}\"\n        )\n        sys.exit()\n\n    terminal_print_model(\n        env,\n        format=format,\n        in_panel=f\"Details for environment: [b i]{env_type}[/b i]\",\n        summary=False,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.metadata","title":"<code>metadata(ctx)</code>","text":"<p>Metadata-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@context.group()\n@click.pass_context\ndef metadata(ctx):\n\"\"\"Metadata-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.list_metadata","title":"<code>list_metadata(ctx, format) -&gt; None</code>","text":"<p>List available metadata schemas.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@metadata.command(name=\"list\")\n@output_format_option()\n@click.pass_context\ndef list_metadata(ctx, format) -&gt; None:\n\"\"\"List available metadata schemas.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n    from kiara.models.values.value_metadata import ValueMetadata\n\n    metadata_types = kiara_obj.kiara_model_registry.get_models_of_type(ValueMetadata)\n\n    terminal_print_model(\n        metadata_types, format=format, in_panel=\"Available metadata types\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/context/commands/#kiara.interfaces.cli.context.commands.explain_metadata","title":"<code>explain_metadata(ctx, metadata_key, format) -&gt; None</code>","text":"<p>Print details for a specific metadata schema.</p> Source code in <code>kiara/interfaces/cli/context/commands.py</code> <pre><code>@metadata.command(name=\"explain\")\n@click.argument(\"metadata_key\", nargs=1, required=True)\n# @click.option(\n#     \"--details\",\n#     \"-d\",\n#     help=\"Print more metadata schema details (for 'terminal' format).\",\n#     is_flag=True,\n# )\n@output_format_option()\n@click.pass_context\ndef explain_metadata(ctx, metadata_key, format) -&gt; None:\n\"\"\"Print details for a specific metadata schema.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n    from kiara.models.values.value_metadata import ValueMetadata\n\n    metadata_types = kiara_obj.kiara_model_registry.get_models_of_type(ValueMetadata)\n\n    if metadata_key not in metadata_types.item_infos.keys():\n        terminal_print()\n        terminal_print(f\"No metadata schema for key '{metadata_key}' found...\")\n        sys.exit(1)\n\n    info_obj = metadata_types.item_infos[metadata_key]\n\n    terminal_print_model(\n        info_obj,\n        format=format,\n        in_panel=f\"Details for metadata type: [b i]{metadata_key}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/data/__init__/","title":"data","text":""},{"location":"reference/kiara/interfaces/cli/data/commands/","title":"commands","text":"<p>Data-related sub-commands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.data","title":"<code>data(ctx)</code>","text":"<p>Data-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/data/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef data(ctx):\n\"\"\"Data-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.list_values","title":"<code>list_values(ctx, format, all_values, hash, include_internal, value_id, pedigree, data, type_config, serialized, properties, data_type, lineage) -&gt; None</code>","text":"<p>List all data items that are stored in kiara.</p> Source code in <code>kiara/interfaces/cli/data/commands.py</code> <pre><code>@data.command(name=\"list\")\n@click.option(\n    \"--all-values\",\n    \"-a\",\n    help=\"Also list values without aliases.\",\n    is_flag=True,\n    default=False,\n)\n@click.option(\n    \"--include-internal\",\n    \"-I\",\n    help=\"Also list values that are used mostly internally (e.g. metadata for other values, ...). Implies 'all-ids' is 'True'.\",\n    is_flag=True,\n)\n@click.option(\n    \"--value_id\",\n    \"-i\",\n    help=\"Display value id information for each value.\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"--type-config\",\n    \"-c\",\n    help=\"Display type details for each value.\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"--hash\", \"-H\", help=\"Display the value hash.\", default=False, is_flag=True\n)\n@click.option(\n    \"--lineage\",\n    \"-l\",\n    help=\"Display lineage information for each value.\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"--pedigree\",\n    \"-P\",\n    help=\"Display pedigree information for each value.\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"--data\",\n    \"-d\",\n    help=\"Show a preview of the data associated with this value.\",\n    default=False,\n    is_flag=True,\n)\n@click.option(\n    \"--serialized\",\n    \"-s\",\n    help=\"Display serialization details for this value.\",\n    is_flag=True,\n)\n@click.option(\"--properties\", \"-p\", help=\"Display the value properties.\", is_flag=True)\n@click.option(\n    \"--data-type\",\n    \"-t\",\n    help=\"Only display values that match the specified type(s)\",\n    multiple=True,\n    required=False,\n)\n@output_format_option()\n@click.pass_context\ndef list_values(\n    ctx,\n    format,\n    all_values,\n    hash,\n    include_internal,\n    value_id,\n    pedigree,\n    data,\n    type_config,\n    serialized,\n    properties,\n    data_type,\n    lineage,\n) -&gt; None:\n\"\"\"List all data items that are stored in kiara.\"\"\"\n\n    from kiara.interfaces.python_api import ValuesInfo\n    from kiara.interfaces.python_api.models.info import RENDER_FIELDS\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    if include_internal:\n        all_values = True\n\n    matcher_config = {\"allow_internal\": include_internal, \"has_alias\": not all_values}\n    if data_type:\n        matcher_config[\"data_types\"] = data_type\n\n    values = kiara_api.list_values(\n        allow_internal=include_internal, data_types=data_type, has_alias=not all_values\n    )\n\n    list_by_alias = True\n\n    render_fields = [k for k, v in RENDER_FIELDS.items() if v[\"show_default\"]]\n    if list_by_alias:\n        render_fields[0] = \"aliases\"\n        render_fields[1] = \"value_id\"\n\n    if not value_id and not all_values:\n        render_fields.remove(\"value_id\")\n    if type_config:\n        render_fields.append(\"data_type_config\")\n    if hash:\n        render_fields.append(\"hash\")\n    if data:\n        render_fields.append(\"data\")\n    if properties:\n        render_fields.append(\"properties\")\n    if pedigree:\n        render_fields.append(\"pedigree\")\n    if lineage:\n        render_fields.append(\"lineage\")\n    if serialized:\n        render_fields.append(\"serialize_details\")\n\n    values_info_model = ValuesInfo.create_from_instances(\n        kiara=kiara_api.context, instances={str(k): v for k, v in values.items()}\n    )\n\n    render_config = {\n        \"render_type\": \"terminal\",\n        \"list_by_alias\": list_by_alias,\n        \"show_internal_values\": include_internal,\n        \"render_fields\": render_fields,\n    }\n\n    if not all_values:\n        title = \"Available aliases\"\n    else:\n        title = \"Available values\"\n\n    terminal_print_model(\n        values_info_model, format=format, in_panel=title, **render_config\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.explain_value","title":"<code>explain_value(ctx, value_id: Tuple[str], pedigree: bool, serialized: bool, format: str, preview_data: bool, properties: bool, destinies: bool, destiny_backlinks: bool, lineage: bool, environment: bool)</code>","text":"<p>Print the metadata of a stored value.</p> <p>All of the 'show-additional-information' flags are only applied when the 'terminal' output format is selected. This might change in the future.</p> Source code in <code>kiara/interfaces/cli/data/commands.py</code> <pre><code>@data.command(name=\"explain\")\n@click.argument(\"value_id\", nargs=-1, required=True)\n@click.option(\n    \"--pedigree\", \"-P\", help=\"Display pedigree information for the value.\", is_flag=True\n)\n@click.option(\n    \"--lineage\", \"-l\", help=\"Display lineage information for the value.\", is_flag=True\n)\n@click.option(\n    \"--serialized\",\n    \"-s\",\n    help=\"Display this values' serialization information.\",\n    is_flag=True,\n)\n@click.option(\"--preview-data\", \"-d\", help=\"Display a data preview.\", is_flag=True)\n@click.option(\n    \"--properties\",\n    \"-p\",\n    help=\"Resolve and display properties of this value.\",\n    is_flag=True,\n)\n@click.option(\n    \"--destinies\",\n    \"-D\",\n    help=\"Resolve and display values destinies for this value.\",\n    is_flag=True,\n)\n@click.option(\n    \"--destiny-backlinks\",\n    \"-B\",\n    help=\"Resolve and display values this value is a destiny for.\",\n    is_flag=True,\n)\n@click.option(\n    \"--environment\", \"-e\", help=\"Show environment hashes and data.\", is_flag=True\n)\n@output_format_option()\n@click.pass_context\ndef explain_value(\n    ctx,\n    value_id: Tuple[str],\n    pedigree: bool,\n    serialized: bool,\n    format: str,\n    preview_data: bool,\n    properties: bool,\n    destinies: bool,\n    destiny_backlinks: bool,\n    lineage: bool,\n    environment: bool,\n):\n\"\"\"Print the metadata of a stored value.\n\n    All of the 'show-additional-information' flags are only applied when the 'terminal' output format is selected. This might change in the future.\n    \"\"\"\n\n    from kiara.interfaces.python_api import ValueInfo\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    render_config = {\n        \"show_pedigree\": pedigree,\n        \"show_serialized\": serialized,\n        \"show_data_preview\": preview_data,\n        \"show_properties\": properties,\n        \"show_destinies\": destinies,\n        \"show_destiny_backlinks\": destiny_backlinks,\n        \"show_lineage\": lineage,\n        \"show_environment_hashes\": environment,\n        \"show_environment_data\": False,\n    }\n\n    all_values = []\n    for v_id in value_id:\n        try:\n            value = kiara_obj.data_registry.get_value(v_id)\n        except Exception as e:\n            terminal_print()\n            terminal_print(f\"[red]Error[/red]: {e}\")\n            sys.exit(1)\n        if not value:\n            terminal_print(f\"[red]Error[/red]: No value found for: {v_id}\")\n            sys.exit(1)\n        all_values.append(value)\n\n    if len(all_values) == 1:\n        title = f\"Value details for: [b i]{value_id[0]}[/b i]\"\n    else:\n        title = \"Value details\"\n\n    v_infos = (\n        ValueInfo.create_from_instance(kiara=kiara_obj, instance=v) for v in all_values\n    )\n\n    terminal_print_model(*v_infos, format=format, in_panel=title, **render_config)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.load_value","title":"<code>load_value(ctx, value: str, single_page: bool)</code>","text":"<p>Load a stored value and print it in a format suitable for the terminal.</p> Source code in <code>kiara/interfaces/cli/data/commands.py</code> <pre><code>@data.command(name=\"load\")\n@click.argument(\"value\", nargs=1, required=True)\n@click.option(\n    \"--single-page\",\n    \"-s\",\n    help=\"Only pretty print a single (preview) page, instead of using a pager when available.\",\n    is_flag=True,\n)\n@click.pass_context\ndef load_value(ctx, value: str, single_page: bool):\n\"\"\"Load a stored value and print it in a format suitable for the terminal.\"\"\"\n\n    # kiara_obj: Kiara = ctx.obj[\"kiara\"]\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    try:\n        _value = kiara_api.get_value(value=value)\n    except Exception as e:\n        terminal_print()\n        terminal_print(f\"[red]Error[/red]: {e}\")\n        sys.exit(1)\n    if not _value:\n        terminal_print(f\"[red]Error[/red]: No value found for: {value}\")\n        sys.exit(1)\n\n    if single_page:\n        logger.debug(\n            \"fallback.render_value\",\n            solution=\"use pretty print\",\n            source_type=_value.data_type_name,\n            target_type=\"terminal_renderable\",\n            reason=\"no 'render_value' operation for source/target operation\",\n        )\n        try:\n            renderable = kiara_api.context.data_registry.pretty_print_data(\n                _value.value_id, target_type=\"terminal_renderable\"\n            )\n        except Exception as e:\n            log_exception(e)\n            log_message(\"error.pretty_print\", value=_value.value_id, error=e)\n            renderable = [str(_value.data)]\n\n        terminal_print(renderable)\n        sys.exit(0)\n    else:\n        from kiara.interfaces.tui.pager import PagerApp\n\n        app = PagerApp(api=kiara_api, value=str(_value.value_id))\n        app.run()\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/data/commands/#kiara.interfaces.cli.data.commands.filter_value","title":"<code>filter_value(ctx, value: str, filters: str, inputs: Iterable[str], explain: bool, output: Iterable[str], save: Iterable[str], help: bool)</code>","text":"<p>Filter a value, then display it like the 'load' subcommand does.</p> <p>Filters must be provided as a single string, where filters are seperated using \":\".</p> Source code in <code>kiara/interfaces/cli/data/commands.py</code> <pre><code>@data.command(\"filter\")\n@click.argument(\"value\", nargs=1, required=True, default=\"__no_value__\")\n@click.argument(\"filters\", nargs=1, default=\"__no_filters__\")\n@click.argument(\"inputs\", nargs=-1, required=False)\n@click.option(\n    \"--explain\",\n    \"-e\",\n    help=\"Display information about the selected operation and exit.\",\n    is_flag=True,\n)\n@click.option(\n    \"--output\", \"-o\", help=\"The output format and configuration.\", multiple=True\n)\n@click.option(\n    \"--save\",\n    \"-s\",\n    help=\"Save one or several of the outputs of this run. If the argument contains a '=', the format is [output_name]=[alias], if not, the values will be saved as '[alias]-[output_name]'.\",\n    required=False,\n    multiple=True,\n)\n@click.option(\"--help\", \"-h\", help=\"Show this message and exit.\", is_flag=True)\n@click.pass_context\ndef filter_value(\n    ctx,\n    value: str,\n    filters: str,\n    inputs: Iterable[str],\n    explain: bool,\n    output: Iterable[str],\n    save: Iterable[str],\n    help: bool,\n):\n\"\"\"Filter a value, then display it like the 'load' subcommand does.\n\n    Filters must be provided as a single string, where filters are seperated using \":\".\n    \"\"\"\n\n    from kiara.utils.cli.rich_click import rich_format_filter_operation_help\n    from kiara.utils.cli.run import (\n        _validate_save_option,\n        calculate_aliases,\n        execute_job,\n        set_and_validate_inputs,\n        validate_operation_in_terminal,\n    )\n    from kiara.utils.output import OutputDetails\n\n    save_results = _validate_save_option(save)\n\n    output_details = OutputDetails.from_data(output)\n    silent = False\n    if output_details.format == \"silent\":\n        silent = True\n\n    kiara_obj: Kiara = ctx.obj.kiara\n    api: KiaraAPI = ctx.obj.kiara_api\n\n    cmd_help = \"[yellow bold]Usage: [/yellow bold][bold]kiara data filter VALUE FILTER_1:FILTER_2 [FILTER ARGS...][/bold]\"\n\n    if help and value == \"__no_value__\":\n        rich_format_filter_operation_help(\n            api=api,\n            obj=ctx.command,\n            ctx=ctx,\n            cmd_help=cmd_help,\n        )\n        sys.exit(0)\n\n    if filters == \"__no_filters__\":\n        rich_format_filter_operation_help(\n            api=api, obj=ctx.command, ctx=ctx, cmd_help=cmd_help, value=value\n        )\n        sys.exit(0)\n\n    try:\n        _value = kiara_obj.data_registry.get_value(value=value)\n    except Exception as e:\n        terminal_print()\n        terminal_print(f\"[red]Error[/red]: {e}\")\n        sys.exit(1)\n    if not _value:\n        terminal_print(f\"[red]Error[/red]: No value found for: {value}\")\n        sys.exit(1)\n\n    _filter_names = filters.split(\":\")\n    filter_names = []\n    for fn in _filter_names:\n        filter_names.extend(fn.split(\":\"))\n\n    filter_op_type: FilterOperationType = (\n        kiara_obj.operation_registry.get_operation_type(\"filter\")\n    )\n    op = filter_op_type.create_filter_operation(\n        data_type=_value.data_type_name, filters=filter_names\n    )\n\n    all_inputs = [f\"value={value}\"]\n    all_inputs.extend(inputs)\n\n    kiara_op = validate_operation_in_terminal(\n        api=api, module_or_operation=op.module_config\n    )\n    final_aliases = calculate_aliases(operation=kiara_op, alias_tokens=save)\n    inputs_value_map = set_and_validate_inputs(\n        api=api,\n        operation=kiara_op,\n        inputs=all_inputs,\n        explain=explain,\n        print_help=help,\n        click_context=ctx,\n        cmd_help=cmd_help,\n    )\n\n    job_id = execute_job(\n        api=api,\n        operation=kiara_op,\n        inputs=inputs_value_map,\n        silent=True,\n        save_results=False,\n        aliases=final_aliases,\n    )\n\n    if not silent:\n        result = api.get_job_result(job_id=job_id)\n        # result = kiara_op.retrieve_result(job_id=job_id)\n\n        title = f\"[b]Value '[i]{value}[/i]'[/b], filtered with: {filters}\"\n        filtered = result[\"filtered_value\"]\n        try:\n            renderable = api.context.data_registry.pretty_print_data(\n                filtered.value_id, target_type=\"terminal_renderable\"\n            )\n        except Exception as e:\n            log_exception(e)\n            log_message(\"error.pretty_print\", value=_value.value_id, error=e)\n            renderable = [str(_value.data)]\n        terminal_print(\n            renderable, in_panel=title, empty_line_before=True, show_data_type=True\n        )\n\n    if save_results:\n        try:\n            result = api.get_job_result(job_id=job_id)\n            saved_results = api.store_values(result, alias_map=final_aliases)\n\n            api.context.job_registry.store_job_record(job_id=job_id)\n\n            if len(saved_results) == 1:\n                title = \"[b]Stored result value[/b]\"\n            else:\n                title = \"[b]Stored result values[/b]\"\n            terminal_print(saved_results, in_panel=title, empty_line_before=True)\n        except Exception as e:\n            log_exception(e)\n            terminal_print(f\"[red]Error saving results[/red]: {e}\")\n            sys.exit(1)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/module/__init__/","title":"module","text":""},{"location":"reference/kiara/interfaces/cli/module/commands/","title":"commands","text":"<p>Module related subcommands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands.module","title":"<code>module(ctx)</code>","text":"<p>Module-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/module/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef module(ctx):\n\"\"\"Module-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands.list_modules","title":"<code>list_modules(ctx, full_doc: bool, filter: Iterable[str], format: str)</code>","text":"<p>List available module data_types.</p> Source code in <code>kiara/interfaces/cli/module/commands.py</code> <pre><code>@module.command(name=\"list\")\n@click.option(\n    \"--full-doc\",\n    \"-d\",\n    is_flag=True,\n    help=\"Display the full documentation for every module type (when using 'terminal' output format).\",\n)\n@output_format_option()\n@click.argument(\"filter\", nargs=-1, required=False)\n@click.pass_context\ndef list_modules(ctx, full_doc: bool, filter: Iterable[str], format: str):\n\"\"\"List available module data_types.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n    module_types_info = kiara_api.retrieve_module_types_info(filter=filter)\n\n    if filter:\n        title = f\"Filtered modules: {filter}\"\n    else:\n        title = \"All modules\"\n\n    terminal_print_model(\n        module_types_info, format=format, in_panel=title, full_doc=full_doc\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands.explain_module_type","title":"<code>explain_module_type(ctx, module_type: str, format: str)</code>","text":"<p>Print details of a module type.</p> <p>This is different to the 'explain-instance' command, because module data_types need to be instantiated with configuration, before we can query all their properties (like input/output data_types).</p> Source code in <code>kiara/interfaces/cli/module/commands.py</code> <pre><code>@module.command(name=\"explain\")\n@click.argument(\"module_type\", nargs=1, required=True)\n@output_format_option()\n@click.pass_context\ndef explain_module_type(ctx, module_type: str, format: str):\n\"\"\"Print details of a module type.\n\n    This is different to the 'explain-instance' command, because module data_types need to be\n    instantiated with configuration, before we can query all their properties (like\n    input/output data_types).\n    \"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n    info = kiara_api.retrieve_module_type_info(module_type=module_type)\n\n    terminal_print_model(\n        info, format=format, in_panel=f\"Module type: [b i]{module_type}[/b i]\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/module/commands/#kiara.interfaces.cli.module.commands.explain_module","title":"<code>explain_module(ctx, module_type: str, module_config: Iterable[Any], format: str)</code>","text":"<p>Describe a module instance.</p> <p>This command shows information and metadata about an instantiated kiara module.</p> Source code in <code>kiara/interfaces/cli/module/commands.py</code> <pre><code>@module.command(\"explain-instance\")\n@click.argument(\"module_type\", nargs=1)\n@click.argument(\n    \"module_config\",\n    nargs=-1,\n)\n@output_format_option()\n@click.pass_context\ndef explain_module(ctx, module_type: str, module_config: Iterable[Any], format: str):\n\"\"\"Describe a module instance.\n\n    This command shows information and metadata about an instantiated *kiara* module.\n    \"\"\"\n\n    if module_config:\n        module_config = dict_from_cli_args(*module_config)\n    else:\n        module_config = {}\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    operation = kiara_api.create_operation(\n        module_type=module_type, module_config=module_config\n    )\n\n    terminal_print_model(\n        operation.create_renderable(),  # type: ignore\n        format=format,\n        in_panel=f\"Module instance of type: [b i]{module_type}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/operation/__init__/","title":"operation","text":""},{"location":"reference/kiara/interfaces/cli/operation/commands/","title":"commands","text":""},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands.operation","title":"<code>operation(ctx)</code>","text":"<p>Operation-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/operation/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef operation(ctx):\n\"\"\"Operation-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands.list_types","title":"<code>list_types(ctx, full_doc: bool, format: str, filter: Iterable[str])</code>","text":"Source code in <code>kiara/interfaces/cli/operation/commands.py</code> <pre><code>@operation.command(\"list-types\")\n@click.option(\n    \"--full-doc\",\n    \"-d\",\n    is_flag=True,\n    help=\"Display the full documentation for every operation type (when using 'terminal' output format).\",\n)\n@click.argument(\"filter\", nargs=-1, required=False)\n@output_format_option()\n@click.pass_context\ndef list_types(ctx, full_doc: bool, format: str, filter: Iterable[str]):\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    op_mgmt = kiara_obj.operation_registry\n\n    op_types = op_mgmt.operation_type_classes\n\n    title = \"Available operation types\"\n    if filter:\n        title = \"Filtered data types\"\n        temp = {}\n        for k, v in op_types.items():\n            match = True\n            for f in filter:\n                if f.lower() not in k.lower():\n                    match = False\n                    break\n            if match:\n                temp[k] = v\n        op_types = temp\n\n    from kiara.interfaces.python_api.models.info import OperationTypeClassesInfo\n\n    operation_types_info = OperationTypeClassesInfo.create_from_type_items(\n        kiara=kiara_obj, group_title=\"all_items\", **op_types\n    )\n\n    terminal_print_model(operation_types_info, format=format, in_panel=title)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands.explain_type","title":"<code>explain_type(ctx, operation_type: str, format: str)</code>","text":"Source code in <code>kiara/interfaces/cli/operation/commands.py</code> <pre><code>@operation.command()\n@click.argument(\"operation_type\", nargs=1, required=True)\n@output_format_option()\n@click.pass_context\n@handle_exception()\ndef explain_type(ctx, operation_type: str, format: str):\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    op_type = kiara_api.retrieve_operation_type_info(operation_type)\n\n    terminal_print_model(\n        op_type, format=format, in_panel=f\"Operation type: [b i]{operation_type}[/b i]\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands.list_operations","title":"<code>list_operations(ctx, by_type: bool, filter: Iterable[str], full_doc: bool, include_internal: bool, format: str)</code>","text":"Source code in <code>kiara/interfaces/cli/operation/commands.py</code> <pre><code>@operation.command(name=\"list\")\n@click.option(\n    \"--by-type\",\n    \"-t\",\n    is_flag=True,\n    help=\"List the operations by operation type (when using 'terminal' as format).\",\n)\n@click.argument(\"filter\", nargs=-1, required=False)\n@click.option(\n    \"--full-doc\",\n    \"-d\",\n    is_flag=True,\n    help=\"Display the full doc for all operations (when using 'terminal' as format).\",\n)\n@click.option(\n    \"--include-internal\",\n    \"-I\",\n    help=\"Whether to include operations that are mainly used internally.\",\n    is_flag=True,\n)\n@output_format_option()\n@click.pass_context\ndef list_operations(\n    ctx,\n    by_type: bool,\n    filter: Iterable[str],\n    full_doc: bool,\n    include_internal: bool,\n    format: str,\n):\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    operations = kiara_obj.operation_registry.operations\n    title = \"Available operations\"\n    if filter:\n        title = \"Filtered operations\"\n        temp = {}\n        for op_id, op in operations.items():\n            match = True\n            for f in filter:\n                if f.lower() not in op_id.lower():\n                    match = False\n                    break\n            if match:\n                temp[op_id] = op\n        operations = temp\n\n    if not include_internal:\n        temp = {}\n        for op_id, op in operations.items():\n            if not op.operation_details.is_internal_operation:\n                temp[op_id] = op\n\n        operations = temp\n\n    from kiara.interfaces.python_api import OperationGroupInfo\n\n    ops_info = OperationGroupInfo.create_from_operations(\n        kiara=kiara_obj, group_title=title, **operations\n    )\n\n    terminal_print_model(\n        ops_info,\n        format=format,\n        in_panel=title,\n        include_internal_operations=include_internal,\n        full_doc=full_doc,\n        by_type=by_type,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/operation/commands/#kiara.interfaces.cli.operation.commands.explain","title":"<code>explain(ctx, operation_id: str, source: bool, format: str, module_info: bool)</code>","text":"Source code in <code>kiara/interfaces/cli/operation/commands.py</code> <pre><code>@operation.command()\n@click.argument(\"operation_id\", nargs=1, required=True)\n@click.option(\n    \"--source\",\n    \"-s\",\n    help=\"Show module source code (or pipeline configuration).\",\n    is_flag=True,\n)\n@click.option(\n    \"--module-info\", \"-m\", help=\"Show module type and config information.\", is_flag=True\n)\n@output_format_option()\n@click.pass_context\n@handle_exception()\ndef explain(ctx, operation_id: str, source: bool, format: str, module_info: bool):\n\n    kiara_obj: Kiara = ctx.obj.kiara\n    api: KiaraAPI = ctx.obj.kiara_api\n\n    if os.path.isfile(os.path.realpath(operation_id)):\n        operation = api.get_operation(operation_id)\n    else:\n        operation = kiara_obj.operation_registry.get_operation(operation_id)\n\n    if not operation:\n        terminal_print()\n        terminal_print(f\"No operation with id '{operation_id}' registered.\")\n        sys.exit(1)\n\n    terminal_print_model(\n        operation,\n        format=format,\n        in_panel=f\"Operation: [b i]{operation_id}[/b i]\",\n        include_src=source,\n        include_module_details=module_info,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/__init__/","title":"pipeline","text":""},{"location":"reference/kiara/interfaces/cli/pipeline/commands/","title":"commands","text":"<p>Pipeline-related subcommands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.pipeline","title":"<code>pipeline(ctx)</code>","text":"<p>Pipeline-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef pipeline(ctx):\n\"\"\"Pipeline-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.list_pipelines","title":"<code>list_pipelines(ctx, full_doc: bool, filter: typing.Iterable[str], format: str)</code>","text":"<p>List available module data_types.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command(name=\"list\")\n@click.option(\n    \"--full-doc\",\n    \"-d\",\n    is_flag=True,\n    help=\"Display the full documentation for every module type.\",\n)\n@click.argument(\"filter\", nargs=-1, required=False)\n@output_format_option()\n@click.pass_context\ndef list_pipelines(ctx, full_doc: bool, filter: typing.Iterable[str], format: str):\n\"\"\"List available module data_types.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    kiara_obj.operation_registry.get_operation_type(\"pipeline\")\n\n    table = Table(box=box.SIMPLE, show_header=True)\n    table.add_column(\"Id\", no_wrap=True)\n    table.add_column(\"Description\", no_wrap=False, style=\"i\")\n\n    op_ids = kiara_obj.operation_registry.operations_by_type[\"pipeline\"]\n\n    title = \"Available pipelines\"\n    if filter:\n        title = \"Filtered pipelines\"\n        temp = {}\n        for op_id in op_ids:\n            op = kiara_obj.operation_registry.get_operation(op_id)\n            match = True\n            for f in filter:\n                if f.lower() not in op_id.lower():\n                    match = False\n                    break\n            if match:\n                temp[op_id] = op\n        operations = temp\n\n    else:\n        operations = {\n            op_id: kiara_obj.operation_registry.get_operation(op_id) for op_id in op_ids\n        }\n\n    from kiara.interfaces.python_api import OperationGroupInfo\n\n    ops_info = OperationGroupInfo.create_from_operations(\n        kiara=kiara_obj, group_title=title, **operations\n    )\n    terminal_print_model(ops_info, format=format, in_panel=title, full_doc=full_doc)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.explain","title":"<code>explain(ctx, pipeline_name_or_path: str, format: str, stages_extraction_type: str)</code>","text":"<p>Print details about pipeline inputs, outputs, and overall structure.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command()\n@click.argument(\"pipeline-name-or-path\", nargs=1)\n@click.option(\n    \"--stages-extraction-type\",\n    \"-s\",\n    default=\"late\",\n    help=\"How to extract the stages from the pipeline structure. Available: 'late', 'early', as well as pipeline specific profiles (if in pipeline metadata).\",\n)\n@output_format_option()\n@click.pass_context\n@handle_exception()\ndef explain(ctx, pipeline_name_or_path: str, format: str, stages_extraction_type: str):\n\"\"\"Print details about pipeline inputs, outputs, and overall structure.\"\"\"\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    from kiara.utils.pipelines import get_pipeline_config\n\n    pc = get_pipeline_config(kiara=kiara_obj, pipeline=pipeline_name_or_path)\n    terminal_print_model(\n        pc,\n        format=format,\n        in_panel=f\"Pipeline: [b i]{pipeline_name_or_path}[/b i]\",\n        stages_extraction_type=stages_extraction_type,\n        show_pipeline_inputs_for_steps=False,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.explain_stages","title":"<code>explain_stages(ctx, pipeline_name_or_path: str, format: str, stages_extraction_type: str)</code>","text":"<p>Print details about pipeline inputs, outputs, and overall structure.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command()\n@click.argument(\"pipeline-name-or-path\", nargs=1)\n@click.option(\n    \"--stages-extraction-type\",\n    \"-s\",\n    default=\"late\",\n    help=\"How to extract the stages from the pipeline structure. Available: 'late', 'early', as well as pipeline specific profiles (if in pipeline metadata).\",\n)\n@output_format_option()\n@click.pass_context\n@handle_exception()\ndef explain_stages(\n    ctx, pipeline_name_or_path: str, format: str, stages_extraction_type: str\n):\n\"\"\"Print details about pipeline inputs, outputs, and overall structure.\"\"\"\n\n    from kiara.models.module.pipeline.stages import PipelineStages\n    from kiara.utils.pipelines import get_pipeline_config\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    pc = get_pipeline_config(kiara=kiara_obj, pipeline=pipeline_name_or_path)\n    structure = pc.structure\n\n    stages = PipelineStages.create(\n        structure=structure, stages_extraction_type=stages_extraction_type\n    )\n    terminal_print_model(\n        stages,\n        format=format,\n        in_panel=f\"Stages for pipeline: [b i]{pipeline_name_or_path}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.execution_graph","title":"<code>execution_graph(ctx, pipeline_name_or_path: str)</code>","text":"<p>Print the execution graph for a pipeline structure.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command()\n@click.argument(\"pipeline-name-or-path\", nargs=1)\n@click.pass_context\ndef execution_graph(ctx, pipeline_name_or_path: str):\n\"\"\"Print the execution graph for a pipeline structure.\"\"\"\n\n    from kiara.utils.graphs import print_ascii_graph\n    from kiara.utils.pipelines import get_pipeline_config\n\n    kiara_obj = ctx.obj.kiara\n\n    pc = get_pipeline_config(kiara=kiara_obj, pipeline=pipeline_name_or_path)\n\n    structure = pc.structure\n\n    print_ascii_graph(\n        structure.execution_graph, restart_interpreter_if_asciinet_installed=True\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.data_flow_graph","title":"<code>data_flow_graph(ctx, pipeline_name_or_path: str, full: bool)</code>","text":"<p>Print the data flow graph for a pipeline structure.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command()\n@click.argument(\"pipeline-name-or-path\", nargs=1)\n@click.option(\n    \"--full\",\n    \"-f\",\n    is_flag=True,\n    help=\"Display full data-flow graph, incl. intermediate input/output connections.\",\n)\n@click.pass_context\ndef data_flow_graph(ctx, pipeline_name_or_path: str, full: bool):\n\"\"\"Print the data flow graph for a pipeline structure.\"\"\"\n\n    from kiara.utils.graphs import print_ascii_graph\n    from kiara.utils.pipelines import get_pipeline_config\n\n    kiara_obj = ctx.obj.kiara\n\n    pc = get_pipeline_config(kiara=kiara_obj, pipeline=pipeline_name_or_path)\n\n    structure = pc.structure\n\n    if full:\n        print_ascii_graph(\n            structure.data_flow_graph, restart_interpreter_if_asciinet_installed=True\n        )\n    else:\n        print_ascii_graph(\n            structure.data_flow_graph_simple,\n            restart_interpreter_if_asciinet_installed=True,\n        )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/pipeline/commands/#kiara.interfaces.cli.pipeline.commands.stages_graph","title":"<code>stages_graph(ctx, pipeline_name_or_path: str, stages_extraction_type: str)</code>","text":"<p>Print the data flow graph for a pipeline structure.</p> Source code in <code>kiara/interfaces/cli/pipeline/commands.py</code> <pre><code>@pipeline.command()\n@click.argument(\"pipeline-name-or-path\", nargs=1)\n@click.option(\n    \"--stages-extraction-type\",\n    \"-s\",\n    default=\"late\",\n    help=\"How to extract the stages from the pipeline structure. Available: 'late', 'early', as well as pipeline specific profiles (if in pipeline metadata).\",\n)\n@click.pass_context\ndef stages_graph(ctx, pipeline_name_or_path: str, stages_extraction_type: str):\n\"\"\"Print the data flow graph for a pipeline structure.\"\"\"\n\n    from kiara.utils.graphs import print_ascii_graph\n    from kiara.utils.pipelines import get_pipeline_config\n\n    kiara_obj = ctx.obj.kiara\n\n    pc = get_pipeline_config(kiara=kiara_obj, pipeline=pipeline_name_or_path)\n\n    structure = pc.structure\n    stages_graph = structure.get_stages_graph(\n        stages_extraction_type=stages_extraction_type\n    )\n\n    print_ascii_graph(\n        stages_graph,\n        restart_interpreter_if_asciinet_installed=True,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/__init__/","title":"render","text":""},{"location":"reference/kiara/interfaces/cli/render/commands/","title":"commands","text":"<p>Pipeline-related subcommands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.render_wrapper","title":"<code>render_wrapper(kiara_api: KiaraAPI, source_type: str, item: Any, target_type: Union[str, None], render_config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>def render_wrapper(\n    kiara_api: \"KiaraAPI\",\n    source_type: str,\n    item: Any,\n    target_type: Union[str, None],\n    render_config: Mapping[str, Any],\n):\n\n    if target_type is None:\n        renderers = kiara_api.retrieve_renderers_for(source_type=source_type)\n        all_targets: Set[str] = set()\n        for renderer in renderers:\n            targets = renderer.retrieve_supported_render_targets()\n            if isinstance(targets, str):\n                targets = [targets]\n            all_targets.update(targets)\n\n        terminal_print()\n        msg = \"No target type specified, available targets:\\n\\n\"\n        for target in all_targets:\n            msg += f\"- {target}\\n\"\n        terminal_print(Markdown(msg))\n        sys.exit(1)\n\n    result = kiara_api.render(\n        source_type=source_type,\n        item=item,\n        target_type=target_type,\n        render_config=render_config,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.result_wrapper","title":"<code>result_wrapper(result: Any, output: Union[str, None], force: bool = False, terminal_render_config: Union[None, Mapping[str, Any]] = None)</code>","text":"Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>def result_wrapper(\n    result: Any,\n    output: Union[str, None],\n    force: bool = False,\n    terminal_render_config: Union[None, Mapping[str, Any]] = None,\n):\n\n    if output:\n        output_file = Path(output)\n        if output_file.exists() and not force:\n            terminal_print()\n            terminal_print(\n                f\"Output file '{output_file}' already exists, use '--force' to overwrite.\",\n            )\n        output_file.parent.mkdir(parents=True, exist_ok=True)\n        if isinstance(result, str):\n            output_file.write_text(result)\n        elif isinstance(result, bytes):\n            output_file.write_bytes(result)\n        else:\n            terminal_print()\n            terminal_print(\n                f\"Render output if type '{type(result)}', can't write to file.\"\n            )\n\n    else:\n\n        if isinstance(result, str):\n            print(result)  # noqa\n        elif isinstance(result, bytes):\n            terminal_print()\n            terminal_print(\n                \"Render result is binary data, can't print to terminal. Use the '--output' option to write to a file.\"\n            )\n        else:\n            if terminal_render_config is None:\n                terminal_render_config = {}\n            terminal_print(result, **terminal_render_config)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.render","title":"<code>render(ctx) -&gt; None</code>","text":"<p>Rendering-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef render(ctx) -&gt; None:\n\"\"\"Rendering-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.list_renderers","title":"<code>list_renderers(ctx) -&gt; None</code>","text":"<p>List all available renderers.</p> Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@render.command()\n@click.pass_context\ndef list_renderers(ctx) -&gt; None:\n\"\"\"List all available renderers.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    infos = kiara_api.retrieve_renderer_infos()\n    terminal_print()\n    terminal_print_model(infos)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.pipeline","title":"<code>pipeline(ctx, pipeline: str) -&gt; None</code>","text":"<p>Render a kiara pipeline.</p> Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@render.group()\n@click.argument(\"pipeline\", nargs=1, metavar=\"PIPELINE_NAME_OR_PATH\")\n@click.pass_context\ndef pipeline(ctx, pipeline: str) -&gt; None:\n\"\"\"Render a kiara pipeline.\"\"\"\n\n    api: KiaraAPI = ctx.obj.kiara_api\n\n    if pipeline.startswith(\"workflow:\"):\n        # pipeline_defaults = {}\n        raise NotImplementedError()\n    else:\n        from kiara.models.module.pipeline.pipeline import Pipeline\n\n        pipeline_obj = Pipeline.create_pipeline(kiara=api.context, pipeline=pipeline)\n\n    ctx.obj[\"item\"] = pipeline_obj\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.render_func_pipeline","title":"<code>render_func_pipeline(ctx, render_config: Tuple[str, ...], target_type: Union[str, None], output: Union[str, None], force: bool) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@pipeline.command(\"as\")\n@click.argument(\"target_type\", nargs=1, metavar=\"TARGET_TYPE\", required=False)\n@click.argument(\"render_config\", nargs=-1, required=False)\n@click.option(\"--output\", \"-o\", help=\"Write the rendered output to a file.\")\n@click.option(\"--force\", \"-f\", help=\"Overwrite existing output file.\", is_flag=True)\n@click.pass_context\n@handle_exception()\ndef render_func_pipeline(\n    ctx,\n    render_config: Tuple[str, ...],\n    target_type: Union[str, None],\n    output: Union[str, None],\n    force: bool,\n) -&gt; None:\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n    item = ctx.obj[\"item\"]\n\n    render_config_dict = dict_from_cli_args(*render_config)\n\n    result = render_wrapper(\n        kiara_api=kiara_api,\n        source_type=\"pipeline\",\n        item=item,\n        target_type=target_type,\n        render_config=render_config_dict,\n    )\n\n    result_wrapper(result=result, output=output, force=force)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.value","title":"<code>value(ctx, value: str) -&gt; None</code>","text":"<p>Render a kiara value.</p> Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@render.group()\n@click.argument(\"value\", nargs=1, metavar=\"VALUE_ID_OR_ALIAS\")\n@click.pass_context\ndef value(ctx, value: str) -&gt; None:\n\"\"\"Render a kiara value.\"\"\"\n\n    api: KiaraAPI = ctx.obj.kiara_api\n\n    value_obj = api.get_value(value)\n\n    ctx.obj[\"item\"] = value_obj\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.render_func_value","title":"<code>render_func_value(ctx, render_config: Tuple[str, ...], target_type: Union[str, None], output: Union[str, None], force: bool) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@value.command(\"as\")\n@click.argument(\"target_type\", nargs=1, metavar=\"TARGET_TYPE\", required=False)\n@click.argument(\"render_config\", nargs=-1, required=False)\n@click.option(\"--output\", \"-o\", help=\"Write the rendered output to a file.\")\n@click.option(\"--force\", \"-f\", help=\"Overwrite existing output file.\", is_flag=True)\n# @click.option(\n#     \"--metadata\",\n#     \"-m\",\n#     help=\"Also show the render metadata.\",\n#     is_flag=True,\n#     default=False,\n# )\n# @click.option(\n#     \"--no-data\", \"-n\", help=\"Show the rendered data.\", is_flag=True, default=False\n# )\n@click.pass_context\n@handle_exception()\ndef render_func_value(\n    ctx,\n    render_config: Tuple[str, ...],\n    target_type: Union[str, None],\n    output: Union[str, None],\n    force: bool,\n) -&gt; None:\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n    item = ctx.obj[\"item\"]\n\n    render_config_dict = dict_from_cli_args(*render_config)\n\n    result = render_wrapper(\n        kiara_api=kiara_api,\n        source_type=\"value\",\n        item=item,\n        target_type=target_type,\n        render_config=render_config_dict,\n    )\n\n    # in case we have a rendervalue result, and we want to terminal print, we need to forward some of the render config\n    show_render_metadata = render_config_dict.get(\"include_metadata\", False)\n    show_render_result = render_config_dict.get(\"include_data\", True)\n    cnf = {\n        \"show_render_metadata\": show_render_metadata,\n        \"show_render_result\": show_render_result,\n    }\n\n    result_wrapper(\n        result=result, output=output, force=force, terminal_render_config=cnf\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.kiara_api","title":"<code>kiara_api(ctx) -&gt; None</code>","text":"<p>Render a kiara value.</p> Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@render.group(\"kiara_api\")\n@click.pass_context\ndef kiara_api(ctx) -&gt; None:\n\"\"\"Render a kiara value.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/render/commands/#kiara.interfaces.cli.render.commands.render_func_api","title":"<code>render_func_api(ctx, render_config: Tuple[str, ...], target_type: Union[str, None], output: Union[str, None], force: bool) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/cli/render/commands.py</code> <pre><code>@kiara_api.command(\"as\")\n@click.argument(\"target_type\", nargs=1, metavar=\"TARGET_TYPE\", required=False)\n@click.argument(\"render_config\", nargs=-1, required=False)\n@click.option(\"--output\", \"-o\", help=\"Write the rendered output to a file.\")\n@click.option(\"--force\", \"-f\", help=\"Overwrite existing output file.\", is_flag=True)\n@click.pass_context\n@handle_exception()\ndef render_func_api(\n    ctx,\n    render_config: Tuple[str, ...],\n    target_type: Union[str, None],\n    output: Union[str, None],\n    force: bool,\n) -&gt; None:\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    render_config_dict = dict_from_cli_args(*render_config)\n\n    result = render_wrapper(\n        kiara_api=kiara_api,\n        source_type=\"kiara_api\",\n        item=kiara_api,\n        target_type=target_type,\n        render_config=render_config_dict,\n    )\n\n    # in case we have a rendervalue result, and we want to terminal print, we need to forward some of the render config\n    show_render_metadata = render_config_dict.get(\"include_metadata\", False)\n    show_render_result = render_config_dict.get(\"include_data\", True)\n    cnf = {\n        \"show_render_metadata\": show_render_metadata,\n        \"show_render_result\": show_render_result,\n    }\n\n    result_wrapper(\n        result=result, output=output, force=force, terminal_render_config=cnf\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/type/__init__/","title":"type","text":""},{"location":"reference/kiara/interfaces/cli/type/commands/","title":"commands","text":"<p>Type-related subcommands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands.type_group","title":"<code>type_group(ctx)</code>","text":"<p>Information about available data types.</p> Source code in <code>kiara/interfaces/cli/type/commands.py</code> <pre><code>@click.group(name=\"data-type\")\n@click.pass_context\ndef type_group(ctx):\n\"\"\"Information about available data types.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands.list_types","title":"<code>list_types(ctx, full_doc, include_internal: bool, filter: Iterable[str], format: str)</code>","text":"<p>List available data_types.</p> Source code in <code>kiara/interfaces/cli/type/commands.py</code> <pre><code>@type_group.command(name=\"list\")\n@click.option(\n    \"--full-doc\",\n    \"-d\",\n    is_flag=True,\n    help=\"Display the full documentation for every data type (when using 'terminal' output format).\",\n)\n@click.option(\n    \"--include-internal\",\n    \"-I\",\n    is_flag=True,\n    help=\"Also list types that are only (or mostly) used internally.\",\n)\n@click.argument(\"filter\", nargs=-1, required=False)\n@output_format_option()\n@click.pass_context\ndef list_types(\n    ctx, full_doc, include_internal: bool, filter: Iterable[str], format: str\n):\n\"\"\"List available data_types.\"\"\"\n\n    from kiara.data_types import DataType\n    from kiara.interfaces.python_api import DataTypeClassesInfo\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    if not include_internal:\n        type_classes: Dict[str, Type[DataType]] = {}\n        for name, cls in kiara_obj.data_type_classes.items():\n            if not kiara_obj.type_registry.is_internal_type(name):\n                type_classes[name] = cls\n    else:\n        type_classes = dict(kiara_obj.data_type_classes)\n\n    title = \"Available data types\"\n    if filter:\n        title = \"Filtered data types\"\n        temp = {}\n        for k, v in type_classes.items():\n            match = True\n            for f in filter:\n                if f.lower() not in k.lower():\n                    match = False\n                    break\n            if match:\n                temp[k] = v\n        type_classes = temp\n\n    data_types_info = DataTypeClassesInfo.create_from_type_items(\n        kiara=kiara_obj, group_title=title, **type_classes\n    )\n\n    terminal_print_model(\n        data_types_info, format=format, in_panel=\"Available data types\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands.hierarchy","title":"<code>hierarchy(ctx, include_internal) -&gt; None</code>","text":"<p>Show the current runtime environments' type hierarchy.</p> Source code in <code>kiara/interfaces/cli/type/commands.py</code> <pre><code>@type_group.command(name=\"hierarchy\")\n@click.option(\n    \"--include-internal\",\n    \"-i\",\n    is_flag=True,\n    help=\"Display internally used data types.\",\n    default=False,\n)\n@click.pass_context\ndef hierarchy(ctx, include_internal) -&gt; None:\n\"\"\"Show the current runtime environments' type hierarchy.\"\"\"\n\n    from kiara.utils.graphs import print_ascii_graph\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    type_mgmt = kiara_obj.type_registry\n    terminal_print()\n\n    if include_internal:\n        print_ascii_graph(type_mgmt.data_type_hierarchy)\n    else:\n        sub_graph = type_mgmt.get_sub_hierarchy(\"any\")\n        print_ascii_graph(sub_graph)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/type/commands/#kiara.interfaces.cli.type.commands.explain_data_type","title":"<code>explain_data_type(ctx, type_name: str, format: str)</code>","text":"<p>Print details of a data type.</p> Source code in <code>kiara/interfaces/cli/type/commands.py</code> <pre><code>@type_group.command(name=\"explain\")\n@click.argument(\"type_name\", nargs=1, required=True)\n@output_format_option()\n@click.pass_context\ndef explain_data_type(ctx, type_name: str, format: str):\n\"\"\"Print details of a data type.\"\"\"\n\n    from kiara.interfaces.python_api import DataTypeClassInfo\n\n    kiara_obj: Kiara = ctx.obj.kiara\n\n    data_type = kiara_obj.type_registry.retrieve_data_type(\n        data_type_name=type_name, data_type_config=None\n    )\n\n    instance_renderable = data_type.create_renderable(show_type_info=False)\n    type_renderable = DataTypeClassInfo.create_from_type_class(\n        type_cls=data_type.__class__, kiara=kiara_obj\n    )\n\n    terminal_print_model(\n        instance_renderable,\n        type_renderable,\n        format=format,\n        in_panel=f\"Data type: [b i]{data_type.data_type_name}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/workflow/__init__/","title":"workflow","text":""},{"location":"reference/kiara/interfaces/cli/workflow/commands/","title":"commands","text":"<p>Data-related sub-commands for the cli.</p>"},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.workflow","title":"<code>workflow(ctx)</code>","text":"<p>Workflow-related sub-commands.</p> Source code in <code>kiara/interfaces/cli/workflow/commands.py</code> <pre><code>@click.group()\n@click.pass_context\ndef workflow(ctx):\n\"\"\"Workflow-related sub-commands.\"\"\"\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.list","title":"<code>list(ctx, all) -&gt; None</code>","text":"<p>List existing workflows.</p> Source code in <code>kiara/interfaces/cli/workflow/commands.py</code> <pre><code>@workflow.command()\n@click.option(\n    \"--all\", \"-a\", help=\"Also displays workflows without alias.\", is_flag=True\n)\n@click.pass_context\ndef list(ctx, all) -&gt; None:\n\"\"\"List existing workflows.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    if all:\n        workflows = kiara_api.retrieve_workflows_info()\n    else:\n        workflows = kiara_api.retrieve_workflow_aliases_info()\n\n    terminal_print_model(workflows)\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.create","title":"<code>create(ctx, workflow_alias: str, blueprint: Union[str, None], desc: Union[str, None] = None, inputs: Tuple[str, ...] = (), force_alias: bool = False)</code>","text":"<p>Create a new workflow.</p> Source code in <code>kiara/interfaces/cli/workflow/commands.py</code> <pre><code>@workflow.command()\n@click.argument(\"workflow_alias\", nargs=1, required=False)\n@click.argument(\"blueprint\", nargs=1, required=False)\n@click.argument(\"inputs\", nargs=-1)\n@click.option(\n    \"--force-alias\",\n    \"-f\",\n    is_flag=True,\n    help=\"Force (replace) an existing alias, if equal to the one provided.\",\n)\n@click.option(\n    \"--desc\", \"-d\", help=\"Description string for the workflow.\", required=False\n)\n@click.pass_context\ndef create(\n    ctx,\n    workflow_alias: str,\n    blueprint: Union[str, None],\n    desc: Union[str, None] = None,\n    inputs: Tuple[str, ...] = (),\n    force_alias: bool = False,\n):\n\"\"\"Create a new workflow.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n\n    inputs_dict: Union[None, Dict[str, Any]] = None\n    if inputs:\n        inputs_dict = dict_from_cli_args(*inputs)\n\n    workflow_obj = kiara_api.create_workflow(\n        workflow_alias=workflow_alias,\n        initial_pipeline=blueprint,\n        initial_inputs=inputs_dict,\n    )\n\n    workflow_obj.process_steps()\n\n    if force_alias:\n        kiara_api.context.workflow_registry.unregister_alias(workflow_alias)\n\n    workflow_obj.snapshot(save=True)\n\n    terminal_print_model(\n        workflow_obj.info,\n        in_panel=f\"Workflow: [b i]{workflow_alias}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.explain","title":"<code>explain(ctx, workflow: str)</code>","text":"<p>Explain the workflow with the specified id/alias.</p> Source code in <code>kiara/interfaces/cli/workflow/commands.py</code> <pre><code>@workflow.command()\n@click.argument(\"workflow\", nargs=1)\n@click.pass_context\ndef explain(ctx, workflow: str):\n\"\"\"Explain the workflow with the specified id/alias.\"\"\"\n\n    kiara_api: KiaraAPI = ctx.obj.kiara_api\n    workflow_info = kiara_api.retrieve_workflow_info(workflow=workflow)\n    terminal_print(\n        workflow_info.create_renderable(),\n        in_panel=f\"Workflow: [b i]{workflow}[/b i]\",\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/cli/workflow/commands/#kiara.interfaces.cli.workflow.commands.set_input","title":"<code>set_input(ctx, workflow: str, inputs: Tuple[str], process: bool)</code>","text":"<p>Set one or several inputs on the specified workflow.</p> Source code in <code>kiara/interfaces/cli/workflow/commands.py</code> <pre><code>@workflow.command()\n@click.argument(\"workflow\", nargs=1)\n@click.argument(\"inputs\", nargs=-1, required=False)\n@click.option(\n    \"--process/--no-process\",\n    \"-a/-n\",\n    help=\"Process all possible intermediate and end-results.\",\n    is_flag=True,\n    default=True,\n)\n@click.pass_context\ndef set_input(ctx, workflow: str, inputs: Tuple[str], process: bool):\n\"\"\"Set one or several inputs on the specified workflow.\"\"\"\n\n    from kiara.interfaces.python_api import Workflow\n\n    kiara: Kiara = ctx.obj.kiara\n\n    workflow_details = kiara.workflow_registry.get_workflow_metadata(workflow=workflow)\n    workflow_obj = Workflow(kiara=kiara, workflow=workflow_details.workflow_id)\n\n    inputs_schema = workflow_obj.current_pipeline_inputs_schema\n    list_keys = []\n    for name, value_schema in inputs_schema.items():\n        if value_schema.type in [\"list\"]:\n            list_keys.append(name)\n    inputs_dict = dict_from_cli_args(*inputs, list_keys=list_keys)\n\n    workflow_obj.set_inputs(**inputs_dict)\n\n    if process:\n        try:\n            workflow_obj.process_steps()\n        except Exception as e:\n            terminal_print(e)\n\n    workflow_obj.snapshot(save=True)\n    terminal_print_model(workflow_obj.info, in_panel=f\"Workflow: [b i]{workflow}[/b i]\")\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/","title":"python_api","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI","title":"<code>KiaraAPI</code>","text":"<p>         Bases: <code>object</code></p> <p>Public API for clients</p> <p>This class wraps a Kiara instance, and allows easy a access to tasks that are typically done by a frontend. The return types of each method are json seriable in most cases.</p> <p>Can be extended for special scenarios and augmented with scenario-specific methdos (Jupyter, web-frontend, ...)</p> <p>The naming of the API endpoints follows a (loose-ish) convention: - list_: return a list of ids or items, if items, filtering is supported - get_: get specific instances of a type (operation, value, etc.) - retrieve_: get augmented information about an instance or type of something. This usually implies that there is some overhead, so before you use this, make sure that there is not 'get_' or 'list_*' endpoint that could give you what you need. .</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>class KiaraAPI(object):\n\"\"\"Public API for clients\n\n    This class wraps a [Kiara][kiara.context.kiara.Kiara] instance, and allows easy a access to tasks that are\n    typically done by a frontend. The return types of each method are json seriable in most cases.\n\n    Can be extended for special scenarios and augmented with scenario-specific methdos (Jupyter, web-frontend, ...)\n\n    The naming of the API endpoints follows a (loose-ish) convention:\n    - list_*: return a list of ids or items, if items, filtering is supported\n    - get_*: get specific instances of a type (operation, value, etc.)\n    - retrieve_*: get augmented information about an instance or type of something. This usually implies that there is some overhead,\n    so before you use this, make sure that there is not 'get_*' or 'list_*' endpoint that could give you what you need.\n    .\"\"\"\n\n    _instance: Union[\"KiaraAPI\", None] = None\n\n    @classmethod\n    def instance(\n        cls,\n    ) -&gt; \"KiaraAPI\":\n\n        if cls._instance is not None:\n            return cls._instance\n\n        from kiara.context import KiaraConfig\n\n        config = KiaraConfig()\n\n        api = KiaraAPI(kiara_config=config)\n        cls._instance = api\n        return api\n\n    def __init__(self, kiara_config: \"KiaraConfig\"):\n\n        self._kiara_config: KiaraConfig = kiara_config\n        self._contexts: Dict[str, Kiara] = {}\n        self._workflow_cache: Dict[uuid.UUID, Workflow] = {}\n\n        self._current_context: Union[None, Kiara] = None\n        self._current_context_alias: Union[None, str] = None\n\n    @cached_property\n    def doc(self) -&gt; Dict[str, str]:\n\"\"\"Get the documentation for this API.\"\"\"\n\n        result = {}\n        for method_name in dir(self):\n            if method_name.startswith(\"_\"):\n                continue\n\n            method = getattr(self.__class__, method_name)\n            doc = inspect.getdoc(method)\n            if doc is None:\n                doc = \"-- n/a --\"\n            else:\n                doc = textwrap.dedent(doc)\n\n            result[method_name] = doc\n\n        return result\n\n    @property\n    def context(self) -&gt; \"Kiara\":\n\"\"\"Return the kiara context.\n\n        DON\"T USE THIS! This is going away in the production release.\n        \"\"\"\n\n        if self._current_context is None:\n            self._current_context = self._kiara_config.create_context(\n                extra_pipelines=None\n            )\n            self._current_context_alias = self._kiara_config.default_context\n\n        return self._current_context\n\n    def get_runtime_config(self) -&gt; \"KiaraRuntimeConfig\":\n\"\"\"Retrieve the current runtime configuration.\"\"\"\n        return self.context.runtime_config\n\n    def get_context_info(self) -&gt; ContextInfo:\n\"\"\"Retrieve information about the current kiara context.\"\"\"\n\n        context_config = self._kiara_config.get_context_config(\n            self.get_current_context_name()\n        )\n        info = ContextInfo.create_from_context_config(\n            context_config,\n            context_name=self.get_current_context_name(),\n            runtime_config=self._kiara_config.runtime_config,\n        )\n\n        return info\n\n    def ensure_plugin_packages(\n        self, package_names: Union[str, Iterable[str]], update: bool = False\n    ) -&gt; Union[bool, None]:\n\"\"\"Ensure that the specified packages are installed.\n\n        Arguments:\n          package_names: The names of the packages to install.\n          update: If True, update the packages if they are already installed\n\n        Returns:\n            'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.\n        \"\"\"\n\n        if isinstance(package_names, str):\n            package_names = [package_names]\n\n        env_reg = EnvironmentRegistry.instance()\n        python_env: PythonRuntimeEnvironment = env_reg.environments[  # type: ignore\n            \"python\"\n        ]  # type: ignore\n\n        if not package_names:\n            package_names = OFFICIAL_KIARA_PLUGINS  # type: ignore\n\n        if not update:\n            plugin_packages: List[str] = []\n            pkgs = [p.name.replace(\"_\", \"-\") for p in python_env.packages]\n            for package_name in package_names:\n                if package_name.startswith(\"git:\"):\n                    package_name = package_name.replace(\"git:\", \"\")\n                    git = True\n                else:\n                    git = False\n                package_name = package_name.replace(\"_\", \"-\")\n                if not package_name.startswith(\"kiara-plugin.\"):\n                    package_name = f\"kiara-plugin.{package_name}\"\n\n                if git or package_name.replace(\"_\", \"-\") not in pkgs:\n                    if git:\n                        package_name = package_name.replace(\"-\", \"_\")\n                        plugin_packages.append(\n                            f\"git+https://x:x@github.com/DHARPA-project/{package_name}@develop\"\n                        )\n                    else:\n                        plugin_packages.append(package_name)\n        else:\n            plugin_packages = package_names  # type: ignore\n\n        in_jupyter = \"google.colab\" in sys.modules or \"jupyter_client\" in sys.modules\n\n        if not plugin_packages:\n            if in_jupyter:\n                return None\n            else:\n                # nothing to do\n                return False\n\n        class DummyContext(object):\n            def __getattribute__(self, item):\n                raise Exception(\n                    \"Currently installing plugins, no other operations are allowed.\"\n                )\n\n        current_context_name = self._current_context_alias\n        for k in self._contexts.keys():\n            self._contexts[k] = DummyContext()  # type: ignore\n        self._current_context = DummyContext()  # type: ignore\n\n        cmd = [\"-q\", \"--isolated\", \"install\"]\n        if update:\n            cmd.append(\"--upgrade\")\n        cmd.extend(plugin_packages)\n\n        if in_jupyter:\n            from IPython import get_ipython\n\n            ipython = get_ipython()\n            cmd_str = f\"sc -l stdout = {sys.executable} -m pip {' '.join(cmd)}\"\n            ipython.magic(cmd_str)\n            exit_code = 100\n        else:\n            import pip._internal.cli.main as pip\n\n            log_message(\n                \"install.python_packages\", packages=plugin_packages, update=update\n            )\n            exit_code = pip.main(cmd)\n\n        self._contexts.clear()\n        self._current_context = None\n        self._current_context_alias = None\n\n        EnvironmentRegistry._instance = None\n        if current_context_name:\n            self.set_active_context(context_name=current_context_name)\n\n        if exit_code == 100:\n            raise SystemExit(\n                f\"Please manually re-run all cells. Updated or newly installed plugin packages: {', '.join(plugin_packages)}.\"\n            )\n        elif exit_code != 0:\n            raise Exception(\n                f\"Failed to install plugin packages: {', '.join(plugin_packages)}\"\n            )\n\n        return True\n\n    # ==================================================================================================================\n    # context-management related functions\n    def list_context_names(self) -&gt; List[str]:\n\"\"\"list the names of all available/registered contexts.\"\"\"\n\n        return list(self._kiara_config.available_context_names)\n\n    def retrieve_context_infos(self) -&gt; ContextInfos:\n\"\"\"Retrieve information about the available/registered contexts.\"\"\"\n\n        return ContextInfos.create_context_infos(self._kiara_config.context_configs)\n\n    def get_current_context_name(self) -&gt; str:\n\"\"\"Retrieve the name fo the current context.\"\"\"\n\n        if self._current_context_alias is None:\n            self.context\n        return self._current_context_alias  # type: ignore\n\n    def create_new_context(self, context_name: str, set_active: bool) -&gt; None:\n\"\"\"Create a new context.\n\n        Arguments:\n            context_name: the name of the new context\n            set_active: set the newly created context as the active one\n        \"\"\"\n\n        if context_name in self.list_context_names():\n            raise Exception(\n                f\"Can't create context with name '{context_name}': context already exists.\"\n            )\n\n        ctx = self._kiara_config.create_context(context_name, extra_pipelines=None)\n        if set_active:\n            self._current_context = ctx\n            self._current_context_alias = context_name\n\n    def set_active_context(self, context_name: str, create: bool = False) -&gt; None:\n\n        if not context_name:\n            raise Exception(\"No context name provided.\")\n\n        if context_name == self._current_context_alias:\n            return\n        if context_name not in self.list_context_names():\n            if create:\n                self._current_context = self._kiara_config.create_context(\n                    context=context_name, extra_pipelines=None\n                )\n                self._current_context_alias = context_name\n                return\n            else:\n                raise Exception(f\"No context with name '{context_name}' available.\")\n\n        self._current_context = self._kiara_config.create_context(\n            context=context_name, extra_pipelines=None\n        )\n        self._current_context_alias = context_name\n\n    # ==================================================================================================================\n    # methods for data_types\n\n    def list_data_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered data types.\"\"\"\n\n        return self.context.type_registry.data_type_names\n\n    def is_internal_data_type(self, data_type_name: str) -&gt; bool:\n\"\"\"Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.\"\"\"\n\n        return self.context.type_registry.is_internal_type(\n            data_type_name=data_type_name\n        )\n\n    def retrieve_data_types_info(\n        self, filter: Union[str, Iterable[str], None]\n    ) -&gt; DataTypeClassesInfo:\n\"\"\"Retrieve information about all data types.\n\n        A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific\n        Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.\n\n        Arguments:\n            filter: an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)\n\n        Returns:\n            an object containing all information about all data types\n        \"\"\"\n\n        if filter:\n            if isinstance(filter, str):\n                filter = [filter]\n\n            title = f\"Filtered data_types: {filter}\"\n            data_type_names: Iterable[str] = []\n\n            for m in self.context.type_registry.data_type_names:\n                match = True\n\n                for f in filter:\n\n                    if f.lower() not in m.lower():\n                        match = False\n                        break\n\n                if match:\n                    data_type_names.append(m)  # type: ignore\n        else:\n            title = \"All data types\"\n            data_type_names = self.context.type_registry.data_type_names\n\n        data_types = {\n            d: self.context.type_registry.get_data_type_cls(d) for d in data_type_names\n        }\n        data_types_info = DataTypeClassesInfo.create_from_type_items(\n            kiara=self.context, group_title=title, **data_types\n        )\n\n        return data_types_info  # type: ignore\n\n    def retrieve_data_type_info(self, data_type_name: str) -&gt; DataTypeClassInfo:\n\"\"\"Retrieve information about a specific data type.\n\n        Arguments:\n            data_type: the registered name of the data type\n\n        Returns:\n            an object containing all information about a data type\n        \"\"\"\n\n        dt_cls = self.context.type_registry.get_data_type_cls(data_type_name)\n        info = DataTypeClassInfo.create_from_type_class(\n            kiara=self.context, type_cls=dt_cls\n        )\n        return info\n\n    # ==================================================================================================================\n    # methods for module and operations info\n\n    def list_module_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered module types.\"\"\"\n\n        return list(self.context.module_registry.get_module_type_names())\n\n    def retrieve_module_types_info(\n        self, filter: Union[None, str, Iterable[str]] = None\n    ) -&gt; ModuleTypesInfo:\n\"\"\"Retrieve information for all available module types (or a filtered subset thereof).\n\n        A module type is Python class that inherits from [KiaraModule][kiara.modules.KiaraModule], and is the basic\n        building block for processing pipelines. Module types are not used directly by users, Operations are. Operations\n         are instantiated modules (meaning: the module &amp; some (optional) configuration).\n\n        Arguments:\n            filter: an optional string (or list of string) the returned module names have to match (all filters in case of list)\n\n        Returns:\n            a mapping object containing module names as keys, and information about the modules as values\n        \"\"\"\n\n        if filter:\n\n            if isinstance(filter, str):\n                filter = [filter]\n            title = f\"Filtered modules: {filter}\"\n            module_types_names: Iterable[str] = []\n\n            for m in self.context.module_registry.get_module_type_names():\n                match = True\n\n                for f in filter:\n\n                    if f.lower() not in m.lower():\n                        match = False\n                        break\n\n                if match:\n                    module_types_names.append(m)  # type: ignore\n        else:\n            title = \"All modules\"\n            module_types_names = self.context.module_registry.get_module_type_names()\n\n        module_types = {\n            n: self.context.module_registry.get_module_class(n)\n            for n in module_types_names\n        }\n\n        module_types_info = ModuleTypesInfo.create_from_type_items(  # type: ignore\n            kiara=self.context, group_title=title, **module_types\n        )\n        return module_types_info  # type: ignore\n\n    def retrieve_module_type_info(self, module_type: str) -&gt; ModuleTypeInfo:\n\"\"\"Retrieve information about a specific module type.\n\n        This can be used to retrieve information like module documentation and configuration options.\n\n        Arguments:\n            module_type: the registered name of the module\n\n        Returns:\n            an object containing all information about a module type\n        \"\"\"\n\n        m_cls = self.context.module_registry.get_module_class(module_type)\n        info = ModuleTypeInfo.create_from_type_class(kiara=self.context, type_cls=m_cls)\n        return info\n\n    def create_operation(\n        self,\n        module_type: str,\n        module_config: Union[Mapping[str, Any], str, None] = None,\n    ) -&gt; Operation:\n\"\"\"Create an [Operation][kiara.models.module.operation.Operation] instance for the specified module type and (optional) config.\n\n        This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.\n\n        Arguments:\n            module_type: the registered name of the module\n            module_config: (Optional) configuration for the module instance.\n\n        Returns:\n            an Operation instance (which contains all the available information about an instantiated module)\n        \"\"\"\n\n        if module_config is None:\n            module_config = {}\n        elif isinstance(module_config, str):\n            try:\n                module_config = json.load(module_config)  # type: ignore\n            except Exception:\n                try:\n                    module_config = yaml.load(module_config)  # type: ignore\n                except Exception:\n                    raise Exception(\n                        f\"Can't parse module config string: {module_config}.\"\n                    )\n\n        if module_type == \"pipeline\":\n            if not module_config:\n                raise Exception(\"Pipeline configuration can't be empty.\")\n            assert module_config is None or isinstance(module_config, Mapping)\n            operation = create_operation(\"pipeline\", operation_config=module_config)\n            return operation\n        else:\n            mc = Manifest(module_type=module_type, module_config=module_config)\n            module_obj = self.context.module_registry.create_module(mc)\n\n            return module_obj.operation\n\n    def list_operation_ids(\n        self,\n        filter: Union[str, None, Iterable[str]] = None,\n        include_internal: bool = False,\n    ) -&gt; List[str]:\n\"\"\"Get a list of all operation ids that match the specified filter.\n\n        Arguments:\n            filter: an optional single or list of filters (all filters must match the operation id for the operation to be included)\n            include_internal: also return internal operations\n        \"\"\"\n\n        if not filter and include_internal:\n            return sorted(self.context.operation_registry.operation_ids)\n\n        else:\n            return sorted(\n                self.list_operations(\n                    filter=filter, include_internal=include_internal\n                ).keys()\n            )\n\n    def get_operation(\n        self,\n        operation: Union[Mapping[str, Any], str, Path],\n        allow_external: Union[bool, None] = None,\n    ) -&gt; Operation:\n\"\"\"Return the operation instance with the specified id.\n\n        This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.\n\n        The order in which the operation argument is resolved:\n        - if it's a string, and an existing, registered operation_id, the associated operation is returned\n        - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)\n\n        Arguments:\n            operation: the operation id, module_type_name, path to a file, or url\n            allow_external: if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.\n\n        Returns:\n            operation instance data\n        \"\"\"\n\n        _module_type = None\n        _module_config = None\n\n        if allow_external is None:\n            allow_external = self.get_runtime_config().allow_external\n\n        if isinstance(operation, Path):\n            operation = operation.as_posix()\n\n        if isinstance(operation, str):\n\n            if operation in self.list_operation_ids(include_internal=True):\n                _operation = self.context.operation_registry.get_operation(operation)\n                return _operation\n\n            if not allow_external:\n                raise NoSuchExecutionTargetException(\n                    selected_target=operation,\n                    available_targets=self.context.operation_registry.operation_ids,\n                    msg=f\"Can't find operation with id '{operation}', and external operations are not allowed.\",\n                )\n\n            if os.path.isfile(operation):\n                try:\n                    # we use the 'from_file' here, because that will resolve any relative paths in the pipeline\n                    # if this doesn't work, we just assume the file is not a pipeline configuration but\n                    # a manifest file with 'module_type' and optional 'module_config' keys\n                    pipeline_conf = PipelineConfig.from_file(\n                        path=operation, kiara=self.context\n                    )\n                    _module_config = pipeline_conf.dict()\n                except Exception as e:\n                    log_exception(e)\n                    _module_config = get_data_from_file(operation)\n            elif operation.startswith(\"http\"):\n                _module_config = get_data_from_url(operation)\n            else:\n                try:\n                    _module_config = json.load(operation)  # type: ignore\n                except Exception:\n                    try:\n                        _module_config = yaml.load(operation)  # type: ignore\n                    except Exception:\n                        raise Exception(\n                            f\"Can't parse configuration string: {operation}.\"\n                        )\n        else:\n            _module_config = dict(operation)\n\n        if \"module_type\" in _module_config.keys():\n            _module_type = _module_config[\"module_type\"]\n            _module_config = _module_config.get(\"module_config\", {})\n        else:\n            _module_type = \"pipeline\"\n\n        op = self.create_operation(\n            module_type=_module_type, module_config=_module_config\n        )\n        return op\n\n    def list_operations(\n        self,\n        filter: Union[str, None, Iterable[str]] = None,\n        input_types: Union[str, Iterable[str], None] = None,\n        output_types: Union[str, Iterable[str], None] = None,\n        operation_types: Union[str, Iterable[str], None] = None,\n        python_packages: Union[str, Iterable[str], None] = None,\n        include_internal: bool = False,\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"List all available values, optionally filter.\n\n        Arguments:\n            filter: the (optional) filter string(s), an operation must match all of them to be included in the result\n            input_types: each operation must have at least one input that matches one of the specified types\n            output_types: each operation must have at least one output that matches one of the specified types\n            operation_types: only include operations of the specified type(s)\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            python_packages: only include operations that are contained in one of the provided python packages\n        Returns:\n            a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value\n        \"\"\"\n\n        if operation_types:\n            if isinstance(operation_types, str):\n                operation_types = [operation_types]\n            temp: Dict[str, Operation] = {}\n            for op_type_name in operation_types:\n                op_type = self.context.operation_registry.operation_types.get(\n                    op_type_name, None\n                )\n                if op_type is None:\n                    raise Exception(f\"Operation type not registered: {op_type_name}\")\n\n                temp.update(op_type.operations)\n            operations: Mapping[str, Operation] = temp\n        else:\n            operations = self.context.operation_registry.operations\n\n        if filter:\n            if isinstance(filter, str):\n                filter = [filter]\n            temp = {}\n            for op_id, op in operations.items():\n                match = True\n                for f in filter:\n                    if not f:\n                        continue\n                    if f.lower() not in op_id.lower():\n                        match = False\n                        break\n                if match:\n                    temp[op_id] = op\n            operations = temp\n\n        if not include_internal:\n            temp = {}\n            for op_id, op in operations.items():\n                if not op.operation_details.is_internal_operation:\n                    temp[op_id] = op\n\n            operations = temp\n\n        if input_types:\n            if isinstance(input_types, str):\n                input_types = [input_types]\n            temp = {}\n            for op_id, op in operations.items():\n                for input_type in input_types:\n                    match = False\n                    for schema in op.inputs_schema.values():\n                        if schema.type == input_type:\n                            temp[op_id] = op\n                            match = True\n                            break\n                    if match:\n                        break\n\n            operations = temp\n\n        if output_types:\n            if isinstance(output_types, str):\n                output_types = [output_types]\n            temp = {}\n            for op_id, op in operations.items():\n                for output_type in output_types:\n                    match = False\n                    for schema in op.outputs_schema.values():\n                        if schema.type == output_type:\n                            temp[op_id] = op\n                            match = True\n                            break\n                    if match:\n                        break\n\n            operations = temp\n\n        if python_packages:\n            temp = {}\n            if isinstance(python_packages, str):\n                python_packages = [python_packages]\n            for op_id, op in operations.items():\n                info = OperationInfo.create_from_instance(\n                    kiara=self.context, instance=op\n                )\n                pkg = info.context.labels.get(\"package\", None)\n                if pkg in python_packages:\n                    temp[pkg] = op\n            operations = temp\n\n        return operations\n\n    def retrieve_operation_info(\n        self, operation: str, allow_external: bool = False\n    ) -&gt; OperationInfo:\n\"\"\"Return the full information for the specified operation id.\n\n        This is similar to the 'get_operation' method, but returns additional information. Only use this instead of\n        'get_operation' if you need the additional info, as it's more expensive to get.\n\n        Arguments:\n            operation: the operation id\n\n        Returns:\n            augmented operation instance data\n        \"\"\"\n\n        if not allow_external:\n            op = self.context.operation_registry.get_operation(operation_id=operation)\n        else:\n            op = create_operation(module_or_operation=operation)\n        op_info = OperationInfo.create_from_operation(kiara=self.context, operation=op)\n        return op_info\n\n    def retrieve_operations_info(\n        self,\n        *filters,\n        input_types: Union[str, Iterable[str], None] = None,\n        output_types: Union[str, Iterable[str], None] = None,\n        operation_types: Union[str, Iterable[str], None] = None,\n        python_packages: Union[str, Iterable[str], None] = None,\n        include_internal: bool = False,\n    ) -&gt; OperationGroupInfo:\n\"\"\"Retrieve information about the matching operations.\n\n        This retrieves the same list of operations as [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations],\n        but augments each result instance with additional information that might be useful in frontends.\n\n        'OperationInfo' objects contains augmented information on top of what 'normal' [Operation][kiara.models.module.operation.Operation] objects\n        hold, but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations] method\n        instead.\n\n        Arguments:\n            filters: the (optional) filter strings, an operation must match all of them to be included in the result\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            output_types: each operation must have at least one output that matches one of the specified types\n            operation_types: only include operations of the specified type(s)\n            include_internal: whether to include operations that are predominantly used internally in kiara.\n            python_packages: only include operations that are contained in one of the provided python packages\n        Returns:\n            a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value\n        \"\"\"\n\n        title = \"Available operations\"\n        if filters:\n            title = \"Filtered operations\"\n\n        operations = self.list_operations(\n            filters,\n            input_types=input_types,\n            output_types=output_types,\n            include_internal=include_internal,\n            operation_types=operation_types,\n            python_packages=python_packages,\n        )\n\n        ops_info = OperationGroupInfo.create_from_operations(\n            kiara=self.context, group_title=title, **operations\n        )\n        return ops_info\n\n    # ==================================================================================================================\n    # methods relating to pipelines\n    def register_pipeline(\n        self,\n        data: Union[Path, str, Mapping[str, Any]],\n        operation_id: Union[str, None] = None,\n    ) -&gt; Operation:\n\"\"\"Register a pipelne as new operation into this context.\n\n        Arguments:\n            data: a dict or a path to a json/yaml file containing the definition\n            operation_id: the id to use for the operation (if not specified, the id will be auto-determined)\n\n        Returns:\n            the assembled operation\n        \"\"\"\n\n        return self.context.operation_registry.register_pipeline(\n            data=data, operation_id=operation_id\n        )\n\n    def register_pipelines(\n        self, *pipeline_paths: Union[str, Path]\n    ) -&gt; Dict[str, Operation]:\n\"\"\"Register all pipelines found in the specified paths.\"\"\"\n\n        return self.context.operation_registry.register_pipelines(*pipeline_paths)\n\n    # ==================================================================================================================\n    # methods relating to values and data\n\n    def register_data(\n        self,\n        data: Any,\n        data_type: Union[None, str] = None,\n        reuse_existing: bool = False,\n    ) -&gt; Value:\n\"\"\"Register data with kiara.\n\n        This will create a new value instance from the data and return it. The data/value itself won't be stored\n        in a store, you have to use the 'store_value' function for that.\n\n        Arguments:\n            data: the data to register\n            data_type: (optional) the data type of the data. If not provided, kiara will try to infer the data type.\n            reuse_existing: whether to re-use an existing value that is already registered and has the same hash.\n\n        Returns:\n            a [kiara.models.values.value.Value] instance\n        \"\"\"\n\n        if data_type is None:\n            raise NotImplementedError(\n                \"Infering data types not implemented yet. Please provide one manually.\"\n            )\n\n        value = self.context.data_registry.register_data(\n            data=data, schema=data_type, reuse_existing=reuse_existing\n        )\n        return value\n\n    def list_value_ids(self, **matcher_params) -&gt; List[uuid.UUID]:\n\"\"\"List all available value ids for this kiara context.\n\n        This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n        having to look up the details of each value (like [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n        does). This method can also be used with a matcher, but in this case the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n        would be preferable in most cases, because it is called under the hood, and the performance advantage of not\n        having to look up value details is gone.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a list of value ids\n        \"\"\"\n\n        if matcher_params:\n            values = self.list_values(**matcher_params)\n            return sorted(values.keys())\n        else:\n            _values = self.context.data_registry.retrieve_all_available_value_ids()\n            return sorted(_values)\n\n    def list_values(self, **matcher_params: Any) -&gt; Dict[uuid.UUID, Value]:\n\"\"\"List all available values, optionally filter.\n\n        Retrieve information about all values that are available in the current kiara context session (both stored\n        and non-stored).\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n        \"\"\"\n\n        if matcher_params:\n            matcher = ValueMatcher.create_matcher(**matcher_params)\n\n            values = self.context.data_registry.find_values(matcher=matcher)\n        else:\n            # TODO: make that parallel?\n            values = {\n                k: self.context.data_registry.get_value(k)\n                for k in self.context.data_registry.retrieve_all_available_value_ids()\n            }\n\n        return values\n\n    def get_value(self, value: Union[str, Value, uuid.UUID]) -&gt; Value:\n\"\"\"Retrieve a value instance with the specified id or alias.\n\n        Raises an exception if no value could be found.\n\n        Arguments:\n            value: a value id, alias or object that has a 'value_id' attribute.\n\n        Returns:\n            the Value instance\n        \"\"\"\n\n        return self.context.data_registry.get_value(value=value)\n\n    def retrieve_value_info(self, value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo:\n\"\"\"Retrieve an info object for a value.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.get_value] method\n        instead.\n\n        Arguments:\n            value: a value id, alias or object that has a 'value_id' attribute.\n\n        Returns:\n            the ValueInfo instance\n\n        \"\"\"\n\n        _value = self.get_value(value=value)\n        return ValueInfo.create_from_instance(kiara=self.context, instance=_value)\n\n    def retrieve_values_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n        This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n        but augments each result value instance with additional information that might be useful in frontends.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values] method\n        instead.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n        \"\"\"\n\n        values = self.list_values(**matcher_params)\n\n        infos = ValuesInfo.create_from_instances(\n            kiara=self.context, instances={str(k): v for k, v in values.items()}\n        )\n        return infos  # type: ignore\n\n    def list_alias_names(self, **matcher_params) -&gt; List[str]:\n\"\"\"List all available alias keys.\n\n        This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n        having to look up the details of each value (like [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n        does). This method can also be used with a matcher, but in this case the [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n        would be preferrable in most cases, because it is called under the hood, and the performance advantage of not\n        having to look up value details is gone.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a list of value ids\n        \"\"\"\n\n        if matcher_params:\n            values = self.list_aliases(**matcher_params)\n            return list(values.keys())\n        else:\n            _values = self.context.alias_registry.all_aliases\n            return list(_values)\n\n    def list_aliases(self, **matcher_params) -&gt; Dict[str, Value]:\n\"\"\"List all available values that have an alias assigned, optionally filter.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n        \"\"\"\n\n        if matcher_params:\n            matcher_params[\"has_alias\"] = True\n            all_values = self.list_values(**matcher_params)\n            result: Dict[str, Value] = {}\n            for value in all_values.values():\n                aliases = self.context.alias_registry.find_aliases_for_value_id(\n                    value_id=value.value_id\n                )\n                for a in aliases:\n                    if a in result.keys():\n                        raise Exception(\n                            f\"Duplicate value alias '{a}': this is most likely a bug.\"\n                        )\n                    result[a] = value\n\n            result = {k: result[k] for k in sorted(result.keys())}\n        else:\n            # faster if not other matcher params\n            all_aliases = self.context.alias_registry.all_aliases\n            result = {\n                k: self.context.data_registry.get_value(f\"alias:{k}\")\n                for k in all_aliases\n            }\n\n        return result\n\n    def retrieve_aliases_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n        This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n        but augments each result value instance with additional information that might be useful in frontends.\n\n        'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n        hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n        of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.list_aliases] method\n        instead.\n\n        Arguments:\n            matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n        Returns:\n            a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n        \"\"\"\n\n        values = self.list_aliases(**matcher_params)\n\n        infos = ValuesInfo.create_from_instances(\n            kiara=self.context, instances={str(k): v for k, v in values.items()}\n        )\n        return infos  # type: ignore\n\n    def assemble_value_map(\n        self,\n        values: Mapping[str, Union[uuid.UUID, None, str, Value]],\n        values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n        register_data: bool = False,\n        reuse_existing_data: bool = False,\n    ) -&gt; ValueMap:\n\"\"\"Retrive a [ValueMap][TODO] object from the provided value ids or value links.\n\n        By default, this method can only use values/datasets that are already registered in *kiara*. If you want to\n        auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.\n\n        Arguments:\n            values: a dictionary with the values in question\n            values_schema: an optional dictionary with the schema for each of the values that are not yet registered\n            register_data: whether to allow auto-registration of 'raw' data\n            reuse_existing_data: whether to reuse existing data with the same hash as the 'raw' data that is being registered\n\n        Returns:\n            a value map instance\n        \"\"\"\n\n        if register_data:\n            temp: Dict[str, Union[str, Value, uuid.UUID, None]] = {}\n            for k, v in values.items():\n\n                if isinstance(v, (Value, uuid.UUID)):\n                    temp[k] = v\n                    continue\n\n                if isinstance(v, str):\n                    try:\n                        v = uuid.UUID(v)\n                        temp[k] = v\n                        continue\n                    except Exception:\n                        if v.startswith(\"alias:\"):  # type: ignore\n                            _v = v.replace(\"alias:\", \"\")  # type: ignore\n                        else:\n                            _v = v\n                        if _v in self.list_aliases():\n                            temp[k] = f\"alias:{_v}\"\n                            continue\n\n                if not values_schema:\n                    raise Exception(\n                        f\"Can't assemble value map field without schema: '{k}' -- {str(v)}\"\n                    )\n\n                if k not in values_schema.keys():\n                    raise Exception(\n                        f\"Can't assemble value map field without schema key: '{k}' -- {str(v)}\"\n                    )\n\n                if v is None:\n                    temp[k] = None\n                else:\n                    _v = self.register_data(\n                        data=v,\n                        data_type=values_schema[k].type,\n                        reuse_existing=reuse_existing_data,\n                    )\n                    temp[k] = _v\n            values = temp\n\n        return self.context.data_registry.load_values(\n            values=values, values_schema=values_schema\n        )\n\n    def store_value(\n        self,\n        value: Union[str, uuid.UUID, Value],\n        alias: Union[str, Iterable[str], None],\n        allow_overwrite: bool = True,\n    ) -&gt; StoreValueResult:\n\"\"\"Store the specified value in the (default) value store.\n\n        Arguments:\n            value: the value (or a reference to it)\n            alias: (Optional) aliases for the value\n            allow_overwrite: whether to allow overwriting existing aliases\n        \"\"\"\n\n        if isinstance(alias, str):\n            alias = [alias]\n\n        value_obj = self.get_value(value)\n        persisted_data: Union[None, PersistedData] = None\n        try:\n            persisted_data = self.context.data_registry.store_value(value=value_obj)\n            if alias:\n                self.context.alias_registry.register_aliases(\n                    value_obj.value_id, *alias, allow_overwrite=allow_overwrite\n                )\n            result = StoreValueResult.construct(\n                value=value_obj,\n                aliases=sorted(alias) if alias else [],\n                error=None,\n                persisted_data=persisted_data,\n            )\n        except Exception as e:\n            log_exception(e)\n            result = StoreValueResult.construct(\n                value=value_obj,\n                aliases=sorted(alias) if alias else [],\n                error=str(e),\n                persisted_data=persisted_data,\n            )\n\n        return result\n\n    def store_values(\n        self,\n        values: Mapping[str, Union[str, uuid.UUID, Value]],\n        alias_map: Mapping[str, Iterable[str]],\n    ) -&gt; StoreValuesResult:\n\"\"\"Store multiple values into the (default) kiara value store.\n\n        Values are identified by unique keys in both input arguments, the alias map references the key that is used in\n        the 'values' argument.\n\n        Arguments:\n            values: a map of value keys/values\n            alias_map: a map of value keys aliases\n\n        Returns:\n            an object outlining which values (identified by the specified value key) where stored and how\n        \"\"\"\n\n        result = {}\n        for field_name, value in values.items():\n            aliases = alias_map.get(field_name)\n            value_obj = self.get_value(value)\n            store_result = self.store_value(value=value_obj, alias=aliases)\n            result[field_name] = store_result\n\n        return StoreValuesResult.construct(__root__=result)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # operation-related methods\n\n    def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType:\n\"\"\"Get the management object for the specified operation type.\"\"\"\n\n        return self.context.operation_registry.get_operation_type(op_type=op_type)\n\n    def retrieve_operation_type_info(\n        self, op_type: Union[str, Type[OP_TYPE]]\n    ) -&gt; OperationTypeInfo:\n\"\"\"Get an info object for the specified operation type.\"\"\"\n\n        _op_type = self.get_operation_type(op_type=op_type)\n        return OperationTypeInfo.create_from_type_class(\n            kiara=self.context, type_cls=_op_type.__class__\n        )\n\n    def find_operation_id(\n        self, module_type: str, module_config: Union[None, Mapping[str, Any]] = None\n    ) -&gt; Union[None, str]:\n\"\"\"Try to find the registered operation id for the specified module type and configuration.\n\n        Arguments:\n            module_type: the module type\n            module_config: the module configuration\n\n        Returns:\n            the registered operation id, if found, or None\n        \"\"\"\n\n        manifest = self.context.create_manifest(\n            module_or_operation=module_type, config=module_config\n        )\n        return self.context.operation_registry.find_operation_id(manifest=manifest)\n\n    def assemble_filter_pipeline_config(\n        self,\n        data_type: str,\n        filters: Union[str, Iterable[str], Mapping[str, str]],\n        endpoint: Union[None, Manifest, str] = None,\n        endpoint_input_field: Union[str, None] = None,\n        endpoint_step_id: Union[str, None] = None,\n        extra_input_aliases: Union[None, Mapping[str, str]] = None,\n        extra_output_aliases: Union[None, Mapping[str, str]] = None,\n    ) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n        Optionally, a module that uses the filtered dataset as input can be specified.\n\n        # TODO: document filter names\n        For the 'filters' argument, the accepted inputs are:\n        - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n        - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n        - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n        Arguments:\n            data_type: the type of the data to filter\n            filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n            endpoint: optional module to put as last step in the created pipeline\n            endpoing_input_field: field name of the input that will receive the filtered value\n            endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n            extra_input_aliases: extra output aliases to add to the pipeline config\n            extra_output_aliases: extra output aliases to add to the pipeline config\n\n        Returns:\n            the (pipeline) module configuration of the filter pipeline\n        \"\"\"\n\n        filter_op_type: FilterOperationType = self.context.operation_registry.get_operation_type(\"filter\")  # type: ignore\n        pipeline_config = filter_op_type.assemble_filter_pipeline_config(\n            data_type=data_type,\n            filters=filters,\n            endpoint=endpoint,\n            endpoint_input_field=endpoint_input_field,\n            endpoint_step_id=endpoint_step_id,\n            extra_input_aliases=extra_input_aliases,\n            extra_output_aliases=extra_output_aliases,\n        )\n\n        return pipeline_config\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # render-related methods\n\n    def retrieve_renderer_infos(\n        self, source_type: Union[str, None] = None\n    ) -&gt; RendererInfos:\n\n        if not source_type:\n            renderers = self.context.render_registry.registered_renderers\n        else:\n            renderers = self.context.render_registry.retrieve_renderers_for_source_type(\n                source_type=source_type\n            )\n\n        group = {k.get_renderer_alias(): k for k in renderers}\n        infos = RendererInfos.create_from_instances(kiara=self.context, instances=group)\n        return infos  # type: ignore\n\n    def retrieve_renderers_for(self, source_type: str) -&gt; List[KiaraRenderer]:\n\n        return self.context.render_registry.retrieve_renderers_for_source_type(\n            source_type=source_type\n        )\n\n    def render(\n        self,\n        item: Any,\n        source_type: str,\n        target_type: str,\n        render_config: Union[Mapping[str, Any], None] = None,\n    ) -&gt; Any:\n\n        registry = self.context.render_registry\n        result = registry.render(\n            item=item,\n            source_type=source_type,\n            target_type=target_type,\n            render_config=render_config,\n        )\n        return result\n\n    def assemble_render_pipeline(\n        self,\n        data_type: str,\n        target_format: Union[str, Iterable[str]] = \"string\",\n        filters: Union[None, str, Iterable[str], Mapping[str, str]] = None,\n        use_pretty_print: bool = False,\n    ) -&gt; Operation:\n\"\"\"Create a manifest describing a transformation that renders a value of the specified data type in the target format.\n\n        If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n        the value type of the source value, and the provided target format.\n\n        Arguments:\n            value: the value (or value id)\n            target_format: the format into which to render the value\n            filters: a list of filters to apply to the value before rendering it\n            use_pretty_print: if True, use a 'pretty_print' operation instead of 'render_value'\n\n        Returns:\n            the manifest for the transformation\n        \"\"\"\n\n        if data_type not in self.context.data_type_names:\n            raise DataTypeUnknownException(data_type=data_type)\n\n        if use_pretty_print:\n            pretty_print_op_type: PrettyPrintOperationType = (\n                self.context.operation_registry.get_operation_type(\"pretty_print\")\n            )  # type: ignore\n            ops = pretty_print_op_type.get_target_types_for(data_type)\n        else:\n            render_op_type: RenderValueOperationType = self.context.operation_registry.get_operation_type(\n                # type: ignore\n                \"render_value\"\n            )  # type: ignore\n            ops = render_op_type.get_render_operations_for_source_type(data_type)\n\n        if isinstance(target_format, str):\n            target_format = [target_format]\n\n        match = None\n        for _target_type in target_format:\n            if _target_type not in ops.keys():\n                continue\n            match = ops[_target_type]\n            break\n\n        if not match:\n            if not ops:\n                msg = f\"No render operations registered for source type '{data_type}'.\"\n            else:\n                msg = f\"Registered target types for source type '{data_type}': {', '.join(ops.keys())}.\"\n            raise Exception(\n                f\"No render operation for source type '{data_type}' to target type(s) registered: '{', '.join(target_format)}'. {msg}\"\n            )\n\n        if filters:\n            # filter_op_type: FilterOperationType = self._kiara.operation_registry.get_operation_type(\"filter\")  # type: ignore\n            endpoint = Manifest(\n                module_type=match.module_type, module_config=match.module_config\n            )\n            extra_input_aliases = {\"render_value.render_config\": \"render_config\"}\n            extra_output_aliases = {\n                \"render_value.render_value_result\": \"render_value_result\"\n            }\n            pipeline_config = self.assemble_filter_pipeline_config(\n                data_type=data_type,\n                filters=filters,\n                endpoint=endpoint,\n                endpoint_input_field=\"value\",\n                endpoint_step_id=\"render_value\",\n                extra_input_aliases=extra_input_aliases,\n                extra_output_aliases=extra_output_aliases,\n            )\n            manifest = Manifest(\n                module_type=\"pipeline\", module_config=pipeline_config.dict()\n            )\n            module = self.context.module_registry.create_module(manifest=manifest)\n            operation = Operation.create_from_module(module, doc=pipeline_config.doc)\n        else:\n            operation = match\n\n        return operation\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # job-related methods\n    def queue_manifest(\n        self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job using the provided manifest to describe the module and config that should be executed.\n\n        Arguments:\n            manifest: the manifest\n            inputs: the job inputs (can be either references to values, or raw inputs\n\n        Returns:\n            a result value map instance\n        \"\"\"\n\n        if inputs is None:\n            inputs = {}\n\n        job_config = self.context.job_registry.prepare_job_config(\n            manifest=manifest, inputs=inputs\n        )\n\n        job_id = self.context.job_registry.execute_job(\n            job_config=job_config, wait=False\n        )\n        return job_id\n\n    def run_manifest(\n        self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n    ) -&gt; ValueMap:\n\"\"\"Run a job using the provided manifest to describe the module and config that should be executed.\n\n        Arguments:\n            manifest: the manifest\n            inputs: the job inputs (can be either references to values, or raw inputs\n\n        Returns:\n            a result value map instance\n        \"\"\"\n\n        job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n        return self.context.job_registry.retrieve_result(job_id=job_id)\n\n    def queue_job(\n        self,\n        operation: Union[str, Path, Manifest, OperationInfo],\n        inputs: Mapping[str, Any],\n        operation_config: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; uuid.UUID:\n\"\"\"Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n        This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n        Arguments:\n            operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n            inputs: the operation inputs\n            operation_config: the (optional) module config in case 'operation' is a module name\n\n        Returns:\n            the queued job id\n        \"\"\"\n\n        if isinstance(operation, Path):\n            if not operation.is_file():\n                raise Exception(\n                    f\"Can't queue job from file '{operation.as_posix()}': file does not exist.\"\n                )\n            operation = operation.as_posix()\n        elif isinstance(operation, OperationInfo):\n            operation = operation.operation\n\n        if not isinstance(operation, Manifest):\n            manifest: Manifest = create_operation(\n                module_or_operation=operation,\n                operation_config=operation_config,\n                kiara=self.context,\n            )\n        else:\n            manifest = operation\n\n        job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n        return job_id\n\n    def run_job(\n        self,\n        operation: Union[str, Path, Manifest, OperationInfo],\n        inputs: Union[None, Mapping[str, Any]] = None,\n        operation_config: Union[None, Mapping[str, Any]] = None,\n    ) -&gt; ValueMap:\n\"\"\"Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n        This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n        In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead,\n        since this is a blocking operation.\n\n        Arguments:\n            operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n            inputs: the operation inputs\n            operation_config: the (optional) module config in case 'operation' is a module name\n\n        Returns:\n            the job result value map\n\n        \"\"\"\n\n        if inputs is None:\n            inputs = {}\n        job_id = self.queue_job(\n            operation=operation, inputs=inputs, operation_config=operation_config\n        )\n        return self.context.job_registry.retrieve_result(job_id=job_id)\n\n    def get_job(self, job_id: Union[str, uuid.UUID]) -&gt; ActiveJob:\n\"\"\"Retrieve the status of the job with the provided id.\"\"\"\n\n        if isinstance(job_id, str):\n            job_id = uuid.UUID(job_id)\n\n        job_status = self.context.job_registry.get_job(job_id=job_id)\n        return job_status\n\n    def get_job_result(self, job_id: Union[str, uuid.UUID]) -&gt; ValueMap:\n\"\"\"Retrieve the result(s) of the specified job.\"\"\"\n\n        if isinstance(job_id, str):\n            job_id = uuid.UUID(job_id)\n\n        result = self.context.job_registry.retrieve_result(job_id=job_id)\n        return result\n\n    def render_value(\n        self,\n        value: Union[str, uuid.UUID, Value],\n        target_format: Union[str, Iterable[str]] = \"string\",\n        filters: Union[None, Iterable[str], Mapping[str, str]] = None,\n        render_config: Union[Mapping[str, str], None] = None,\n        add_root_scenes: bool = True,\n        use_pretty_print: bool = False,\n    ) -&gt; RenderValueResult:\n\"\"\"Render a value in the specified target format.\n\n        If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n        the value type of the source value, and the provided target format.\n\n        Arguments:\n            value: the value (or value id)\n            target_format: the format into which to render the value\n            filters: an (optional) list of filters\n            render_config: manifest specific render configuration\n            add_root_scenes: add root scenes to the result\n            use_pretty_print: use 'pretty_print' operation instead of 'render_value'\n\n        Returns:\n            the rendered value data, and any related scenes, if applicable\n        \"\"\"\n\n        _value = self.get_value(value)\n        try:\n            render_operation: Union[None, Operation] = self.assemble_render_pipeline(\n                data_type=_value.data_type_name,\n                target_format=target_format,\n                filters=filters,\n                use_pretty_print=use_pretty_print,\n            )\n\n        except Exception as e:\n\n            log_message(\n                \"create_render_pipeline.failure\",\n                source_type=_value.data_type_name,\n                target_format=target_format,\n                error=e,\n            )\n\n            if use_pretty_print:\n                pretty_print_ops: PrettyPrintOperationType = self.context.operation_registry.get_operation_type(\"pretty_print\")  # type: ignore\n                if not isinstance(target_format, str):\n                    raise NotImplementedError(\n                        \"Can't handle multiple target formats for 'render_value' yet.\"\n                    )\n                render_operation = (\n                    pretty_print_ops.get_operation_for_render_combination(\n                        source_type=\"any\", target_type=target_format\n                    )\n                )\n            else:\n                render_ops: RenderValueOperationType = self.context.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n                if not isinstance(target_format, str):\n                    raise NotImplementedError(\n                        \"Can't handle multiple target formats for 'render_value' yet.\"\n                    )\n                render_operation = render_ops.get_render_operation(\n                    source_type=\"any\", target_type=target_format\n                )\n\n        if render_operation is None:\n            raise Exception(\n                f\"Could not find render operation for value: {_value.value_id}\"\n            )\n\n        if render_config and \"render_config\" in render_config.keys():\n            # raise NotImplementedError()\n            # TODO: is this necessary?\n            render_config = render_config[\"render_config\"]  # type: ignore\n            # manifest_hash = render_config[\"manifest_hash\"]\n            # if manifest_hash != render_operation.manifest_hash:\n            #     raise NotImplementedError(\n            #         \"Using a non-default render operation is not supported (yet).\"\n            #     )\n            # render_config = render_config[\"render_config\"]\n\n        if render_config is None:\n            render_config = {}\n        else:\n            render_config = dict(render_config)\n\n        # render_type = render_config.pop(\"render_type\", None)\n        # if not render_type or render_type == \"data\":\n        #     pass\n        # elif render_type == \"metadata\":\n        #     pass\n        # elif render_type == \"properties\":\n        #     pass\n        # elif render_type == \"lineage\":\n        #     pass\n\n        result = render_operation.run(\n            kiara=self.context,\n            inputs={\"value\": _value, \"render_config\": render_config},\n        )\n\n        if use_pretty_print:\n            render_result: Value = result[\"rendered_value\"]\n            value_render_data = render_result.data\n        else:\n            render_result = result[\"render_value_result\"]\n\n            if render_result.data_type_name != \"render_value_result\":\n                raise Exception(\n                    f\"Invalid result type for render operation: {render_result.data_type_name}\"\n                )\n\n            value_render_data: RenderValueResult = render_result.data  # type: ignore\n\n        return value_render_data\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # workflow-related methods\n\n    def list_workflow_ids(self) -&gt; List[uuid.UUID]:\n\"\"\"List all available workflow ids.\"\"\"\n\n        return list(self.context.workflow_registry.all_workflow_ids)\n\n    def list_workflow_alias_names(self) -&gt; List[str]:\n\"\"\" \"List all available workflow aliases.\"\"\"\n\n        return list(self.context.workflow_registry.workflow_aliases.keys())\n\n    def get_workflow(\n        self, workflow: Union[str, uuid.UUID], create_if_necessary: bool = True\n    ) -&gt; Workflow:\n\"\"\"Retrieve the workflow instance with the specified id or alias.\"\"\"\n\n        no_such_alias: bool = False\n        workflow_id: Union[uuid.UUID, None] = None\n        workflow_alias: Union[str, None] = None\n\n        if isinstance(workflow, str):\n            try:\n                workflow_id = uuid.UUID(workflow)\n            except Exception:\n                workflow_alias = workflow\n                try:\n                    workflow_id = self.context.workflow_registry.get_workflow_id(\n                        workflow_alias=workflow\n                    )\n                except NoSuchWorkflowException:\n                    no_such_alias = True\n        else:\n            workflow_id = workflow\n\n        if workflow_id is None:\n            raise Exception(f\"Can't retrieve workflow for: {workflow}\")\n\n        if workflow_id in self._workflow_cache.keys():\n            return self._workflow_cache[workflow_id]\n\n        if workflow_id is None and not create_if_necessary:\n            if not no_such_alias:\n                msg = f\"No workflow with id '{workflow}' registered.\"\n            else:\n                msg = f\"No workflow with alias '{workflow}' registered.\"\n\n            raise NoSuchWorkflowException(workflow=workflow, msg=msg)\n\n        if workflow_id:\n            # workflow_metadata = self.context.workflow_registry.get_workflow_metadata(\n            #     workflow=workflow_id\n            # )\n            workflow_obj = Workflow(kiara=self.context, workflow=workflow_id)\n            self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n        else:\n            # means we need to create it\n            workflow_obj = self.create_workflow(workflow_alias=workflow_alias)\n\n        return workflow_obj\n\n    def retrieve_workflow_info(self, workflow: Union[str, uuid.UUID, Workflow]):\n\n        if isinstance(workflow, Workflow):\n            _workflow: Workflow = workflow\n        else:\n            _workflow = self.get_workflow(workflow)\n\n        return WorkflowInfo.create_from_workflow(workflow=_workflow)\n\n    def list_workflows(self, **matcher_params) -&gt; Mapping[uuid.UUID, Workflow]:\n\"\"\"List all available workflow sessions, indexed by their unique id.\"\"\"\n\n        workflows = {}\n\n        matcher = WorkflowMatcher(**matcher_params)\n        if matcher.has_alias:\n            for (\n                alias,\n                workflow_id,\n            ) in self.context.workflow_registry.workflow_aliases.items():\n\n                workflow = self.get_workflow(workflow=workflow_id)\n                workflows[workflow.workflow_id] = workflow\n            return workflows\n        else:\n            for workflow_id in self.context.workflow_registry.all_workflow_ids:\n                workflow = self.get_workflow(workflow=workflow_id)\n                workflows[workflow_id] = workflow\n            return workflows\n\n    def list_workflow_aliases(self, **matcher_params) -&gt; Dict[str, Workflow]:\n\"\"\"List all available workflow sessions that have an alias, indexed by alias.\"\"\"\n\n        if matcher_params:\n            matcher_params[\"has_alias\"] = True\n            workflows = self.list_workflows(**matcher_params)\n            result: Dict[str, Workflow] = {}\n            for workflow in workflows.values():\n                aliases = self.context.workflow_registry.get_aliases(\n                    workflow_id=workflow.workflow_id\n                )\n                for a in aliases:\n                    if a in result.keys():\n                        raise Exception(\n                            f\"Duplicate workflow alias '{a}': this is most likely a bug.\"\n                        )\n                    result[a] = workflow\n            result = {k: result[k] for k in sorted(result.keys())}\n        else:\n            # faster if not other matcher params\n            all_aliases = self.context.workflow_registry.workflow_aliases\n            result = {\n                a: self.get_workflow(workflow=all_aliases[a])\n                for a in sorted(all_aliases.keys())\n            }\n        return result\n\n    def retrieve_workflows_info(self, **matcher_params: Any) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by (stringified) workflow-id.\"\"\"\n\n        workflows = self.list_workflows(**matcher_params)\n\n        workflow_infos = WorkflowGroupInfo.create_from_workflows(\n            *workflows.values(),\n            group_title=None,\n            alias_map=self.context.workflow_registry.workflow_aliases,\n        )\n        return workflow_infos\n\n    def retrieve_workflow_aliases_info(\n        self, **matcher_params: Any\n    ) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by alias.\"\"\"\n\n        workflows = self.list_workflow_aliases(**matcher_params)\n        workflow_infos = WorkflowGroupInfo.create_from_workflows(\n            *workflows.values(),\n            group_title=None,\n            alias_map=self.context.workflow_registry.workflow_aliases,\n        )\n        return workflow_infos\n\n    def create_workflow(\n        self,\n        workflow_alias: Union[None, str] = None,\n        initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None,\n        initial_inputs: Union[None, Mapping[str, Any]] = None,\n        documentation: Union[Any, None] = None,\n        save: bool = False,\n        force_alias: bool = False,\n    ) -&gt; Workflow:\n\n        if workflow_alias is not None:\n            try:\n                uuid.UUID(workflow_alias)\n                raise Exception(\n                    f\"Can't create workflow, provided alias can't be a uuid: {workflow_alias}.\"\n                )\n            except Exception:\n                pass\n\n        workflow_id = ID_REGISTRY.generate()\n        metadata = WorkflowMetadata(\n            workflow_id=workflow_id, documentation=documentation\n        )\n\n        workflow_obj = Workflow(kiara=self.context, workflow=metadata)\n        if workflow_alias:\n            workflow_obj._pending_aliases.add(workflow_alias)\n\n        if initial_pipeline:\n            operation = self.get_operation(operation=initial_pipeline)\n            if operation.module_type == \"pipeline\":\n                pipeline_details: PipelineOperationDetails = operation.operation_details  # type: ignore\n                workflow_obj.add_steps(*pipeline_details.pipeline_config.steps)\n                input_aliases = pipeline_details.pipeline_config.input_aliases\n                for k, v in input_aliases.items():\n                    workflow_obj.set_input_alias(input_field=k, alias=v)\n                output_aliases = pipeline_details.pipeline_config.output_aliases\n                for k, v in output_aliases.items():\n                    workflow_obj.set_output_alias(output_field=k, alias=v)\n            else:\n                raise NotImplementedError()\n\n            workflow_obj.set_inputs(**operation.module.config.defaults)\n\n        if initial_inputs:\n            workflow_obj.set_inputs(**initial_inputs)\n\n        self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n\n        if save:\n            if force_alias and workflow_alias:\n                self.context.workflow_registry.unregister_alias(workflow_alias)\n            workflow_obj.save()\n\n        return workflow_obj\n\n    def _repr_html_(self):\n\n        info = self.get_context_info()\n        r = info.create_renderable()\n        mime_bundle = r._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n        return mime_bundle[\"text/html\"]\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.doc","title":"<code>doc: Dict[str, str]</code>  <code>property</code> <code>cached</code>","text":"<p>Get the documentation for this API.</p>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.context","title":"<code>context: Kiara</code>  <code>property</code>","text":"<p>Return the kiara context.</p> <p>DON\"T USE THIS! This is going away in the production release.</p>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.instance","title":"<code>instance() -&gt; KiaraAPI</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>@classmethod\ndef instance(\n    cls,\n) -&gt; \"KiaraAPI\":\n\n    if cls._instance is not None:\n        return cls._instance\n\n    from kiara.context import KiaraConfig\n\n    config = KiaraConfig()\n\n    api = KiaraAPI(kiara_config=config)\n    cls._instance = api\n    return api\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_runtime_config","title":"<code>get_runtime_config() -&gt; KiaraRuntimeConfig</code>","text":"<p>Retrieve the current runtime configuration.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_runtime_config(self) -&gt; \"KiaraRuntimeConfig\":\n\"\"\"Retrieve the current runtime configuration.\"\"\"\n    return self.context.runtime_config\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_context_info","title":"<code>get_context_info() -&gt; ContextInfo</code>","text":"<p>Retrieve information about the current kiara context.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_context_info(self) -&gt; ContextInfo:\n\"\"\"Retrieve information about the current kiara context.\"\"\"\n\n    context_config = self._kiara_config.get_context_config(\n        self.get_current_context_name()\n    )\n    info = ContextInfo.create_from_context_config(\n        context_config,\n        context_name=self.get_current_context_name(),\n        runtime_config=self._kiara_config.runtime_config,\n    )\n\n    return info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.ensure_plugin_packages","title":"<code>ensure_plugin_packages(package_names: Union[str, Iterable[str]], update: bool = False) -&gt; Union[bool, None]</code>","text":"<p>Ensure that the specified packages are installed.</p> <p>Parameters:</p> Name Type Description Default <code>package_names</code> <code>Union[str, Iterable[str]]</code> <p>The names of the packages to install.</p> required <code>update</code> <code>bool</code> <p>If True, update the packages if they are already installed</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[bool, None]</code> <p>'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def ensure_plugin_packages(\n    self, package_names: Union[str, Iterable[str]], update: bool = False\n) -&gt; Union[bool, None]:\n\"\"\"Ensure that the specified packages are installed.\n\n    Arguments:\n      package_names: The names of the packages to install.\n      update: If True, update the packages if they are already installed\n\n    Returns:\n        'None' if run in jupyter, 'True' if any packages were installed, 'False' otherwise.\n    \"\"\"\n\n    if isinstance(package_names, str):\n        package_names = [package_names]\n\n    env_reg = EnvironmentRegistry.instance()\n    python_env: PythonRuntimeEnvironment = env_reg.environments[  # type: ignore\n        \"python\"\n    ]  # type: ignore\n\n    if not package_names:\n        package_names = OFFICIAL_KIARA_PLUGINS  # type: ignore\n\n    if not update:\n        plugin_packages: List[str] = []\n        pkgs = [p.name.replace(\"_\", \"-\") for p in python_env.packages]\n        for package_name in package_names:\n            if package_name.startswith(\"git:\"):\n                package_name = package_name.replace(\"git:\", \"\")\n                git = True\n            else:\n                git = False\n            package_name = package_name.replace(\"_\", \"-\")\n            if not package_name.startswith(\"kiara-plugin.\"):\n                package_name = f\"kiara-plugin.{package_name}\"\n\n            if git or package_name.replace(\"_\", \"-\") not in pkgs:\n                if git:\n                    package_name = package_name.replace(\"-\", \"_\")\n                    plugin_packages.append(\n                        f\"git+https://x:x@github.com/DHARPA-project/{package_name}@develop\"\n                    )\n                else:\n                    plugin_packages.append(package_name)\n    else:\n        plugin_packages = package_names  # type: ignore\n\n    in_jupyter = \"google.colab\" in sys.modules or \"jupyter_client\" in sys.modules\n\n    if not plugin_packages:\n        if in_jupyter:\n            return None\n        else:\n            # nothing to do\n            return False\n\n    class DummyContext(object):\n        def __getattribute__(self, item):\n            raise Exception(\n                \"Currently installing plugins, no other operations are allowed.\"\n            )\n\n    current_context_name = self._current_context_alias\n    for k in self._contexts.keys():\n        self._contexts[k] = DummyContext()  # type: ignore\n    self._current_context = DummyContext()  # type: ignore\n\n    cmd = [\"-q\", \"--isolated\", \"install\"]\n    if update:\n        cmd.append(\"--upgrade\")\n    cmd.extend(plugin_packages)\n\n    if in_jupyter:\n        from IPython import get_ipython\n\n        ipython = get_ipython()\n        cmd_str = f\"sc -l stdout = {sys.executable} -m pip {' '.join(cmd)}\"\n        ipython.magic(cmd_str)\n        exit_code = 100\n    else:\n        import pip._internal.cli.main as pip\n\n        log_message(\n            \"install.python_packages\", packages=plugin_packages, update=update\n        )\n        exit_code = pip.main(cmd)\n\n    self._contexts.clear()\n    self._current_context = None\n    self._current_context_alias = None\n\n    EnvironmentRegistry._instance = None\n    if current_context_name:\n        self.set_active_context(context_name=current_context_name)\n\n    if exit_code == 100:\n        raise SystemExit(\n            f\"Please manually re-run all cells. Updated or newly installed plugin packages: {', '.join(plugin_packages)}.\"\n        )\n    elif exit_code != 0:\n        raise Exception(\n            f\"Failed to install plugin packages: {', '.join(plugin_packages)}\"\n        )\n\n    return True\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_context_names","title":"<code>list_context_names() -&gt; List[str]</code>","text":"<p>list the names of all available/registered contexts.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_context_names(self) -&gt; List[str]:\n\"\"\"list the names of all available/registered contexts.\"\"\"\n\n    return list(self._kiara_config.available_context_names)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_context_infos","title":"<code>retrieve_context_infos() -&gt; ContextInfos</code>","text":"<p>Retrieve information about the available/registered contexts.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_context_infos(self) -&gt; ContextInfos:\n\"\"\"Retrieve information about the available/registered contexts.\"\"\"\n\n    return ContextInfos.create_context_infos(self._kiara_config.context_configs)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_current_context_name","title":"<code>get_current_context_name() -&gt; str</code>","text":"<p>Retrieve the name fo the current context.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_current_context_name(self) -&gt; str:\n\"\"\"Retrieve the name fo the current context.\"\"\"\n\n    if self._current_context_alias is None:\n        self.context\n    return self._current_context_alias  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.create_new_context","title":"<code>create_new_context(context_name: str, set_active: bool) -&gt; None</code>","text":"<p>Create a new context.</p> <p>Parameters:</p> Name Type Description Default <code>context_name</code> <code>str</code> <p>the name of the new context</p> required <code>set_active</code> <code>bool</code> <p>set the newly created context as the active one</p> required Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_new_context(self, context_name: str, set_active: bool) -&gt; None:\n\"\"\"Create a new context.\n\n    Arguments:\n        context_name: the name of the new context\n        set_active: set the newly created context as the active one\n    \"\"\"\n\n    if context_name in self.list_context_names():\n        raise Exception(\n            f\"Can't create context with name '{context_name}': context already exists.\"\n        )\n\n    ctx = self._kiara_config.create_context(context_name, extra_pipelines=None)\n    if set_active:\n        self._current_context = ctx\n        self._current_context_alias = context_name\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.set_active_context","title":"<code>set_active_context(context_name: str, create: bool = False) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def set_active_context(self, context_name: str, create: bool = False) -&gt; None:\n\n    if not context_name:\n        raise Exception(\"No context name provided.\")\n\n    if context_name == self._current_context_alias:\n        return\n    if context_name not in self.list_context_names():\n        if create:\n            self._current_context = self._kiara_config.create_context(\n                context=context_name, extra_pipelines=None\n            )\n            self._current_context_alias = context_name\n            return\n        else:\n            raise Exception(f\"No context with name '{context_name}' available.\")\n\n    self._current_context = self._kiara_config.create_context(\n        context=context_name, extra_pipelines=None\n    )\n    self._current_context_alias = context_name\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_data_type_names","title":"<code>list_data_type_names() -&gt; List[str]</code>","text":"<p>Get a list of all registered data types.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_data_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered data types.\"\"\"\n\n    return self.context.type_registry.data_type_names\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.is_internal_data_type","title":"<code>is_internal_data_type(data_type_name: str) -&gt; bool</code>","text":"<p>Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def is_internal_data_type(self, data_type_name: str) -&gt; bool:\n\"\"\"Checks if the data type is repdominantly used internally by kiara, or whether it should be exposed to the user.\"\"\"\n\n    return self.context.type_registry.is_internal_type(\n        data_type_name=data_type_name\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_data_types_info","title":"<code>retrieve_data_types_info(filter: Union[str, Iterable[str], None]) -&gt; DataTypeClassesInfo</code>","text":"<p>Retrieve information about all data types.</p> <p>A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, Iterable[str], None]</code> <p>an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)</p> required <p>Returns:</p> Type Description <code>DataTypeClassesInfo</code> <p>an object containing all information about all data types</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_data_types_info(\n    self, filter: Union[str, Iterable[str], None]\n) -&gt; DataTypeClassesInfo:\n\"\"\"Retrieve information about all data types.\n\n    A data type is a Python class that inherits from [DataType[kiara.data_types.DataType], and it wraps a specific\n    Python class that holds the actual data and provides metadata and convenience methods for managing the data internally. Data types are not directly used by users, but they are exposed in the input/output schemas of moudles and other data-related features.\n\n    Arguments:\n        filter: an optional string or (list of strings) the returned datatype ids have to match (all filters in the case of a list)\n\n    Returns:\n        an object containing all information about all data types\n    \"\"\"\n\n    if filter:\n        if isinstance(filter, str):\n            filter = [filter]\n\n        title = f\"Filtered data_types: {filter}\"\n        data_type_names: Iterable[str] = []\n\n        for m in self.context.type_registry.data_type_names:\n            match = True\n\n            for f in filter:\n\n                if f.lower() not in m.lower():\n                    match = False\n                    break\n\n            if match:\n                data_type_names.append(m)  # type: ignore\n    else:\n        title = \"All data types\"\n        data_type_names = self.context.type_registry.data_type_names\n\n    data_types = {\n        d: self.context.type_registry.get_data_type_cls(d) for d in data_type_names\n    }\n    data_types_info = DataTypeClassesInfo.create_from_type_items(\n        kiara=self.context, group_title=title, **data_types\n    )\n\n    return data_types_info  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_data_type_info","title":"<code>retrieve_data_type_info(data_type_name: str) -&gt; DataTypeClassInfo</code>","text":"<p>Retrieve information about a specific data type.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <p>the registered name of the data type</p> required <p>Returns:</p> Type Description <code>DataTypeClassInfo</code> <p>an object containing all information about a data type</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_data_type_info(self, data_type_name: str) -&gt; DataTypeClassInfo:\n\"\"\"Retrieve information about a specific data type.\n\n    Arguments:\n        data_type: the registered name of the data type\n\n    Returns:\n        an object containing all information about a data type\n    \"\"\"\n\n    dt_cls = self.context.type_registry.get_data_type_cls(data_type_name)\n    info = DataTypeClassInfo.create_from_type_class(\n        kiara=self.context, type_cls=dt_cls\n    )\n    return info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_module_type_names","title":"<code>list_module_type_names() -&gt; List[str]</code>","text":"<p>Get a list of all registered module types.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_module_type_names(self) -&gt; List[str]:\n\"\"\"Get a list of all registered module types.\"\"\"\n\n    return list(self.context.module_registry.get_module_type_names())\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_module_types_info","title":"<code>retrieve_module_types_info(filter: Union[None, str, Iterable[str]] = None) -&gt; ModuleTypesInfo</code>","text":"<p>Retrieve information for all available module types (or a filtered subset thereof).</p> <p>A module type is Python class that inherits from KiaraModule, and is the basic building block for processing pipelines. Module types are not used directly by users, Operations are. Operations  are instantiated modules (meaning: the module &amp; some (optional) configuration).</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[None, str, Iterable[str]]</code> <p>an optional string (or list of string) the returned module names have to match (all filters in case of list)</p> <code>None</code> <p>Returns:</p> Type Description <code>ModuleTypesInfo</code> <p>a mapping object containing module names as keys, and information about the modules as values</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_module_types_info(\n    self, filter: Union[None, str, Iterable[str]] = None\n) -&gt; ModuleTypesInfo:\n\"\"\"Retrieve information for all available module types (or a filtered subset thereof).\n\n    A module type is Python class that inherits from [KiaraModule][kiara.modules.KiaraModule], and is the basic\n    building block for processing pipelines. Module types are not used directly by users, Operations are. Operations\n     are instantiated modules (meaning: the module &amp; some (optional) configuration).\n\n    Arguments:\n        filter: an optional string (or list of string) the returned module names have to match (all filters in case of list)\n\n    Returns:\n        a mapping object containing module names as keys, and information about the modules as values\n    \"\"\"\n\n    if filter:\n\n        if isinstance(filter, str):\n            filter = [filter]\n        title = f\"Filtered modules: {filter}\"\n        module_types_names: Iterable[str] = []\n\n        for m in self.context.module_registry.get_module_type_names():\n            match = True\n\n            for f in filter:\n\n                if f.lower() not in m.lower():\n                    match = False\n                    break\n\n            if match:\n                module_types_names.append(m)  # type: ignore\n    else:\n        title = \"All modules\"\n        module_types_names = self.context.module_registry.get_module_type_names()\n\n    module_types = {\n        n: self.context.module_registry.get_module_class(n)\n        for n in module_types_names\n    }\n\n    module_types_info = ModuleTypesInfo.create_from_type_items(  # type: ignore\n        kiara=self.context, group_title=title, **module_types\n    )\n    return module_types_info  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_module_type_info","title":"<code>retrieve_module_type_info(module_type: str) -&gt; ModuleTypeInfo</code>","text":"<p>Retrieve information about a specific module type.</p> <p>This can be used to retrieve information like module documentation and configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the registered name of the module</p> required <p>Returns:</p> Type Description <code>ModuleTypeInfo</code> <p>an object containing all information about a module type</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_module_type_info(self, module_type: str) -&gt; ModuleTypeInfo:\n\"\"\"Retrieve information about a specific module type.\n\n    This can be used to retrieve information like module documentation and configuration options.\n\n    Arguments:\n        module_type: the registered name of the module\n\n    Returns:\n        an object containing all information about a module type\n    \"\"\"\n\n    m_cls = self.context.module_registry.get_module_class(module_type)\n    info = ModuleTypeInfo.create_from_type_class(kiara=self.context, type_cls=m_cls)\n    return info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.create_operation","title":"<code>create_operation(module_type: str, module_config: Union[Mapping[str, Any], str, None] = None) -&gt; Operation</code>","text":"<p>Create an Operation instance for the specified module type and (optional) config.</p> <p>This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the registered name of the module</p> required <code>module_config</code> <code>Union[Mapping[str, Any], str, None]</code> <p>(Optional) configuration for the module instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>an Operation instance (which contains all the available information about an instantiated module)</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_operation(\n    self,\n    module_type: str,\n    module_config: Union[Mapping[str, Any], str, None] = None,\n) -&gt; Operation:\n\"\"\"Create an [Operation][kiara.models.module.operation.Operation] instance for the specified module type and (optional) config.\n\n    This can be used to get information about the operation itself, it's inputs &amp; outputs schemas, documentation etc.\n\n    Arguments:\n        module_type: the registered name of the module\n        module_config: (Optional) configuration for the module instance.\n\n    Returns:\n        an Operation instance (which contains all the available information about an instantiated module)\n    \"\"\"\n\n    if module_config is None:\n        module_config = {}\n    elif isinstance(module_config, str):\n        try:\n            module_config = json.load(module_config)  # type: ignore\n        except Exception:\n            try:\n                module_config = yaml.load(module_config)  # type: ignore\n            except Exception:\n                raise Exception(\n                    f\"Can't parse module config string: {module_config}.\"\n                )\n\n    if module_type == \"pipeline\":\n        if not module_config:\n            raise Exception(\"Pipeline configuration can't be empty.\")\n        assert module_config is None or isinstance(module_config, Mapping)\n        operation = create_operation(\"pipeline\", operation_config=module_config)\n        return operation\n    else:\n        mc = Manifest(module_type=module_type, module_config=module_config)\n        module_obj = self.context.module_registry.create_module(mc)\n\n        return module_obj.operation\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_operation_ids","title":"<code>list_operation_ids(filter: Union[str, None, Iterable[str]] = None, include_internal: bool = False) -&gt; List[str]</code>","text":"<p>Get a list of all operation ids that match the specified filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, None, Iterable[str]]</code> <p>an optional single or list of filters (all filters must match the operation id for the operation to be included)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>also return internal operations</p> <code>False</code> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_operation_ids(\n    self,\n    filter: Union[str, None, Iterable[str]] = None,\n    include_internal: bool = False,\n) -&gt; List[str]:\n\"\"\"Get a list of all operation ids that match the specified filter.\n\n    Arguments:\n        filter: an optional single or list of filters (all filters must match the operation id for the operation to be included)\n        include_internal: also return internal operations\n    \"\"\"\n\n    if not filter and include_internal:\n        return sorted(self.context.operation_registry.operation_ids)\n\n    else:\n        return sorted(\n            self.list_operations(\n                filter=filter, include_internal=include_internal\n            ).keys()\n        )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_operation","title":"<code>get_operation(operation: Union[Mapping[str, Any], str, Path], allow_external: Union[bool, None] = None) -&gt; Operation</code>","text":"<p>Return the operation instance with the specified id.</p> <p>This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.</p> <p>The order in which the operation argument is resolved: - if it's a string, and an existing, registered operation_id, the associated operation is returned - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[Mapping[str, Any], str, Path]</code> <p>the operation id, module_type_name, path to a file, or url</p> required <code>allow_external</code> <code>Union[bool, None]</code> <p>if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>operation instance data</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_operation(\n    self,\n    operation: Union[Mapping[str, Any], str, Path],\n    allow_external: Union[bool, None] = None,\n) -&gt; Operation:\n\"\"\"Return the operation instance with the specified id.\n\n    This can be used to get information about a specific operation, like inputs/outputs scheman, documentation, etc.\n\n    The order in which the operation argument is resolved:\n    - if it's a string, and an existing, registered operation_id, the associated operation is returned\n    - if it's a path to an existing file, the content of the file is loaded into a dict and depending on the content a pipeline module will be created, or a 'normal' manifest (if module_type is a key in the dict)\n\n    Arguments:\n        operation: the operation id, module_type_name, path to a file, or url\n        allow_external: if True, allow loading operations from external sources (e.g. a URL), if 'None' is provided, the configured value in the runtime configuration is used.\n\n    Returns:\n        operation instance data\n    \"\"\"\n\n    _module_type = None\n    _module_config = None\n\n    if allow_external is None:\n        allow_external = self.get_runtime_config().allow_external\n\n    if isinstance(operation, Path):\n        operation = operation.as_posix()\n\n    if isinstance(operation, str):\n\n        if operation in self.list_operation_ids(include_internal=True):\n            _operation = self.context.operation_registry.get_operation(operation)\n            return _operation\n\n        if not allow_external:\n            raise NoSuchExecutionTargetException(\n                selected_target=operation,\n                available_targets=self.context.operation_registry.operation_ids,\n                msg=f\"Can't find operation with id '{operation}', and external operations are not allowed.\",\n            )\n\n        if os.path.isfile(operation):\n            try:\n                # we use the 'from_file' here, because that will resolve any relative paths in the pipeline\n                # if this doesn't work, we just assume the file is not a pipeline configuration but\n                # a manifest file with 'module_type' and optional 'module_config' keys\n                pipeline_conf = PipelineConfig.from_file(\n                    path=operation, kiara=self.context\n                )\n                _module_config = pipeline_conf.dict()\n            except Exception as e:\n                log_exception(e)\n                _module_config = get_data_from_file(operation)\n        elif operation.startswith(\"http\"):\n            _module_config = get_data_from_url(operation)\n        else:\n            try:\n                _module_config = json.load(operation)  # type: ignore\n            except Exception:\n                try:\n                    _module_config = yaml.load(operation)  # type: ignore\n                except Exception:\n                    raise Exception(\n                        f\"Can't parse configuration string: {operation}.\"\n                    )\n    else:\n        _module_config = dict(operation)\n\n    if \"module_type\" in _module_config.keys():\n        _module_type = _module_config[\"module_type\"]\n        _module_config = _module_config.get(\"module_config\", {})\n    else:\n        _module_type = \"pipeline\"\n\n    op = self.create_operation(\n        module_type=_module_type, module_config=_module_config\n    )\n    return op\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_operations","title":"<code>list_operations(filter: Union[str, None, Iterable[str]] = None, input_types: Union[str, Iterable[str], None] = None, output_types: Union[str, Iterable[str], None] = None, operation_types: Union[str, Iterable[str], None] = None, python_packages: Union[str, Iterable[str], None] = None, include_internal: bool = False) -&gt; Mapping[str, Operation]</code>","text":"<p>List all available values, optionally filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>Union[str, None, Iterable[str]]</code> <p>the (optional) filter string(s), an operation must match all of them to be included in the result</p> <code>None</code> <code>input_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one input that matches one of the specified types</p> <code>None</code> <code>output_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one output that matches one of the specified types</p> <code>None</code> <code>operation_types</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations of the specified type(s)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>python_packages</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations that are contained in one of the provided python packages</p> <code>None</code> <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_operations(\n    self,\n    filter: Union[str, None, Iterable[str]] = None,\n    input_types: Union[str, Iterable[str], None] = None,\n    output_types: Union[str, Iterable[str], None] = None,\n    operation_types: Union[str, Iterable[str], None] = None,\n    python_packages: Union[str, Iterable[str], None] = None,\n    include_internal: bool = False,\n) -&gt; Mapping[str, Operation]:\n\"\"\"List all available values, optionally filter.\n\n    Arguments:\n        filter: the (optional) filter string(s), an operation must match all of them to be included in the result\n        input_types: each operation must have at least one input that matches one of the specified types\n        output_types: each operation must have at least one output that matches one of the specified types\n        operation_types: only include operations of the specified type(s)\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        python_packages: only include operations that are contained in one of the provided python packages\n    Returns:\n        a dictionary with the operation id as key, and [kiara.models.module.operation.Operation] instance data as value\n    \"\"\"\n\n    if operation_types:\n        if isinstance(operation_types, str):\n            operation_types = [operation_types]\n        temp: Dict[str, Operation] = {}\n        for op_type_name in operation_types:\n            op_type = self.context.operation_registry.operation_types.get(\n                op_type_name, None\n            )\n            if op_type is None:\n                raise Exception(f\"Operation type not registered: {op_type_name}\")\n\n            temp.update(op_type.operations)\n        operations: Mapping[str, Operation] = temp\n    else:\n        operations = self.context.operation_registry.operations\n\n    if filter:\n        if isinstance(filter, str):\n            filter = [filter]\n        temp = {}\n        for op_id, op in operations.items():\n            match = True\n            for f in filter:\n                if not f:\n                    continue\n                if f.lower() not in op_id.lower():\n                    match = False\n                    break\n            if match:\n                temp[op_id] = op\n        operations = temp\n\n    if not include_internal:\n        temp = {}\n        for op_id, op in operations.items():\n            if not op.operation_details.is_internal_operation:\n                temp[op_id] = op\n\n        operations = temp\n\n    if input_types:\n        if isinstance(input_types, str):\n            input_types = [input_types]\n        temp = {}\n        for op_id, op in operations.items():\n            for input_type in input_types:\n                match = False\n                for schema in op.inputs_schema.values():\n                    if schema.type == input_type:\n                        temp[op_id] = op\n                        match = True\n                        break\n                if match:\n                    break\n\n        operations = temp\n\n    if output_types:\n        if isinstance(output_types, str):\n            output_types = [output_types]\n        temp = {}\n        for op_id, op in operations.items():\n            for output_type in output_types:\n                match = False\n                for schema in op.outputs_schema.values():\n                    if schema.type == output_type:\n                        temp[op_id] = op\n                        match = True\n                        break\n                if match:\n                    break\n\n        operations = temp\n\n    if python_packages:\n        temp = {}\n        if isinstance(python_packages, str):\n            python_packages = [python_packages]\n        for op_id, op in operations.items():\n            info = OperationInfo.create_from_instance(\n                kiara=self.context, instance=op\n            )\n            pkg = info.context.labels.get(\"package\", None)\n            if pkg in python_packages:\n                temp[pkg] = op\n        operations = temp\n\n    return operations\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_operation_info","title":"<code>retrieve_operation_info(operation: str, allow_external: bool = False) -&gt; OperationInfo</code>","text":"<p>Return the full information for the specified operation id.</p> <p>This is similar to the 'get_operation' method, but returns additional information. Only use this instead of 'get_operation' if you need the additional info, as it's more expensive to get.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>the operation id</p> required <p>Returns:</p> Type Description <code>OperationInfo</code> <p>augmented operation instance data</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operation_info(\n    self, operation: str, allow_external: bool = False\n) -&gt; OperationInfo:\n\"\"\"Return the full information for the specified operation id.\n\n    This is similar to the 'get_operation' method, but returns additional information. Only use this instead of\n    'get_operation' if you need the additional info, as it's more expensive to get.\n\n    Arguments:\n        operation: the operation id\n\n    Returns:\n        augmented operation instance data\n    \"\"\"\n\n    if not allow_external:\n        op = self.context.operation_registry.get_operation(operation_id=operation)\n    else:\n        op = create_operation(module_or_operation=operation)\n    op_info = OperationInfo.create_from_operation(kiara=self.context, operation=op)\n    return op_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_operations_info","title":"<code>retrieve_operations_info(*filters, input_types: Union[str, Iterable[str], None] = None, output_types: Union[str, Iterable[str], None] = None, operation_types: Union[str, Iterable[str], None] = None, python_packages: Union[str, Iterable[str], None] = None, include_internal: bool = False) -&gt; OperationGroupInfo</code>","text":"<p>Retrieve information about the matching operations.</p> <p>This retrieves the same list of operations as list_operations, but augments each result instance with additional information that might be useful in frontends.</p> <p>'OperationInfo' objects contains augmented information on top of what 'normal' Operation objects hold, but they can take longer to create/resolve. If you don't need any of the augmented information, just use the list_operations method instead.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <p>the (optional) filter strings, an operation must match all of them to be included in the result</p> <code>()</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>output_types</code> <code>Union[str, Iterable[str], None]</code> <p>each operation must have at least one output that matches one of the specified types</p> <code>None</code> <code>operation_types</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations of the specified type(s)</p> <code>None</code> <code>include_internal</code> <code>bool</code> <p>whether to include operations that are predominantly used internally in kiara.</p> <code>False</code> <code>python_packages</code> <code>Union[str, Iterable[str], None]</code> <p>only include operations that are contained in one of the provided python packages</p> <code>None</code> <p>Returns:</p> Type Description <code>OperationGroupInfo</code> <p>a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operations_info(\n    self,\n    *filters,\n    input_types: Union[str, Iterable[str], None] = None,\n    output_types: Union[str, Iterable[str], None] = None,\n    operation_types: Union[str, Iterable[str], None] = None,\n    python_packages: Union[str, Iterable[str], None] = None,\n    include_internal: bool = False,\n) -&gt; OperationGroupInfo:\n\"\"\"Retrieve information about the matching operations.\n\n    This retrieves the same list of operations as [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations],\n    but augments each result instance with additional information that might be useful in frontends.\n\n    'OperationInfo' objects contains augmented information on top of what 'normal' [Operation][kiara.models.module.operation.Operation] objects\n    hold, but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [list_operations][kiara.interfaces.python_api.KiaraAPI.list_operations] method\n    instead.\n\n    Arguments:\n        filters: the (optional) filter strings, an operation must match all of them to be included in the result\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        output_types: each operation must have at least one output that matches one of the specified types\n        operation_types: only include operations of the specified type(s)\n        include_internal: whether to include operations that are predominantly used internally in kiara.\n        python_packages: only include operations that are contained in one of the provided python packages\n    Returns:\n        a wrapper object containing a dictionary of items with value_id as key, and [kiara.interfaces.python_api.models.info.OperationInfo] as value\n    \"\"\"\n\n    title = \"Available operations\"\n    if filters:\n        title = \"Filtered operations\"\n\n    operations = self.list_operations(\n        filters,\n        input_types=input_types,\n        output_types=output_types,\n        include_internal=include_internal,\n        operation_types=operation_types,\n        python_packages=python_packages,\n    )\n\n    ops_info = OperationGroupInfo.create_from_operations(\n        kiara=self.context, group_title=title, **operations\n    )\n    return ops_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.register_pipeline","title":"<code>register_pipeline(data: Union[Path, str, Mapping[str, Any]], operation_id: Union[str, None] = None) -&gt; Operation</code>","text":"<p>Register a pipelne as new operation into this context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Path, str, Mapping[str, Any]]</code> <p>a dict or a path to a json/yaml file containing the definition</p> required <code>operation_id</code> <code>Union[str, None]</code> <p>the id to use for the operation (if not specified, the id will be auto-determined)</p> <code>None</code> <p>Returns:</p> Type Description <code>Operation</code> <p>the assembled operation</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_pipeline(\n    self,\n    data: Union[Path, str, Mapping[str, Any]],\n    operation_id: Union[str, None] = None,\n) -&gt; Operation:\n\"\"\"Register a pipelne as new operation into this context.\n\n    Arguments:\n        data: a dict or a path to a json/yaml file containing the definition\n        operation_id: the id to use for the operation (if not specified, the id will be auto-determined)\n\n    Returns:\n        the assembled operation\n    \"\"\"\n\n    return self.context.operation_registry.register_pipeline(\n        data=data, operation_id=operation_id\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.register_pipelines","title":"<code>register_pipelines(*pipeline_paths: Union[str, Path]) -&gt; Dict[str, Operation]</code>","text":"<p>Register all pipelines found in the specified paths.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_pipelines(\n    self, *pipeline_paths: Union[str, Path]\n) -&gt; Dict[str, Operation]:\n\"\"\"Register all pipelines found in the specified paths.\"\"\"\n\n    return self.context.operation_registry.register_pipelines(*pipeline_paths)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.register_data","title":"<code>register_data(data: Any, data_type: Union[None, str] = None, reuse_existing: bool = False) -&gt; Value</code>","text":"<p>Register data with kiara.</p> <p>This will create a new value instance from the data and return it. The data/value itself won't be stored in a store, you have to use the 'store_value' function for that.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>the data to register</p> required <code>data_type</code> <code>Union[None, str]</code> <p>(optional) the data type of the data. If not provided, kiara will try to infer the data type.</p> <code>None</code> <code>reuse_existing</code> <code>bool</code> <p>whether to re-use an existing value that is already registered and has the same hash.</p> <code>False</code> <p>Returns:</p> Type Description <code>Value</code> <p>a [kiara.models.values.value.Value] instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def register_data(\n    self,\n    data: Any,\n    data_type: Union[None, str] = None,\n    reuse_existing: bool = False,\n) -&gt; Value:\n\"\"\"Register data with kiara.\n\n    This will create a new value instance from the data and return it. The data/value itself won't be stored\n    in a store, you have to use the 'store_value' function for that.\n\n    Arguments:\n        data: the data to register\n        data_type: (optional) the data type of the data. If not provided, kiara will try to infer the data type.\n        reuse_existing: whether to re-use an existing value that is already registered and has the same hash.\n\n    Returns:\n        a [kiara.models.values.value.Value] instance\n    \"\"\"\n\n    if data_type is None:\n        raise NotImplementedError(\n            \"Infering data types not implemented yet. Please provide one manually.\"\n        )\n\n    value = self.context.data_registry.register_data(\n        data=data, schema=data_type, reuse_existing=reuse_existing\n    )\n    return value\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_value_ids","title":"<code>list_value_ids(**matcher_params) -&gt; List[uuid.UUID]</code>","text":"<p>List all available value ids for this kiara context.</p> <p>This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without having to look up the details of each value (like list_values does). This method can also be used with a matcher, but in this case the list_values would be preferable in most cases, because it is called under the hood, and the performance advantage of not having to look up value details is gone.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[uuid.UUID]</code> <p>a list of value ids</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_value_ids(self, **matcher_params) -&gt; List[uuid.UUID]:\n\"\"\"List all available value ids for this kiara context.\n\n    This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n    having to look up the details of each value (like [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n    does). This method can also be used with a matcher, but in this case the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values]\n    would be preferable in most cases, because it is called under the hood, and the performance advantage of not\n    having to look up value details is gone.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a list of value ids\n    \"\"\"\n\n    if matcher_params:\n        values = self.list_values(**matcher_params)\n        return sorted(values.keys())\n    else:\n        _values = self.context.data_registry.retrieve_all_available_value_ids()\n        return sorted(_values)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_values","title":"<code>list_values(**matcher_params: Any) -&gt; Dict[uuid.UUID, Value]</code>","text":"<p>List all available values, optionally filter.</p> <p>Retrieve information about all values that are available in the current kiara context session (both stored and non-stored).</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <code>Any</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[uuid.UUID, Value]</code> <p>a dictionary with value_id as key, and [kiara.models.values.value.Value] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_values(self, **matcher_params: Any) -&gt; Dict[uuid.UUID, Value]:\n\"\"\"List all available values, optionally filter.\n\n    Retrieve information about all values that are available in the current kiara context session (both stored\n    and non-stored).\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n    \"\"\"\n\n    if matcher_params:\n        matcher = ValueMatcher.create_matcher(**matcher_params)\n\n        values = self.context.data_registry.find_values(matcher=matcher)\n    else:\n        # TODO: make that parallel?\n        values = {\n            k: self.context.data_registry.get_value(k)\n            for k in self.context.data_registry.retrieve_all_available_value_ids()\n        }\n\n    return values\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_value","title":"<code>get_value(value: Union[str, Value, uuid.UUID]) -&gt; Value</code>","text":"<p>Retrieve a value instance with the specified id or alias.</p> <p>Raises an exception if no value could be found.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, Value, uuid.UUID]</code> <p>a value id, alias or object that has a 'value_id' attribute.</p> required <p>Returns:</p> Type Description <code>Value</code> <p>the Value instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_value(self, value: Union[str, Value, uuid.UUID]) -&gt; Value:\n\"\"\"Retrieve a value instance with the specified id or alias.\n\n    Raises an exception if no value could be found.\n\n    Arguments:\n        value: a value id, alias or object that has a 'value_id' attribute.\n\n    Returns:\n        the Value instance\n    \"\"\"\n\n    return self.context.data_registry.get_value(value=value)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_value_info","title":"<code>retrieve_value_info(value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo</code>","text":"<p>Retrieve an info object for a value.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the get_value method instead.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>a value id, alias or object that has a 'value_id' attribute.</p> required <p>Returns:</p> Type Description <code>ValueInfo</code> <p>the ValueInfo instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_value_info(self, value: Union[str, uuid.UUID, Value]) -&gt; ValueInfo:\n\"\"\"Retrieve an info object for a value.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.get_value] method\n    instead.\n\n    Arguments:\n        value: a value id, alias or object that has a 'value_id' attribute.\n\n    Returns:\n        the ValueInfo instance\n\n    \"\"\"\n\n    _value = self.get_value(value=value)\n    return ValueInfo.create_from_instance(kiara=self.context, instance=_value)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_values_info","title":"<code>retrieve_values_info(**matcher_params) -&gt; ValuesInfo</code>","text":"<p>Retrieve information about the matching values.</p> <p>This retrieves the same list of values as list_values, but augments each result value instance with additional information that might be useful in frontends.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the list_values method instead.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValuesInfo</code> <p>a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_values_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n    This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n    but augments each result value instance with additional information that might be useful in frontends.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [list_values][kiara.interfaces.python_api.KiaraAPI.list_values] method\n    instead.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a wrapper object containing the items as dictionary with value_id as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n    \"\"\"\n\n    values = self.list_values(**matcher_params)\n\n    infos = ValuesInfo.create_from_instances(\n        kiara=self.context, instances={str(k): v for k, v in values.items()}\n    )\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_alias_names","title":"<code>list_alias_names(**matcher_params) -&gt; List[str]</code>","text":"<p>List all available alias keys.</p> <p>This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without having to look up the details of each value (like list_aliases does). This method can also be used with a matcher, but in this case the list_aliases would be preferrable in most cases, because it is called under the hood, and the performance advantage of not having to look up value details is gone.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of value ids</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_alias_names(self, **matcher_params) -&gt; List[str]:\n\"\"\"List all available alias keys.\n\n    This method exists mainly so frontend can retrieve a list of all value_ids that exists on the backend without\n    having to look up the details of each value (like [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n    does). This method can also be used with a matcher, but in this case the [list_aliases][kiara.interfaces.python_api.KiaraAPI.list_aliases]\n    would be preferrable in most cases, because it is called under the hood, and the performance advantage of not\n    having to look up value details is gone.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a list of value ids\n    \"\"\"\n\n    if matcher_params:\n        values = self.list_aliases(**matcher_params)\n        return list(values.keys())\n    else:\n        _values = self.context.alias_registry.all_aliases\n        return list(_values)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_aliases","title":"<code>list_aliases(**matcher_params) -&gt; Dict[str, Value]</code>","text":"<p>List all available values that have an alias assigned, optionally filter.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Value]</code> <p>a dictionary with value_id as key, and [kiara.models.values.value.Value] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_aliases(self, **matcher_params) -&gt; Dict[str, Value]:\n\"\"\"List all available values that have an alias assigned, optionally filter.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with value_id as key, and [kiara.models.values.value.Value] as value\n    \"\"\"\n\n    if matcher_params:\n        matcher_params[\"has_alias\"] = True\n        all_values = self.list_values(**matcher_params)\n        result: Dict[str, Value] = {}\n        for value in all_values.values():\n            aliases = self.context.alias_registry.find_aliases_for_value_id(\n                value_id=value.value_id\n            )\n            for a in aliases:\n                if a in result.keys():\n                    raise Exception(\n                        f\"Duplicate value alias '{a}': this is most likely a bug.\"\n                    )\n                result[a] = value\n\n        result = {k: result[k] for k in sorted(result.keys())}\n    else:\n        # faster if not other matcher params\n        all_aliases = self.context.alias_registry.all_aliases\n        result = {\n            k: self.context.data_registry.get_value(f\"alias:{k}\")\n            for k in all_aliases\n        }\n\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_aliases_info","title":"<code>retrieve_aliases_info(**matcher_params) -&gt; ValuesInfo</code>","text":"<p>Retrieve information about the matching values.</p> <p>This retrieves the same list of values as list_values, but augments each result value instance with additional information that might be useful in frontends.</p> <p>'ValueInfo' objects contains augmented information on top of what 'normal' Value objects hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any of the augmented information, just use the get_value method instead.</p> <p>Parameters:</p> Name Type Description Default <code>matcher_params</code> <p>the (optional) filter parameters, check the ValueMatcher class for available parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValuesInfo</code> <p>a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_aliases_info(self, **matcher_params) -&gt; ValuesInfo:\n\"\"\"Retrieve information about the matching values.\n\n    This retrieves the same list of values as [list_values][kiara.interfaces.python_api.KiaraAPI.list_values],\n    but augments each result value instance with additional information that might be useful in frontends.\n\n    'ValueInfo' objects contains augmented information on top of what 'normal' [Value][kiara.models.values.value.Value] objects\n    hold (like resolved properties for example), but they can take longer to create/resolve. If you don't need any\n    of the augmented information, just use the [get_value][kiara.interfaces.python_api.KiaraAPI.list_aliases] method\n    instead.\n\n    Arguments:\n        matcher_params: the (optional) filter parameters, check the [ValueMatcher][kiara.models.values.matchers.ValueMatcher] class for available parameters\n\n    Returns:\n        a dictionary with a value alias as key, and [kiara.interfaces.python_api.models.values.ValueInfo] as value\n    \"\"\"\n\n    values = self.list_aliases(**matcher_params)\n\n    infos = ValuesInfo.create_from_instances(\n        kiara=self.context, instances={str(k): v for k, v in values.items()}\n    )\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.assemble_value_map","title":"<code>assemble_value_map(values: Mapping[str, Union[uuid.UUID, None, str, Value]], values_schema: Union[None, Mapping[str, ValueSchema]] = None, register_data: bool = False, reuse_existing_data: bool = False) -&gt; ValueMap</code>","text":"<p>Retrive a ValueMap object from the provided value ids or value links.</p> <p>By default, this method can only use values/datasets that are already registered in kiara. If you want to auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Mapping[str, Union[uuid.UUID, None, str, Value]]</code> <p>a dictionary with the values in question</p> required <code>values_schema</code> <code>Union[None, Mapping[str, ValueSchema]]</code> <p>an optional dictionary with the schema for each of the values that are not yet registered</p> <code>None</code> <code>register_data</code> <code>bool</code> <p>whether to allow auto-registration of 'raw' data</p> <code>False</code> <code>reuse_existing_data</code> <code>bool</code> <p>whether to reuse existing data with the same hash as the 'raw' data that is being registered</p> <code>False</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>a value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_value_map(\n    self,\n    values: Mapping[str, Union[uuid.UUID, None, str, Value]],\n    values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n    register_data: bool = False,\n    reuse_existing_data: bool = False,\n) -&gt; ValueMap:\n\"\"\"Retrive a [ValueMap][TODO] object from the provided value ids or value links.\n\n    By default, this method can only use values/datasets that are already registered in *kiara*. If you want to\n    auto-register 'raw' data, you need to set the 'register_data' flag to 'True', and provide a schema for each of the fields that are not yet registered.\n\n    Arguments:\n        values: a dictionary with the values in question\n        values_schema: an optional dictionary with the schema for each of the values that are not yet registered\n        register_data: whether to allow auto-registration of 'raw' data\n        reuse_existing_data: whether to reuse existing data with the same hash as the 'raw' data that is being registered\n\n    Returns:\n        a value map instance\n    \"\"\"\n\n    if register_data:\n        temp: Dict[str, Union[str, Value, uuid.UUID, None]] = {}\n        for k, v in values.items():\n\n            if isinstance(v, (Value, uuid.UUID)):\n                temp[k] = v\n                continue\n\n            if isinstance(v, str):\n                try:\n                    v = uuid.UUID(v)\n                    temp[k] = v\n                    continue\n                except Exception:\n                    if v.startswith(\"alias:\"):  # type: ignore\n                        _v = v.replace(\"alias:\", \"\")  # type: ignore\n                    else:\n                        _v = v\n                    if _v in self.list_aliases():\n                        temp[k] = f\"alias:{_v}\"\n                        continue\n\n            if not values_schema:\n                raise Exception(\n                    f\"Can't assemble value map field without schema: '{k}' -- {str(v)}\"\n                )\n\n            if k not in values_schema.keys():\n                raise Exception(\n                    f\"Can't assemble value map field without schema key: '{k}' -- {str(v)}\"\n                )\n\n            if v is None:\n                temp[k] = None\n            else:\n                _v = self.register_data(\n                    data=v,\n                    data_type=values_schema[k].type,\n                    reuse_existing=reuse_existing_data,\n                )\n                temp[k] = _v\n        values = temp\n\n    return self.context.data_registry.load_values(\n        values=values, values_schema=values_schema\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.store_value","title":"<code>store_value(value: Union[str, uuid.UUID, Value], alias: Union[str, Iterable[str], None], allow_overwrite: bool = True) -&gt; StoreValueResult</code>","text":"<p>Store the specified value in the (default) value store.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>the value (or a reference to it)</p> required <code>alias</code> <code>Union[str, Iterable[str], None]</code> <p>(Optional) aliases for the value</p> required <code>allow_overwrite</code> <code>bool</code> <p>whether to allow overwriting existing aliases</p> <code>True</code> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def store_value(\n    self,\n    value: Union[str, uuid.UUID, Value],\n    alias: Union[str, Iterable[str], None],\n    allow_overwrite: bool = True,\n) -&gt; StoreValueResult:\n\"\"\"Store the specified value in the (default) value store.\n\n    Arguments:\n        value: the value (or a reference to it)\n        alias: (Optional) aliases for the value\n        allow_overwrite: whether to allow overwriting existing aliases\n    \"\"\"\n\n    if isinstance(alias, str):\n        alias = [alias]\n\n    value_obj = self.get_value(value)\n    persisted_data: Union[None, PersistedData] = None\n    try:\n        persisted_data = self.context.data_registry.store_value(value=value_obj)\n        if alias:\n            self.context.alias_registry.register_aliases(\n                value_obj.value_id, *alias, allow_overwrite=allow_overwrite\n            )\n        result = StoreValueResult.construct(\n            value=value_obj,\n            aliases=sorted(alias) if alias else [],\n            error=None,\n            persisted_data=persisted_data,\n        )\n    except Exception as e:\n        log_exception(e)\n        result = StoreValueResult.construct(\n            value=value_obj,\n            aliases=sorted(alias) if alias else [],\n            error=str(e),\n            persisted_data=persisted_data,\n        )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.store_values","title":"<code>store_values(values: Mapping[str, Union[str, uuid.UUID, Value]], alias_map: Mapping[str, Iterable[str]]) -&gt; StoreValuesResult</code>","text":"<p>Store multiple values into the (default) kiara value store.</p> <p>Values are identified by unique keys in both input arguments, the alias map references the key that is used in the 'values' argument.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Mapping[str, Union[str, uuid.UUID, Value]]</code> <p>a map of value keys/values</p> required <code>alias_map</code> <code>Mapping[str, Iterable[str]]</code> <p>a map of value keys aliases</p> required <p>Returns:</p> Type Description <code>StoreValuesResult</code> <p>an object outlining which values (identified by the specified value key) where stored and how</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def store_values(\n    self,\n    values: Mapping[str, Union[str, uuid.UUID, Value]],\n    alias_map: Mapping[str, Iterable[str]],\n) -&gt; StoreValuesResult:\n\"\"\"Store multiple values into the (default) kiara value store.\n\n    Values are identified by unique keys in both input arguments, the alias map references the key that is used in\n    the 'values' argument.\n\n    Arguments:\n        values: a map of value keys/values\n        alias_map: a map of value keys aliases\n\n    Returns:\n        an object outlining which values (identified by the specified value key) where stored and how\n    \"\"\"\n\n    result = {}\n    for field_name, value in values.items():\n        aliases = alias_map.get(field_name)\n        value_obj = self.get_value(value)\n        store_result = self.store_value(value=value_obj, alias=aliases)\n        result[field_name] = store_result\n\n    return StoreValuesResult.construct(__root__=result)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_operation_type","title":"<code>get_operation_type(op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType</code>","text":"<p>Get the management object for the specified operation type.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationType:\n\"\"\"Get the management object for the specified operation type.\"\"\"\n\n    return self.context.operation_registry.get_operation_type(op_type=op_type)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_operation_type_info","title":"<code>retrieve_operation_type_info(op_type: Union[str, Type[OP_TYPE]]) -&gt; OperationTypeInfo</code>","text":"<p>Get an info object for the specified operation type.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_operation_type_info(\n    self, op_type: Union[str, Type[OP_TYPE]]\n) -&gt; OperationTypeInfo:\n\"\"\"Get an info object for the specified operation type.\"\"\"\n\n    _op_type = self.get_operation_type(op_type=op_type)\n    return OperationTypeInfo.create_from_type_class(\n        kiara=self.context, type_cls=_op_type.__class__\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.find_operation_id","title":"<code>find_operation_id(module_type: str, module_config: Union[None, Mapping[str, Any]] = None) -&gt; Union[None, str]</code>","text":"<p>Try to find the registered operation id for the specified module type and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the module type</p> required <code>module_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the module configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[None, str]</code> <p>the registered operation id, if found, or None</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def find_operation_id(\n    self, module_type: str, module_config: Union[None, Mapping[str, Any]] = None\n) -&gt; Union[None, str]:\n\"\"\"Try to find the registered operation id for the specified module type and configuration.\n\n    Arguments:\n        module_type: the module type\n        module_config: the module configuration\n\n    Returns:\n        the registered operation id, if found, or None\n    \"\"\"\n\n    manifest = self.context.create_manifest(\n        module_or_operation=module_type, config=module_config\n    )\n    return self.context.operation_registry.find_operation_id(manifest=manifest)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.assemble_filter_pipeline_config","title":"<code>assemble_filter_pipeline_config(data_type: str, filters: Union[str, Iterable[str], Mapping[str, str]], endpoint: Union[None, Manifest, str] = None, endpoint_input_field: Union[str, None] = None, endpoint_step_id: Union[str, None] = None, extra_input_aliases: Union[None, Mapping[str, str]] = None, extra_output_aliases: Union[None, Mapping[str, str]] = None) -&gt; PipelineConfig</code>","text":"<p>Assemble a (pipeline) module config to filter values of a specific data type.</p> <p>Optionally, a module that uses the filtered dataset as input can be specified.</p>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.assemble_filter_pipeline_config--todo-document-filter-names","title":"TODO: document filter names","text":"<p>For the 'filters' argument, the accepted inputs are: - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically - a map of string pairs: the keys are step ids, the values operation ids or filter names</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>the type of the data to filter</p> required <code>filters</code> <code>Union[str, Iterable[str], Mapping[str, str]]</code> <p>a list of operation ids or filter names (and potentiall step_ids if type is a mapping)</p> required <code>endpoint</code> <code>Union[None, Manifest, str]</code> <p>optional module to put as last step in the created pipeline</p> <code>None</code> <code>endpoing_input_field</code> <p>field name of the input that will receive the filtered value</p> required <code>endpoint_step_id</code> <code>Union[str, None]</code> <p>id to use for the endpoint step (module type name will be used if not provided)</p> <code>None</code> <code>extra_input_aliases</code> <code>Union[None, Mapping[str, str]]</code> <p>extra output aliases to add to the pipeline config</p> <code>None</code> <code>extra_output_aliases</code> <code>Union[None, Mapping[str, str]]</code> <p>extra output aliases to add to the pipeline config</p> <code>None</code> <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>the (pipeline) module configuration of the filter pipeline</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_filter_pipeline_config(\n    self,\n    data_type: str,\n    filters: Union[str, Iterable[str], Mapping[str, str]],\n    endpoint: Union[None, Manifest, str] = None,\n    endpoint_input_field: Union[str, None] = None,\n    endpoint_step_id: Union[str, None] = None,\n    extra_input_aliases: Union[None, Mapping[str, str]] = None,\n    extra_output_aliases: Union[None, Mapping[str, str]] = None,\n) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n    Optionally, a module that uses the filtered dataset as input can be specified.\n\n    # TODO: document filter names\n    For the 'filters' argument, the accepted inputs are:\n    - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n    - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n    - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n    Arguments:\n        data_type: the type of the data to filter\n        filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n        endpoint: optional module to put as last step in the created pipeline\n        endpoing_input_field: field name of the input that will receive the filtered value\n        endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n        extra_input_aliases: extra output aliases to add to the pipeline config\n        extra_output_aliases: extra output aliases to add to the pipeline config\n\n    Returns:\n        the (pipeline) module configuration of the filter pipeline\n    \"\"\"\n\n    filter_op_type: FilterOperationType = self.context.operation_registry.get_operation_type(\"filter\")  # type: ignore\n    pipeline_config = filter_op_type.assemble_filter_pipeline_config(\n        data_type=data_type,\n        filters=filters,\n        endpoint=endpoint,\n        endpoint_input_field=endpoint_input_field,\n        endpoint_step_id=endpoint_step_id,\n        extra_input_aliases=extra_input_aliases,\n        extra_output_aliases=extra_output_aliases,\n    )\n\n    return pipeline_config\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_renderer_infos","title":"<code>retrieve_renderer_infos(source_type: Union[str, None] = None) -&gt; RendererInfos</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_renderer_infos(\n    self, source_type: Union[str, None] = None\n) -&gt; RendererInfos:\n\n    if not source_type:\n        renderers = self.context.render_registry.registered_renderers\n    else:\n        renderers = self.context.render_registry.retrieve_renderers_for_source_type(\n            source_type=source_type\n        )\n\n    group = {k.get_renderer_alias(): k for k in renderers}\n    infos = RendererInfos.create_from_instances(kiara=self.context, instances=group)\n    return infos  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_renderers_for","title":"<code>retrieve_renderers_for(source_type: str) -&gt; List[KiaraRenderer]</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_renderers_for(self, source_type: str) -&gt; List[KiaraRenderer]:\n\n    return self.context.render_registry.retrieve_renderers_for_source_type(\n        source_type=source_type\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.render","title":"<code>render(item: Any, source_type: str, target_type: str, render_config: Union[Mapping[str, Any], None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def render(\n    self,\n    item: Any,\n    source_type: str,\n    target_type: str,\n    render_config: Union[Mapping[str, Any], None] = None,\n) -&gt; Any:\n\n    registry = self.context.render_registry\n    result = registry.render(\n        item=item,\n        source_type=source_type,\n        target_type=target_type,\n        render_config=render_config,\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.assemble_render_pipeline","title":"<code>assemble_render_pipeline(data_type: str, target_format: Union[str, Iterable[str]] = 'string', filters: Union[None, str, Iterable[str], Mapping[str, str]] = None, use_pretty_print: bool = False) -&gt; Operation</code>","text":"<p>Create a manifest describing a transformation that renders a value of the specified data type in the target format.</p> <p>If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches the value type of the source value, and the provided target format.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>the value (or value id)</p> required <code>target_format</code> <code>Union[str, Iterable[str]]</code> <p>the format into which to render the value</p> <code>'string'</code> <code>filters</code> <code>Union[None, str, Iterable[str], Mapping[str, str]]</code> <p>a list of filters to apply to the value before rendering it</p> <code>None</code> <code>use_pretty_print</code> <code>bool</code> <p>if True, use a 'pretty_print' operation instead of 'render_value'</p> <code>False</code> <p>Returns:</p> Type Description <code>Operation</code> <p>the manifest for the transformation</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def assemble_render_pipeline(\n    self,\n    data_type: str,\n    target_format: Union[str, Iterable[str]] = \"string\",\n    filters: Union[None, str, Iterable[str], Mapping[str, str]] = None,\n    use_pretty_print: bool = False,\n) -&gt; Operation:\n\"\"\"Create a manifest describing a transformation that renders a value of the specified data type in the target format.\n\n    If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n    the value type of the source value, and the provided target format.\n\n    Arguments:\n        value: the value (or value id)\n        target_format: the format into which to render the value\n        filters: a list of filters to apply to the value before rendering it\n        use_pretty_print: if True, use a 'pretty_print' operation instead of 'render_value'\n\n    Returns:\n        the manifest for the transformation\n    \"\"\"\n\n    if data_type not in self.context.data_type_names:\n        raise DataTypeUnknownException(data_type=data_type)\n\n    if use_pretty_print:\n        pretty_print_op_type: PrettyPrintOperationType = (\n            self.context.operation_registry.get_operation_type(\"pretty_print\")\n        )  # type: ignore\n        ops = pretty_print_op_type.get_target_types_for(data_type)\n    else:\n        render_op_type: RenderValueOperationType = self.context.operation_registry.get_operation_type(\n            # type: ignore\n            \"render_value\"\n        )  # type: ignore\n        ops = render_op_type.get_render_operations_for_source_type(data_type)\n\n    if isinstance(target_format, str):\n        target_format = [target_format]\n\n    match = None\n    for _target_type in target_format:\n        if _target_type not in ops.keys():\n            continue\n        match = ops[_target_type]\n        break\n\n    if not match:\n        if not ops:\n            msg = f\"No render operations registered for source type '{data_type}'.\"\n        else:\n            msg = f\"Registered target types for source type '{data_type}': {', '.join(ops.keys())}.\"\n        raise Exception(\n            f\"No render operation for source type '{data_type}' to target type(s) registered: '{', '.join(target_format)}'. {msg}\"\n        )\n\n    if filters:\n        # filter_op_type: FilterOperationType = self._kiara.operation_registry.get_operation_type(\"filter\")  # type: ignore\n        endpoint = Manifest(\n            module_type=match.module_type, module_config=match.module_config\n        )\n        extra_input_aliases = {\"render_value.render_config\": \"render_config\"}\n        extra_output_aliases = {\n            \"render_value.render_value_result\": \"render_value_result\"\n        }\n        pipeline_config = self.assemble_filter_pipeline_config(\n            data_type=data_type,\n            filters=filters,\n            endpoint=endpoint,\n            endpoint_input_field=\"value\",\n            endpoint_step_id=\"render_value\",\n            extra_input_aliases=extra_input_aliases,\n            extra_output_aliases=extra_output_aliases,\n        )\n        manifest = Manifest(\n            module_type=\"pipeline\", module_config=pipeline_config.dict()\n        )\n        module = self.context.module_registry.create_module(manifest=manifest)\n        operation = Operation.create_from_module(module, doc=pipeline_config.doc)\n    else:\n        operation = match\n\n    return operation\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.queue_manifest","title":"<code>queue_manifest(manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None) -&gt; uuid.UUID</code>","text":"<p>Queue a job using the provided manifest to describe the module and config that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the manifest</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the job inputs (can be either references to values, or raw inputs</p> <code>None</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>a result value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def queue_manifest(\n    self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n) -&gt; uuid.UUID:\n\"\"\"Queue a job using the provided manifest to describe the module and config that should be executed.\n\n    Arguments:\n        manifest: the manifest\n        inputs: the job inputs (can be either references to values, or raw inputs\n\n    Returns:\n        a result value map instance\n    \"\"\"\n\n    if inputs is None:\n        inputs = {}\n\n    job_config = self.context.job_registry.prepare_job_config(\n        manifest=manifest, inputs=inputs\n    )\n\n    job_id = self.context.job_registry.execute_job(\n        job_config=job_config, wait=False\n    )\n    return job_id\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.run_manifest","title":"<code>run_manifest(manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None) -&gt; ValueMap</code>","text":"<p>Run a job using the provided manifest to describe the module and config that should be executed.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Manifest</code> <p>the manifest</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the job inputs (can be either references to values, or raw inputs</p> <code>None</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>a result value map instance</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def run_manifest(\n    self, manifest: Manifest, inputs: Union[None, Mapping[str, Any]] = None\n) -&gt; ValueMap:\n\"\"\"Run a job using the provided manifest to describe the module and config that should be executed.\n\n    Arguments:\n        manifest: the manifest\n        inputs: the job inputs (can be either references to values, or raw inputs\n\n    Returns:\n        a result value map instance\n    \"\"\"\n\n    job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n    return self.context.job_registry.retrieve_result(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.queue_job","title":"<code>queue_job(operation: Union[str, Path, Manifest, OperationInfo], inputs: Mapping[str, Any], operation_config: Union[None, Mapping[str, Any]] = None) -&gt; uuid.UUID</code>","text":"<p>Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.</p> <p>This is a convenience method that auto-detects what is meant by the 'operation' string input argument.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[str, Path, Manifest, OperationInfo]</code> <p>a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..</p> required <code>inputs</code> <code>Mapping[str, Any]</code> <p>the operation inputs</p> required <code>operation_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the (optional) module config in case 'operation' is a module name</p> <code>None</code> <p>Returns:</p> Type Description <code>uuid.UUID</code> <p>the queued job id</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def queue_job(\n    self,\n    operation: Union[str, Path, Manifest, OperationInfo],\n    inputs: Mapping[str, Any],\n    operation_config: Union[None, Mapping[str, Any]] = None,\n) -&gt; uuid.UUID:\n\"\"\"Queue a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n    This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n    Arguments:\n        operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n        inputs: the operation inputs\n        operation_config: the (optional) module config in case 'operation' is a module name\n\n    Returns:\n        the queued job id\n    \"\"\"\n\n    if isinstance(operation, Path):\n        if not operation.is_file():\n            raise Exception(\n                f\"Can't queue job from file '{operation.as_posix()}': file does not exist.\"\n            )\n        operation = operation.as_posix()\n    elif isinstance(operation, OperationInfo):\n        operation = operation.operation\n\n    if not isinstance(operation, Manifest):\n        manifest: Manifest = create_operation(\n            module_or_operation=operation,\n            operation_config=operation_config,\n            kiara=self.context,\n        )\n    else:\n        manifest = operation\n\n    job_id = self.queue_manifest(manifest=manifest, inputs=inputs)\n    return job_id\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.run_job","title":"<code>run_job(operation: Union[str, Path, Manifest, OperationInfo], inputs: Union[None, Mapping[str, Any]] = None, operation_config: Union[None, Mapping[str, Any]] = None) -&gt; ValueMap</code>","text":"<p>Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.</p> <p>This is a convenience method that auto-detects what is meant by the 'operation' string input argument.</p> <p>In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead, since this is a blocking operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>Union[str, Path, Manifest, OperationInfo]</code> <p>a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..</p> required <code>inputs</code> <code>Union[None, Mapping[str, Any]]</code> <p>the operation inputs</p> <code>None</code> <code>operation_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>the (optional) module config in case 'operation' is a module name</p> <code>None</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>the job result value map</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def run_job(\n    self,\n    operation: Union[str, Path, Manifest, OperationInfo],\n    inputs: Union[None, Mapping[str, Any]] = None,\n    operation_config: Union[None, Mapping[str, Any]] = None,\n) -&gt; ValueMap:\n\"\"\"Run a job from a operation id, module_name (and config), or pipeline file, wait for the job to finish and retrieve the result.\n\n    This is a convenience method that auto-detects what is meant by the 'operation' string input argument.\n\n    In general, try to avoid this method and use 'queue_job', 'get_job' and 'retrieve_job_result' manually instead,\n    since this is a blocking operation.\n\n    Arguments:\n        operation: a module name, operation id, or a path to a pipeline file (resolved in this order, until a match is found)..\n        inputs: the operation inputs\n        operation_config: the (optional) module config in case 'operation' is a module name\n\n    Returns:\n        the job result value map\n\n    \"\"\"\n\n    if inputs is None:\n        inputs = {}\n    job_id = self.queue_job(\n        operation=operation, inputs=inputs, operation_config=operation_config\n    )\n    return self.context.job_registry.retrieve_result(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_job","title":"<code>get_job(job_id: Union[str, uuid.UUID]) -&gt; ActiveJob</code>","text":"<p>Retrieve the status of the job with the provided id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_job(self, job_id: Union[str, uuid.UUID]) -&gt; ActiveJob:\n\"\"\"Retrieve the status of the job with the provided id.\"\"\"\n\n    if isinstance(job_id, str):\n        job_id = uuid.UUID(job_id)\n\n    job_status = self.context.job_registry.get_job(job_id=job_id)\n    return job_status\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_job_result","title":"<code>get_job_result(job_id: Union[str, uuid.UUID]) -&gt; ValueMap</code>","text":"<p>Retrieve the result(s) of the specified job.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_job_result(self, job_id: Union[str, uuid.UUID]) -&gt; ValueMap:\n\"\"\"Retrieve the result(s) of the specified job.\"\"\"\n\n    if isinstance(job_id, str):\n        job_id = uuid.UUID(job_id)\n\n    result = self.context.job_registry.retrieve_result(job_id=job_id)\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.render_value","title":"<code>render_value(value: Union[str, uuid.UUID, Value], target_format: Union[str, Iterable[str]] = 'string', filters: Union[None, Iterable[str], Mapping[str, str]] = None, render_config: Union[Mapping[str, str], None] = None, add_root_scenes: bool = True, use_pretty_print: bool = False) -&gt; RenderValueResult</code>","text":"<p>Render a value in the specified target format.</p> <p>If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches the value type of the source value, and the provided target format.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, uuid.UUID, Value]</code> <p>the value (or value id)</p> required <code>target_format</code> <code>Union[str, Iterable[str]]</code> <p>the format into which to render the value</p> <code>'string'</code> <code>filters</code> <code>Union[None, Iterable[str], Mapping[str, str]]</code> <p>an (optional) list of filters</p> <code>None</code> <code>render_config</code> <code>Union[Mapping[str, str], None]</code> <p>manifest specific render configuration</p> <code>None</code> <code>add_root_scenes</code> <code>bool</code> <p>add root scenes to the result</p> <code>True</code> <code>use_pretty_print</code> <code>bool</code> <p>use 'pretty_print' operation instead of 'render_value'</p> <code>False</code> <p>Returns:</p> Type Description <code>RenderValueResult</code> <p>the rendered value data, and any related scenes, if applicable</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def render_value(\n    self,\n    value: Union[str, uuid.UUID, Value],\n    target_format: Union[str, Iterable[str]] = \"string\",\n    filters: Union[None, Iterable[str], Mapping[str, str]] = None,\n    render_config: Union[Mapping[str, str], None] = None,\n    add_root_scenes: bool = True,\n    use_pretty_print: bool = False,\n) -&gt; RenderValueResult:\n\"\"\"Render a value in the specified target format.\n\n    If a list is provided as value for 'target_format', all items are tried until a 'render_value' operation is found that matches\n    the value type of the source value, and the provided target format.\n\n    Arguments:\n        value: the value (or value id)\n        target_format: the format into which to render the value\n        filters: an (optional) list of filters\n        render_config: manifest specific render configuration\n        add_root_scenes: add root scenes to the result\n        use_pretty_print: use 'pretty_print' operation instead of 'render_value'\n\n    Returns:\n        the rendered value data, and any related scenes, if applicable\n    \"\"\"\n\n    _value = self.get_value(value)\n    try:\n        render_operation: Union[None, Operation] = self.assemble_render_pipeline(\n            data_type=_value.data_type_name,\n            target_format=target_format,\n            filters=filters,\n            use_pretty_print=use_pretty_print,\n        )\n\n    except Exception as e:\n\n        log_message(\n            \"create_render_pipeline.failure\",\n            source_type=_value.data_type_name,\n            target_format=target_format,\n            error=e,\n        )\n\n        if use_pretty_print:\n            pretty_print_ops: PrettyPrintOperationType = self.context.operation_registry.get_operation_type(\"pretty_print\")  # type: ignore\n            if not isinstance(target_format, str):\n                raise NotImplementedError(\n                    \"Can't handle multiple target formats for 'render_value' yet.\"\n                )\n            render_operation = (\n                pretty_print_ops.get_operation_for_render_combination(\n                    source_type=\"any\", target_type=target_format\n                )\n            )\n        else:\n            render_ops: RenderValueOperationType = self.context.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n            if not isinstance(target_format, str):\n                raise NotImplementedError(\n                    \"Can't handle multiple target formats for 'render_value' yet.\"\n                )\n            render_operation = render_ops.get_render_operation(\n                source_type=\"any\", target_type=target_format\n            )\n\n    if render_operation is None:\n        raise Exception(\n            f\"Could not find render operation for value: {_value.value_id}\"\n        )\n\n    if render_config and \"render_config\" in render_config.keys():\n        # raise NotImplementedError()\n        # TODO: is this necessary?\n        render_config = render_config[\"render_config\"]  # type: ignore\n        # manifest_hash = render_config[\"manifest_hash\"]\n        # if manifest_hash != render_operation.manifest_hash:\n        #     raise NotImplementedError(\n        #         \"Using a non-default render operation is not supported (yet).\"\n        #     )\n        # render_config = render_config[\"render_config\"]\n\n    if render_config is None:\n        render_config = {}\n    else:\n        render_config = dict(render_config)\n\n    # render_type = render_config.pop(\"render_type\", None)\n    # if not render_type or render_type == \"data\":\n    #     pass\n    # elif render_type == \"metadata\":\n    #     pass\n    # elif render_type == \"properties\":\n    #     pass\n    # elif render_type == \"lineage\":\n    #     pass\n\n    result = render_operation.run(\n        kiara=self.context,\n        inputs={\"value\": _value, \"render_config\": render_config},\n    )\n\n    if use_pretty_print:\n        render_result: Value = result[\"rendered_value\"]\n        value_render_data = render_result.data\n    else:\n        render_result = result[\"render_value_result\"]\n\n        if render_result.data_type_name != \"render_value_result\":\n            raise Exception(\n                f\"Invalid result type for render operation: {render_result.data_type_name}\"\n            )\n\n        value_render_data: RenderValueResult = render_result.data  # type: ignore\n\n    return value_render_data\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_workflow_ids","title":"<code>list_workflow_ids() -&gt; List[uuid.UUID]</code>","text":"<p>List all available workflow ids.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_ids(self) -&gt; List[uuid.UUID]:\n\"\"\"List all available workflow ids.\"\"\"\n\n    return list(self.context.workflow_registry.all_workflow_ids)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_workflow_alias_names","title":"<code>list_workflow_alias_names() -&gt; List[str]</code>","text":"<p>\"List all available workflow aliases.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_alias_names(self) -&gt; List[str]:\n\"\"\" \"List all available workflow aliases.\"\"\"\n\n    return list(self.context.workflow_registry.workflow_aliases.keys())\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.get_workflow","title":"<code>get_workflow(workflow: Union[str, uuid.UUID], create_if_necessary: bool = True) -&gt; Workflow</code>","text":"<p>Retrieve the workflow instance with the specified id or alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def get_workflow(\n    self, workflow: Union[str, uuid.UUID], create_if_necessary: bool = True\n) -&gt; Workflow:\n\"\"\"Retrieve the workflow instance with the specified id or alias.\"\"\"\n\n    no_such_alias: bool = False\n    workflow_id: Union[uuid.UUID, None] = None\n    workflow_alias: Union[str, None] = None\n\n    if isinstance(workflow, str):\n        try:\n            workflow_id = uuid.UUID(workflow)\n        except Exception:\n            workflow_alias = workflow\n            try:\n                workflow_id = self.context.workflow_registry.get_workflow_id(\n                    workflow_alias=workflow\n                )\n            except NoSuchWorkflowException:\n                no_such_alias = True\n    else:\n        workflow_id = workflow\n\n    if workflow_id is None:\n        raise Exception(f\"Can't retrieve workflow for: {workflow}\")\n\n    if workflow_id in self._workflow_cache.keys():\n        return self._workflow_cache[workflow_id]\n\n    if workflow_id is None and not create_if_necessary:\n        if not no_such_alias:\n            msg = f\"No workflow with id '{workflow}' registered.\"\n        else:\n            msg = f\"No workflow with alias '{workflow}' registered.\"\n\n        raise NoSuchWorkflowException(workflow=workflow, msg=msg)\n\n    if workflow_id:\n        # workflow_metadata = self.context.workflow_registry.get_workflow_metadata(\n        #     workflow=workflow_id\n        # )\n        workflow_obj = Workflow(kiara=self.context, workflow=workflow_id)\n        self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n    else:\n        # means we need to create it\n        workflow_obj = self.create_workflow(workflow_alias=workflow_alias)\n\n    return workflow_obj\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflow_info","title":"<code>retrieve_workflow_info(workflow: Union[str, uuid.UUID, Workflow])</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflow_info(self, workflow: Union[str, uuid.UUID, Workflow]):\n\n    if isinstance(workflow, Workflow):\n        _workflow: Workflow = workflow\n    else:\n        _workflow = self.get_workflow(workflow)\n\n    return WorkflowInfo.create_from_workflow(workflow=_workflow)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_workflows","title":"<code>list_workflows(**matcher_params) -&gt; Mapping[uuid.UUID, Workflow]</code>","text":"<p>List all available workflow sessions, indexed by their unique id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflows(self, **matcher_params) -&gt; Mapping[uuid.UUID, Workflow]:\n\"\"\"List all available workflow sessions, indexed by their unique id.\"\"\"\n\n    workflows = {}\n\n    matcher = WorkflowMatcher(**matcher_params)\n    if matcher.has_alias:\n        for (\n            alias,\n            workflow_id,\n        ) in self.context.workflow_registry.workflow_aliases.items():\n\n            workflow = self.get_workflow(workflow=workflow_id)\n            workflows[workflow.workflow_id] = workflow\n        return workflows\n    else:\n        for workflow_id in self.context.workflow_registry.all_workflow_ids:\n            workflow = self.get_workflow(workflow=workflow_id)\n            workflows[workflow_id] = workflow\n        return workflows\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.list_workflow_aliases","title":"<code>list_workflow_aliases(**matcher_params) -&gt; Dict[str, Workflow]</code>","text":"<p>List all available workflow sessions that have an alias, indexed by alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def list_workflow_aliases(self, **matcher_params) -&gt; Dict[str, Workflow]:\n\"\"\"List all available workflow sessions that have an alias, indexed by alias.\"\"\"\n\n    if matcher_params:\n        matcher_params[\"has_alias\"] = True\n        workflows = self.list_workflows(**matcher_params)\n        result: Dict[str, Workflow] = {}\n        for workflow in workflows.values():\n            aliases = self.context.workflow_registry.get_aliases(\n                workflow_id=workflow.workflow_id\n            )\n            for a in aliases:\n                if a in result.keys():\n                    raise Exception(\n                        f\"Duplicate workflow alias '{a}': this is most likely a bug.\"\n                    )\n                result[a] = workflow\n        result = {k: result[k] for k in sorted(result.keys())}\n    else:\n        # faster if not other matcher params\n        all_aliases = self.context.workflow_registry.workflow_aliases\n        result = {\n            a: self.get_workflow(workflow=all_aliases[a])\n            for a in sorted(all_aliases.keys())\n        }\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflows_info","title":"<code>retrieve_workflows_info(**matcher_params: Any) -&gt; WorkflowGroupInfo</code>","text":"<p>Get a map info instances for all available workflows, indexed by (stringified) workflow-id.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflows_info(self, **matcher_params: Any) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by (stringified) workflow-id.\"\"\"\n\n    workflows = self.list_workflows(**matcher_params)\n\n    workflow_infos = WorkflowGroupInfo.create_from_workflows(\n        *workflows.values(),\n        group_title=None,\n        alias_map=self.context.workflow_registry.workflow_aliases,\n    )\n    return workflow_infos\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.retrieve_workflow_aliases_info","title":"<code>retrieve_workflow_aliases_info(**matcher_params: Any) -&gt; WorkflowGroupInfo</code>","text":"<p>Get a map info instances for all available workflows, indexed by alias.</p> Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def retrieve_workflow_aliases_info(\n    self, **matcher_params: Any\n) -&gt; WorkflowGroupInfo:\n\"\"\"Get a map info instances for all available workflows, indexed by alias.\"\"\"\n\n    workflows = self.list_workflow_aliases(**matcher_params)\n    workflow_infos = WorkflowGroupInfo.create_from_workflows(\n        *workflows.values(),\n        group_title=None,\n        alias_map=self.context.workflow_registry.workflow_aliases,\n    )\n    return workflow_infos\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api.KiaraAPI.create_workflow","title":"<code>create_workflow(workflow_alias: Union[None, str] = None, initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None, initial_inputs: Union[None, Mapping[str, Any]] = None, documentation: Union[Any, None] = None, save: bool = False, force_alias: bool = False) -&gt; Workflow</code>","text":"Source code in <code>kiara/interfaces/python_api/__init__.py</code> <pre><code>def create_workflow(\n    self,\n    workflow_alias: Union[None, str] = None,\n    initial_pipeline: Union[None, Path, str, Mapping[str, Any]] = None,\n    initial_inputs: Union[None, Mapping[str, Any]] = None,\n    documentation: Union[Any, None] = None,\n    save: bool = False,\n    force_alias: bool = False,\n) -&gt; Workflow:\n\n    if workflow_alias is not None:\n        try:\n            uuid.UUID(workflow_alias)\n            raise Exception(\n                f\"Can't create workflow, provided alias can't be a uuid: {workflow_alias}.\"\n            )\n        except Exception:\n            pass\n\n    workflow_id = ID_REGISTRY.generate()\n    metadata = WorkflowMetadata(\n        workflow_id=workflow_id, documentation=documentation\n    )\n\n    workflow_obj = Workflow(kiara=self.context, workflow=metadata)\n    if workflow_alias:\n        workflow_obj._pending_aliases.add(workflow_alias)\n\n    if initial_pipeline:\n        operation = self.get_operation(operation=initial_pipeline)\n        if operation.module_type == \"pipeline\":\n            pipeline_details: PipelineOperationDetails = operation.operation_details  # type: ignore\n            workflow_obj.add_steps(*pipeline_details.pipeline_config.steps)\n            input_aliases = pipeline_details.pipeline_config.input_aliases\n            for k, v in input_aliases.items():\n                workflow_obj.set_input_alias(input_field=k, alias=v)\n            output_aliases = pipeline_details.pipeline_config.output_aliases\n            for k, v in output_aliases.items():\n                workflow_obj.set_output_alias(output_field=k, alias=v)\n        else:\n            raise NotImplementedError()\n\n        workflow_obj.set_inputs(**operation.module.config.defaults)\n\n    if initial_inputs:\n        workflow_obj.set_inputs(**initial_inputs)\n\n    self._workflow_cache[workflow_obj.workflow_id] = workflow_obj\n\n    if save:\n        if force_alias and workflow_alias:\n            self.context.workflow_registry.unregister_alias(workflow_alias)\n        workflow_obj.save()\n\n    return workflow_obj\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/__init__/#kiara.interfaces.python_api-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/batch/","title":"batch","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation","title":"<code>BatchOperation</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>class BatchOperation(BaseModel):\n    class Config:\n        validate_assignment = True\n\n    @classmethod\n    def from_file(\n        cls,\n        path: str,\n        kiara: Union[\"Kiara\", None] = None,\n    ):\n\n        data = get_data_from_file(path)\n        pipeline_id = data.get(\"pipeline_name\", None)\n        if pipeline_id is None:\n            name = os.path.basename(path)\n            if name.endswith(\".json\"):\n                name = name[0:-5]\n            elif name.endswith(\".yaml\"):\n                name = name[0:-5]\n            data[\"pipeline_name\"] = name\n\n        alias = os.path.basename(path)\n\n        return cls.from_config(alias=alias, data=data, kiara=kiara)\n\n    @classmethod\n    def from_config(\n        cls,\n        alias: str,\n        data: Mapping[str, Any],\n        kiara: Union[\"Kiara\", None],\n    ):\n\n        data = dict(data)\n        inputs = data.pop(\"inputs\", {})\n        save = data.pop(\"save\", False)\n        pipeline_id = data.pop(\"pipeline_name\", None)\n        if pipeline_id is None:\n            pipeline_id = str(uuid.uuid4())\n\n        if kiara is None:\n            kiara = Kiara.instance()\n\n        pipeline_config = PipelineConfig.from_config(\n            pipeline_name=pipeline_id, data=data, kiara=kiara\n        )\n\n        result = cls(\n            alias=alias,\n            pipeline_config=pipeline_config,\n            inputs=inputs,\n            save_defaults=save,\n        )\n        result._kiara = kiara\n        return result\n\n    alias: str = Field(description=\"The batch name/alias.\")\n    pipeline_config: PipelineConfig = Field(\n        description=\"The configuration of the underlying pipeline.\"\n    )\n    inputs: Dict[str, Any] = Field(\n        description=\"The (base) inputs to use. Can be augmented before running the operation.\"\n    )\n\n    save_defaults: Dict[str, List[str]] = Field(\n        description=\"Configuration which values to save, under which alias(es).\",\n        default_factory=dict,\n    )\n\n    _kiara: Kiara = PrivateAttr(default=None)\n\n    @root_validator(pre=True)\n    def add_alias(cls, values):\n\n        if not values.get(\"alias\", None):\n            pc = values.get(\"pipeline_config\", None)\n            if not pc:\n                raise ValueError(\"No pipeline config provided.\")\n            if isinstance(pc, PipelineConfig):\n                alias = pc.pipeline_name\n            else:\n                alias = pc.get(\"pipeline_name\", None)\n            values[\"alias\"] = alias\n\n        return values\n\n    @validator(\"save_defaults\", always=True, pre=True)\n    def validate_save(cls, save, values):\n\n        alias = values[\"alias\"]\n        pipeline_config = values[\"pipeline_config\"]\n        return cls.create_save_aliases(\n            save=save, alias=alias, pipeline_config=pipeline_config\n        )\n\n    @classmethod\n    def create_save_aliases(\n        cls,\n        save: Union[bool, None, str, Mapping],\n        alias: str,\n        pipeline_config: PipelineConfig,\n    ) -&gt; Mapping[str, Any]:\n\n        assert isinstance(pipeline_config, PipelineConfig)\n\n        if save in [False, None]:\n            save_new: Dict[str, Any] = {}\n        elif save is True:\n            field_names = pipeline_config.structure.pipeline_outputs_schema.keys()\n            save_new = create_save_config(field_names=field_names, aliases=alias)\n        elif isinstance(save, str):\n            field_names = pipeline_config.structure.pipeline_outputs_schema.keys()\n            save_new = create_save_config(field_names=field_names, aliases=save)\n        elif isinstance(save, Mapping):\n            save_new = dict(save)\n        else:\n            raise ValueError(\n                f\"Invalid type '{type(save)}' for 'save' attribute: must be None, bool, string or Mapping.\"\n            )\n\n        return save_new\n\n    def run(\n        self,\n        inputs: Union[Mapping[str, Any], None] = None,\n        save: Union[None, bool, str, Mapping[str, Any]] = None,\n    ) -&gt; ValueMap:\n\n        pipeline = Pipeline(\n            structure=self.pipeline_config.structure,\n            kiara=self._kiara,\n        )\n        pipeline_controller = SinglePipelineBatchController(\n            pipeline=pipeline, job_registry=self._kiara.job_registry\n        )\n\n        run_inputs = dict(self.inputs)\n        if inputs:\n            run_inputs.update(inputs)\n\n        pipeline.set_pipeline_inputs(inputs=run_inputs)\n        pipeline_controller.process_pipeline()\n\n        result = self._kiara.data_registry.load_values(\n            pipeline.get_current_pipeline_outputs()\n        )\n\n        if save is not None:\n            if save is True:\n                save = self.save_defaults\n            else:\n                save = self.__class__.create_save_aliases(\n                    save=save, alias=self.alias, pipeline_config=self.pipeline_config\n                )\n\n            self._kiara.save_values(values=result, alias_map=save)\n\n        return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.alias","title":"<code>alias: str = Field(description='The batch name/alias.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.pipeline_config","title":"<code>pipeline_config: PipelineConfig = Field(description='The configuration of the underlying pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.inputs","title":"<code>inputs: Dict[str, Any] = Field(description='The (base) inputs to use. Can be augmented before running the operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.save_defaults","title":"<code>save_defaults: Dict[str, List[str]] = Field(description='Configuration which values to save, under which alias(es).', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>class Config:\n    validate_assignment = True\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.Config-attributes","title":"Attributes","text":"<code>validate_assignment = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.from_file","title":"<code>from_file(path: str, kiara: Union[Kiara, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: str,\n    kiara: Union[\"Kiara\", None] = None,\n):\n\n    data = get_data_from_file(path)\n    pipeline_id = data.get(\"pipeline_name\", None)\n    if pipeline_id is None:\n        name = os.path.basename(path)\n        if name.endswith(\".json\"):\n            name = name[0:-5]\n        elif name.endswith(\".yaml\"):\n            name = name[0:-5]\n        data[\"pipeline_name\"] = name\n\n    alias = os.path.basename(path)\n\n    return cls.from_config(alias=alias, data=data, kiara=kiara)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.from_config","title":"<code>from_config(alias: str, data: Mapping[str, Any], kiara: Union[Kiara, None])</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>@classmethod\ndef from_config(\n    cls,\n    alias: str,\n    data: Mapping[str, Any],\n    kiara: Union[\"Kiara\", None],\n):\n\n    data = dict(data)\n    inputs = data.pop(\"inputs\", {})\n    save = data.pop(\"save\", False)\n    pipeline_id = data.pop(\"pipeline_name\", None)\n    if pipeline_id is None:\n        pipeline_id = str(uuid.uuid4())\n\n    if kiara is None:\n        kiara = Kiara.instance()\n\n    pipeline_config = PipelineConfig.from_config(\n        pipeline_name=pipeline_id, data=data, kiara=kiara\n    )\n\n    result = cls(\n        alias=alias,\n        pipeline_config=pipeline_config,\n        inputs=inputs,\n        save_defaults=save,\n    )\n    result._kiara = kiara\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.add_alias","title":"<code>add_alias(values)</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>@root_validator(pre=True)\ndef add_alias(cls, values):\n\n    if not values.get(\"alias\", None):\n        pc = values.get(\"pipeline_config\", None)\n        if not pc:\n            raise ValueError(\"No pipeline config provided.\")\n        if isinstance(pc, PipelineConfig):\n            alias = pc.pipeline_name\n        else:\n            alias = pc.get(\"pipeline_name\", None)\n        values[\"alias\"] = alias\n\n    return values\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.validate_save","title":"<code>validate_save(save, values)</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>@validator(\"save_defaults\", always=True, pre=True)\ndef validate_save(cls, save, values):\n\n    alias = values[\"alias\"]\n    pipeline_config = values[\"pipeline_config\"]\n    return cls.create_save_aliases(\n        save=save, alias=alias, pipeline_config=pipeline_config\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.create_save_aliases","title":"<code>create_save_aliases(save: Union[bool, None, str, Mapping], alias: str, pipeline_config: PipelineConfig) -&gt; Mapping[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>@classmethod\ndef create_save_aliases(\n    cls,\n    save: Union[bool, None, str, Mapping],\n    alias: str,\n    pipeline_config: PipelineConfig,\n) -&gt; Mapping[str, Any]:\n\n    assert isinstance(pipeline_config, PipelineConfig)\n\n    if save in [False, None]:\n        save_new: Dict[str, Any] = {}\n    elif save is True:\n        field_names = pipeline_config.structure.pipeline_outputs_schema.keys()\n        save_new = create_save_config(field_names=field_names, aliases=alias)\n    elif isinstance(save, str):\n        field_names = pipeline_config.structure.pipeline_outputs_schema.keys()\n        save_new = create_save_config(field_names=field_names, aliases=save)\n    elif isinstance(save, Mapping):\n        save_new = dict(save)\n    else:\n        raise ValueError(\n            f\"Invalid type '{type(save)}' for 'save' attribute: must be None, bool, string or Mapping.\"\n        )\n\n    return save_new\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch.BatchOperation.run","title":"<code>run(inputs: Union[Mapping[str, Any], None] = None, save: Union[None, bool, str, Mapping[str, Any]] = None) -&gt; ValueMap</code>","text":"Source code in <code>kiara/interfaces/python_api/batch.py</code> <pre><code>def run(\n    self,\n    inputs: Union[Mapping[str, Any], None] = None,\n    save: Union[None, bool, str, Mapping[str, Any]] = None,\n) -&gt; ValueMap:\n\n    pipeline = Pipeline(\n        structure=self.pipeline_config.structure,\n        kiara=self._kiara,\n    )\n    pipeline_controller = SinglePipelineBatchController(\n        pipeline=pipeline, job_registry=self._kiara.job_registry\n    )\n\n    run_inputs = dict(self.inputs)\n    if inputs:\n        run_inputs.update(inputs)\n\n    pipeline.set_pipeline_inputs(inputs=run_inputs)\n    pipeline_controller.process_pipeline()\n\n    result = self._kiara.data_registry.load_values(\n        pipeline.get_current_pipeline_outputs()\n    )\n\n    if save is not None:\n        if save is True:\n            save = self.save_defaults\n        else:\n            save = self.__class__.create_save_aliases(\n                save=save, alias=self.alias, pipeline_config=self.pipeline_config\n            )\n\n        self._kiara.save_values(values=result, alias_map=save)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/batch/#kiara.interfaces.python_api.batch-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/operation/","title":"operation","text":""},{"location":"reference/kiara/interfaces/python_api/utils/","title":"utils","text":""},{"location":"reference/kiara/interfaces/python_api/utils/#kiara.interfaces.python_api.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/utils/#kiara.interfaces.python_api.utils.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/utils/#kiara.interfaces.python_api.utils-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/utils/#kiara.interfaces.python_api.utils.create_save_config","title":"<code>create_save_config(field_names: Union[str, Iterable[str]], aliases: Union[None, str, Iterable[str], Mapping[str, Any]]) -&gt; Dict[str, List[str]]</code>","text":"Source code in <code>kiara/interfaces/python_api/utils.py</code> <pre><code>def create_save_config(\n    field_names: Union[str, Iterable[str]],\n    aliases: Union[None, str, Iterable[str], Mapping[str, Any]],\n) -&gt; Dict[str, List[str]]:\n\n    if isinstance(field_names, str):\n        field_names = [field_names]\n\n    if aliases is None:\n        alias_map: Dict[str, List[str]] = {}\n    elif isinstance(aliases, str):\n        alias_map = {}\n        for field_name in field_names:\n            alias_map[field_name] = [f\"{aliases}.{field_name}\"]\n    elif isinstance(aliases, Mapping):\n        alias_map = {}\n        for field_name in aliases.keys():\n            if field_name in field_names:\n                if isinstance(aliases[field_name], str):\n                    alias_map[field_name] = [aliases[field_name]]\n                else:\n                    alias_map[field_name] = sorted(aliases[field_name])\n            else:\n                logger.warning(\n                    \"ignore.field_alias\",\n                    ignored_field_name=field_name,\n                    reason=\"field name not in results\",\n                    available_field_names=sorted(field_names),\n                )\n                continue\n    else:\n        raise Exception(\n            f\"Invalid type '{type(aliases)}' for aliases parameter, must be string or mapping.\"\n        )\n\n    return alias_map\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/value/","title":"value","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult","title":"<code>StoreValueResult</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/interfaces/python_api/value.py</code> <pre><code>class StoreValueResult(BaseModel):\n\n    value: Value = Field(description=\"The stored value.\")\n    aliases: List[str] = Field(\n        description=\"The aliases that where assigned to the value when stored.\"\n    )\n    persisted_data: Union[None, PersistedData] = Field(\n        description=\"The structure describing the data that was persisted, 'None' if the data was already stored before (or storing failed).\"\n    )\n    error: Union[str, None] = Field(\n        description=\"An error that occured while trying to store.\"\n    )\n\n    def _repr_html_(self):\n\n        r = self.create_renderable()\n        mime_bundle = r._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n        return mime_bundle[\"text/html\"]\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n\n        yield self.create_renderable()\n\n    def create_renderable(self, **config) -&gt; RenderableType:\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\", \"i\")\n        table.add_column(\"value\")\n\n        table.add_row(\"value_id\", str(self.value.value_id))\n        if self.aliases:\n            if len(self.aliases) &gt; 1:\n                a = \"aliases\"\n            else:\n                a = \"alias\"\n            table.add_row(a, \", \".join(self.aliases))\n        else:\n            table.add_row(\"aliases\", \"-- no aliases --\")\n        table.add_row(\"data type\", self.value.data_type_name)\n        table.add_row(\"size\", humanfriendly.format_size(self.value.value_size))\n        table.add_row(\"success\", \"yes\" if not self.error else \"no\")\n        if self.error:\n            table.add_row(\"[red]error[/red]\", f\"{self.error}\")\n\n        return Panel(table, title=\"Store operation result\", title_align=\"left\")\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult.value","title":"<code>value: Value = Field(description='The stored value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult.aliases","title":"<code>aliases: List[str] = Field(description='The aliases that where assigned to the value when stored.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult.persisted_data","title":"<code>persisted_data: Union[None, PersistedData] = Field(description=\"The structure describing the data that was persisted, 'None' if the data was already stored before (or storing failed).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult.error","title":"<code>error: Union[str, None] = Field(description='An error that occured while trying to store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValueResult.create_renderable","title":"<code>create_renderable(**config) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/value.py</code> <pre><code>def create_renderable(self, **config) -&gt; RenderableType:\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", \"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"value_id\", str(self.value.value_id))\n    if self.aliases:\n        if len(self.aliases) &gt; 1:\n            a = \"aliases\"\n        else:\n            a = \"alias\"\n        table.add_row(a, \", \".join(self.aliases))\n    else:\n        table.add_row(\"aliases\", \"-- no aliases --\")\n    table.add_row(\"data type\", self.value.data_type_name)\n    table.add_row(\"size\", humanfriendly.format_size(self.value.value_size))\n    table.add_row(\"success\", \"yes\" if not self.error else \"no\")\n    if self.error:\n        table.add_row(\"[red]error[/red]\", f\"{self.error}\")\n\n    return Panel(table, title=\"Store operation result\", title_align=\"left\")\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValuesResult","title":"<code>StoreValuesResult</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/interfaces/python_api/value.py</code> <pre><code>class StoreValuesResult(BaseModel):\n\n    __root__: Dict[str, StoreValueResult]\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=True, show_lines=False, box=box.SIMPLE)\n        table.add_column(\"field\", style=\"b\")\n        table.add_column(\"data type\", style=\"i\")\n        table.add_column(\"stored id\", style=\"i\")\n        table.add_column(\"alias(es)\")\n\n        for field_name, value_result in self.__root__.items():\n            row = [\n                field_name,\n                str(value_result.value.value_schema.type),\n                str(value_result.value.value_id),\n            ]\n            if value_result.aliases:\n                row.append(\", \".join(value_result.aliases))\n            else:\n                row.append(\"\")\n            table.add_row(*row)\n\n        return table\n\n    def __len__(self):\n        return len(self.__root__)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValuesResult-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/value/#kiara.interfaces.python_api.value.StoreValuesResult.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/value.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=True, show_lines=False, box=box.SIMPLE)\n    table.add_column(\"field\", style=\"b\")\n    table.add_column(\"data type\", style=\"i\")\n    table.add_column(\"stored id\", style=\"i\")\n    table.add_column(\"alias(es)\")\n\n    for field_name, value_result in self.__root__.items():\n        row = [\n            field_name,\n            str(value_result.value.value_schema.type),\n            str(value_result.value.value_id),\n        ]\n        if value_result.aliases:\n            row.append(\", \".join(value_result.aliases))\n        else:\n            row.append(\"\")\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/","title":"workflow","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.WorkflowPipelineController","title":"<code>WorkflowPipelineController</code>","text":"<p>         Bases: <code>SinglePipelineController</code></p> <p>A PipelineController that executes all pipeline steps non-interactively.</p> <p>This is the default implementation of a <code>PipelineController</code>, and probably the most simple implementation of one. It waits until all inputs are set, after which it executes all pipeline steps in the required order.</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>class WorkflowPipelineController(SinglePipelineController):\n\"\"\"A [PipelineController][kiara.models.modules.pipeline.controller.PipelineController] that executes all pipeline steps non-interactively.\n\n    This is the default implementation of a ``PipelineController``, and probably the most simple implementation of one.\n    It waits until all inputs are set, after which it executes all pipeline steps in the required order.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        kiara: \"Kiara\",\n    ):\n\n        self._is_running: bool = False\n        super().__init__(job_registry=kiara.job_registry)\n\n    def _pipeline_event_occurred(self, event: PipelineEvent):\n\n        if event.pipeline_id != self.pipeline.pipeline_id:\n            return\n\n        self._pipeline_details = None\n\n    def process_pipeline(\n        self,\n    ) -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]:\n\n        log = logger.bind(pipeline_id=self.pipeline.pipeline_id)\n        if self._is_running:\n            log.debug(\n                \"ignore.pipeline_process\",\n                reason=\"Pipeline already running.\",\n            )\n            raise Exception(\"Pipeline already running.\")\n\n        log.debug(\"execute.pipeline\")\n        self._is_running = True\n\n        result: Dict[uuid.UUID, uuid.UUID] = {}\n        errors: Dict[str, ActiveJob] = {}\n\n        try:\n            stages = self.pipeline.structure.extract_processing_stages(\n                stages_extraction_type=\"late\"\n            )\n            for idx, stage in enumerate(stages, start=1):\n\n                log.debug(\n                    \"execute.pipeline.stage\",\n                    stage=idx,\n                )\n\n                job_ids = {}\n                stage_failed = False\n                for step_id in stage:\n\n                    log.debug(\n                        \"execute.pipeline.step\",\n                        step_id=step_id,\n                    )\n\n                    try:\n                        job_id = self.process_step(step_id)\n                        job_ids[step_id] = job_id\n                    except Exception as e:\n                        # TODO: cancel running jobs?\n                        log_exception(e)\n                        log.error(\n                            \"error.processing.workflow_pipeline\",\n                            step_id=step_id,\n                            error=e,\n                        )\n                        stage_failed = True\n\n                self._job_registry.wait_for(*job_ids.values())\n                for step_id, job_id in job_ids.items():\n                    j = self._job_registry.get_job(job_id)\n                    if j.status != JobStatus.SUCCESS:\n                        errors[step_id] = j\n                output_job_map = self.set_processing_results(job_ids=job_ids)\n                result.update(output_job_map)\n                if not stage_failed:\n                    log.debug(\n                        \"execute_finished.pipeline.stage\",\n                        stage=idx,\n                    )\n                else:\n                    log.debug(\n                        \"execute_failed.pipeline.stage\",\n                        stage=idx,\n                    )\n                    break\n        except Exception as e:\n            log_exception(e)\n        finally:\n            self._is_running = False\n\n        log.debug(\"execute_finished.pipeline\")\n        return result, errors\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.WorkflowPipelineController-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.WorkflowPipelineController.process_pipeline","title":"<code>process_pipeline() -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def process_pipeline(\n    self,\n) -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]:\n\n    log = logger.bind(pipeline_id=self.pipeline.pipeline_id)\n    if self._is_running:\n        log.debug(\n            \"ignore.pipeline_process\",\n            reason=\"Pipeline already running.\",\n        )\n        raise Exception(\"Pipeline already running.\")\n\n    log.debug(\"execute.pipeline\")\n    self._is_running = True\n\n    result: Dict[uuid.UUID, uuid.UUID] = {}\n    errors: Dict[str, ActiveJob] = {}\n\n    try:\n        stages = self.pipeline.structure.extract_processing_stages(\n            stages_extraction_type=\"late\"\n        )\n        for idx, stage in enumerate(stages, start=1):\n\n            log.debug(\n                \"execute.pipeline.stage\",\n                stage=idx,\n            )\n\n            job_ids = {}\n            stage_failed = False\n            for step_id in stage:\n\n                log.debug(\n                    \"execute.pipeline.step\",\n                    step_id=step_id,\n                )\n\n                try:\n                    job_id = self.process_step(step_id)\n                    job_ids[step_id] = job_id\n                except Exception as e:\n                    # TODO: cancel running jobs?\n                    log_exception(e)\n                    log.error(\n                        \"error.processing.workflow_pipeline\",\n                        step_id=step_id,\n                        error=e,\n                    )\n                    stage_failed = True\n\n            self._job_registry.wait_for(*job_ids.values())\n            for step_id, job_id in job_ids.items():\n                j = self._job_registry.get_job(job_id)\n                if j.status != JobStatus.SUCCESS:\n                    errors[step_id] = j\n            output_job_map = self.set_processing_results(job_ids=job_ids)\n            result.update(output_job_map)\n            if not stage_failed:\n                log.debug(\n                    \"execute_finished.pipeline.stage\",\n                    stage=idx,\n                )\n            else:\n                log.debug(\n                    \"execute_failed.pipeline.stage\",\n                    stage=idx,\n                )\n                break\n    except Exception as e:\n        log_exception(e)\n    finally:\n        self._is_running = False\n\n    log.debug(\"execute_finished.pipeline\")\n    return result, errors\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.WorkflowStatus","title":"<code>WorkflowStatus</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>class WorkflowStatus(KiaraModel):\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow","title":"<code>Workflow</code>","text":"<p>         Bases: <code>object</code></p> <p>A wrapper object to make working with workflows easier for frontend code.</p> <p>This is the type of class everyone advises you against creating in Object-Oriented code, all it contains is basically internal state. In this case, I believe it's warranted because otherwise frontend code would spin out of control, complexity-wise. I'm happy to be proven wrong, though.</p> <p>None of this is thread-safe (yet).</p> <p>This object can be initialized in different ways, depending on circumstances:</p> <ul> <li>if you want to create a new workflow object: use 'None' or a WorkflowMetadata object you createed earlier      (ensure you don't re-use an existing workflow_id, otherwise it might get overwrittern in the backend)</li> <li>if you want to create the wrapper object from an existing workflow: provide its id or alias string</li> </ul> <p>Parameters:</p> Name Type Description Default <code>kiara</code> <code>Union[Kiara, None]</code> <p>the kiara context in which this workflow lives</p> <code>None</code> <code>workflow</code> <code>Union[None, WorkflowMetadata, uuid.UUID, str]</code> <p>the workflow metadata (or reference to it)</p> <code>None</code> <code>load_existing</code> <code>Union[bool, None]</code> <p>if set to 'False', a workflow with the provided id/alias can't already exist, if 'True', it must, if set to 'None', kiara tries to be smart and loads if exists, otherwise creates a new one</p> <code>None</code> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>class Workflow(object):\n\"\"\"A wrapper object to make working with workflows easier for frontend code.\n\n    This is the type of class everyone advises you against creating in Object-Oriented code, all it contains is basically\n    internal state. In this case, I believe it's warranted because otherwise frontend code would spin out of control,\n    complexity-wise. I'm happy to be proven wrong, though.\n\n    None of this is thread-safe (yet).\n\n    This object can be initialized in different ways, depending on circumstances:\n\n     - if you want to create a new workflow object: use 'None' or a WorkflowMetadata object you createed earlier\n         (ensure you don't re-use an existing workflow_id, otherwise it might get overwrittern in the backend)\n     - if you want to create the wrapper object from an existing workflow: provide its id or alias string\n\n    Arguments:\n        kiara: the kiara context in which this workflow lives\n        workflow: the workflow metadata (or reference to it)\n        load_existing: if set to 'False', a workflow with the provided id/alias can't already exist, if 'True', it must, if set to 'None', kiara tries to be smart and loads if exists, otherwise creates a new one\n    \"\"\"\n\n    @classmethod\n    def load(\n        cls,\n        workflow: Union[uuid.UUID, str],\n        kiara: Union[\"Kiara\", None] = None,\n        create: bool = False,\n    ):\n\"\"\"Load an existing workflow using a workflow id or alias.\"\"\"\n\n        try:\n            workflow_obj = Workflow(workflow=workflow, kiara=kiara, load_existing=True)\n        except NoSuchWorkflowException as nswe:\n            if create:\n\n                if isinstance(workflow, uuid.UUID):\n                    raise nswe\n                temp = None\n                try:\n                    temp = uuid.UUID(workflow)\n                except Exception:\n                    pass\n                if temp is not None:\n                    raise nswe\n\n                if kiara is None:\n                    from kiara.context import Kiara\n\n                    kiara = Kiara.instance()\n\n                workflow_metadata = kiara.workflow_registry.register_workflow(\n                    workflow_aliases=[workflow]\n                )\n                workflow_obj = Workflow(workflow=workflow_metadata.workflow_id)\n\n        return workflow_obj\n\n    @classmethod\n    def create(\n        cls,\n        alias: Union[None, str] = None,\n        replace_existing_alias: bool = False,\n        doc: Union[Any, None] = None,\n        kiara: Union[\"Kiara\", None] = None,\n    ):\n\"\"\"Create a new workflow object.\"\"\"\n\n        if replace_existing_alias and alias is not None:\n            if kiara is None:\n                from kiara.context import Kiara\n\n                kiara = Kiara.instance()\n\n            kiara.workflow_registry.unregister_alias(alias=alias)\n\n        workflow = Workflow(workflow=alias, kiara=kiara, load_existing=False)\n        if doc:\n            workflow.documentation = doc\n        return workflow\n\n    def __init__(\n        self,\n        workflow: Union[None, WorkflowMetadata, uuid.UUID, str] = None,\n        kiara: Union[\"Kiara\", None] = None,\n        load_existing: Union[bool, None] = None,\n    ):\n\n        if kiara is None:\n            from kiara.context import Kiara\n\n            kiara = Kiara.instance()\n\n        self._kiara: \"Kiara\" = kiara\n        self._metadata_is_stored: bool = False\n        self._metadata_is_synced: bool = False\n\n        self._pending_aliases: Set[str] = set()\n\n        _workflow_id: Union[None, uuid.UUID] = None\n        _workflow_alias: Union[None, str] = None\n        _workflow_metadata: Union[None, WorkflowMetadata] = None\n\n        if workflow is None:\n            if load_existing is True:\n                raise Exception(\n                    \"Can't create workflow: no workflow reference provided, but 'load_existing' forced to 'True'.\"\n                )\n            _w_id = ID_REGISTRY.generate(comment=\"New workflow object.\")\n            _workflow_metadata = WorkflowMetadata(workflow_id=_w_id)\n        elif isinstance(workflow, str):\n            try:\n                _workflow_id = uuid.UUID(workflow)\n                _workflow_metadata = (\n                    self._kiara.workflow_registry.get_workflow_metadata(\n                        workflow=_workflow_id\n                    )\n                )\n                if load_existing is False:\n                    raise Exception(\n                        f\"Can't create workflow for id '{_workflow_id}': workflow with this id already registered and 'load_existing' set to 'False'.\"\n                    )\n                self._metadata_is_stored = True\n                self._metadata_is_synced = True\n            except NoSuchWorkflowException as nswe:\n                # means an uuid was provided\n                raise nswe\n            except Exception:\n                # means it's an alias\n                _workflow_alias = workflow\n                try:\n                    _workflow_id = self._kiara.workflow_registry.get_workflow_id(\n                        workflow\n                    )\n                    if load_existing is False:\n                        raise Exception(\n                            f\"Can't create workflow with alias '{_workflow_alias}': alias already registered, and 'load_existing' set to 'False'.\"\n                        )\n                    _workflow_metadata = (\n                        self._kiara.workflow_registry.get_workflow_metadata(\n                            workflow=_workflow_id\n                        )\n                    )\n                    self._metadata_is_stored = True\n                    self._metadata_is_synced = True\n                except NoSuchWorkflowException:\n                    # does not exist yet\n                    if load_existing is True:\n                        raise NoSuchWorkflowException(\n                            msg=f\"Can't load workflow with alias '{_workflow_alias}': no workflow with this alias registered.\",\n                            workflow=_workflow_alias,\n                        )\n                    self._pending_aliases.add(_workflow_alias)\n                    _workflow_id = ID_REGISTRY.generate(comment=\"New workflow object.\")\n                    _workflow_metadata = WorkflowMetadata(workflow_id=_workflow_id)\n        elif isinstance(workflow, uuid.UUID):\n            _workflow_id = workflow\n            if load_existing is False:\n                raise Exception(\n                    f\"Can't create workflow for id '{_workflow_id}': 'load_existing' set to 'False'.\"\n                )\n            _workflow_metadata = self._kiara.workflow_registry.get_workflow_metadata(\n                workflow=_workflow_id\n            )\n            self._metadata_is_stored = True\n            self._metadata_is_synced = True\n        elif isinstance(workflow, WorkflowMetadata):\n            if load_existing is True:\n                raise Exception(\n                    f\"Can't create workflow with id '{workflow.workflow_id}': 'load_existing' forced to 'True'.\"\n                )\n            temp = None\n            _workflow_metadata = None\n            try:\n                temp = self._kiara.workflow_registry.get_workflow_metadata(\n                    workflow.workflow_id\n                )\n            except Exception:\n                _workflow_metadata = workflow\n                _workflow_id = _workflow_metadata.workflow_id\n\n            if temp is not None:\n                raise Exception(\n                    f\"Can't create new workflow with id '{workflow.workflow_id}': id already registered.\"\n                )\n\n        else:\n            raise Exception(\n                f\"Can't find workflow metadata for '{workflow}: invalid type '{type(workflow)}'.\"\n            )\n\n        assert _workflow_id is not None\n        assert _workflow_metadata is not None\n\n        self._workflow_metadata: WorkflowMetadata = _workflow_metadata\n        self._workflow_id: uuid.UUID = self.workflow_metadata.workflow_id\n\n        self._execution_context: ExecutionContext = ExecutionContext()\n        self._pipeline_controller: WorkflowPipelineController = (\n            WorkflowPipelineController(kiara=self._kiara)\n        )\n\n        self._all_inputs: Dict[str, Union[None, uuid.UUID]] = {}\n        self._all_inputs_optimistic_lookup: Dict[str, Dict[Hashable, uuid.UUID]] = {}\n        self._current_pipeline_inputs: Union[Dict[str, uuid.UUID], None] = None\n        self._current_pipeline_outputs: Union[Dict[str, uuid.UUID], None] = None\n\n        self._steps: Dict[str, PipelineStep] = {}\n\n        self._current_workflow_inputs_schema: Union[Dict[str, ValueSchema], None] = None\n        self._current_workflow_outputs_schema: Union[\n            Dict[str, ValueSchema], None\n        ] = None\n        self._workflow_input_aliases: Dict[str, str] = dict(\n            _workflow_metadata.input_aliases\n        )\n        self._workflow_output_aliases: Dict[str, str] = dict(\n            _workflow_metadata.output_aliases\n        )\n\n        self._current_workflow_inputs: Union[Dict[str, uuid.UUID], None] = None\n        self._current_workflow_outputs: Union[Dict[str, uuid.UUID], None] = None\n\n        # self._current_state_cid: Union[None, CID] = None\n        # self._state_history: Dict[datetime, str] = {}\n        self._state_cache: Dict[str, WorkflowState] = {}\n        self._state_output_cache: Dict[str, Set[uuid.UUID]] = {}\n        self._state_jobrecord_cache: Dict[str, Set[uuid.UUID]] = {}\n\n        self._job_id_cache: Dict[uuid.UUID, uuid.UUID] = {}\n\"\"\"Cache to save job ids per output value(s), in order to save jobs if output values are saved.\"\"\"\n\n        self._pipeline: Union[Pipeline, None] = None\n        self._pipeline_info: Union[PipelineInfo, None] = None\n        self._current_info: Union[WorkflowInfo, None] = None\n        self._current_state: Union[WorkflowState, None] = None\n\n        if self._workflow_metadata.workflow_history:\n            self.load_state()\n\n    def _sync_workflow_metadata(self):\n\"\"\"Store/update the metadata of this workflow.\"\"\"\n\n        self._workflow_metadata = self._kiara.workflow_registry.register_workflow(\n            workflow_metadata=self._workflow_metadata,\n            workflow_aliases=self._pending_aliases,\n        )\n        self._pending_aliases.clear()\n        self._metadata_is_stored = True\n        self._metadata_is_synced = True\n\n    @property\n    def workflow_id(self) -&gt; uuid.UUID:\n\"\"\"Retrieve the globally unique id for this workflow.\"\"\"\n        return self._workflow_metadata.workflow_id\n\n    @property\n    def workflow_metadata(self) -&gt; WorkflowMetadata:\n\"\"\"Retrieve an object that contains metadata for this workflow.\"\"\"\n        return self._workflow_metadata\n\n    @property\n    def documentation(self) -&gt; DocumentationMetadataModel:\n        return self.workflow_metadata.documentation\n\n    @documentation.setter\n    def documentation(self, documentation: Any):\n\n        doc = DocumentationMetadataModel.create(documentation)\n        self.workflow_metadata.documentation = doc\n\n    @property\n    def is_persisted(self) -&gt; bool:\n\"\"\"Check whether this workflow is persisted in it's current state.\"\"\"\n\n        return self.workflow_metadata.is_persisted\n\n    @property\n    def current_pipeline_inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n        return self.pipeline.structure.pipeline_inputs_schema\n\n    @property\n    def current_pipeline_inputs(self) -&gt; Mapping[str, uuid.UUID]:\n\n        if self._current_pipeline_inputs is None:\n            self._apply_inputs()\n        assert self._current_pipeline_inputs is not None\n        return self._current_pipeline_inputs\n\n    @property\n    def current_pipeline_input_values(self) -&gt; ValueMap:\n        return self._kiara.data_registry.load_values(\n            values=self.current_pipeline_inputs\n        )\n\n    @property\n    def current_pipeline_outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n        return self.pipeline.structure.pipeline_outputs_schema\n\n    @property\n    def current_pipeline_outputs(self) -&gt; Mapping[str, uuid.UUID]:\n\n        if self._current_pipeline_outputs is None:\n            try:\n                self.process_steps()\n            except Exception:\n                self._current_pipeline_outputs = (\n                    self.pipeline.get_current_pipeline_outputs()\n                )\n\n        assert self._current_pipeline_outputs is not None\n        return self._current_pipeline_outputs\n\n    @property\n    def current_pipeline_output_values(self) -&gt; ValueMap:\n        return self._kiara.data_registry.load_values(\n            values=self.current_pipeline_outputs\n        )\n\n    @property\n    def input_aliases(self) -&gt; Mapping[str, str]:\n        return self._workflow_input_aliases\n\n    @property\n    def output_aliases(self) -&gt; Mapping[str, str]:\n        return self._workflow_output_aliases\n\n    def clear_current_inputs_for_step(self, step_id):\n\n        fields = self.get_current_inputs_schema_for_step(step_id)\n        for field in fields.keys():\n            self.set_inputs(**{k: None for k in fields.keys()})\n\n    @property\n    def current_inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\n        if self._current_workflow_inputs_schema is not None:\n            return self._current_workflow_inputs_schema\n\n        temp = {}\n        # TODO; check correctness when an alias refers to two different inputs\n        for k, v in self.current_pipeline_inputs_schema.items():\n            if k in self._workflow_input_aliases.keys():\n                temp[self._workflow_input_aliases[k]] = v\n            else:\n                temp[k] = v\n        self._current_workflow_inputs_schema = temp\n        return self._current_workflow_inputs_schema\n\n    def get_current_inputs_schema_for_step(\n        self, step_id: str\n    ) -&gt; Mapping[str, ValueSchema]:\n        return self.pipeline.structure.get_pipeline_inputs_schema_for_step(\n            step_id=step_id\n        )\n\n    def get_current_outputs_schema_for_step(\n        self, step_id: str\n    ) -&gt; Mapping[str, ValueSchema]:\n        return self.pipeline.structure.get_pipeline_outputs_schema_for_step(\n            step_id=step_id\n        )\n\n    @property\n    def current_input_names(self) -&gt; List[str]:\n        return sorted(self.current_inputs_schema.keys())\n\n    @property\n    def current_inputs(self) -&gt; Mapping[str, uuid.UUID]:\n\n        if self._current_workflow_inputs is not None:\n            return self._current_workflow_inputs\n\n        temp = {}\n        for k, v in self.current_pipeline_inputs.items():\n            if k in self._workflow_input_aliases.keys():\n                temp[self._workflow_input_aliases[k]] = v\n            else:\n                temp[k] = v\n        self._current_workflow_inputs = temp\n        return self._current_workflow_inputs\n\n    @property\n    def current_input_values(self) -&gt; ValueMap:\n        return self._kiara.data_registry.load_values(values=self.current_inputs)\n\n    @property\n    def current_outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\n        if self._current_workflow_outputs_schema is not None:\n            return self._current_workflow_outputs_schema\n\n        if not self._workflow_output_aliases:\n            self._current_workflow_outputs_schema = dict(\n                self.current_pipeline_outputs_schema\n            )\n        else:\n            temp = {}\n            for k, v in self._workflow_output_aliases.items():\n                temp[v] = self.current_pipeline_outputs_schema[k]\n            self._current_workflow_outputs_schema = temp\n\n        return self._current_workflow_outputs_schema\n\n    @property\n    def current_output_names(self) -&gt; List[str]:\n        return sorted(self.current_outputs_schema.keys())\n\n    @property\n    def current_outputs(self) -&gt; Mapping[str, uuid.UUID]:\n\n        if self._current_workflow_outputs is not None:\n            return self._current_workflow_outputs\n\n        if not self._workflow_output_aliases:\n            self._current_workflow_outputs = dict(self.current_pipeline_outputs)\n        else:\n            temp: Dict[str, uuid.UUID] = {}\n            for k, v in self._workflow_output_aliases.items():\n                temp[v] = self.current_pipeline_outputs[k]\n            self._current_workflow_outputs = temp\n\n        return self._current_workflow_outputs\n\n    @property\n    def current_output_values(self) -&gt; ValueMap:\n        return self._kiara.data_registry.load_values(values=self.current_outputs)\n\n    @property\n    def current_state(self) -&gt; WorkflowState:\n\n        if self._current_state is not None:\n            return self._current_state\n\n        self._current_state = WorkflowState.create_from_workflow(self)\n        self._state_cache[self._current_state.instance_id] = self._current_state\n        return self._current_state\n\n    @property\n    def pipeline(self) -&gt; Pipeline:\n\n        if self._pipeline is not None:\n            return self._pipeline\n\n        self._invalidate_pipeline()\n\n        steps = list(self._steps.values())\n        # input_aliases_temp = create_input_alias_map(steps=steps)\n        # input_aliases = {}\n        # for k, v in input_aliases_temp.items():\n        #     if k in self._pipeline_input_aliases.keys():\n        #         input_aliases[k] = self._pipeline_input_aliases[k]\n        #     else:\n        #         input_aliases[k] = v\n        #\n        # if not self._pipeline_output_aliasess:\n        #     output_aliases = create_output_alias_map(steps=steps)\n        # else:\n        #     output_aliases = self._pipeline_output_aliasess\n\n        pipeline_config = PipelineConfig.from_config(\n            pipeline_name=\"__workflow__\",\n            data={\n                \"steps\": steps,\n                \"doc\": self.workflow_metadata.documentation,\n                # \"input_aliases\": input_aliases,\n                # \"output_aliases\": output_aliases,\n            },\n        )\n        structure = pipeline_config.structure\n        self._pipeline = Pipeline(structure=structure, kiara=self._kiara)\n        self._pipeline_controller.pipeline = self._pipeline\n        return self._pipeline\n\n    def _apply_inputs(self) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        pipeline = self.pipeline\n\n        inputs_to_set = {}\n        for field_name, value in self._all_inputs.items():\n            # if value in [None, NONE_VALUE_ID, NOT_SET_VALUE_ID]:\n            #     continue\n            if field_name in pipeline.structure.pipeline_inputs_schema.keys():\n                inputs_to_set[field_name] = value\n\n        logger.debug(\n            \"workflow.apply_inputs\",\n            workflow_id=str(self.workflow_id),\n            keys=\", \".join(inputs_to_set.keys()),\n        )\n\n        changed: Mapping[\n            str, Mapping[str, Mapping[str, ChangedValue]]\n        ] = pipeline.set_pipeline_inputs(inputs=inputs_to_set)\n\n        self._current_pipeline_inputs = pipeline.get_current_pipeline_inputs()\n\n        for field_name, value_id in self._current_pipeline_inputs.items():\n            self._all_inputs[field_name] = value_id\n        self._current_pipeline_outputs = None\n\n        for stage, steps in pipeline.get_steps_by_stage().items():\n            stage_valid = True\n            cached_steps = []\n            for step_id in steps.keys():\n                step_details = pipeline.get_step_details(step_id=step_id)\n                if step_details.status == StepStatus.INPUTS_INVALID:\n                    stage_valid = False\n                    break\n                elif step_details.status == StepStatus.INPUTS_READY:\n                    job_config = JobConfig(\n                        module_type=step_details.step.module_type,\n                        module_config=step_details.step.module.config.dict(),\n                        inputs=step_details.inputs,\n                    )\n                    match = self._kiara.job_registry.find_matching_job_record(\n                        inputs_manifest=job_config\n                    )\n                    if match:\n                        cached_steps.append(step_id)\n            if cached_steps:\n                self.process_steps(*cached_steps)\n            if not stage_valid:\n                break\n\n        self._current_state = None\n        self._current_info = None\n        self._pipeline_info = None\n        return changed\n\n    def process_steps(\n        self, *step_ids: str\n    ) -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]:\n\n        self.pipeline\n\n        if not step_ids:\n            output_job_map, errors = self._pipeline_controller.process_pipeline()\n        else:\n            job_ids = {}\n            for step_id in step_ids:\n                job_id = self._pipeline_controller.process_step(\n                    step_id=step_id, wait=True\n                )\n                job_ids[step_id] = job_id\n\n            self._pipeline_controller._job_registry.wait_for(*job_ids.values())\n            errors = {}\n            for step_id, job_id in job_ids.items():\n                j = self._pipeline_controller._job_registry.get_job(job_id)\n                if j.status != JobStatus.SUCCESS:\n                    errors[step_id] = j\n            output_job_map = self._pipeline_controller.set_processing_results(\n                job_ids=job_ids\n            )\n\n        self._job_id_cache.update(output_job_map)\n\n        self._current_pipeline_outputs = self.pipeline.get_current_pipeline_outputs()\n        self._current_state = None\n        self._pipeline_info = None\n        self._current_info = None\n\n        return output_job_map, errors\n\n    def _invalidate_pipeline(self):\n\n        self._pipeline_controller.pipeline = None\n        self._pipeline = None\n        self._pipeline_info = None\n        self._current_info = None\n        self._current_state = None\n        self._current_workflow_inputs_schema = None\n        self._current_workflow_outputs_schema = None\n        self._current_pipeline_inputs = None\n        self._current_pipeline_outputs = None\n\n    def set_input(self, field_name: str, value: Any) -&gt; Union[None, uuid.UUID]:\n\"\"\"Set a single pipeline input.\n\n        Arguments:\n            field_name: The name of the input field.\n            value: The value to set.\n\n        Returns:\n            None if the value for that field in the pipeline didn't change, otherwise the value_id of the new (registered) value.\n\n        \"\"\"\n\n        diff = self.set_inputs(**{field_name: value})\n        return diff.get(field_name, None)\n\n    def set_inputs(self, **inputs: Any) -&gt; Dict[str, Union[uuid.UUID, None]]:\n\"\"\"Set multiple pipeline inputs, at once.\n\n        Arguments:\n            inputs: The inputs to set.\n\n        Returns:\n            a dict containing only the newly set or changed values with field name as keys, and value_id (or None) as values.\n        \"\"\"\n\n        _inputs = {}\n        for k, v in inputs.items():\n            # translate aliases\n            match = False\n            for field, alias in self._workflow_input_aliases.items():\n                if k == alias:\n                    match = True\n                    _inputs[field] = v\n\n            if not match and k in self.current_pipeline_inputs_schema.keys():\n                _inputs[k] = v\n\n        inputs = _inputs\n\n        invalid = []\n        for k, v in inputs.items():\n            if k not in self.pipeline.structure.pipeline_inputs_schema.keys():\n                invalid.append(k)\n        if invalid:\n            raise Exception(\n                f\"Can't set pipeline inputs, invalid field(s): {', '.join(invalid)}. Available inputs: '{', '.join(self.pipeline.structure.pipeline_inputs_schema.keys())}'\"\n            )\n\n        diff: Dict[str, Union[None, uuid.UUID]] = {}\n        for k, val_new in inputs.items():\n\n            val_old = self._all_inputs.get(k, None)\n            if val_old is None and val_new is None:\n                continue\n\n            if val_new is None:\n                self._all_inputs[k] = None\n                diff[k] = None\n                continue\n\n            if isinstance(val_new, uuid.UUID):\n                if val_new == val_old:\n                    continue\n                else:\n                    self._all_inputs[k] = val_new\n                    diff[k] = val_new\n                    continue\n\n            if isinstance(val_new, Value):\n                if val_new.value_id == val_old:\n                    continue\n                else:\n                    self._all_inputs[k] = val_new.value_id\n                    diff[k] = val_new.value_id\n                    continue\n\n            # TODO: check for aliases?\n            try:\n                _new_item_hash = hash(val_new)\n\n                _match: Union[None, uuid.UUID] = None\n                for _item_hash, _value_id in self._all_inputs_optimistic_lookup.get(\n                    k, {}\n                ).items():\n                    if _item_hash == _new_item_hash:\n                        if _value_id == val_old:\n                            _match = val_old\n                            break\n\n                if not _match:\n                    _schema = self.current_pipeline_inputs_schema[k]\n                    val = self._kiara.data_registry.register_data(\n                        data=val_new, schema=_schema, reuse_existing=True\n                    )\n                    _match = val.value_id\n                    self._all_inputs_optimistic_lookup.setdefault(k, {})[\n                        _new_item_hash\n                    ] = _match\n\n                if _match == val_old:\n                    continue\n                else:\n                    self._all_inputs[k] = _match\n                    diff[k] = _match\n                    continue\n\n            except Exception:\n                # value can't be hashed, so we have to accept we can not re-use an existing value for this\n                _schema = self.current_pipeline_inputs_schema[k]\n                val = self._kiara.data_registry.register_data(\n                    data=val_new, schema=_schema, reuse_existing=True\n                )\n                new_value_id = val.value_id\n                if new_value_id == val_old:\n                    continue\n                else:\n                    self._all_inputs[k] = new_value_id\n                    diff[k] = new_value_id\n\n        self._all_inputs.update(diff)\n\n        if diff:\n            self._current_info = None\n            self._current_state = None\n            self._current_pipeline_inputs = None\n            self._current_pipeline_outputs = None\n            self._current_workflow_inputs = None\n            self._current_workflow_outputs = None\n            self._pipeline_info = None\n            self._apply_inputs()\n\n        return diff\n\n    def add_steps(\n        self,\n        *pipeline_steps: Union[PipelineStep, Mapping[str, Any]],\n        replace_existing: bool = False,\n        clear_existing: bool = False,\n    ):\n\n        if clear_existing:\n            self.clear_steps()\n\n        duplicates = []\n        for step in pipeline_steps:\n            if isinstance(step, PipelineStep):\n                step_id = step.step_id\n            else:\n                step_id = step[\"step_id\"]\n            if step_id in self._steps.keys() and not replace_existing:\n                duplicates.append(step_id)\n\n        if duplicates:\n            raise Exception(\n                f\"Can't add steps, step id(s) already taken: {', '.join(duplicates)}.\"\n            )\n\n        for step in pipeline_steps:\n            if isinstance(step, PipelineStep):\n                input_connections = {}\n                for input_field, links in step.input_links.items():\n                    if len(links) != 1:\n                        raise NotImplementedError()\n                    input_connections[input_field] = links[0].alias\n                data: Mapping[str, Any] = {\n                    \"operation\": step.manifest_src.module_type,\n                    \"step_id\": step.step_id,\n                    \"module_config\": step.manifest_src.module_config,\n                    \"input_connections\": input_connections,\n                    \"doc\": step.doc,\n                    \"replace_existing\": replace_existing,\n                }\n            else:\n                data = step\n\n            self.add_step(**data)\n\n        self._invalidate_pipeline()\n\n    def clear_steps(self, *step_ids: str):\n\n        if not step_ids:\n            self._steps.clear()\n        else:\n            for step_id in step_ids:\n                self._steps.pop(step_id, None)\n\n        self._invalidate_pipeline()\n\n    def set_input_alias(self, input_field: str, alias: str):\n\n        if \".\" in input_field:\n            tokens = input_field.split(\".\")\n            if len(tokens) != 2:\n                raise Exception(\n                    f\"Invalid input field specification '{input_field}': can only contain a single (or no) '.' character.\"\n                )\n            input_field = generate_pipeline_endpoint_name(tokens[0], tokens[1])\n\n        self._workflow_input_aliases[input_field] = alias\n        self._current_workflow_inputs = None\n        self._current_workflow_inputs_schema = None\n        self.workflow_metadata.input_aliases[input_field] = alias\n        self._metadata_is_synced = False\n\n    def set_output_alias(self, output_field: str, alias: str):\n\n        if \".\" in output_field:\n            tokens = output_field.split(\".\")\n            if len(tokens) != 2:\n                raise Exception(\n                    f\"Invalid output field specification '{output_field}': can only contain a single (or no) '.' character.\"\n                )\n            output_field = generate_pipeline_endpoint_name(tokens[0], tokens[1])\n\n        self._workflow_output_aliases[output_field] = alias\n        self._current_workflow_outputs = None\n        self._current_workflow_outputs_schema = None\n        self.workflow_metadata.output_aliases[output_field] = alias\n        self._metadata_is_synced = False\n\n    # def remove_step(self, step_id: str):\n    #\n    #     if step_id not in self._steps.keys():\n    #         raise Exception(f\"Can't remove step, no step with id '{step_id}'.\")\n    #\n    #     del_step = self._steps[step_id]\n    #     for step_id, step in self._steps.items():\n    #         for input_field, links in step.input_links.items():\n    #             for link in links:\n    #                 if link.step_id == del_step.step_id:\n    #                     links.remove(link)\n    #\n    #     self._invalidate_pipeline()\n\n    def add_step(\n        self,\n        operation: str,\n        step_id: Union[str, None] = None,\n        module_config: Union[None, Mapping[str, Any]] = None,\n        input_connections: Union[None, Mapping[str, str]] = None,\n        doc: Union[str, DocumentationMetadataModel, None] = None,\n        replace_existing: bool = False,\n    ) -&gt; PipelineStep:\n\"\"\"Add a step to the workflows current pipeline structure.\n\n        If no 'step_id' is provided, a unque one will automatically be generated based on the 'module_type' argument.\n\n        Arguments:\n            operation: the module or operation name\n            step_id: the id of the new step\n            module_config: (optional) configuration for the kiara module this step uses\n            input_connections: a map with this steps input field name(s) as keys and output field links (format: &lt;step_id&gt;.&lt;output_field_name&gt;) as value(s).\n            replace_existing: if set to 'True', this replaces a step with the same id that already exists, otherwise an exception will be thrown\n        \"\"\"\n\n        if step_id is None:\n            step_id = find_free_id(\n                slugify(operation, delim=\"_\"), current_ids=self._steps.keys()\n            )\n\n        if \".\" in step_id:\n            raise Exception(f\"Invalid step id '{step_id}': id can't contain '.'.\")\n\n        if step_id in self._steps.keys() and not replace_existing:\n            raise Exception(\n                f\"Can't add step with id '{step_id}': step already exists and 'replace_existing' not set.\"\n            )\n        elif step_id in self._steps.keys():\n            raise NotImplementedError()\n\n        manifest = self._kiara.create_manifest(\n            module_or_operation=operation, config=module_config\n        )\n        module = self._kiara.module_registry.create_module(manifest=manifest)\n        manifest_src = Manifest(\n            module_type=manifest.module_type, module_config=manifest.module_config\n        )\n        step = PipelineStep(\n            step_id=step_id,\n            module_type=module.module_type_name,\n            module_config=module.config.dict(),\n            module_details=KiaraModuleInstance.from_module(module=module),\n            doc=doc,\n            manifest_src=manifest_src,\n        )\n        step._module = module\n        self._steps[step_id] = step\n\n        if input_connections:\n            for k, v in input_connections.items():\n                self.connect_to_inputs(v, f\"{step_id}.{k}\")\n\n        self._invalidate_pipeline()\n\n        return step\n\n    def connect_fields(self, *fields: Union[Tuple[str, str], str]):\n\n        pairs = []\n        current_pair = None\n        for field in fields:\n            if isinstance(field, str):\n                tokens = field.split(\".\")\n                if not len(tokens) == 2:\n                    raise Exception(\n                        f\"Can't connect field '{field}', field name must be in format: &lt;step_id&gt;.&lt;field_name&gt;.\"\n                    )\n                if not current_pair:\n                    current_pair = [tokens]\n                else:\n                    if not len(current_pair) == 1:\n                        raise Exception(\n                            f\"Can't connect fields, invalid input(s): {fields}\"\n                        )\n                    current_pair.append(tokens)\n                    pairs.append(current_pair)\n                    current_pair = None\n            else:\n                if not len(field) == 2:\n                    raise Exception(\n                        f\"Can't connect fields, field tuples must have length 2: {field}\"\n                    )\n                if current_pair:\n                    raise Exception(\n                        f\"Can't connect fields, dangling single field: {current_pair}\"\n                    )\n                pair = []\n                for f in field:\n                    tokens = f.split(\".\")\n                    if not len(tokens) == 2:\n                        raise Exception(\n                            f\"Can't connect field '{f}', field name must be in format: &lt;step_id&gt;.&lt;field_name&gt;.\"\n                        )\n                    pair.append(tokens)\n                pairs.append(pair)\n\n        for pair in pairs:\n            self.connect_steps(pair[0][0], pair[0][1], pair[1][0], pair[1][1])\n\n    def connect_steps(\n        self,\n        source_step: Union[PipelineStep, str],\n        source_field: str,\n        target_step: Union[PipelineStep, str],\n        target_field: str,\n    ):\n\n        if isinstance(source_step, str):\n            source_step_obj = self.get_step(source_step)\n        else:\n            source_step_obj = source_step\n        if isinstance(target_step, str):\n            target_step_obj = self.get_step(target_step)\n        else:\n            target_step_obj = target_step\n\n        source_step_id = source_step_obj.step_id\n        target_step_id = target_step_obj.step_id\n\n        reversed = False\n\n        if source_field not in source_step_obj.module.outputs_schema.keys():\n            reversed = True\n        if target_field not in target_step_obj.module.inputs_schema.keys():\n            reversed = True\n\n        if reversed:\n            if target_field not in target_step_obj.module.outputs_schema.keys():\n                raise Exception(\n                    f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n                )\n            if source_field not in source_step_obj.module.inputs_schema.keys():\n                raise Exception(\n                    f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n                )\n        else:\n            if target_field not in target_step_obj.module.inputs_schema.keys():\n                raise Exception(\n                    f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n                )\n            if source_field not in source_step_obj.module.outputs_schema.keys():\n                raise Exception(\n                    f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n                )\n\n        # we rely on the value of input links to always be a dict here\n        if not reversed:\n            source_addr = StepValueAddress(\n                step_id=source_step_id, value_name=source_field\n            )\n            target_step_obj.input_links.setdefault(target_field, []).append(source_addr)  # type: ignore\n        else:\n            source_addr = StepValueAddress(\n                step_id=target_step_id, value_name=target_field\n            )\n            source_step_obj.input_links.setdefault(source_field, []).append(source_addr)  # type: ignore\n\n        self._invalidate_pipeline()\n\n    def connect_to_inputs(self, source_field: str, *input_fields: str):\n\n        source_tokens = source_field.split(\".\")\n        if len(source_tokens) != 2:\n            raise Exception(\n                f\"Can't add input link(s): invalid format for provided source '{source_field}', must be string with a single '.' to delimit step-id and output field name.\"\n            )\n\n        source_step = self.get_step(source_tokens[0])\n        if source_step is None:\n            raise Exception(\n                f\"Can't add input link(s)': no source step with id '{source_tokens[0]}' exists.\"\n            )\n\n        if source_tokens[1] not in source_step.module.outputs_schema.keys():\n            av_fields = \", \".join(source_step.module.outputs_schema.keys())\n            raise Exception(\n                f\"Can't add input link(s): source step with id '{source_step.step_id}' does not have output field '{source_tokens[1]}'. Available field names: {av_fields}.\"\n            )\n\n        source_addr = StepValueAddress(\n            step_id=source_step.step_id, value_name=source_tokens[1]\n        )\n\n        steps = []\n        for input_field in input_fields:\n            input_tokens = input_field.split(\".\")\n            if len(input_tokens) != 2:\n                raise Exception(\n                    f\"Can't add input link '{input_field}': invalid format, must be string with a single '.' to delimit step-id and field name.\"\n                )\n\n            step = self.get_step(input_tokens[0])\n            if step is None:\n                raise Exception(\n                    f\"Can't add input link '{input_field}': no step with id '{input_tokens[0]}' exists.\"\n                )\n\n            if input_tokens[1] not in step.module.inputs_schema.keys():\n                av_fields = \", \".join(step.module.inputs_schema.keys())\n                raise Exception(\n                    f\"Can't add input link '{input_field}': step with id '{input_tokens[0]}' does not have input field '{input_tokens[1]}'. Available field names: {av_fields}.\"\n                )\n            steps.append((step, input_tokens[1]))\n\n        for s in steps:\n            step, field_name = s\n            # we rely on the value of input links to always be a dict here\n            step.input_links.setdefault(field_name, []).append(source_addr)  # type: ignore\n\n        self._invalidate_pipeline()\n\n    def get_step(self, step_id: str) -&gt; PipelineStep:\n\n        step = self._steps.get(step_id, None)\n        if step is None:\n            if self._steps:\n                msg = f\"Available step ids: {', '.join(self._steps.keys())}\"\n            else:\n                msg = \"Workflow does not have any steps (yet).\"\n            raise Exception(f\"No step with id '{step_id}' registered. {msg}\")\n        return step\n\n    def load_state(\n        self, workflow_state_id: Union[str, None] = None\n    ) -&gt; Union[None, WorkflowState]:\n\"\"\"Load a past state.\n\n        If no state id is specified, the latest one that was saved will be used.\n\n        Returns:\n            'None' if no state was loaded, otherwise the relevant 'WorkflowState' instance\n        \"\"\"\n\n        if workflow_state_id is None:\n            if not self._workflow_metadata.workflow_history:\n                return None\n            else:\n                workflow_state_id = self._workflow_metadata.last_state_id\n\n        if workflow_state_id is None:\n            raise Exception(\n                f\"Can't load current state for workflow '{self.workflow_id}': no state available.\"\n            )\n\n        state = self._state_cache.get(workflow_state_id, None)\n        if state is not None:\n            return state\n\n        state = self._kiara.workflow_registry.get_workflow_state(\n            workflow=self.workflow_id, workflow_state_id=workflow_state_id\n        )\n        assert workflow_state_id == state.instance_id\n\n        self._state_cache[workflow_state_id] = state\n\n        self._all_inputs.clear()\n        self._current_pipeline_inputs = None\n        self.clear_steps()\n        self._invalidate_pipeline()\n\n        self.add_steps(*state.steps)\n        # self._workflow_input_aliases = dict(state.input_aliases)\n        # self._workflow_output_aliases = dict(state.output_aliases)\n\n        self.set_inputs(**state.inputs)\n        assert {k: v for k, v in self._current_pipeline_inputs.items() if v not in [NONE_VALUE_ID, NOT_SET_VALUE_ID]} == {k: v for k, v in state.inputs.items() if v not in [NONE_VALUE_ID, NOT_SET_VALUE_ID]}  # type: ignore\n        self._current_pipeline_outputs = (\n            state.pipeline_info.pipeline_state.pipeline_outputs\n        )\n        self._pipeline_info = state.pipeline_info\n        self._current_state = state\n        self._current_info = None\n\n        return state\n\n    @property\n    def all_state_ids(self) -&gt; List[str]:\n\n        hashes = set(self._workflow_metadata.workflow_history.values())\n        return sorted(hashes)\n\n    @property\n    def all_states(self) -&gt; Mapping[str, WorkflowState]:\n\"\"\"Return a list of all states this workflow had in the past, indexed by the hash of each state.\"\"\"\n\n        missing = []\n        for state_id in self.workflow_metadata.workflow_history.values():\n            if state_id not in self._state_cache.keys():\n                missing.append(state_id)\n\n        if missing:\n            # TODO: only request missing ones?\n            all_states = self._kiara.workflow_registry.get_all_states_for_workflow(\n                workflow=self.workflow_id\n            )\n            self._state_cache.update(all_states)\n\n        return self._state_cache\n\n    @property\n    def info(self) -&gt; WorkflowInfo:\n\n        if self._current_info is not None:\n            return self._current_info\n\n        self._current_info = WorkflowInfo.create_from_workflow(workflow=self)\n        return self._current_info\n\n    @property\n    def pipeline_info(self) -&gt; PipelineInfo:\n\n        if self._pipeline_info is not None:\n            return self._pipeline_info\n\n        self._pipeline_info = PipelineInfo.create_from_pipeline(\n            kiara=self._kiara, pipeline=self.pipeline\n        )\n        return self._pipeline_info\n\n    def save(self, *aliases: str):\n\n        self._pending_aliases.update(aliases)\n\n        self._workflow_metadata = self._kiara.workflow_registry.register_workflow(\n            workflow_metadata=self.workflow_metadata,\n            workflow_aliases=self._pending_aliases,\n        )\n        self._pending_aliases.clear()\n        self._metadata_is_stored = True\n        self._metadata_is_synced = True\n\n    def snapshot(self, save: bool = False) -&gt; WorkflowState:\n\n        state = self.current_state\n\n        if state.instance_id not in self._state_cache.keys():\n            self._state_cache[state.instance_id] = state\n\n        now = datetime.now(pytz.utc)\n\n        for field_name, value in self.current_pipeline_outputs.items():\n            if value in [NOT_SET_VALUE_ID, NONE_VALUE_ID]:\n                continue\n\n            self._state_output_cache.setdefault(state.instance_id, set()).add(value)\n            self._state_jobrecord_cache.setdefault(state.instance_id, set()).add(\n                self._job_id_cache[value]\n            )\n\n        self.workflow_metadata.workflow_history[now] = state.instance_id\n        self._metadata_is_synced = False\n\n        if save:\n            self.register_snapshot(snapshot=state.instance_id)\n        return state\n\n    def register_snapshot(self, snapshot: Union[datetime, str]):\n\n        timestamps: List[datetime]\n        if isinstance(snapshot, str):\n            if snapshot not in self._state_cache.keys():\n                raise Exception(\n                    f\"Can't register snapshot with hash '{snapshot}': no state with this hash available.\"\n                )\n            state: WorkflowState = self._state_cache[snapshot]\n            timestamps = [\n                _timestamp\n                for _timestamp, _hash in self.workflow_metadata.workflow_history.items()\n                if _hash == snapshot\n            ]\n        elif isinstance(snapshot, datetime):\n            if snapshot not in self.workflow_metadata.workflow_history.keys():\n                raise Exception(\n                    f\"Can't register snapshot with timestamp '{snapshot}': no state with this timestamp available.\"\n                )\n            state = self._state_cache[self.workflow_metadata.workflow_history[snapshot]]\n            timestamps = [snapshot]\n        else:\n            raise Exception(\n                f\"Can't register snapshot '{snapshot}': invalid type '{type(snapshot)}'.\"\n            )\n\n        # input values are stored in the add_workflow_state method on the backend\n\n        if state.instance_id in self._state_output_cache.keys():\n            for value_id in self._state_output_cache[state.instance_id]:\n                self._kiara.data_registry.store_value(value=value_id)\n\n        if state.instance_id in self._state_jobrecord_cache.keys():\n            for job_id in self._state_jobrecord_cache[state.instance_id]:\n                try:\n                    self._kiara.job_registry.store_job_record(job_id=job_id)\n                except Exception as e:\n                    log_exception(e)\n\n        if not self._metadata_is_stored:\n            self._sync_workflow_metadata()\n            self._metadata_is_synced = True\n\n        if not self._metadata_is_synced:\n            self._kiara.workflow_registry.update_workflow_metadata(\n                self.workflow_metadata\n            )\n\n        for timestamp in timestamps:\n            self._workflow_metadata = self._kiara.workflow_registry.add_workflow_state(\n                workflow=self._workflow_metadata.workflow_id,\n                workflow_state=state,\n                timestamp=timestamp,\n            )\n            self._metadata_is_synced = True\n\n        return state\n\n    def create_renderable(self, **config: Any):\n\n        if not self._steps:\n            return \"Invalid workflow: no steps set yet.\"\n\n        return self.info.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.workflow_id","title":"<code>workflow_id: uuid.UUID</code>  <code>property</code>","text":"<p>Retrieve the globally unique id for this workflow.</p>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.workflow_metadata","title":"<code>workflow_metadata: WorkflowMetadata</code>  <code>property</code>","text":"<p>Retrieve an object that contains metadata for this workflow.</p>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.documentation","title":"<code>documentation: DocumentationMetadataModel</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.is_persisted","title":"<code>is_persisted: bool</code>  <code>property</code>","text":"<p>Check whether this workflow is persisted in it's current state.</p>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_inputs_schema","title":"<code>current_pipeline_inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_inputs","title":"<code>current_pipeline_inputs: Mapping[str, uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_input_values","title":"<code>current_pipeline_input_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_outputs_schema","title":"<code>current_pipeline_outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_outputs","title":"<code>current_pipeline_outputs: Mapping[str, uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_pipeline_output_values","title":"<code>current_pipeline_output_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.input_aliases","title":"<code>input_aliases: Mapping[str, str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.output_aliases","title":"<code>output_aliases: Mapping[str, str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_inputs_schema","title":"<code>current_inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_input_names","title":"<code>current_input_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_inputs","title":"<code>current_inputs: Mapping[str, uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_input_values","title":"<code>current_input_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_outputs_schema","title":"<code>current_outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_output_names","title":"<code>current_output_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_outputs","title":"<code>current_outputs: Mapping[str, uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_output_values","title":"<code>current_output_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.current_state","title":"<code>current_state: WorkflowState</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.pipeline","title":"<code>pipeline: Pipeline</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.all_state_ids","title":"<code>all_state_ids: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.all_states","title":"<code>all_states: Mapping[str, WorkflowState]</code>  <code>property</code>","text":"<p>Return a list of all states this workflow had in the past, indexed by the hash of each state.</p>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.info","title":"<code>info: WorkflowInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.pipeline_info","title":"<code>pipeline_info: PipelineInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.load","title":"<code>load(workflow: Union[uuid.UUID, str], kiara: Union[Kiara, None] = None, create: bool = False)</code>  <code>classmethod</code>","text":"<p>Load an existing workflow using a workflow id or alias.</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>@classmethod\ndef load(\n    cls,\n    workflow: Union[uuid.UUID, str],\n    kiara: Union[\"Kiara\", None] = None,\n    create: bool = False,\n):\n\"\"\"Load an existing workflow using a workflow id or alias.\"\"\"\n\n    try:\n        workflow_obj = Workflow(workflow=workflow, kiara=kiara, load_existing=True)\n    except NoSuchWorkflowException as nswe:\n        if create:\n\n            if isinstance(workflow, uuid.UUID):\n                raise nswe\n            temp = None\n            try:\n                temp = uuid.UUID(workflow)\n            except Exception:\n                pass\n            if temp is not None:\n                raise nswe\n\n            if kiara is None:\n                from kiara.context import Kiara\n\n                kiara = Kiara.instance()\n\n            workflow_metadata = kiara.workflow_registry.register_workflow(\n                workflow_aliases=[workflow]\n            )\n            workflow_obj = Workflow(workflow=workflow_metadata.workflow_id)\n\n    return workflow_obj\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.create","title":"<code>create(alias: Union[None, str] = None, replace_existing_alias: bool = False, doc: Union[Any, None] = None, kiara: Union[Kiara, None] = None)</code>  <code>classmethod</code>","text":"<p>Create a new workflow object.</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    alias: Union[None, str] = None,\n    replace_existing_alias: bool = False,\n    doc: Union[Any, None] = None,\n    kiara: Union[\"Kiara\", None] = None,\n):\n\"\"\"Create a new workflow object.\"\"\"\n\n    if replace_existing_alias and alias is not None:\n        if kiara is None:\n            from kiara.context import Kiara\n\n            kiara = Kiara.instance()\n\n        kiara.workflow_registry.unregister_alias(alias=alias)\n\n    workflow = Workflow(workflow=alias, kiara=kiara, load_existing=False)\n    if doc:\n        workflow.documentation = doc\n    return workflow\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.clear_current_inputs_for_step","title":"<code>clear_current_inputs_for_step(step_id)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def clear_current_inputs_for_step(self, step_id):\n\n    fields = self.get_current_inputs_schema_for_step(step_id)\n    for field in fields.keys():\n        self.set_inputs(**{k: None for k in fields.keys()})\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.get_current_inputs_schema_for_step","title":"<code>get_current_inputs_schema_for_step(step_id: str) -&gt; Mapping[str, ValueSchema]</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def get_current_inputs_schema_for_step(\n    self, step_id: str\n) -&gt; Mapping[str, ValueSchema]:\n    return self.pipeline.structure.get_pipeline_inputs_schema_for_step(\n        step_id=step_id\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.get_current_outputs_schema_for_step","title":"<code>get_current_outputs_schema_for_step(step_id: str) -&gt; Mapping[str, ValueSchema]</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def get_current_outputs_schema_for_step(\n    self, step_id: str\n) -&gt; Mapping[str, ValueSchema]:\n    return self.pipeline.structure.get_pipeline_outputs_schema_for_step(\n        step_id=step_id\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.process_steps","title":"<code>process_steps(*step_ids: str) -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def process_steps(\n    self, *step_ids: str\n) -&gt; Tuple[Mapping[uuid.UUID, uuid.UUID], Mapping[str, ActiveJob]]:\n\n    self.pipeline\n\n    if not step_ids:\n        output_job_map, errors = self._pipeline_controller.process_pipeline()\n    else:\n        job_ids = {}\n        for step_id in step_ids:\n            job_id = self._pipeline_controller.process_step(\n                step_id=step_id, wait=True\n            )\n            job_ids[step_id] = job_id\n\n        self._pipeline_controller._job_registry.wait_for(*job_ids.values())\n        errors = {}\n        for step_id, job_id in job_ids.items():\n            j = self._pipeline_controller._job_registry.get_job(job_id)\n            if j.status != JobStatus.SUCCESS:\n                errors[step_id] = j\n        output_job_map = self._pipeline_controller.set_processing_results(\n            job_ids=job_ids\n        )\n\n    self._job_id_cache.update(output_job_map)\n\n    self._current_pipeline_outputs = self.pipeline.get_current_pipeline_outputs()\n    self._current_state = None\n    self._pipeline_info = None\n    self._current_info = None\n\n    return output_job_map, errors\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.set_input","title":"<code>set_input(field_name: str, value: Any) -&gt; Union[None, uuid.UUID]</code>","text":"<p>Set a single pipeline input.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the input field.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Returns:</p> Type Description <code>Union[None, uuid.UUID]</code> <p>None if the value for that field in the pipeline didn't change, otherwise the value_id of the new (registered) value.</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def set_input(self, field_name: str, value: Any) -&gt; Union[None, uuid.UUID]:\n\"\"\"Set a single pipeline input.\n\n    Arguments:\n        field_name: The name of the input field.\n        value: The value to set.\n\n    Returns:\n        None if the value for that field in the pipeline didn't change, otherwise the value_id of the new (registered) value.\n\n    \"\"\"\n\n    diff = self.set_inputs(**{field_name: value})\n    return diff.get(field_name, None)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.set_inputs","title":"<code>set_inputs(**inputs: Any) -&gt; Dict[str, Union[uuid.UUID, None]]</code>","text":"<p>Set multiple pipeline inputs, at once.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Any</code> <p>The inputs to set.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Union[uuid.UUID, None]]</code> <p>a dict containing only the newly set or changed values with field name as keys, and value_id (or None) as values.</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def set_inputs(self, **inputs: Any) -&gt; Dict[str, Union[uuid.UUID, None]]:\n\"\"\"Set multiple pipeline inputs, at once.\n\n    Arguments:\n        inputs: The inputs to set.\n\n    Returns:\n        a dict containing only the newly set or changed values with field name as keys, and value_id (or None) as values.\n    \"\"\"\n\n    _inputs = {}\n    for k, v in inputs.items():\n        # translate aliases\n        match = False\n        for field, alias in self._workflow_input_aliases.items():\n            if k == alias:\n                match = True\n                _inputs[field] = v\n\n        if not match and k in self.current_pipeline_inputs_schema.keys():\n            _inputs[k] = v\n\n    inputs = _inputs\n\n    invalid = []\n    for k, v in inputs.items():\n        if k not in self.pipeline.structure.pipeline_inputs_schema.keys():\n            invalid.append(k)\n    if invalid:\n        raise Exception(\n            f\"Can't set pipeline inputs, invalid field(s): {', '.join(invalid)}. Available inputs: '{', '.join(self.pipeline.structure.pipeline_inputs_schema.keys())}'\"\n        )\n\n    diff: Dict[str, Union[None, uuid.UUID]] = {}\n    for k, val_new in inputs.items():\n\n        val_old = self._all_inputs.get(k, None)\n        if val_old is None and val_new is None:\n            continue\n\n        if val_new is None:\n            self._all_inputs[k] = None\n            diff[k] = None\n            continue\n\n        if isinstance(val_new, uuid.UUID):\n            if val_new == val_old:\n                continue\n            else:\n                self._all_inputs[k] = val_new\n                diff[k] = val_new\n                continue\n\n        if isinstance(val_new, Value):\n            if val_new.value_id == val_old:\n                continue\n            else:\n                self._all_inputs[k] = val_new.value_id\n                diff[k] = val_new.value_id\n                continue\n\n        # TODO: check for aliases?\n        try:\n            _new_item_hash = hash(val_new)\n\n            _match: Union[None, uuid.UUID] = None\n            for _item_hash, _value_id in self._all_inputs_optimistic_lookup.get(\n                k, {}\n            ).items():\n                if _item_hash == _new_item_hash:\n                    if _value_id == val_old:\n                        _match = val_old\n                        break\n\n            if not _match:\n                _schema = self.current_pipeline_inputs_schema[k]\n                val = self._kiara.data_registry.register_data(\n                    data=val_new, schema=_schema, reuse_existing=True\n                )\n                _match = val.value_id\n                self._all_inputs_optimistic_lookup.setdefault(k, {})[\n                    _new_item_hash\n                ] = _match\n\n            if _match == val_old:\n                continue\n            else:\n                self._all_inputs[k] = _match\n                diff[k] = _match\n                continue\n\n        except Exception:\n            # value can't be hashed, so we have to accept we can not re-use an existing value for this\n            _schema = self.current_pipeline_inputs_schema[k]\n            val = self._kiara.data_registry.register_data(\n                data=val_new, schema=_schema, reuse_existing=True\n            )\n            new_value_id = val.value_id\n            if new_value_id == val_old:\n                continue\n            else:\n                self._all_inputs[k] = new_value_id\n                diff[k] = new_value_id\n\n    self._all_inputs.update(diff)\n\n    if diff:\n        self._current_info = None\n        self._current_state = None\n        self._current_pipeline_inputs = None\n        self._current_pipeline_outputs = None\n        self._current_workflow_inputs = None\n        self._current_workflow_outputs = None\n        self._pipeline_info = None\n        self._apply_inputs()\n\n    return diff\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.add_steps","title":"<code>add_steps(*pipeline_steps: Union[PipelineStep, Mapping[str, Any]], replace_existing: bool = False, clear_existing: bool = False)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def add_steps(\n    self,\n    *pipeline_steps: Union[PipelineStep, Mapping[str, Any]],\n    replace_existing: bool = False,\n    clear_existing: bool = False,\n):\n\n    if clear_existing:\n        self.clear_steps()\n\n    duplicates = []\n    for step in pipeline_steps:\n        if isinstance(step, PipelineStep):\n            step_id = step.step_id\n        else:\n            step_id = step[\"step_id\"]\n        if step_id in self._steps.keys() and not replace_existing:\n            duplicates.append(step_id)\n\n    if duplicates:\n        raise Exception(\n            f\"Can't add steps, step id(s) already taken: {', '.join(duplicates)}.\"\n        )\n\n    for step in pipeline_steps:\n        if isinstance(step, PipelineStep):\n            input_connections = {}\n            for input_field, links in step.input_links.items():\n                if len(links) != 1:\n                    raise NotImplementedError()\n                input_connections[input_field] = links[0].alias\n            data: Mapping[str, Any] = {\n                \"operation\": step.manifest_src.module_type,\n                \"step_id\": step.step_id,\n                \"module_config\": step.manifest_src.module_config,\n                \"input_connections\": input_connections,\n                \"doc\": step.doc,\n                \"replace_existing\": replace_existing,\n            }\n        else:\n            data = step\n\n        self.add_step(**data)\n\n    self._invalidate_pipeline()\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.clear_steps","title":"<code>clear_steps(*step_ids: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def clear_steps(self, *step_ids: str):\n\n    if not step_ids:\n        self._steps.clear()\n    else:\n        for step_id in step_ids:\n            self._steps.pop(step_id, None)\n\n    self._invalidate_pipeline()\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.set_input_alias","title":"<code>set_input_alias(input_field: str, alias: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def set_input_alias(self, input_field: str, alias: str):\n\n    if \".\" in input_field:\n        tokens = input_field.split(\".\")\n        if len(tokens) != 2:\n            raise Exception(\n                f\"Invalid input field specification '{input_field}': can only contain a single (or no) '.' character.\"\n            )\n        input_field = generate_pipeline_endpoint_name(tokens[0], tokens[1])\n\n    self._workflow_input_aliases[input_field] = alias\n    self._current_workflow_inputs = None\n    self._current_workflow_inputs_schema = None\n    self.workflow_metadata.input_aliases[input_field] = alias\n    self._metadata_is_synced = False\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.set_output_alias","title":"<code>set_output_alias(output_field: str, alias: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def set_output_alias(self, output_field: str, alias: str):\n\n    if \".\" in output_field:\n        tokens = output_field.split(\".\")\n        if len(tokens) != 2:\n            raise Exception(\n                f\"Invalid output field specification '{output_field}': can only contain a single (or no) '.' character.\"\n            )\n        output_field = generate_pipeline_endpoint_name(tokens[0], tokens[1])\n\n    self._workflow_output_aliases[output_field] = alias\n    self._current_workflow_outputs = None\n    self._current_workflow_outputs_schema = None\n    self.workflow_metadata.output_aliases[output_field] = alias\n    self._metadata_is_synced = False\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.add_step","title":"<code>add_step(operation: str, step_id: Union[str, None] = None, module_config: Union[None, Mapping[str, Any]] = None, input_connections: Union[None, Mapping[str, str]] = None, doc: Union[str, DocumentationMetadataModel, None] = None, replace_existing: bool = False) -&gt; PipelineStep</code>","text":"<p>Add a step to the workflows current pipeline structure.</p> <p>If no 'step_id' is provided, a unque one will automatically be generated based on the 'module_type' argument.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>the module or operation name</p> required <code>step_id</code> <code>Union[str, None]</code> <p>the id of the new step</p> <code>None</code> <code>module_config</code> <code>Union[None, Mapping[str, Any]]</code> <p>(optional) configuration for the kiara module this step uses</p> <code>None</code> <code>input_connections</code> <code>Union[None, Mapping[str, str]]</code> <p>a map with this steps input field name(s) as keys and output field links (format: .) as value(s). <code>None</code> <code>replace_existing</code> <code>bool</code> <p>if set to 'True', this replaces a step with the same id that already exists, otherwise an exception will be thrown</p> <code>False</code> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def add_step(\n    self,\n    operation: str,\n    step_id: Union[str, None] = None,\n    module_config: Union[None, Mapping[str, Any]] = None,\n    input_connections: Union[None, Mapping[str, str]] = None,\n    doc: Union[str, DocumentationMetadataModel, None] = None,\n    replace_existing: bool = False,\n) -&gt; PipelineStep:\n\"\"\"Add a step to the workflows current pipeline structure.\n\n    If no 'step_id' is provided, a unque one will automatically be generated based on the 'module_type' argument.\n\n    Arguments:\n        operation: the module or operation name\n        step_id: the id of the new step\n        module_config: (optional) configuration for the kiara module this step uses\n        input_connections: a map with this steps input field name(s) as keys and output field links (format: &lt;step_id&gt;.&lt;output_field_name&gt;) as value(s).\n        replace_existing: if set to 'True', this replaces a step with the same id that already exists, otherwise an exception will be thrown\n    \"\"\"\n\n    if step_id is None:\n        step_id = find_free_id(\n            slugify(operation, delim=\"_\"), current_ids=self._steps.keys()\n        )\n\n    if \".\" in step_id:\n        raise Exception(f\"Invalid step id '{step_id}': id can't contain '.'.\")\n\n    if step_id in self._steps.keys() and not replace_existing:\n        raise Exception(\n            f\"Can't add step with id '{step_id}': step already exists and 'replace_existing' not set.\"\n        )\n    elif step_id in self._steps.keys():\n        raise NotImplementedError()\n\n    manifest = self._kiara.create_manifest(\n        module_or_operation=operation, config=module_config\n    )\n    module = self._kiara.module_registry.create_module(manifest=manifest)\n    manifest_src = Manifest(\n        module_type=manifest.module_type, module_config=manifest.module_config\n    )\n    step = PipelineStep(\n        step_id=step_id,\n        module_type=module.module_type_name,\n        module_config=module.config.dict(),\n        module_details=KiaraModuleInstance.from_module(module=module),\n        doc=doc,\n        manifest_src=manifest_src,\n    )\n    step._module = module\n    self._steps[step_id] = step\n\n    if input_connections:\n        for k, v in input_connections.items():\n            self.connect_to_inputs(v, f\"{step_id}.{k}\")\n\n    self._invalidate_pipeline()\n\n    return step\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.connect_fields","title":"<code>connect_fields(*fields: Union[Tuple[str, str], str])</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def connect_fields(self, *fields: Union[Tuple[str, str], str]):\n\n    pairs = []\n    current_pair = None\n    for field in fields:\n        if isinstance(field, str):\n            tokens = field.split(\".\")\n            if not len(tokens) == 2:\n                raise Exception(\n                    f\"Can't connect field '{field}', field name must be in format: &lt;step_id&gt;.&lt;field_name&gt;.\"\n                )\n            if not current_pair:\n                current_pair = [tokens]\n            else:\n                if not len(current_pair) == 1:\n                    raise Exception(\n                        f\"Can't connect fields, invalid input(s): {fields}\"\n                    )\n                current_pair.append(tokens)\n                pairs.append(current_pair)\n                current_pair = None\n        else:\n            if not len(field) == 2:\n                raise Exception(\n                    f\"Can't connect fields, field tuples must have length 2: {field}\"\n                )\n            if current_pair:\n                raise Exception(\n                    f\"Can't connect fields, dangling single field: {current_pair}\"\n                )\n            pair = []\n            for f in field:\n                tokens = f.split(\".\")\n                if not len(tokens) == 2:\n                    raise Exception(\n                        f\"Can't connect field '{f}', field name must be in format: &lt;step_id&gt;.&lt;field_name&gt;.\"\n                    )\n                pair.append(tokens)\n            pairs.append(pair)\n\n    for pair in pairs:\n        self.connect_steps(pair[0][0], pair[0][1], pair[1][0], pair[1][1])\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.connect_steps","title":"<code>connect_steps(source_step: Union[PipelineStep, str], source_field: str, target_step: Union[PipelineStep, str], target_field: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def connect_steps(\n    self,\n    source_step: Union[PipelineStep, str],\n    source_field: str,\n    target_step: Union[PipelineStep, str],\n    target_field: str,\n):\n\n    if isinstance(source_step, str):\n        source_step_obj = self.get_step(source_step)\n    else:\n        source_step_obj = source_step\n    if isinstance(target_step, str):\n        target_step_obj = self.get_step(target_step)\n    else:\n        target_step_obj = target_step\n\n    source_step_id = source_step_obj.step_id\n    target_step_id = target_step_obj.step_id\n\n    reversed = False\n\n    if source_field not in source_step_obj.module.outputs_schema.keys():\n        reversed = True\n    if target_field not in target_step_obj.module.inputs_schema.keys():\n        reversed = True\n\n    if reversed:\n        if target_field not in target_step_obj.module.outputs_schema.keys():\n            raise Exception(\n                f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n            )\n        if source_field not in source_step_obj.module.inputs_schema.keys():\n            raise Exception(\n                f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n            )\n    else:\n        if target_field not in target_step_obj.module.inputs_schema.keys():\n            raise Exception(\n                f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n            )\n        if source_field not in source_step_obj.module.outputs_schema.keys():\n            raise Exception(\n                f\"Can't connect steps '{source_step_id}.{source_field}' -&gt; '{target_step_id}.{target_field}': invalid field name(s).\"\n            )\n\n    # we rely on the value of input links to always be a dict here\n    if not reversed:\n        source_addr = StepValueAddress(\n            step_id=source_step_id, value_name=source_field\n        )\n        target_step_obj.input_links.setdefault(target_field, []).append(source_addr)  # type: ignore\n    else:\n        source_addr = StepValueAddress(\n            step_id=target_step_id, value_name=target_field\n        )\n        source_step_obj.input_links.setdefault(source_field, []).append(source_addr)  # type: ignore\n\n    self._invalidate_pipeline()\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.connect_to_inputs","title":"<code>connect_to_inputs(source_field: str, *input_fields: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def connect_to_inputs(self, source_field: str, *input_fields: str):\n\n    source_tokens = source_field.split(\".\")\n    if len(source_tokens) != 2:\n        raise Exception(\n            f\"Can't add input link(s): invalid format for provided source '{source_field}', must be string with a single '.' to delimit step-id and output field name.\"\n        )\n\n    source_step = self.get_step(source_tokens[0])\n    if source_step is None:\n        raise Exception(\n            f\"Can't add input link(s)': no source step with id '{source_tokens[0]}' exists.\"\n        )\n\n    if source_tokens[1] not in source_step.module.outputs_schema.keys():\n        av_fields = \", \".join(source_step.module.outputs_schema.keys())\n        raise Exception(\n            f\"Can't add input link(s): source step with id '{source_step.step_id}' does not have output field '{source_tokens[1]}'. Available field names: {av_fields}.\"\n        )\n\n    source_addr = StepValueAddress(\n        step_id=source_step.step_id, value_name=source_tokens[1]\n    )\n\n    steps = []\n    for input_field in input_fields:\n        input_tokens = input_field.split(\".\")\n        if len(input_tokens) != 2:\n            raise Exception(\n                f\"Can't add input link '{input_field}': invalid format, must be string with a single '.' to delimit step-id and field name.\"\n            )\n\n        step = self.get_step(input_tokens[0])\n        if step is None:\n            raise Exception(\n                f\"Can't add input link '{input_field}': no step with id '{input_tokens[0]}' exists.\"\n            )\n\n        if input_tokens[1] not in step.module.inputs_schema.keys():\n            av_fields = \", \".join(step.module.inputs_schema.keys())\n            raise Exception(\n                f\"Can't add input link '{input_field}': step with id '{input_tokens[0]}' does not have input field '{input_tokens[1]}'. Available field names: {av_fields}.\"\n            )\n        steps.append((step, input_tokens[1]))\n\n    for s in steps:\n        step, field_name = s\n        # we rely on the value of input links to always be a dict here\n        step.input_links.setdefault(field_name, []).append(source_addr)  # type: ignore\n\n    self._invalidate_pipeline()\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.get_step","title":"<code>get_step(step_id: str) -&gt; PipelineStep</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def get_step(self, step_id: str) -&gt; PipelineStep:\n\n    step = self._steps.get(step_id, None)\n    if step is None:\n        if self._steps:\n            msg = f\"Available step ids: {', '.join(self._steps.keys())}\"\n        else:\n            msg = \"Workflow does not have any steps (yet).\"\n        raise Exception(f\"No step with id '{step_id}' registered. {msg}\")\n    return step\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.load_state","title":"<code>load_state(workflow_state_id: Union[str, None] = None) -&gt; Union[None, WorkflowState]</code>","text":"<p>Load a past state.</p> <p>If no state id is specified, the latest one that was saved will be used.</p> <p>Returns:</p> Type Description <code>Union[None, WorkflowState]</code> <p>'None' if no state was loaded, otherwise the relevant 'WorkflowState' instance</p> Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def load_state(\n    self, workflow_state_id: Union[str, None] = None\n) -&gt; Union[None, WorkflowState]:\n\"\"\"Load a past state.\n\n    If no state id is specified, the latest one that was saved will be used.\n\n    Returns:\n        'None' if no state was loaded, otherwise the relevant 'WorkflowState' instance\n    \"\"\"\n\n    if workflow_state_id is None:\n        if not self._workflow_metadata.workflow_history:\n            return None\n        else:\n            workflow_state_id = self._workflow_metadata.last_state_id\n\n    if workflow_state_id is None:\n        raise Exception(\n            f\"Can't load current state for workflow '{self.workflow_id}': no state available.\"\n        )\n\n    state = self._state_cache.get(workflow_state_id, None)\n    if state is not None:\n        return state\n\n    state = self._kiara.workflow_registry.get_workflow_state(\n        workflow=self.workflow_id, workflow_state_id=workflow_state_id\n    )\n    assert workflow_state_id == state.instance_id\n\n    self._state_cache[workflow_state_id] = state\n\n    self._all_inputs.clear()\n    self._current_pipeline_inputs = None\n    self.clear_steps()\n    self._invalidate_pipeline()\n\n    self.add_steps(*state.steps)\n    # self._workflow_input_aliases = dict(state.input_aliases)\n    # self._workflow_output_aliases = dict(state.output_aliases)\n\n    self.set_inputs(**state.inputs)\n    assert {k: v for k, v in self._current_pipeline_inputs.items() if v not in [NONE_VALUE_ID, NOT_SET_VALUE_ID]} == {k: v for k, v in state.inputs.items() if v not in [NONE_VALUE_ID, NOT_SET_VALUE_ID]}  # type: ignore\n    self._current_pipeline_outputs = (\n        state.pipeline_info.pipeline_state.pipeline_outputs\n    )\n    self._pipeline_info = state.pipeline_info\n    self._current_state = state\n    self._current_info = None\n\n    return state\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.save","title":"<code>save(*aliases: str)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def save(self, *aliases: str):\n\n    self._pending_aliases.update(aliases)\n\n    self._workflow_metadata = self._kiara.workflow_registry.register_workflow(\n        workflow_metadata=self.workflow_metadata,\n        workflow_aliases=self._pending_aliases,\n    )\n    self._pending_aliases.clear()\n    self._metadata_is_stored = True\n    self._metadata_is_synced = True\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.snapshot","title":"<code>snapshot(save: bool = False) -&gt; WorkflowState</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def snapshot(self, save: bool = False) -&gt; WorkflowState:\n\n    state = self.current_state\n\n    if state.instance_id not in self._state_cache.keys():\n        self._state_cache[state.instance_id] = state\n\n    now = datetime.now(pytz.utc)\n\n    for field_name, value in self.current_pipeline_outputs.items():\n        if value in [NOT_SET_VALUE_ID, NONE_VALUE_ID]:\n            continue\n\n        self._state_output_cache.setdefault(state.instance_id, set()).add(value)\n        self._state_jobrecord_cache.setdefault(state.instance_id, set()).add(\n            self._job_id_cache[value]\n        )\n\n    self.workflow_metadata.workflow_history[now] = state.instance_id\n    self._metadata_is_synced = False\n\n    if save:\n        self.register_snapshot(snapshot=state.instance_id)\n    return state\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.register_snapshot","title":"<code>register_snapshot(snapshot: Union[datetime, str])</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def register_snapshot(self, snapshot: Union[datetime, str]):\n\n    timestamps: List[datetime]\n    if isinstance(snapshot, str):\n        if snapshot not in self._state_cache.keys():\n            raise Exception(\n                f\"Can't register snapshot with hash '{snapshot}': no state with this hash available.\"\n            )\n        state: WorkflowState = self._state_cache[snapshot]\n        timestamps = [\n            _timestamp\n            for _timestamp, _hash in self.workflow_metadata.workflow_history.items()\n            if _hash == snapshot\n        ]\n    elif isinstance(snapshot, datetime):\n        if snapshot not in self.workflow_metadata.workflow_history.keys():\n            raise Exception(\n                f\"Can't register snapshot with timestamp '{snapshot}': no state with this timestamp available.\"\n            )\n        state = self._state_cache[self.workflow_metadata.workflow_history[snapshot]]\n        timestamps = [snapshot]\n    else:\n        raise Exception(\n            f\"Can't register snapshot '{snapshot}': invalid type '{type(snapshot)}'.\"\n        )\n\n    # input values are stored in the add_workflow_state method on the backend\n\n    if state.instance_id in self._state_output_cache.keys():\n        for value_id in self._state_output_cache[state.instance_id]:\n            self._kiara.data_registry.store_value(value=value_id)\n\n    if state.instance_id in self._state_jobrecord_cache.keys():\n        for job_id in self._state_jobrecord_cache[state.instance_id]:\n            try:\n                self._kiara.job_registry.store_job_record(job_id=job_id)\n            except Exception as e:\n                log_exception(e)\n\n    if not self._metadata_is_stored:\n        self._sync_workflow_metadata()\n        self._metadata_is_synced = True\n\n    if not self._metadata_is_synced:\n        self._kiara.workflow_registry.update_workflow_metadata(\n            self.workflow_metadata\n        )\n\n    for timestamp in timestamps:\n        self._workflow_metadata = self._kiara.workflow_registry.add_workflow_state(\n            workflow=self._workflow_metadata.workflow_id,\n            workflow_state=state,\n            timestamp=timestamp,\n        )\n        self._metadata_is_synced = True\n\n    return state\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow.Workflow.create_renderable","title":"<code>create_renderable(**config: Any)</code>","text":"Source code in <code>kiara/interfaces/python_api/workflow.py</code> <pre><code>def create_renderable(self, **config: Any):\n\n    if not self._steps:\n        return \"Invalid workflow: no steps set yet.\"\n\n    return self.info.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/workflow/#kiara.interfaces.python_api.workflow-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/__init__/","title":"models","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/","title":"info","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.INFO_BASE_INSTANCE_TYPE","title":"<code>INFO_BASE_INSTANCE_TYPE = TypeVar('INFO_BASE_INSTANCE_TYPE')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.INFO_BASE_CLASS","title":"<code>INFO_BASE_CLASS = TypeVar('INFO_BASE_CLASS', bound=type)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RENDER_FIELDS","title":"<code>RENDER_FIELDS: Dict[str, Dict[str, Any]] = {'value_id': {'show_default': True, 'render': {'terminal': lambda v: str(v.value_id)}}, 'aliases': {'show_default': True, 'render': {'terminal': lambda v: ', '.join(v.aliases)}}, 'type': {'show_default': True, 'render': {'terminal': lambda x: x.value_schema.type}}, 'value_schema': {'show_default': False}, 'is_persisted': {'show_default': False, 'render': {'terminal': lambda v: 'yes' if v.is_persisted else 'no'}}, 'hash': {'show_default': False, 'render': {'terminal': lambda v: v.value_hash}}, 'data': {'show_default': False, 'render': {'terminal': pretty_print_value_data_terminal}}, 'pedigree': {'show_default': False, 'render': {'terminal': lambda v: '-- external data -- ' if v == ORPHAN else v}}, 'lineage': {'show_default': False}, 'load_config': {'show_default': False}, 'data_type_config': {'show_default': False, 'render': {'terminal': lambda v: Syntax(orjson_dumps(v.value_schema.type_config, option=orjson.OPT_INDENT_2), 'json', background_color='default')}}, 'serialize_details': {'show_default': False, 'render': {'terminal': lambda v: v.serialized.create_renderable()}}, 'properties': {'show_default': False, 'render': {'terminal': lambda v: v.property_values.create_renderable(show_header=False)}}, 'size': {'show_default': True, 'render': {'terminal': lambda v: humanfriendly.format_size(v.value_size)}}}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.INFO_ITEM_TYPE","title":"<code>INFO_ITEM_TYPE = TypeVar('INFO_ITEM_TYPE', bound=ItemInfo)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription","title":"<code>ValueTypeAndDescription</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ValueTypeAndDescription(BaseModel):\n\n    description: str = Field(description=\"The description for the value.\")\n    type: str = Field(description=\"The value type.\")\n    value_default: Any = Field(description=\"Default for the value.\", default=None)\n    required: bool = Field(description=\"Whether this value is required\")\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription.description","title":"<code>description: str = Field(description='The description for the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription.type","title":"<code>type: str = Field(description='The value type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription.value_default","title":"<code>value_default: Any = Field(description='Default for the value.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueTypeAndDescription.required","title":"<code>required: bool = Field(description='Whether this value is required')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo","title":"<code>ItemInfo</code>","text":"<p>         Bases: <code>KiaraModel</code>, <code>Generic[INFO_BASE_INSTANCE_TYPE]</code></p> <p>Base class that holds/manages information about an item within kiara.</p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ItemInfo(KiaraModel, Generic[INFO_BASE_INSTANCE_TYPE]):\n\"\"\"Base class that holds/manages information about an item within kiara.\"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def base_instance_class(cls) -&gt; Type[INFO_BASE_INSTANCE_TYPE]:\n        pass\n\n    @classmethod\n    @abc.abstractmethod\n    def create_from_instance(\n        cls, kiara: \"Kiara\", instance: INFO_BASE_INSTANCE_TYPE, **kwargs\n    ):\n        pass\n\n    @validator(\"documentation\", pre=True)\n    def validate_doc(cls, value):\n\n        return DocumentationMetadataModel.create(value)\n\n    type_name: str = Field(description=\"The registered name for this item type.\")\n    documentation: DocumentationMetadataModel = Field(\n        description=\"Documentation for the item.\"\n    )\n    authors: AuthorsMetadataModel = Field(\n        description=\"Information about authorship for the item.\"\n    )\n    context: ContextMetadataModel = Field(\n        description=\"Generic properties of this item (description, tags, labels, references, ...).\"\n    )\n\n    def _retrieve_id(self) -&gt; str:\n        return self.type_name\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.type_name\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        if hasattr(self, \"python_class\"):\n            table.add_row(\"Python class\", self.python_class.create_renderable())  # type: ignore\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.type_name","title":"<code>type_name: str = Field(description='The registered name for this item type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.documentation","title":"<code>documentation: DocumentationMetadataModel = Field(description='Documentation for the item.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.authors","title":"<code>authors: AuthorsMetadataModel = Field(description='Information about authorship for the item.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.context","title":"<code>context: ContextMetadataModel = Field(description='Generic properties of this item (description, tags, labels, references, ...).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[INFO_BASE_INSTANCE_TYPE]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef base_instance_class(cls) -&gt; Type[INFO_BASE_INSTANCE_TYPE]:\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: INFO_BASE_INSTANCE_TYPE, **kwargs)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef create_from_instance(\n    cls, kiara: \"Kiara\", instance: INFO_BASE_INSTANCE_TYPE, **kwargs\n):\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@validator(\"documentation\", pre=True)\ndef validate_doc(cls, value):\n\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ItemInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    if hasattr(self, \"python_class\"):\n        table.add_row(\"Python class\", self.python_class.create_renderable())  # type: ignore\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo","title":"<code>TypeInfo</code>","text":"<p>         Bases: <code>ItemInfo</code>, <code>Generic[INFO_BASE_CLASS]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class TypeInfo(ItemInfo, Generic[INFO_BASE_CLASS]):\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: INFO_BASE_CLASS, **kwargs):\n\n        return cls.create_from_type_class(type_cls=instance, kiara=kiara)\n\n    @classmethod\n    @abc.abstractmethod\n    def create_from_type_class(\n        self, type_cls: INFO_BASE_CLASS, kiara: \"Kiara\"\n    ) -&gt; \"ItemInfo\":\n        pass\n\n    @classmethod\n    def base_instance_class(self) -&gt; INFO_BASE_CLASS:\n        return type  # type: ignore\n\n    python_class: PythonClass = Field(\n        description=\"The python class that implements this module type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo.python_class","title":"<code>python_class: PythonClass = Field(description='The python class that implements this module type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: INFO_BASE_CLASS, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: INFO_BASE_CLASS, **kwargs):\n\n    return cls.create_from_type_class(type_cls=instance, kiara=kiara)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: INFO_BASE_CLASS, kiara: Kiara) -&gt; ItemInfo</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef create_from_type_class(\n    self, type_cls: INFO_BASE_CLASS, kiara: \"Kiara\"\n) -&gt; \"ItemInfo\":\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfo.base_instance_class","title":"<code>base_instance_class() -&gt; INFO_BASE_CLASS</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_instance_class(self) -&gt; INFO_BASE_CLASS:\n    return type  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup","title":"<code>InfoItemGroup</code>","text":"<p>         Bases: <code>KiaraModel</code>, <code>Generic[INFO_ITEM_TYPE]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class InfoItemGroup(KiaraModel, Generic[INFO_ITEM_TYPE]):\n    @classmethod\n    @abc.abstractmethod\n    def base_info_class(cls) -&gt; Type[INFO_ITEM_TYPE]:\n        pass\n\n    @classmethod\n    def create_from_instances(\n        cls,\n        kiara: \"Kiara\",\n        instances: Mapping[str, INFO_BASE_INSTANCE_TYPE],\n        **kwargs: Any,\n    ) -&gt; \"InfoItemGroup[INFO_ITEM_TYPE]\":\n\n        info_cls = cls.base_info_class()\n        items = {}\n        for k in sorted(instances.keys()):\n            v = instances[k]\n            items[k] = info_cls.create_from_instance(kiara=kiara, instance=v, **kwargs)\n\n        group_title = kwargs.pop(\"group_title\", None)\n        result = cls(group_title=group_title, item_infos=items)\n        result._kiara = kiara\n        return result\n\n    group_title: Union[str, None] = Field(description=\"The group alias.\", default=None)\n    item_infos: Mapping[str, INFO_ITEM_TYPE] = Field(description=\"The info items.\")\n    _kiara: Union[\"Kiara\", None] = PrivateAttr(default=None)\n\n    def _retrieve_subcomponent_keys(self) -&gt; Iterable[str]:\n        return self.item_infos.keys()\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\"type_name\": self.__class__._kiara_model_name, \"included_types\": list(self.item_infos.keys())}  # type: ignore\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        full_doc = config.get(\"full_doc\", False)\n\n        table = Table(show_header=True, box=box.SIMPLE, show_lines=full_doc)\n        table.add_column(\"Name\", style=\"i\")\n        table.add_column(\"Description\")\n\n        for type_name in sorted(self.item_infos.keys()):\n            t_md = self.item_infos[type_name]\n            if full_doc:\n                md = Markdown(t_md.documentation.full_doc)\n            else:\n                md = Markdown(t_md.documentation.description)\n            table.add_row(type_name, md)\n\n        return table\n\n    def __getitem__(self, item: str) -&gt; INFO_ITEM_TYPE:\n\n        return self.item_infos[item]\n\n    # def __iter__(self):\n    #     return self.item_infos.__iter__()\n\n    def __len__(self):\n        return len(self.item_infos)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup.group_title","title":"<code>group_title: Union[str, None] = Field(description='The group alias.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup.item_infos","title":"<code>item_infos: Mapping[str, INFO_ITEM_TYPE] = Field(description='The info items.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup.base_info_class","title":"<code>base_info_class() -&gt; Type[INFO_ITEM_TYPE]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef base_info_class(cls) -&gt; Type[INFO_ITEM_TYPE]:\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup.create_from_instances","title":"<code>create_from_instances(kiara: Kiara, instances: Mapping[str, INFO_BASE_INSTANCE_TYPE], **kwargs: Any) -&gt; InfoItemGroup[INFO_ITEM_TYPE]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instances(\n    cls,\n    kiara: \"Kiara\",\n    instances: Mapping[str, INFO_BASE_INSTANCE_TYPE],\n    **kwargs: Any,\n) -&gt; \"InfoItemGroup[INFO_ITEM_TYPE]\":\n\n    info_cls = cls.base_info_class()\n    items = {}\n    for k in sorted(instances.keys()):\n        v = instances[k]\n        items[k] = info_cls.create_from_instance(kiara=kiara, instance=v, **kwargs)\n\n    group_title = kwargs.pop(\"group_title\", None)\n    result = cls(group_title=group_title, item_infos=items)\n    result._kiara = kiara\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.InfoItemGroup.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    full_doc = config.get(\"full_doc\", False)\n\n    table = Table(show_header=True, box=box.SIMPLE, show_lines=full_doc)\n    table.add_column(\"Name\", style=\"i\")\n    table.add_column(\"Description\")\n\n    for type_name in sorted(self.item_infos.keys()):\n        t_md = self.item_infos[type_name]\n        if full_doc:\n            md = Markdown(t_md.documentation.full_doc)\n        else:\n            md = Markdown(t_md.documentation.description)\n        table.add_row(type_name, md)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfoItemGroup","title":"<code>TypeInfoItemGroup</code>","text":"<p>         Bases: <code>InfoItemGroup[TypeInfo]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class TypeInfoItemGroup(InfoItemGroup[TypeInfo]):\n    @classmethod\n    @abc.abstractmethod\n    def base_info_class(cls) -&gt; Type[TypeInfo]:\n        pass\n\n    @classmethod\n    def create_from_type_items(\n        cls, kiara: \"Kiara\", group_title: Union[str, None] = None, **items: Type\n    ) -&gt; \"TypeInfoItemGroup\":\n\n        type_infos = {\n            k: cls.base_info_class().create_from_type_class(type_cls=v, kiara=kiara)\n            for k, v in items.items()\n        }\n        data_types_info = cls.construct(group_alias=group_title, item_infos=type_infos)  # type: ignore\n        return data_types_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfoItemGroup-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfoItemGroup.base_info_class","title":"<code>base_info_class() -&gt; Type[TypeInfo]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef base_info_class(cls) -&gt; Type[TypeInfo]:\n    pass\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.TypeInfoItemGroup.create_from_type_items","title":"<code>create_from_type_items(kiara: Kiara, group_title: Union[str, None] = None, **items: Type) -&gt; TypeInfoItemGroup</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_type_items(\n    cls, kiara: \"Kiara\", group_title: Union[str, None] = None, **items: Type\n) -&gt; \"TypeInfoItemGroup\":\n\n    type_infos = {\n        k: cls.base_info_class().create_from_type_class(type_cls=v, kiara=kiara)\n        for k, v in items.items()\n    }\n    data_types_info = cls.construct(group_alias=group_title, item_infos=type_infos)  # type: ignore\n    return data_types_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo","title":"<code>KiaraModelTypeInfo</code>","text":"<p>         Bases: <code>TypeInfo[Type[KiaraModel]]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class KiaraModelTypeInfo(TypeInfo[Type[KiaraModel]]):\n\n    _kiara_model_id = \"info.kiara_model\"\n\n    @classmethod\n    def create_from_type_class(\n        self, type_cls: Type[KiaraModel], kiara: \"Kiara\"\n    ) -&gt; \"KiaraModelTypeInfo\":\n\n        authors_md = AuthorsMetadataModel.from_class(type_cls)\n        doc = DocumentationMetadataModel.from_class_doc(type_cls)\n        python_class = PythonClass.from_class(type_cls)\n        properties_md = ContextMetadataModel.from_class(type_cls)\n        type_name = type_cls._kiara_model_id  # type: ignore\n        schema = type_cls.schema()\n\n        return KiaraModelTypeInfo.construct(\n            type_name=type_name,\n            documentation=doc,\n            authors=authors_md,\n            context=properties_md,\n            python_class=python_class,\n            metadata_schema=schema,\n        )\n\n    metadata_schema: Dict[str, Any] = Field(\n        description=\"The (json) schema for this model data.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", True)\n        include_schema = config.get(\"include_schema\", False)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        if hasattr(self, \"python_class\"):\n            table.add_row(\"Python class\", self.python_class.create_renderable())\n\n        if include_schema:\n            schema = Syntax(\n                orjson_dumps(self.metadata_schema, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            table.add_row(\"metadata_schema\", schema)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo.metadata_schema","title":"<code>metadata_schema: Dict[str, Any] = Field(description='The (json) schema for this model data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: Type[KiaraModel], kiara: Kiara) -&gt; KiaraModelTypeInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_type_class(\n    self, type_cls: Type[KiaraModel], kiara: \"Kiara\"\n) -&gt; \"KiaraModelTypeInfo\":\n\n    authors_md = AuthorsMetadataModel.from_class(type_cls)\n    doc = DocumentationMetadataModel.from_class_doc(type_cls)\n    python_class = PythonClass.from_class(type_cls)\n    properties_md = ContextMetadataModel.from_class(type_cls)\n    type_name = type_cls._kiara_model_id  # type: ignore\n    schema = type_cls.schema()\n\n    return KiaraModelTypeInfo.construct(\n        type_name=type_name,\n        documentation=doc,\n        authors=authors_md,\n        context=properties_md,\n        python_class=python_class,\n        metadata_schema=schema,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelTypeInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", True)\n    include_schema = config.get(\"include_schema\", False)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    if hasattr(self, \"python_class\"):\n        table.add_row(\"Python class\", self.python_class.create_renderable())\n\n    if include_schema:\n        schema = Syntax(\n            orjson_dumps(self.metadata_schema, option=orjson.OPT_INDENT_2),\n            \"json\",\n            background_color=\"default\",\n        )\n        table.add_row(\"metadata_schema\", schema)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo","title":"<code>KiaraModelClassesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class KiaraModelClassesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.kiara_models\"\n\n    @classmethod\n    def find_kiara_models(\n        cls, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n    ) -&gt; \"KiaraModelClassesInfo\":\n\n        models = find_all_kiara_model_classes()\n\n        # we don't need the kiara instance, this is just to satisfy mypy\n        kiara: Kiara = None  # type: ignore\n        group: KiaraModelClassesInfo = KiaraModelClassesInfo.create_from_type_items(kiara=kiara, group_title=alias, **models)  # type: ignore\n\n        if only_for_package:\n            temp = {}\n            for key, info in group.item_infos.items():\n                if info.context.labels.get(\"package\") == only_for_package:\n                    temp[key] = info\n\n            group = KiaraModelClassesInfo.construct(\n                group_id=group.instance_id, group_alias=group.group_alias, item_infos=temp  # type: ignore\n            )\n\n        return group\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[KiaraModelTypeInfo]:\n        return KiaraModelTypeInfo  # type: ignore\n\n    type_name: Literal[\"kiara_model\"] = \"kiara_model\"\n    item_infos: Mapping[str, KiaraModelTypeInfo] = Field(  # type: ignore\n        description=\"The value metadata info instances for each type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo.type_name","title":"<code>type_name: Literal['kiara_model'] = 'kiara_model'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo.item_infos","title":"<code>item_infos: Mapping[str, KiaraModelTypeInfo] = Field(description='The value metadata info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo.find_kiara_models","title":"<code>find_kiara_models(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; KiaraModelClassesInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef find_kiara_models(\n    cls, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; \"KiaraModelClassesInfo\":\n\n    models = find_all_kiara_model_classes()\n\n    # we don't need the kiara instance, this is just to satisfy mypy\n    kiara: Kiara = None  # type: ignore\n    group: KiaraModelClassesInfo = KiaraModelClassesInfo.create_from_type_items(kiara=kiara, group_title=alias, **models)  # type: ignore\n\n    if only_for_package:\n        temp = {}\n        for key, info in group.item_infos.items():\n            if info.context.labels.get(\"package\") == only_for_package:\n                temp[key] = info\n\n        group = KiaraModelClassesInfo.construct(\n            group_id=group.instance_id, group_alias=group.group_alias, item_infos=temp  # type: ignore\n        )\n\n    return group\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModelClassesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[KiaraModelTypeInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[KiaraModelTypeInfo]:\n    return KiaraModelTypeInfo  # type: ignore\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo","title":"<code>ValueInfo</code>","text":"<p>         Bases: <code>ItemInfo[Value]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ValueInfo(ItemInfo[Value]):\n\n    _kiara_model_id = \"info.value\"\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[Value]:\n        return Value\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: Value, **kwargs: Any):\n\n        resolve_aliases = kwargs.get(\"resolve_aliases\", True)\n        resolve_destinies = kwargs.get(\"resolve_destinies\", True)\n        resolve_properties = kwargs.get(\"resolve_properties\", True)\n\n        if resolve_aliases:\n            aliases = sorted(\n                kiara.alias_registry.find_aliases_for_value_id(instance.value_id)\n            )\n        else:\n            aliases = None\n\n        if instance.is_stored:\n            persisted_details = kiara.data_registry.retrieve_persisted_value_details(\n                value_id=instance.value_id\n            )\n        else:\n            persisted_details = None\n\n        if instance.data_type_name in kiara.type_registry.data_type_profiles:\n            is_internal = \"internal\" in kiara.type_registry.get_type_lineage(\n                instance.data_type_name\n            )\n        else:\n            is_internal = False\n\n        if resolve_destinies:\n            destiny_links = kiara.data_registry.find_destinies_for_value(\n                value_id=instance.value_id\n            )\n            filtered_destinies = {}\n            for alias, value_id in destiny_links.items():\n                if (\n                    alias in instance.property_links.keys()\n                    and value_id == instance.property_links[alias]\n                ):\n                    continue\n                filtered_destinies[alias] = value_id\n        else:\n            filtered_destinies = None\n\n        if resolve_properties:\n            properties = instance.get_all_property_data()\n        else:\n            properties = None\n\n        authors = AuthorsMetadataModel()\n        context = ContextMetadataModel()\n        doc = DocumentationMetadataModel()\n\n        model = ValueInfo(\n            type_name=str(instance.value_id),\n            documentation=doc,\n            authors=authors,\n            context=context,\n            value_id=instance.value_id,\n            kiara_id=instance.kiara_id,\n            value_schema=instance.value_schema,\n            value_status=instance.value_status,\n            environment_hashes=instance.environment_hashes,\n            value_size=instance.value_size,\n            value_hash=instance.value_hash,\n            pedigree=instance.pedigree,\n            pedigree_output_name=instance.pedigree_output_name,\n            data_type_info=instance.data_type_info,\n            # data_type_config=instance.data_type_config,\n            # data_type_class=instance.data_type_class,\n            property_links=instance.property_links,\n            destiny_links=filtered_destinies,\n            destiny_backlinks=instance.destiny_backlinks,\n            aliases=aliases,\n            serialized=persisted_details,\n            properties=properties,\n            is_internal=is_internal,\n            is_persisted=instance._is_stored,\n        )\n        model._value = instance\n        model._alias_registry = kiara.alias_registry  # type: ignore\n        model._data_registry = instance._data_registry\n        return model\n\n    value_id: uuid.UUID = Field(description=\"The id of the value.\")\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The id of the kiara context this value belongs to.\"\n    )\n\n    value_schema: ValueSchema = Field(\n        description=\"The schema that was used for this Value.\"\n    )\n\n    value_status: ValueStatus = Field(description=\"The set/unset status of this value.\")\n    value_size: int = Field(description=\"The size of this value, in bytes.\")\n    value_hash: str = Field(description=\"The hash of this value.\")\n    pedigree: ValuePedigree = Field(\n        description=\"Information about the module and inputs that went into creating this value.\"\n    )\n    pedigree_output_name: str = Field(\n        description=\"The output name that produced this value (using the manifest inside the pedigree).\"\n    )\n    data_type_info: DataTypeInfo = Field(\n        description=\"Information about the underlying data type and it's configuration.\"\n    )\n    aliases: Union[List[str], None] = Field(\n        description=\"The aliases that are registered for this value.\"\n    )\n    serialized: Union[PersistedData, None] = Field(\n        description=\"Details for the serialization process that was used for this value.\"\n    )\n    properties: Union[Mapping[str, Any], None] = Field(\n        description=\"Property data for this value.\", default=None\n    )\n    destiny_links: Union[Mapping[str, uuid.UUID], None] = Field(\n        description=\"References to all the values that act as destiny for this value in this context.\"\n    )\n    environment_hashes: Mapping[str, Mapping[str, str]] = Field(\n        description=\"Hashes for the environments this value was created in.\"\n    )\n    enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(\n        description=\"Information about the environments this value was created in.\",\n        default=None,\n    )\n    property_links: Mapping[str, uuid.UUID] = Field(\n        description=\"Links to values that are properties of this value.\",\n        default_factory=dict,\n    )\n    destiny_backlinks: Mapping[uuid.UUID, str] = Field(\n        description=\"Backlinks to values that this value acts as destiny/or property for.\",\n        default_factory=dict,\n    )\n    is_internal: bool = Field(\n        description=\"Whether this value is only used internally in kiara.\",\n        default=False,\n    )\n    is_persisted: bool = Field(\n        description=\"Whether this value is stored in at least one data store.\"\n    )\n    _alias_registry: \"AliasRegistry\" = PrivateAttr(default=None)\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n    _value: Value = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.value_id)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.value_id.bytes\n\n    @property\n    def property_values(self) -&gt; \"ValueMap\":\n        return self._value.property_values\n\n    @property\n    def lineage(self) -&gt; \"ValueLineage\":\n        return self._value.lineage\n\n    def resolve_aliases(self):\n        if self.aliases is None:\n            aliases = self._alias_registry.find_aliases_for_value_id(self.value_id)\n            if aliases:\n                aliases = sorted(aliases)\n            self.aliases = aliases\n\n    def resolve_destinies(self):\n        if self.destiny_links is None:\n            destiny_links = self._value._data_registry.find_destinies_for_value(\n                value_id=self.value_id\n            )\n            filtered_destinies = {}\n            for alias, value_id in destiny_links.items():\n                if (\n                    alias in self.property_links.keys()\n                    and value_id == self.property_links[alias]\n                ):\n                    continue\n                filtered_destinies[alias] = value_id\n            self.destiny_links = filtered_destinies\n\n    def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n        return self._value.create_info_data(**config)\n\n    def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n        return self._value.create_renderable(**render_config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.value_id","title":"<code>value_id: uuid.UUID = Field(description='The id of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context this value belongs to.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.value_schema","title":"<code>value_schema: ValueSchema = Field(description='The schema that was used for this Value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.value_status","title":"<code>value_status: ValueStatus = Field(description='The set/unset status of this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.value_size","title":"<code>value_size: int = Field(description='The size of this value, in bytes.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.value_hash","title":"<code>value_hash: str = Field(description='The hash of this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.pedigree","title":"<code>pedigree: ValuePedigree = Field(description='Information about the module and inputs that went into creating this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.pedigree_output_name","title":"<code>pedigree_output_name: str = Field(description='The output name that produced this value (using the manifest inside the pedigree).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.data_type_info","title":"<code>data_type_info: DataTypeInfo = Field(description=\"Information about the underlying data type and it's configuration.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.aliases","title":"<code>aliases: Union[List[str], None] = Field(description='The aliases that are registered for this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.serialized","title":"<code>serialized: Union[PersistedData, None] = Field(description='Details for the serialization process that was used for this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.properties","title":"<code>properties: Union[Mapping[str, Any], None] = Field(description='Property data for this value.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.destiny_links","title":"<code>destiny_links: Union[Mapping[str, uuid.UUID], None] = Field(description='References to all the values that act as destiny for this value in this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.environment_hashes","title":"<code>environment_hashes: Mapping[str, Mapping[str, str]] = Field(description='Hashes for the environments this value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.enviroments","title":"<code>enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(description='Information about the environments this value was created in.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.property_links","title":"<code>property_links: Mapping[str, uuid.UUID] = Field(description='Links to values that are properties of this value.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.destiny_backlinks","title":"<code>destiny_backlinks: Mapping[uuid.UUID, str] = Field(description='Backlinks to values that this value acts as destiny/or property for.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.is_internal","title":"<code>is_internal: bool = Field(description='Whether this value is only used internally in kiara.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.is_persisted","title":"<code>is_persisted: bool = Field(description='Whether this value is stored in at least one data store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.property_values","title":"<code>property_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.lineage","title":"<code>lineage: ValueLineage</code>  <code>property</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[Value]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[Value]:\n    return Value\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: Value, **kwargs: Any)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: Value, **kwargs: Any):\n\n    resolve_aliases = kwargs.get(\"resolve_aliases\", True)\n    resolve_destinies = kwargs.get(\"resolve_destinies\", True)\n    resolve_properties = kwargs.get(\"resolve_properties\", True)\n\n    if resolve_aliases:\n        aliases = sorted(\n            kiara.alias_registry.find_aliases_for_value_id(instance.value_id)\n        )\n    else:\n        aliases = None\n\n    if instance.is_stored:\n        persisted_details = kiara.data_registry.retrieve_persisted_value_details(\n            value_id=instance.value_id\n        )\n    else:\n        persisted_details = None\n\n    if instance.data_type_name in kiara.type_registry.data_type_profiles:\n        is_internal = \"internal\" in kiara.type_registry.get_type_lineage(\n            instance.data_type_name\n        )\n    else:\n        is_internal = False\n\n    if resolve_destinies:\n        destiny_links = kiara.data_registry.find_destinies_for_value(\n            value_id=instance.value_id\n        )\n        filtered_destinies = {}\n        for alias, value_id in destiny_links.items():\n            if (\n                alias in instance.property_links.keys()\n                and value_id == instance.property_links[alias]\n            ):\n                continue\n            filtered_destinies[alias] = value_id\n    else:\n        filtered_destinies = None\n\n    if resolve_properties:\n        properties = instance.get_all_property_data()\n    else:\n        properties = None\n\n    authors = AuthorsMetadataModel()\n    context = ContextMetadataModel()\n    doc = DocumentationMetadataModel()\n\n    model = ValueInfo(\n        type_name=str(instance.value_id),\n        documentation=doc,\n        authors=authors,\n        context=context,\n        value_id=instance.value_id,\n        kiara_id=instance.kiara_id,\n        value_schema=instance.value_schema,\n        value_status=instance.value_status,\n        environment_hashes=instance.environment_hashes,\n        value_size=instance.value_size,\n        value_hash=instance.value_hash,\n        pedigree=instance.pedigree,\n        pedigree_output_name=instance.pedigree_output_name,\n        data_type_info=instance.data_type_info,\n        # data_type_config=instance.data_type_config,\n        # data_type_class=instance.data_type_class,\n        property_links=instance.property_links,\n        destiny_links=filtered_destinies,\n        destiny_backlinks=instance.destiny_backlinks,\n        aliases=aliases,\n        serialized=persisted_details,\n        properties=properties,\n        is_internal=is_internal,\n        is_persisted=instance._is_stored,\n    )\n    model._value = instance\n    model._alias_registry = kiara.alias_registry  # type: ignore\n    model._data_registry = instance._data_registry\n    return model\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.resolve_aliases","title":"<code>resolve_aliases()</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def resolve_aliases(self):\n    if self.aliases is None:\n        aliases = self._alias_registry.find_aliases_for_value_id(self.value_id)\n        if aliases:\n            aliases = sorted(aliases)\n        self.aliases = aliases\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.resolve_destinies","title":"<code>resolve_destinies()</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def resolve_destinies(self):\n    if self.destiny_links is None:\n        destiny_links = self._value._data_registry.find_destinies_for_value(\n            value_id=self.value_id\n        )\n        filtered_destinies = {}\n        for alias, value_id in destiny_links.items():\n            if (\n                alias in self.property_links.keys()\n                and value_id == self.property_links[alias]\n            ):\n                continue\n            filtered_destinies[alias] = value_id\n        self.destiny_links = filtered_destinies\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.create_info_data","title":"<code>create_info_data(**config: Any) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n    return self._value.create_info_data(**config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValueInfo.create_renderable","title":"<code>create_renderable(**render_config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n    return self._value.create_renderable(**render_config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValuesInfo","title":"<code>ValuesInfo</code>","text":"<p>         Bases: <code>InfoItemGroup[ValueInfo]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ValuesInfo(InfoItemGroup[ValueInfo]):\n    @classmethod\n    def base_info_class(cls) -&gt; Type[ValueInfo]:\n        return ValueInfo\n\n    def create_render_map(\n        self, render_type: str, default_render_func: Callable, **render_config\n    ):\n\n        list_by_alias = render_config.get(\"list_by_alias\", True)\n        show_internal = render_config.get(\"show_internal_values\", False)\n\n        render_fields = render_config.get(\"render_fields\", None)\n        if not render_fields:\n            render_fields = [k for k, v in RENDER_FIELDS.items() if v[\"show_default\"]]\n            if list_by_alias:\n                render_fields[0] = \"aliases\"\n                render_fields[1] = \"value_id\"\n\n        render_map: Dict[uuid.UUID, Dict[str, Any]] = {}\n\n        lookup = {}\n        value_info: ValueInfo\n        for value_info in self.item_infos.values():  # type: ignore\n            if not show_internal and value_info.is_internal:\n                continue\n            lookup[value_info.value_id] = value_info\n\n            details = {}\n            for property in render_fields:\n\n                render_func = (\n                    RENDER_FIELDS.get(property, {})\n                    .get(\"render\", {})\n                    .get(render_type, None)\n                )\n                if render_func is None:\n                    if hasattr(value_info, property):\n                        attr = getattr(value_info, property)\n                        rendered = default_render_func(attr)\n                    else:\n                        raise Exception(\n                            f\"Can't render property '{property}': no render function registered and not a property.\"\n                        )\n                else:\n                    rendered = render_func(value_info)\n                details[property] = rendered\n            render_map[value_info.value_id] = details\n\n        if not list_by_alias:\n            return {str(k): v for k, v in render_map.items()}\n        else:\n            result: Dict[str, Dict[str, Any]] = {}\n            for value_id, render_details in render_map.items():\n                value_aliases = lookup[value_id].aliases\n                if value_aliases:\n                    for alias in value_aliases:\n                        assert alias not in result.keys()\n                        render_details = dict(render_details)\n                        render_details[\"alias\"] = alias\n                        result[alias] = render_details\n                else:\n                    render_details[\"alias\"] = \"\"\n                    result[f\"no_aliases_{value_id}\"] = render_details\n            return result\n\n    def create_renderable(self, render_type: str = \"terminal\", **render_config: Any):\n\n        render_map = self.create_render_map(\n            render_type=render_type,\n            default_render_func=extract_renderable,\n            **render_config,\n        )\n\n        list_by_alias = render_config.get(\"list_by_alias\", True)\n        render_fields = render_config.get(\"render_fields\", None)\n        if not render_fields:\n            render_fields = [k for k, v in RENDER_FIELDS.items() if v[\"show_default\"]]\n        if list_by_alias:\n            render_fields.insert(0, \"alias\")\n            render_fields.remove(\"aliases\")\n\n        table = Table(box=box.SIMPLE)\n        for property in render_fields:\n            if property == \"aliases\" and list_by_alias:\n                table.add_column(\"alias\")\n            elif property == \"size\":\n                table.add_column(\"size\", justify=\"right\")\n            else:\n                table.add_column(property)\n\n        for item_id, details in render_map.items():\n            row = []\n            for field in render_fields:\n                value = details[field]\n                row.append(value)\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValuesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValuesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[ValueInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[ValueInfo]:\n    return ValueInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValuesInfo.create_render_map","title":"<code>create_render_map(render_type: str, default_render_func: Callable, **render_config)</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_render_map(\n    self, render_type: str, default_render_func: Callable, **render_config\n):\n\n    list_by_alias = render_config.get(\"list_by_alias\", True)\n    show_internal = render_config.get(\"show_internal_values\", False)\n\n    render_fields = render_config.get(\"render_fields\", None)\n    if not render_fields:\n        render_fields = [k for k, v in RENDER_FIELDS.items() if v[\"show_default\"]]\n        if list_by_alias:\n            render_fields[0] = \"aliases\"\n            render_fields[1] = \"value_id\"\n\n    render_map: Dict[uuid.UUID, Dict[str, Any]] = {}\n\n    lookup = {}\n    value_info: ValueInfo\n    for value_info in self.item_infos.values():  # type: ignore\n        if not show_internal and value_info.is_internal:\n            continue\n        lookup[value_info.value_id] = value_info\n\n        details = {}\n        for property in render_fields:\n\n            render_func = (\n                RENDER_FIELDS.get(property, {})\n                .get(\"render\", {})\n                .get(render_type, None)\n            )\n            if render_func is None:\n                if hasattr(value_info, property):\n                    attr = getattr(value_info, property)\n                    rendered = default_render_func(attr)\n                else:\n                    raise Exception(\n                        f\"Can't render property '{property}': no render function registered and not a property.\"\n                    )\n            else:\n                rendered = render_func(value_info)\n            details[property] = rendered\n        render_map[value_info.value_id] = details\n\n    if not list_by_alias:\n        return {str(k): v for k, v in render_map.items()}\n    else:\n        result: Dict[str, Dict[str, Any]] = {}\n        for value_id, render_details in render_map.items():\n            value_aliases = lookup[value_id].aliases\n            if value_aliases:\n                for alias in value_aliases:\n                    assert alias not in result.keys()\n                    render_details = dict(render_details)\n                    render_details[\"alias\"] = alias\n                    result[alias] = render_details\n            else:\n                render_details[\"alias\"] = \"\"\n                result[f\"no_aliases_{value_id}\"] = render_details\n        return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ValuesInfo.create_renderable","title":"<code>create_renderable(render_type: str = 'terminal', **render_config: Any)</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, render_type: str = \"terminal\", **render_config: Any):\n\n    render_map = self.create_render_map(\n        render_type=render_type,\n        default_render_func=extract_renderable,\n        **render_config,\n    )\n\n    list_by_alias = render_config.get(\"list_by_alias\", True)\n    render_fields = render_config.get(\"render_fields\", None)\n    if not render_fields:\n        render_fields = [k for k, v in RENDER_FIELDS.items() if v[\"show_default\"]]\n    if list_by_alias:\n        render_fields.insert(0, \"alias\")\n        render_fields.remove(\"aliases\")\n\n    table = Table(box=box.SIMPLE)\n    for property in render_fields:\n        if property == \"aliases\" and list_by_alias:\n            table.add_column(\"alias\")\n        elif property == \"size\":\n            table.add_column(\"size\", justify=\"right\")\n        else:\n            table.add_column(property)\n\n    for item_id, details in render_map.items():\n        row = []\n        for field in render_fields:\n            value = details[field]\n            row.append(value)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata","title":"<code>KiaraModuleConfigMetadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class KiaraModuleConfigMetadata(KiaraModel):\n\n    _kiara_model_id = \"metadata.module_config\"\n\n    @classmethod\n    def from_config_class(\n        cls,\n        config_cls: Type[KiaraModuleConfig],\n    ):\n\n        flat_models = get_flat_models_from_model(config_cls)\n        model_name_map = get_model_name_map(flat_models)\n        m_schema, _, _ = model_process_schema(config_cls, model_name_map=model_name_map)\n        fields = m_schema[\"properties\"]\n\n        config_values = {}\n        for field_name, details in fields.items():\n\n            type_str = \"-- n/a --\"\n            if \"type\" in details.keys():\n                type_str = details[\"type\"]\n\n            desc = details.get(\"description\", DEFAULT_NO_DESC_VALUE)\n            default = config_cls.__fields__[field_name].default\n            if default is None:\n                if callable(config_cls.__fields__[field_name].default_factory):\n                    default = config_cls.__fields__[field_name].default_factory()  # type: ignore\n\n            req = config_cls.__fields__[field_name].required\n\n            config_values[field_name] = ValueTypeAndDescription(\n                description=desc, type=type_str, value_default=default, required=req\n            )\n\n        python_cls = PythonClass.from_class(config_cls)\n        return KiaraModuleConfigMetadata(\n            python_class=python_cls, config_values=config_values\n        )\n\n    python_class: PythonClass = Field(description=\"The config model python class.\")\n    config_values: Dict[str, ValueTypeAndDescription] = Field(\n        description=\"The available configuration values.\"\n    )\n\n    def _retrieve_id(self) -&gt; str:\n        return self.python_class.full_name\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.python_class.full_name\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata.python_class","title":"<code>python_class: PythonClass = Field(description='The config model python class.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata.config_values","title":"<code>config_values: Dict[str, ValueTypeAndDescription] = Field(description='The available configuration values.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.KiaraModuleConfigMetadata.from_config_class","title":"<code>from_config_class(config_cls: Type[KiaraModuleConfig])</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef from_config_class(\n    cls,\n    config_cls: Type[KiaraModuleConfig],\n):\n\n    flat_models = get_flat_models_from_model(config_cls)\n    model_name_map = get_model_name_map(flat_models)\n    m_schema, _, _ = model_process_schema(config_cls, model_name_map=model_name_map)\n    fields = m_schema[\"properties\"]\n\n    config_values = {}\n    for field_name, details in fields.items():\n\n        type_str = \"-- n/a --\"\n        if \"type\" in details.keys():\n            type_str = details[\"type\"]\n\n        desc = details.get(\"description\", DEFAULT_NO_DESC_VALUE)\n        default = config_cls.__fields__[field_name].default\n        if default is None:\n            if callable(config_cls.__fields__[field_name].default_factory):\n                default = config_cls.__fields__[field_name].default_factory()  # type: ignore\n\n        req = config_cls.__fields__[field_name].required\n\n        config_values[field_name] = ValueTypeAndDescription(\n            description=desc, type=type_str, value_default=default, required=req\n        )\n\n    python_cls = PythonClass.from_class(config_cls)\n    return KiaraModuleConfigMetadata(\n        python_class=python_cls, config_values=config_values\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo","title":"<code>DataTypeClassInfo</code>","text":"<p>         Bases: <code>TypeInfo[Type[DataType]]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class DataTypeClassInfo(TypeInfo[Type[\"DataType\"]]):\n\n    _kiara_model_id = \"info.data_type\"\n\n    @classmethod\n    def create_from_type_class(\n        self, type_cls: Type[\"DataType\"], kiara: Union[\"Kiara\", None] = None\n    ) -&gt; \"DataTypeClassInfo\":\n\n        authors = AuthorsMetadataModel.from_class(type_cls)\n        doc = DocumentationMetadataModel.from_class_doc(type_cls)\n        properties_md = ContextMetadataModel.from_class(type_cls)\n\n        if kiara is not None:\n            qual_profiles = kiara.type_registry.get_associated_profiles(type_cls._data_type_name)  # type: ignore\n            lineage = kiara.type_registry.get_type_lineage(type_cls._data_type_name)  # type: ignore\n        else:\n            qual_profiles = None\n            lineage = None\n\n        try:\n            result = DataTypeClassInfo.construct(\n                type_name=type_cls._data_type_name,  # type: ignore\n                python_class=PythonClass.from_class(type_cls),\n                value_cls=PythonClass.from_class(type_cls.python_class()),\n                data_type_config_cls=PythonClass.from_class(\n                    type_cls.data_type_config_class()\n                ),\n                lineage=lineage,  # type: ignore\n                qualifier_profiles=qual_profiles,\n                documentation=doc,\n                authors=authors,\n                context=properties_md,\n            )\n        except Exception as e:\n            if isinstance(\n                e, TypeError\n            ) and \"missing 1 required positional argument: 'cls'\" in str(e):\n                raise Exception(\n                    f\"Invalid implementation of TypeValue subclass '{type_cls.__name__}': 'python_class' method must be marked as a '@classmethod'. This is a bug.\"\n                )\n            raise e\n\n        result._kiara = kiara\n        return result\n\n    @classmethod\n    def base_class(self) -&gt; Type[\"DataType\"]:\n        from kiara.data_types import DataType\n\n        return DataType\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"data_type\"\n\n    value_cls: PythonClass = Field(description=\"The python class of the value itself.\")\n    data_type_config_cls: PythonClass = Field(\n        description=\"The python class holding the schema for configuring this type.\"\n    )\n    lineage: Union[List[str], None] = Field(description=\"This types lineage.\")\n    qualifier_profiles: Union[Mapping[str, Mapping[str, Any]], None] = Field(\n        description=\"A map of qualifier profiles for this data types.\"\n    )\n    _kiara: Union[\"Kiara\", None] = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return self.type_name\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.type_name\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if self.lineage:\n            table.add_row(\"lineage\", \"\\n\".join(self.lineage[0:]))\n        else:\n            table.add_row(\"lineage\", \"-- n/a --\")\n\n        if self.qualifier_profiles:\n            qual_table = Table(show_header=False, box=box.SIMPLE)\n            qual_table.add_column(\"name\")\n            qual_table.add_column(\"config\")\n            for name, details in self.qualifier_profiles.items():\n                json_details = orjson_dumps(details, option=orjson.OPT_INDENT_2)\n                qual_table.add_row(\n                    name, Syntax(json_details, \"json\", background_color=\"default\")\n                )\n            table.add_row(\"qualifier profile(s)\", qual_table)\n        else:\n            table.add_row(\"qualifier profile(s)\", \"-- n/a --\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        table.add_row(\"Python class\", self.python_class.create_renderable())\n        table.add_row(\"Config class\", self.data_type_config_cls.create_renderable())\n        table.add_row(\"Value class\", self.value_cls.create_renderable())\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.value_cls","title":"<code>value_cls: PythonClass = Field(description='The python class of the value itself.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.data_type_config_cls","title":"<code>data_type_config_cls: PythonClass = Field(description='The python class holding the schema for configuring this type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.lineage","title":"<code>lineage: Union[List[str], None] = Field(description='This types lineage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.qualifier_profiles","title":"<code>qualifier_profiles: Union[Mapping[str, Mapping[str, Any]], None] = Field(description='A map of qualifier profiles for this data types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: Type[DataType], kiara: Union[Kiara, None] = None) -&gt; DataTypeClassInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_type_class(\n    self, type_cls: Type[\"DataType\"], kiara: Union[\"Kiara\", None] = None\n) -&gt; \"DataTypeClassInfo\":\n\n    authors = AuthorsMetadataModel.from_class(type_cls)\n    doc = DocumentationMetadataModel.from_class_doc(type_cls)\n    properties_md = ContextMetadataModel.from_class(type_cls)\n\n    if kiara is not None:\n        qual_profiles = kiara.type_registry.get_associated_profiles(type_cls._data_type_name)  # type: ignore\n        lineage = kiara.type_registry.get_type_lineage(type_cls._data_type_name)  # type: ignore\n    else:\n        qual_profiles = None\n        lineage = None\n\n    try:\n        result = DataTypeClassInfo.construct(\n            type_name=type_cls._data_type_name,  # type: ignore\n            python_class=PythonClass.from_class(type_cls),\n            value_cls=PythonClass.from_class(type_cls.python_class()),\n            data_type_config_cls=PythonClass.from_class(\n                type_cls.data_type_config_class()\n            ),\n            lineage=lineage,  # type: ignore\n            qualifier_profiles=qual_profiles,\n            documentation=doc,\n            authors=authors,\n            context=properties_md,\n        )\n    except Exception as e:\n        if isinstance(\n            e, TypeError\n        ) and \"missing 1 required positional argument: 'cls'\" in str(e):\n            raise Exception(\n                f\"Invalid implementation of TypeValue subclass '{type_cls.__name__}': 'python_class' method must be marked as a '@classmethod'. This is a bug.\"\n            )\n        raise e\n\n    result._kiara = kiara\n    return result\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.base_class","title":"<code>base_class() -&gt; Type[DataType]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_class(self) -&gt; Type[\"DataType\"]:\n    from kiara.data_types import DataType\n\n    return DataType\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"data_type\"\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if self.lineage:\n        table.add_row(\"lineage\", \"\\n\".join(self.lineage[0:]))\n    else:\n        table.add_row(\"lineage\", \"-- n/a --\")\n\n    if self.qualifier_profiles:\n        qual_table = Table(show_header=False, box=box.SIMPLE)\n        qual_table.add_column(\"name\")\n        qual_table.add_column(\"config\")\n        for name, details in self.qualifier_profiles.items():\n            json_details = orjson_dumps(details, option=orjson.OPT_INDENT_2)\n            qual_table.add_row(\n                name, Syntax(json_details, \"json\", background_color=\"default\")\n            )\n        table.add_row(\"qualifier profile(s)\", qual_table)\n    else:\n        table.add_row(\"qualifier profile(s)\", \"-- n/a --\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    table.add_row(\"Python class\", self.python_class.create_renderable())\n    table.add_row(\"Config class\", self.data_type_config_cls.create_renderable())\n    table.add_row(\"Value class\", self.value_cls.create_renderable())\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo","title":"<code>DataTypeClassesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class DataTypeClassesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.data_types\"\n\n    # @classmethod\n    # def create_from_type_items(\n    #     cls,\n    #     group_title: Union[str, None] = None,\n    #     **items: Type,\n    # ) -&gt; \"TypeInfoModelGroup\":\n    #\n    #     type_infos = {\n    #         k: cls.base_info_class().create_from_type_class(v) for k, v in items.items()  # type: ignore\n    #     }\n    #     data_types_info = cls.construct(group_alias=group_title, item_infos=type_infos)  # type: ignore\n    #     return data_types_info\n    #\n    # @classmethod\n    # def create_augmented_from_type_items(\n    #     cls,\n    #     kiara: Union[\"Kiara\", None] = None,\n    #     group_alias: Union[str, None] = None,\n    #     **items: Type,\n    # ) -&gt; \"TypeInfoModelGroup\":\n    #\n    #     type_infos = {\n    #         k: cls.base_info_class().create_from_type_class(v, kiara=kiara) for k, v in items.items()  # type: ignore\n    #     }\n    #     data_types_info = cls.construct(group_alias=group_alias, item_infos=type_infos)  # type: ignore\n    #     data_types_info._kiara = kiara\n    #     return data_types_info\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[DataTypeClassInfo]:\n        return DataTypeClassInfo\n\n    type_name: Literal[\"data_type\"] = \"data_type\"\n    item_infos: Mapping[str, DataTypeClassInfo] = Field(  # type: ignore\n        description=\"The data_type info instances for each type.\"\n    )\n    # _kiara: Union[\"Kiara\", None] = PrivateAttr(default=None)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        full_doc = config.get(\"full_doc\", False)\n        show_subtypes_inline = config.get(\"show_qualifier_profiles_inline\", True)\n        show_lineage = config.get(\"show_type_lineage\", True)\n\n        show_lines = full_doc or show_subtypes_inline or show_lineage\n\n        table = Table(show_header=True, box=box.SIMPLE, show_lines=show_lines)\n        table.add_column(\"type name\", style=\"i\")\n\n        if show_lineage:\n            table.add_column(\"type lineage\")\n\n        if show_subtypes_inline:\n            table.add_column(\"(qualifier) profiles\")\n\n        if full_doc:\n            table.add_column(\"documentation\")\n        else:\n            table.add_column(\"description\")\n\n        all_types = self.item_infos.keys()\n\n        for type_name in sorted(all_types):  # type: ignore\n\n            t_md = self.item_infos[type_name]  # type: ignore\n            row: List[Any] = [type_name]\n\n            if show_lineage:\n                if self._kiara is None:\n                    lineage_str = \"-- n/a --\"\n                else:\n                    lineage = list(\n                        self._kiara.type_registry.get_type_lineage(type_name)\n                    )\n                    lineage_str = \", \".join(reversed(lineage[1:]))\n                row.append(lineage_str)\n            if show_subtypes_inline:\n                if self._kiara is None:\n                    qual_profiles = \"-- n/a --\"\n                else:\n                    qual_p = self._kiara.type_registry.get_associated_profiles(\n                        data_type_name=type_name\n                    ).keys()\n                    if qual_p:\n                        qual_profiles = \"\\n\".join(qual_p)\n                    else:\n                        qual_profiles = \"-- n/a --\"\n                row.append(qual_profiles)\n\n            if full_doc:\n                md = Markdown(t_md.documentation.full_doc)\n            else:\n                md = Markdown(t_md.documentation.description)\n            row.append(md)\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo.type_name","title":"<code>type_name: Literal['data_type'] = 'data_type'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo.item_infos","title":"<code>item_infos: Mapping[str, DataTypeClassInfo] = Field(description='The data_type info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[DataTypeClassInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[DataTypeClassInfo]:\n    return DataTypeClassInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.DataTypeClassesInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    full_doc = config.get(\"full_doc\", False)\n    show_subtypes_inline = config.get(\"show_qualifier_profiles_inline\", True)\n    show_lineage = config.get(\"show_type_lineage\", True)\n\n    show_lines = full_doc or show_subtypes_inline or show_lineage\n\n    table = Table(show_header=True, box=box.SIMPLE, show_lines=show_lines)\n    table.add_column(\"type name\", style=\"i\")\n\n    if show_lineage:\n        table.add_column(\"type lineage\")\n\n    if show_subtypes_inline:\n        table.add_column(\"(qualifier) profiles\")\n\n    if full_doc:\n        table.add_column(\"documentation\")\n    else:\n        table.add_column(\"description\")\n\n    all_types = self.item_infos.keys()\n\n    for type_name in sorted(all_types):  # type: ignore\n\n        t_md = self.item_infos[type_name]  # type: ignore\n        row: List[Any] = [type_name]\n\n        if show_lineage:\n            if self._kiara is None:\n                lineage_str = \"-- n/a --\"\n            else:\n                lineage = list(\n                    self._kiara.type_registry.get_type_lineage(type_name)\n                )\n                lineage_str = \", \".join(reversed(lineage[1:]))\n            row.append(lineage_str)\n        if show_subtypes_inline:\n            if self._kiara is None:\n                qual_profiles = \"-- n/a --\"\n            else:\n                qual_p = self._kiara.type_registry.get_associated_profiles(\n                    data_type_name=type_name\n                ).keys()\n                if qual_p:\n                    qual_profiles = \"\\n\".join(qual_p)\n                else:\n                    qual_profiles = \"-- n/a --\"\n            row.append(qual_profiles)\n\n        if full_doc:\n            md = Markdown(t_md.documentation.full_doc)\n        else:\n            md = Markdown(t_md.documentation.description)\n        row.append(md)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo","title":"<code>ModuleTypeInfo</code>","text":"<p>         Bases: <code>TypeInfo[Type[KiaraModule]]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ModuleTypeInfo(TypeInfo[Type[\"KiaraModule\"]]):\n\n    _kiara_model_id = \"info.kiara_module_type\"\n\n    @classmethod\n    def create_from_type_class(cls, type_cls: Type[\"KiaraModule\"], kiara: \"Kiara\") -&gt; \"ModuleTypeInfo\":  # type: ignore\n\n        module_attrs = cls.extract_module_attributes(module_cls=type_cls)\n        return cls.construct(**module_attrs)\n\n    @classmethod\n    def base_class(self) -&gt; Type[\"KiaraModule\"]:\n\n        from kiara.modules import KiaraModule\n\n        return KiaraModule\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"module\"\n\n    @classmethod\n    def extract_module_attributes(\n        self, module_cls: Type[\"KiaraModule\"]\n    ) -&gt; Dict[str, Any]:\n\n        if not hasattr(module_cls, \"process\"):\n            raise Exception(f\"Module class '{module_cls}' misses 'process' method.\")\n\n        module_src = textwrap.dedent(inspect.getsource(module_cls))  # type: ignore\n\n        authors_md = AuthorsMetadataModel.from_class(module_cls)\n        doc = DocumentationMetadataModel.from_class_doc(module_cls)\n        python_class = PythonClass.from_class(module_cls)\n        properties_md = ContextMetadataModel.from_class(module_cls)\n        config = KiaraModuleConfigMetadata.from_config_class(module_cls._config_cls)\n\n        return {\n            \"type_name\": module_cls._module_type_name,  # type: ignore\n            \"documentation\": doc,\n            \"authors\": authors_md,\n            \"context\": properties_md,\n            \"python_class\": python_class,\n            \"config\": config,\n            \"module_src\": module_src,\n        }\n\n    module_src: str = Field(\n        description=\"The source code of the process method of the module.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_config_schema = config.get(\"include_config_schema\", True)\n        include_src = config.get(\"include_src\", True)\n        include_doc = config.get(\"include_doc\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        if include_config_schema:\n            config_cls = self.python_class.get_class()._config_cls  # type: ignore\n            from kiara.utils.output import create_table_from_base_model_cls\n\n            table.add_row(\n                \"Module config schema\", create_table_from_base_model_cls(config_cls)\n            )\n\n        table.add_row(\"Python class\", self.python_class.create_renderable())\n\n        if include_src:\n            from kiara.context.config import KIARA_SETTINGS\n\n            _config = Syntax(\n                self.module_src,\n                \"python\",\n                background_color=KIARA_SETTINGS.syntax_highlight_background,\n            )\n            table.add_row(\"Processing source code\", Panel(_config, box=box.HORIZONTALS))\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.module_src","title":"<code>module_src: str = Field(description='The source code of the process method of the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: Type[KiaraModule], kiara: Kiara) -&gt; ModuleTypeInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_type_class(cls, type_cls: Type[\"KiaraModule\"], kiara: \"Kiara\") -&gt; \"ModuleTypeInfo\":  # type: ignore\n\n    module_attrs = cls.extract_module_attributes(module_cls=type_cls)\n    return cls.construct(**module_attrs)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.base_class","title":"<code>base_class() -&gt; Type[KiaraModule]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_class(self) -&gt; Type[\"KiaraModule\"]:\n\n    from kiara.modules import KiaraModule\n\n    return KiaraModule\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"module\"\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.extract_module_attributes","title":"<code>extract_module_attributes(module_cls: Type[KiaraModule]) -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef extract_module_attributes(\n    self, module_cls: Type[\"KiaraModule\"]\n) -&gt; Dict[str, Any]:\n\n    if not hasattr(module_cls, \"process\"):\n        raise Exception(f\"Module class '{module_cls}' misses 'process' method.\")\n\n    module_src = textwrap.dedent(inspect.getsource(module_cls))  # type: ignore\n\n    authors_md = AuthorsMetadataModel.from_class(module_cls)\n    doc = DocumentationMetadataModel.from_class_doc(module_cls)\n    python_class = PythonClass.from_class(module_cls)\n    properties_md = ContextMetadataModel.from_class(module_cls)\n    config = KiaraModuleConfigMetadata.from_config_class(module_cls._config_cls)\n\n    return {\n        \"type_name\": module_cls._module_type_name,  # type: ignore\n        \"documentation\": doc,\n        \"authors\": authors_md,\n        \"context\": properties_md,\n        \"python_class\": python_class,\n        \"config\": config,\n        \"module_src\": module_src,\n    }\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypeInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_config_schema = config.get(\"include_config_schema\", True)\n    include_src = config.get(\"include_src\", True)\n    include_doc = config.get(\"include_doc\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    if include_config_schema:\n        config_cls = self.python_class.get_class()._config_cls  # type: ignore\n        from kiara.utils.output import create_table_from_base_model_cls\n\n        table.add_row(\n            \"Module config schema\", create_table_from_base_model_cls(config_cls)\n        )\n\n    table.add_row(\"Python class\", self.python_class.create_renderable())\n\n    if include_src:\n        from kiara.context.config import KIARA_SETTINGS\n\n        _config = Syntax(\n            self.module_src,\n            \"python\",\n            background_color=KIARA_SETTINGS.syntax_highlight_background,\n        )\n        table.add_row(\"Processing source code\", Panel(_config, box=box.HORIZONTALS))\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo","title":"<code>ModuleTypesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class ModuleTypesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.module_types\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[TypeInfo]:\n        return ModuleTypeInfo\n\n    type_name: Literal[\"module_type\"] = \"module_type\"\n    item_infos: Mapping[str, ModuleTypeInfo] = Field(  # type: ignore\n        description=\"The module type info instances for each type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo.type_name","title":"<code>type_name: Literal['module_type'] = 'module_type'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo.item_infos","title":"<code>item_infos: Mapping[str, ModuleTypeInfo] = Field(description='The module type info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.ModuleTypesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[TypeInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[TypeInfo]:\n    return ModuleTypeInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeInfo","title":"<code>OperationTypeInfo</code>","text":"<p>         Bases: <code>TypeInfo[Type[OperationType]]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class OperationTypeInfo(TypeInfo[Type[\"OperationType\"]]):\n\n    _kiara_model_id = \"info.operation_type\"\n\n    @classmethod\n    def create_from_type_class(  # type: ignore\n        cls, kiara: \"Kiara\", type_cls: Type[\"OperationType\"]  # type: ignore\n    ) -&gt; \"OperationTypeInfo\":\n\n        authors_md = AuthorsMetadataModel.from_class(type_cls)\n        doc = DocumentationMetadataModel.from_class_doc(type_cls)\n        python_class = PythonClass.from_class(type_cls)\n        properties_md = ContextMetadataModel.from_class(type_cls)\n\n        return OperationTypeInfo.construct(\n            type_name=type_cls._operation_type_name,  # type: ignore\n            documentation=doc,\n            authors=authors_md,\n            context=properties_md,\n            python_class=python_class,\n        )\n\n    @classmethod\n    def base_class(self) -&gt; Type[\"OperationType\"]:\n        from kiara.operations import OperationType\n\n        return OperationType\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"operation_type\"\n\n    def _retrieve_id(self) -&gt; str:\n        return self.type_name\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.type_name\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeInfo.create_from_type_class","title":"<code>create_from_type_class(kiara: Kiara, type_cls: Type[OperationType]) -&gt; OperationTypeInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_type_class(  # type: ignore\n    cls, kiara: \"Kiara\", type_cls: Type[\"OperationType\"]  # type: ignore\n) -&gt; \"OperationTypeInfo\":\n\n    authors_md = AuthorsMetadataModel.from_class(type_cls)\n    doc = DocumentationMetadataModel.from_class_doc(type_cls)\n    python_class = PythonClass.from_class(type_cls)\n    properties_md = ContextMetadataModel.from_class(type_cls)\n\n    return OperationTypeInfo.construct(\n        type_name=type_cls._operation_type_name,  # type: ignore\n        documentation=doc,\n        authors=authors_md,\n        context=properties_md,\n        python_class=python_class,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeInfo.base_class","title":"<code>base_class() -&gt; Type[OperationType]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_class(self) -&gt; Type[\"OperationType\"]:\n    from kiara.operations import OperationType\n\n    return OperationType\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"operation_type\"\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo","title":"<code>OperationTypeClassesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class OperationTypeClassesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.operation_types\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[OperationTypeInfo]:  # type: ignore\n        return OperationTypeInfo\n\n    type_name: Literal[\"operation_type\"] = \"operation_type\"\n    item_infos: Mapping[str, OperationTypeInfo] = Field(  # type: ignore\n        description=\"The operation info instances for each type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo.type_name","title":"<code>type_name: Literal['operation_type'] = 'operation_type'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo.item_infos","title":"<code>item_infos: Mapping[str, OperationTypeInfo] = Field(description='The operation info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationTypeClassesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[OperationTypeInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[OperationTypeInfo]:  # type: ignore\n    return OperationTypeInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo","title":"<code>FieldInfo</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class FieldInfo(BaseModel):\n\n    field_name: str = Field(description=\"The field name.\")\n    field_schema: ValueSchema = Field(description=\"The schema of the field.\")\n    data_type_info: DataTypeInfo = Field(\n        description=\"Information about the data type instance of the associated value.\"\n    )\n    value_required: bool = Field(\n        description=\"Whether user input is required (meaning: 'optional' is False, and no default set).\"\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo.field_name","title":"<code>field_name: str = Field(description='The field name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo.field_schema","title":"<code>field_schema: ValueSchema = Field(description='The schema of the field.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo.data_type_info","title":"<code>data_type_info: DataTypeInfo = Field(description='Information about the data type instance of the associated value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.FieldInfo.value_required","title":"<code>value_required: bool = Field(description=\"Whether user input is required (meaning: 'optional' is False, and no default set).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo","title":"<code>PipelineStructureInfo</code>","text":"<p>         Bases: <code>ItemInfo</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class PipelineStructureInfo(ItemInfo):\n\n    _kiara_model_id = \"info.pipeline_structure\"\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[PipelineStructure]:\n        return PipelineStructure\n\n    @classmethod\n    def create_from_instance(\n        cls, kiara: \"Kiara\", instance: PipelineStructure, **kwargs\n    ):\n\n        authors = AuthorsMetadataModel()\n        context = ContextMetadataModel()\n\n        execution_graph: Dict[str, Any] = {}\n        data_flow_graph: Dict[str, Any] = {}\n        data_flow_graph_simple: Dict[str, Any] = {}\n\n        input_fields = {}\n        for field_name, schema in instance.pipeline_inputs_schema.items():\n            dt = kiara.type_registry.get_data_type_instance(\n                type_name=schema.type, type_config=schema.type_config\n            )\n            dt_info = FieldInfo.construct(\n                field_name=field_name,\n                field_schema=schema,\n                data_type_info=dt.info,\n                value_required=schema.is_required(),\n            )\n            input_fields[field_name] = dt_info\n\n        output_fields = {}\n        for field_name, schema in instance.pipeline_outputs_schema.items():\n            dt = kiara.type_registry.get_data_type_instance(\n                type_name=schema.type, type_config=schema.type_config\n            )\n            dt_info = FieldInfo.construct(\n                field_name=field_name,\n                field_schema=schema,\n                data_type_info=dt.info,\n                value_required=schema.is_required(),\n            )\n            output_fields[field_name] = dt_info\n\n        return cls(\n            type_name=instance.instance_id,\n            documentation=instance.pipeline_config.doc,\n            authors=authors,\n            context=context,\n            pipeline_config=instance.pipeline_config,\n            steps={step.step_id: step for step in instance.steps},\n            step_details=instance.steps_details,\n            input_aliases=instance.input_aliases,\n            output_aliases=instance.output_aliases,\n            constants=instance.constants,\n            defaults=instance.defaults,\n            pipeline_input_fields=input_fields,\n            pipeline_output_fields=output_fields,\n            pipeline_input_refs=instance.pipeline_input_refs,\n            pipeline_output_refs=instance.pipeline_output_refs,\n            execution_graph=execution_graph,\n            data_flow_graph=data_flow_graph,\n            data_flow_graph_simple=data_flow_graph_simple,\n            processing_stages=instance.processing_stages,\n            # processing_stages_info=instance.processing_stages_info,\n        )\n\n    pipeline_config: PipelineConfig = Field(\n        description=\"The underlying pipeline config.\"\n    )\n    steps: Mapping[str, PipelineStep] = Field(\n        description=\"All steps for this pipeline, indexed by their step_id.\"\n    )\n    step_details: Mapping[str, StepInfo] = Field(\n        description=\"Additional information for each step.\"\n    )\n    input_aliases: Dict[str, str] = Field(description=\"The input aliases.\")\n    output_aliases: Dict[str, str] = Field(description=\"The output aliases.\")\n    constants: Mapping[str, Any] = Field(\n        description=\"The input constants for this pipeline.\"\n    )\n    defaults: Mapping[str, Any] = Field(\n        description=\"The default inputs for this pipeline.\"\n    )\n\n    pipeline_input_fields: Mapping[str, FieldInfo] = Field(\n        description=\"The pipeline inputs schema.\"\n    )\n    pipeline_output_fields: Mapping[str, FieldInfo] = Field(\n        description=\"The pipeline outputs schema.\"\n    )\n\n    pipeline_input_refs: Mapping[str, PipelineInputRef] = Field(\n        description=\"References to the step inputs that are linked to pipeline inputs.\"\n    )\n    pipeline_output_refs: Mapping[str, PipelineOutputRef] = Field(\n        description=\"References to the step outputs that are linked to pipeline outputs.\"\n    )\n\n    execution_graph: Dict[str, Any] = Field(\n        description=\"Data describing the execution graph of this pipeline.\"\n    )\n    data_flow_graph: Dict[str, Any] = Field(\n        description=\"Data describing the data flow of this pipeline.\"\n    )\n    data_flow_graph_simple: Dict[str, Any] = Field(\n        description=\"Data describing the (simplified) data flow of this pipeline.\"\n    )\n\n    processing_stages: List[List[str]] = Field(\n        description=\"A list of lists, containing all the step_ids per stage, in the order of execution.\"\n    )\n    # processing_stages_info: Mapping[int, PipelineStage] = Field(\n    #     description=\"More detailed information about each step of this pipelines execution graph.\"\n    # )\n\n    def get_step(self, step_id) -&gt; PipelineStep:\n        return self.steps[step_id]\n\n    def get_step_details(self, step_id: str) -&gt; StepInfo:\n        return self.step_details[step_id]\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        tree = Tree(\"pipeline\")\n        inputs = tree.add(\"inputs\")\n        for field_name, field_info in self.pipeline_input_fields.items():\n            inputs.add(f\"[i]{field_name}[i] (type: {field_info.field_schema.type})\")\n\n        steps = tree.add(\"steps\")\n        for idx, stage in enumerate(self.processing_stages, start=1):\n            stage_node = steps.add(f\"stage {idx}\")\n            for step_id in stage:\n                step_node = stage_node.add(f\"step: {step_id}\")\n                step = self.get_step(step_id=step_id)\n                if step.doc.is_set:\n                    step_node.add(f\"desc: {step.doc.description}\")\n                step_node.add(f\"module: {step.manifest_src.module_type}\")\n\n        outputs = tree.add(\"outputs\")\n        for field_name, field_info in self.pipeline_output_fields.items():\n            outputs.add(f\"[i]{field_name}[i] (type: {field_info.field_schema.type})\")\n\n        return tree\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.pipeline_config","title":"<code>pipeline_config: PipelineConfig = Field(description='The underlying pipeline config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.steps","title":"<code>steps: Mapping[str, PipelineStep] = Field(description='All steps for this pipeline, indexed by their step_id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.step_details","title":"<code>step_details: Mapping[str, StepInfo] = Field(description='Additional information for each step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.input_aliases","title":"<code>input_aliases: Dict[str, str] = Field(description='The input aliases.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.output_aliases","title":"<code>output_aliases: Dict[str, str] = Field(description='The output aliases.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.constants","title":"<code>constants: Mapping[str, Any] = Field(description='The input constants for this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.defaults","title":"<code>defaults: Mapping[str, Any] = Field(description='The default inputs for this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.pipeline_input_fields","title":"<code>pipeline_input_fields: Mapping[str, FieldInfo] = Field(description='The pipeline inputs schema.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.pipeline_output_fields","title":"<code>pipeline_output_fields: Mapping[str, FieldInfo] = Field(description='The pipeline outputs schema.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.pipeline_input_refs","title":"<code>pipeline_input_refs: Mapping[str, PipelineInputRef] = Field(description='References to the step inputs that are linked to pipeline inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.pipeline_output_refs","title":"<code>pipeline_output_refs: Mapping[str, PipelineOutputRef] = Field(description='References to the step outputs that are linked to pipeline outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.execution_graph","title":"<code>execution_graph: Dict[str, Any] = Field(description='Data describing the execution graph of this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.data_flow_graph","title":"<code>data_flow_graph: Dict[str, Any] = Field(description='Data describing the data flow of this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.data_flow_graph_simple","title":"<code>data_flow_graph_simple: Dict[str, Any] = Field(description='Data describing the (simplified) data flow of this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.processing_stages","title":"<code>processing_stages: List[List[str]] = Field(description='A list of lists, containing all the step_ids per stage, in the order of execution.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[PipelineStructure]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[PipelineStructure]:\n    return PipelineStructure\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: PipelineStructure, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instance(\n    cls, kiara: \"Kiara\", instance: PipelineStructure, **kwargs\n):\n\n    authors = AuthorsMetadataModel()\n    context = ContextMetadataModel()\n\n    execution_graph: Dict[str, Any] = {}\n    data_flow_graph: Dict[str, Any] = {}\n    data_flow_graph_simple: Dict[str, Any] = {}\n\n    input_fields = {}\n    for field_name, schema in instance.pipeline_inputs_schema.items():\n        dt = kiara.type_registry.get_data_type_instance(\n            type_name=schema.type, type_config=schema.type_config\n        )\n        dt_info = FieldInfo.construct(\n            field_name=field_name,\n            field_schema=schema,\n            data_type_info=dt.info,\n            value_required=schema.is_required(),\n        )\n        input_fields[field_name] = dt_info\n\n    output_fields = {}\n    for field_name, schema in instance.pipeline_outputs_schema.items():\n        dt = kiara.type_registry.get_data_type_instance(\n            type_name=schema.type, type_config=schema.type_config\n        )\n        dt_info = FieldInfo.construct(\n            field_name=field_name,\n            field_schema=schema,\n            data_type_info=dt.info,\n            value_required=schema.is_required(),\n        )\n        output_fields[field_name] = dt_info\n\n    return cls(\n        type_name=instance.instance_id,\n        documentation=instance.pipeline_config.doc,\n        authors=authors,\n        context=context,\n        pipeline_config=instance.pipeline_config,\n        steps={step.step_id: step for step in instance.steps},\n        step_details=instance.steps_details,\n        input_aliases=instance.input_aliases,\n        output_aliases=instance.output_aliases,\n        constants=instance.constants,\n        defaults=instance.defaults,\n        pipeline_input_fields=input_fields,\n        pipeline_output_fields=output_fields,\n        pipeline_input_refs=instance.pipeline_input_refs,\n        pipeline_output_refs=instance.pipeline_output_refs,\n        execution_graph=execution_graph,\n        data_flow_graph=data_flow_graph,\n        data_flow_graph_simple=data_flow_graph_simple,\n        processing_stages=instance.processing_stages,\n        # processing_stages_info=instance.processing_stages_info,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.get_step","title":"<code>get_step(step_id) -&gt; PipelineStep</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def get_step(self, step_id) -&gt; PipelineStep:\n    return self.steps[step_id]\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.get_step_details","title":"<code>get_step_details(step_id: str) -&gt; StepInfo</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def get_step_details(self, step_id: str) -&gt; StepInfo:\n    return self.step_details[step_id]\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.PipelineStructureInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    tree = Tree(\"pipeline\")\n    inputs = tree.add(\"inputs\")\n    for field_name, field_info in self.pipeline_input_fields.items():\n        inputs.add(f\"[i]{field_name}[i] (type: {field_info.field_schema.type})\")\n\n    steps = tree.add(\"steps\")\n    for idx, stage in enumerate(self.processing_stages, start=1):\n        stage_node = steps.add(f\"stage {idx}\")\n        for step_id in stage:\n            step_node = stage_node.add(f\"step: {step_id}\")\n            step = self.get_step(step_id=step_id)\n            if step.doc.is_set:\n                step_node.add(f\"desc: {step.doc.description}\")\n            step_node.add(f\"module: {step.manifest_src.module_type}\")\n\n    outputs = tree.add(\"outputs\")\n    for field_name, field_info in self.pipeline_output_fields.items():\n        outputs.add(f\"[i]{field_name}[i] (type: {field_info.field_schema.type})\")\n\n    return tree\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo","title":"<code>OperationInfo</code>","text":"<p>         Bases: <code>ItemInfo</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class OperationInfo(ItemInfo):\n\n    _kiara_model_id = \"info.operation\"\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[Operation]:\n        return Operation\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: Operation, **kwargs):\n\n        return cls.create_from_operation(kiara=kiara, operation=instance)\n\n    @classmethod\n    def create_from_operation(cls, kiara: \"Kiara\", operation: Operation):\n\n        module = operation.module\n        module_cls = module.__class__\n\n        authors_md = AuthorsMetadataModel.from_class(module_cls)\n        properties_md = ContextMetadataModel.from_class(module_cls)\n\n        op_types = kiara.operation_registry.find_all_operation_types(\n            operation_id=operation.operation_id\n        )\n\n        input_fields = {}\n        for field_name, schema in operation.inputs_schema.items():\n            dt = kiara.type_registry.get_data_type_instance(\n                type_name=schema.type, type_config=schema.type_config\n            )\n            dt_info = FieldInfo.construct(\n                field_name=field_name,\n                field_schema=schema,\n                data_type_info=dt.info,\n                value_required=schema.is_required(),\n            )\n            input_fields[field_name] = dt_info\n\n        output_fields = {}\n        for field_name, schema in operation.outputs_schema.items():\n            dt = kiara.type_registry.get_data_type_instance(\n                type_name=schema.type, type_config=schema.type_config\n            )\n            dt_info = FieldInfo.construct(\n                field_name=field_name,\n                field_schema=schema,\n                data_type_info=dt.info,\n                value_required=schema.is_required(),\n            )\n            output_fields[field_name] = dt_info\n\n        op_info = OperationInfo.construct(\n            type_name=operation.operation_id,\n            operation_types=list(op_types),\n            input_fields=input_fields,\n            output_fields=output_fields,\n            operation=operation,\n            documentation=operation.doc,\n            authors=authors_md,\n            context=properties_md,\n        )\n\n        return op_info\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"operation\"\n\n    operation: Operation = Field(description=\"The operation instance.\")\n    operation_types: List[str] = Field(\n        description=\"The operation types this operation belongs to.\"\n    )\n    input_fields: Mapping[str, FieldInfo] = Field(\n        description=\"The inputs schema for this operation.\"\n    )\n    output_fields: Mapping[str, FieldInfo] = Field(\n        description=\"The outputs schema for this operation.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", False)\n        include_op_details = config.get(\"include_op_details\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n        table.add_row(\"Context\", self.context.create_renderable(**config))\n\n        if include_op_details:\n            table.add_row(\n                \"Operation details\", self.operation.create_renderable(**config)\n            )\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.operation","title":"<code>operation: Operation = Field(description='The operation instance.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.operation_types","title":"<code>operation_types: List[str] = Field(description='The operation types this operation belongs to.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.input_fields","title":"<code>input_fields: Mapping[str, FieldInfo] = Field(description='The inputs schema for this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.output_fields","title":"<code>output_fields: Mapping[str, FieldInfo] = Field(description='The outputs schema for this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[Operation]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[Operation]:\n    return Operation\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: Operation, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: Operation, **kwargs):\n\n    return cls.create_from_operation(kiara=kiara, operation=instance)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.create_from_operation","title":"<code>create_from_operation(kiara: Kiara, operation: Operation)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_operation(cls, kiara: \"Kiara\", operation: Operation):\n\n    module = operation.module\n    module_cls = module.__class__\n\n    authors_md = AuthorsMetadataModel.from_class(module_cls)\n    properties_md = ContextMetadataModel.from_class(module_cls)\n\n    op_types = kiara.operation_registry.find_all_operation_types(\n        operation_id=operation.operation_id\n    )\n\n    input_fields = {}\n    for field_name, schema in operation.inputs_schema.items():\n        dt = kiara.type_registry.get_data_type_instance(\n            type_name=schema.type, type_config=schema.type_config\n        )\n        dt_info = FieldInfo.construct(\n            field_name=field_name,\n            field_schema=schema,\n            data_type_info=dt.info,\n            value_required=schema.is_required(),\n        )\n        input_fields[field_name] = dt_info\n\n    output_fields = {}\n    for field_name, schema in operation.outputs_schema.items():\n        dt = kiara.type_registry.get_data_type_instance(\n            type_name=schema.type, type_config=schema.type_config\n        )\n        dt_info = FieldInfo.construct(\n            field_name=field_name,\n            field_schema=schema,\n            data_type_info=dt.info,\n            value_required=schema.is_required(),\n        )\n        output_fields[field_name] = dt_info\n\n    op_info = OperationInfo.construct(\n        type_name=operation.operation_id,\n        operation_types=list(op_types),\n        input_fields=input_fields,\n        output_fields=output_fields,\n        operation=operation,\n        documentation=operation.doc,\n        authors=authors_md,\n        context=properties_md,\n    )\n\n    return op_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"operation\"\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", False)\n    include_op_details = config.get(\"include_op_details\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n    table.add_row(\"Context\", self.context.create_renderable(**config))\n\n    if include_op_details:\n        table.add_row(\n            \"Operation details\", self.operation.create_renderable(**config)\n        )\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo","title":"<code>OperationGroupInfo</code>","text":"<p>         Bases: <code>InfoItemGroup</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class OperationGroupInfo(InfoItemGroup):\n\n    _kiara_model_id = \"info.operations\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[ItemInfo]:\n        return OperationInfo\n\n    @classmethod\n    def create_from_operations(\n        cls, kiara: \"Kiara\", group_title: Union[str, None] = None, **items: Operation\n    ) -&gt; \"OperationGroupInfo\":\n\n        op_infos = {\n            k: OperationInfo.create_from_operation(kiara=kiara, operation=v)\n            for k, v in items.items()\n        }\n\n        op_group_info = cls.construct(group_title=group_title, item_infos=op_infos)\n        return op_group_info\n\n    # type_name: Literal[\"operation_type\"] = \"operation_type\"\n    item_infos: Mapping[str, OperationInfo] = Field(\n        description=\"The operation info instances for each type.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        by_type = config.get(\"by_type\", False)\n\n        if by_type:\n            return self._create_renderable_by_type(**config)\n        else:\n            return self._create_renderable_list(**config)\n\n    def _create_renderable_list(self, **config):\n\n        include_internal_operations = config.get(\"include_internal_operations\", True)\n        full_doc = config.get(\"full_doc\", False)\n        filter = config.get(\"filter\", [])\n\n        table = Table(box=box.SIMPLE, show_header=True)\n        table.add_column(\"Id\", no_wrap=True, style=\"i\")\n        table.add_column(\"Type(s)\", style=\"green\")\n        table.add_column(\"Description\")\n\n        for op_id, op_info in self.item_infos.items():\n\n            if (\n                not include_internal_operations\n                and op_info.operation.operation_details.is_internal_operation\n            ):\n                continue\n\n            types = op_info.operation_types\n\n            if \"custom_module\" in types:\n                types.remove(\"custom_module\")\n\n            desc_str = op_info.documentation.description\n            if full_doc:\n                desc = Markdown(op_info.documentation.full_doc)\n            else:\n                desc = Markdown(op_info.documentation.description)\n\n            if filter:\n                match = True\n                for f in filter:\n                    if (\n                        f.lower() not in op_id.lower()\n                        and f.lower() not in desc_str.lower()\n                    ):\n                        match = False\n                        break\n                if match:\n                    table.add_row(op_id, \", \".join(types), desc)\n\n            else:\n                table.add_row(op_id, \", \".join(types), desc)\n\n        return table\n\n    def _create_renderable_by_type(self, **config) -&gt; Table:\n\n        include_internal_operations = config.get(\"include_internal_operations\", True)\n        full_doc = config.get(\"full_doc\", False)\n        filter = config.get(\"filter\", [])\n\n        by_type: Dict[str, Dict[str, OperationInfo]] = {}\n        for op_id, op in self.item_infos.items():\n            if filter:\n                match = True\n                for f in filter:\n                    if (\n                        f.lower() not in op_id.lower()\n                        and f.lower() not in op.documentation.description.lower()\n                    ):\n                        match = False\n                        break\n                if not match:\n                    continue\n            for op_type in op.operation_types:\n                by_type.setdefault(op_type, {})[op_id] = op\n\n        table = Table(box=box.SIMPLE, show_header=True)\n        table.add_column(\"Type\", no_wrap=True, style=\"b green\")\n        table.add_column(\"Id\", no_wrap=True, style=\"i\")\n        if full_doc:\n            table.add_column(\"Documentation\", no_wrap=False, style=\"i\")\n        else:\n            table.add_column(\"Description\", no_wrap=False, style=\"i\")\n\n        for operation_name in sorted(by_type.keys()):\n\n            # if operation_name == \"custom_module\":\n            #     continue\n\n            first_line_value = True\n            op_infos = by_type[operation_name]\n\n            for op_id in sorted(op_infos.keys()):\n                op_info: OperationInfo = op_infos[op_id]\n\n                if (\n                    not include_internal_operations\n                    and op_info.operation.operation_details.is_internal_operation\n                ):\n                    continue\n\n                if full_doc:\n                    desc = Markdown(op_info.documentation.full_doc)\n                else:\n                    desc = Markdown(op_info.documentation.description)\n\n                row: List[RenderableType] = []\n                if first_line_value:\n                    row.append(operation_name)\n                else:\n                    row.append(\"\")\n\n                row.append(op_id)\n                row.append(desc)\n\n                table.add_row(*row)\n                first_line_value = False\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo.item_infos","title":"<code>item_infos: Mapping[str, OperationInfo] = Field(description='The operation info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[ItemInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[ItemInfo]:\n    return OperationInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo.create_from_operations","title":"<code>create_from_operations(kiara: Kiara, group_title: Union[str, None] = None, **items: Operation) -&gt; OperationGroupInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_operations(\n    cls, kiara: \"Kiara\", group_title: Union[str, None] = None, **items: Operation\n) -&gt; \"OperationGroupInfo\":\n\n    op_infos = {\n        k: OperationInfo.create_from_operation(kiara=kiara, operation=v)\n        for k, v in items.items()\n    }\n\n    op_group_info = cls.construct(group_title=group_title, item_infos=op_infos)\n    return op_group_info\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.OperationGroupInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    by_type = config.get(\"by_type\", False)\n\n    if by_type:\n        return self._create_renderable_by_type(**config)\n    else:\n        return self._create_renderable_list(**config)\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo","title":"<code>RendererInfo</code>","text":"<p>         Bases: <code>ItemInfo[KiaraRenderer]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class RendererInfo(ItemInfo[KiaraRenderer]):\n\n    renderer_config: Mapping[str, Any] = Field(description=\"The renderer config.\")\n    renderer_cls: PythonClass = Field(\n        description=\"The Python class that implements the renderer.\"\n    )\n    supported_inputs: List[str] = Field(\n        description=\"Descriptions of the supported inputs.\"\n    )\n    supported_source_types: List[str] = Field(\n        description=\"Descriptions of the supported source types.\"\n    )\n    supported_target_types: List[str] = Field(\n        description=\"Descriptions of the supported target types.\"\n    )\n    supported_python_classes: List[PythonClass] = Field(\n        description=\"A list of supported Python types that are acceptable as inputs.\"\n    )\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[KiaraRenderer]:\n        return KiaraRenderer\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: KiaraRenderer, **kwargs):\n\n        doc = instance.doc\n        authors = AuthorsMetadataModel.from_class(instance.__class__)\n        properties_md = ContextMetadataModel.from_class(instance.__class__)\n\n        renderer_name = instance._renderer_name  # type: ignore\n        renderer_config = instance.renderer_config.dict()\n        renderer_cls = PythonClass.from_class(item_cls=instance.__class__)\n        supported_inputs = list(instance.supported_inputs_descs)\n        supported_python_classes = [\n            PythonClass.from_class(x)\n            for x in instance.retrieve_supported_python_classes()\n        ]\n\n        supported_input_types = instance.retrieve_supported_render_sources()\n        if isinstance(supported_input_types, str):\n            supported_input_types = [supported_input_types]\n        supported_target_types = instance.retrieve_supported_render_targets()\n        if isinstance(supported_target_types, str):\n            supported_target_types = [supported_target_types]\n\n        return cls(\n            type_name=renderer_name,\n            documentation=doc,\n            authors=authors,\n            context=properties_md,\n            renderer_config=renderer_config,\n            renderer_cls=renderer_cls,\n            supported_inputs=supported_inputs,\n            supported_python_classes=supported_python_classes,\n            supported_source_types=supported_input_types,\n            supported_target_types=supported_target_types,\n        )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        show_metadata = config.get(\"show_metadata\", False)\n\n        table = Table(box=box.SIMPLE, show_header=False)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        table.add_row(\"Documentation\", self.documentation.create_renderable(**config))\n        inputs_md = \"\"\n        for inp in self.supported_inputs:\n            inputs_md += f\"- {inp}\\n\"\n        table.add_row(\"Supported inputs\", Markdown(inputs_md))\n\n        if show_metadata:\n            table.add_row(\"Renderer name\", self.type_name)\n            if self.renderer_config:\n                json = orjson_dumps(self.renderer_config, option=orjson.OPT_INDENT_2)\n                table.add_row(\n                    \"Renderer config\", Syntax(json, \"json\", background_color=\"default\")\n                )\n\n            table.add_row(\n                \"Renderer class\", self.renderer_cls.create_renderable(**config)\n            )\n            table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n            table.add_row(\"Context\", self.context.create_renderable(**config))\n\n        python_cls_md = \"\"\n        for inp_cls in self.supported_python_classes:\n            python_cls_md += f\"- {inp_cls.full_name}\\n\"\n        table.add_row(python_cls_md)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.renderer_config","title":"<code>renderer_config: Mapping[str, Any] = Field(description='The renderer config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.renderer_cls","title":"<code>renderer_cls: PythonClass = Field(description='The Python class that implements the renderer.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.supported_inputs","title":"<code>supported_inputs: List[str] = Field(description='Descriptions of the supported inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.supported_source_types","title":"<code>supported_source_types: List[str] = Field(description='Descriptions of the supported source types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.supported_target_types","title":"<code>supported_target_types: List[str] = Field(description='Descriptions of the supported target types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.supported_python_classes","title":"<code>supported_python_classes: List[PythonClass] = Field(description='A list of supported Python types that are acceptable as inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[KiaraRenderer]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[KiaraRenderer]:\n    return KiaraRenderer\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: KiaraRenderer, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: KiaraRenderer, **kwargs):\n\n    doc = instance.doc\n    authors = AuthorsMetadataModel.from_class(instance.__class__)\n    properties_md = ContextMetadataModel.from_class(instance.__class__)\n\n    renderer_name = instance._renderer_name  # type: ignore\n    renderer_config = instance.renderer_config.dict()\n    renderer_cls = PythonClass.from_class(item_cls=instance.__class__)\n    supported_inputs = list(instance.supported_inputs_descs)\n    supported_python_classes = [\n        PythonClass.from_class(x)\n        for x in instance.retrieve_supported_python_classes()\n    ]\n\n    supported_input_types = instance.retrieve_supported_render_sources()\n    if isinstance(supported_input_types, str):\n        supported_input_types = [supported_input_types]\n    supported_target_types = instance.retrieve_supported_render_targets()\n    if isinstance(supported_target_types, str):\n        supported_target_types = [supported_target_types]\n\n    return cls(\n        type_name=renderer_name,\n        documentation=doc,\n        authors=authors,\n        context=properties_md,\n        renderer_config=renderer_config,\n        renderer_cls=renderer_cls,\n        supported_inputs=supported_inputs,\n        supported_python_classes=supported_python_classes,\n        supported_source_types=supported_input_types,\n        supported_target_types=supported_target_types,\n    )\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    show_metadata = config.get(\"show_metadata\", False)\n\n    table = Table(box=box.SIMPLE, show_header=False)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"Documentation\", self.documentation.create_renderable(**config))\n    inputs_md = \"\"\n    for inp in self.supported_inputs:\n        inputs_md += f\"- {inp}\\n\"\n    table.add_row(\"Supported inputs\", Markdown(inputs_md))\n\n    if show_metadata:\n        table.add_row(\"Renderer name\", self.type_name)\n        if self.renderer_config:\n            json = orjson_dumps(self.renderer_config, option=orjson.OPT_INDENT_2)\n            table.add_row(\n                \"Renderer config\", Syntax(json, \"json\", background_color=\"default\")\n            )\n\n        table.add_row(\n            \"Renderer class\", self.renderer_cls.create_renderable(**config)\n        )\n        table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n        table.add_row(\"Context\", self.context.create_renderable(**config))\n\n    python_cls_md = \"\"\n    for inp_cls in self.supported_python_classes:\n        python_cls_md += f\"- {inp_cls.full_name}\\n\"\n    table.add_row(python_cls_md)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfos","title":"<code>RendererInfos</code>","text":"<p>         Bases: <code>InfoItemGroup[RendererInfo]</code></p> Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>class RendererInfos(InfoItemGroup[RendererInfo]):\n    @classmethod\n    def base_info_class(cls) -&gt; Type[RendererInfo]:\n        return RendererInfo\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=True, box=box.SIMPLE, show_lines=True)\n        table.add_column(\"Source type(s)\")\n        table.add_column(\"Target type(s)\")\n        table.add_column(\"Description\")\n\n        for info in self.item_infos.values():\n            row: List[RenderableType] = []\n\n            row.append(\"\\n\".join(info.supported_source_types))  # type: ignore\n            row.append(\"\\n\".join(info.supported_target_types))  # type: ignore\n            row.append(info.documentation.create_renderable(**config))\n\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfos-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfos.base_info_class","title":"<code>base_info_class() -&gt; Type[RendererInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[RendererInfo]:\n    return RendererInfo\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.RendererInfos.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=True, box=box.SIMPLE, show_lines=True)\n    table.add_column(\"Source type(s)\")\n    table.add_column(\"Target type(s)\")\n    table.add_column(\"Description\")\n\n    for info in self.item_infos.values():\n        row: List[RenderableType] = []\n\n        row.append(\"\\n\".join(info.supported_source_types))  # type: ignore\n        row.append(\"\\n\".join(info.supported_target_types))  # type: ignore\n        row.append(info.documentation.create_renderable(**config))\n\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/info/#kiara.interfaces.python_api.models.info.pretty_print_value_data_terminal","title":"<code>pretty_print_value_data_terminal(value: ValueInfo)</code>","text":"Source code in <code>kiara/interfaces/python_api/models/info.py</code> <pre><code>def pretty_print_value_data_terminal(value: \"ValueInfo\"):\n\n    try:\n        renderable = value._value._data_registry.pretty_print_data(\n            value.value_id, target_type=\"terminal_renderable\"\n        )\n    except Exception as e:\n        log_exception(e)\n        log_message(\"error.pretty_print\", value=value.value_id, error=e)\n        renderable = [str(value._value.data)]\n\n    return renderable\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/job/","title":"job","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc","title":"<code>JobDesc</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>An object describing a compute job with both raw or referenced inputs.</p> Source code in <code>kiara/interfaces/python_api/models/job.py</code> <pre><code>class JobDesc(BaseModel):\n\"\"\"An object describing a compute job with both raw or referenced inputs.\"\"\"\n\n    module_type: str = Field(description=\"The module type.\")\n    module_config: Dict[str, Any] = Field(\n        default_factory=dict, description=\"The configuration for the module.\"\n    )\n    inputs: Dict[str, Any] = Field(description=\"The inputs for the job.\")\n\n    def create_job_config(self, kiara: Kiara) -&gt; JobConfig:\n\n        manifest = Manifest(\n            module_type=self.module_type, module_config=self.module_config\n        )\n        module = kiara.module_registry.create_module(manifest=manifest)\n        job_config = JobConfig.create_from_module(\n            data_registry=kiara.data_registry, module=module, inputs=self.inputs\n        )\n        return job_config\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc.module_type","title":"<code>module_type: str = Field(description='The module type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc.module_config","title":"<code>module_config: Dict[str, Any] = Field(default_factory=dict, description='The configuration for the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc.inputs","title":"<code>inputs: Dict[str, Any] = Field(description='The inputs for the job.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/job/#kiara.interfaces.python_api.models.job.JobDesc.create_job_config","title":"<code>create_job_config(kiara: Kiara) -&gt; JobConfig</code>","text":"Source code in <code>kiara/interfaces/python_api/models/job.py</code> <pre><code>def create_job_config(self, kiara: Kiara) -&gt; JobConfig:\n\n    manifest = Manifest(\n        module_type=self.module_type, module_config=self.module_config\n    )\n    module = kiara.module_registry.create_module(manifest=manifest)\n    job_config = JobConfig.create_from_module(\n        data_registry=kiara.data_registry, module=module, inputs=self.inputs\n    )\n    return job_config\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/workflow/","title":"workflow","text":""},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher","title":"<code>WorkflowMatcher</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>An object describing requirements values should satisfy in order to be included in a query result.</p> Source code in <code>kiara/interfaces/python_api/models/workflow.py</code> <pre><code>class WorkflowMatcher(KiaraModel):\n\"\"\"An object describing requirements values should satisfy in order to be included in a query result.\"\"\"\n\n    @classmethod\n    def create_matcher(self, **match_options: Any):\n\n        m = WorkflowMatcher(**match_options)\n        return m\n\n    has_alias: bool = Field(\n        description=\"Workflow must have at least one alias.\", default=False\n    )\n\n    def is_match(self, workflow_id: uuid.UUID, kiara: \"Kiara\") -&gt; bool:\n\n        if self.has_alias:\n            aliases = kiara.workflow_registry.get_aliases(workflow_id=workflow_id)\n            if not aliases:\n                return False\n\n        return True\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher.has_alias","title":"<code>has_alias: bool = Field(description='Workflow must have at least one alias.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher.create_matcher","title":"<code>create_matcher(**match_options: Any)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/interfaces/python_api/models/workflow.py</code> <pre><code>@classmethod\ndef create_matcher(self, **match_options: Any):\n\n    m = WorkflowMatcher(**match_options)\n    return m\n</code></pre>"},{"location":"reference/kiara/interfaces/python_api/models/workflow/#kiara.interfaces.python_api.models.workflow.WorkflowMatcher.is_match","title":"<code>is_match(workflow_id: uuid.UUID, kiara: Kiara) -&gt; bool</code>","text":"Source code in <code>kiara/interfaces/python_api/models/workflow.py</code> <pre><code>def is_match(self, workflow_id: uuid.UUID, kiara: \"Kiara\") -&gt; bool:\n\n    if self.has_alias:\n        aliases = kiara.workflow_registry.get_aliases(workflow_id=workflow_id)\n        if not aliases:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/__init__/","title":"tui","text":""},{"location":"reference/kiara/interfaces/tui/pager/","title":"pager","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.RESERVED_KEYS","title":"<code>RESERVED_KEYS = ('q', 'r')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.app","title":"<code>app = PagerApp(value='journals_node.table')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp","title":"<code>PagerApp</code>","text":"<p>         Bases: <code>App</code></p> Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>class PagerApp(App):\n\n    CSS = \"\"\"\nDataViewPane {\n}\nDataViewControl {\n    dock: bottom;\n    padding: 1 0;\n}\n\"\"\"\n    BINDINGS = [Binding(key=\"q\", action=\"quit\", description=\"Quit\")]\n\n    def __init__(\n        self,\n        api: Union[None, KiaraAPI] = None,\n        value: Union[str, None] = None,\n        *args,\n        **kwargs,\n    ):\n\n        if api is None:\n            api = KiaraAPI.instance()\n\n        self._base_id = \"data_preview\"\n\n        self._api: KiaraAPI = api\n\n        self._init_value: Union[None, str] = value\n\n        self._current_value: Union[None, str] = value\n\n        self._current_render_config: Union[Mapping[str, Any], None] = None  # type: ignore\n        self._current_result: Union[RenderValueResult, None] = None  # type: ignore\n\n        self._data_preview = DataViewPane(id=f\"{self._base_id}.preview\")\n        self._preview_control = DataViewControl(id=f\"{self._base_id}.control\")\n        self._preview_control.set_reserved_keys(RESERVED_KEYS)\n\n        self._num_rows: int = 0\n        self._control_height = 0\n\n        super().__init__(*args, **kwargs)\n\n    def compose(self) -&gt; ComposeResult:\n\"\"\"Create child widgets for the app.\"\"\"\n\n        yield Header()\n        yield self._data_preview\n        yield self._preview_control\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n\n        self._current_value = self._init_value\n        self.update_scene()\n\n    def action_redraw_preview(self) -&gt; None:\n\n        self.update_scene()\n\n    def recalculate_num_rows(self) -&gt; None:\n\n        if self._control_height == 0:\n            ch = 0\n        else:\n            ch = self._control_height + 2\n\n        self._num_rows = (get_console().size.height - 8) - ch\n\n    def on_key(self, event: events.Key) -&gt; None:\n\n        if event.key == \"r\":\n            self.action_redraw_preview()\n            return\n\n        scene = self._preview_control.get_scene_for_key(event.key)\n        if scene:\n            self._current_render_config = scene.render_config\n            self.update_scene()\n\n    def update_scene(self):\n\n        if not self._current_value:\n            self._control_height = self._preview_control.compute_related_scenes(None)\n            self._preview_control.commit()\n            self._data_preview.value_view = \"-- no value --\"\n            return\n\n        self.recalculate_num_rows()\n        if self._current_render_config is None:\n            self._current_render_config = {}\n        self._current_render_config[\"number_of_rows\"] = self._num_rows\n        self._current_render_config[\"display_width\"] = get_console().size.width - 4\n\n        current_result = self._api.render_value(\n            value=self._current_value,\n            target_format=\"terminal_renderable\",\n            render_config=self._current_render_config,\n        )\n        control_height = self._preview_control.compute_related_scenes(\n            current_result.related_scenes\n        )\n\n        if control_height != self._control_height:\n            self._control_height = control_height\n            self.update_scene()\n        else:\n            self._current_result = current_result\n            self._data_preview.value_view = current_result.rendered\n            self._preview_control.commit()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.CSS","title":"<code>CSS = '\\nDataViewPane {\\n}\\nDataViewControl {\\n    dock: bottom;\\n    padding: 1 0;\\n}\\n'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.BINDINGS","title":"<code>BINDINGS = [Binding(key='q', action='quit', description='Quit')]</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.compose","title":"<code>compose() -&gt; ComposeResult</code>","text":"<p>Create child widgets for the app.</p> Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n\"\"\"Create child widgets for the app.\"\"\"\n\n    yield Header()\n    yield self._data_preview\n    yield self._preview_control\n    yield Footer()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.on_mount","title":"<code>on_mount() -&gt; None</code>","text":"Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def on_mount(self) -&gt; None:\n\n    self._current_value = self._init_value\n    self.update_scene()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.action_redraw_preview","title":"<code>action_redraw_preview() -&gt; None</code>","text":"Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def action_redraw_preview(self) -&gt; None:\n\n    self.update_scene()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.recalculate_num_rows","title":"<code>recalculate_num_rows() -&gt; None</code>","text":"Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def recalculate_num_rows(self) -&gt; None:\n\n    if self._control_height == 0:\n        ch = 0\n    else:\n        ch = self._control_height + 2\n\n    self._num_rows = (get_console().size.height - 8) - ch\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.on_key","title":"<code>on_key(event: events.Key) -&gt; None</code>","text":"Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def on_key(self, event: events.Key) -&gt; None:\n\n    if event.key == \"r\":\n        self.action_redraw_preview()\n        return\n\n    scene = self._preview_control.get_scene_for_key(event.key)\n    if scene:\n        self._current_render_config = scene.render_config\n        self.update_scene()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager.PagerApp.update_scene","title":"<code>update_scene()</code>","text":"Source code in <code>kiara/interfaces/tui/pager.py</code> <pre><code>def update_scene(self):\n\n    if not self._current_value:\n        self._control_height = self._preview_control.compute_related_scenes(None)\n        self._preview_control.commit()\n        self._data_preview.value_view = \"-- no value --\"\n        return\n\n    self.recalculate_num_rows()\n    if self._current_render_config is None:\n        self._current_render_config = {}\n    self._current_render_config[\"number_of_rows\"] = self._num_rows\n    self._current_render_config[\"display_width\"] = get_console().size.width - 4\n\n    current_result = self._api.render_value(\n        value=self._current_value,\n        target_format=\"terminal_renderable\",\n        render_config=self._current_render_config,\n    )\n    control_height = self._preview_control.compute_related_scenes(\n        current_result.related_scenes\n    )\n\n    if control_height != self._control_height:\n        self._control_height = control_height\n        self.update_scene()\n    else:\n        self._current_result = current_result\n        self._data_preview.value_view = current_result.rendered\n        self._preview_control.commit()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/pager/#kiara.interfaces.tui.pager-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/tui/widgets/__init__/","title":"widgets","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/","title":"pager","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager-classes","title":"Classes","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewPane","title":"<code>DataViewPane</code>","text":"<p>         Bases: <code>Static</code></p> <p>A widget that displays a data preview.</p> Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>class DataViewPane(Static):\n\"\"\"A widget that displays a data preview.\"\"\"\n\n    value_view = reactive(None)\n    # is_scrollable = True\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n\n        super().__init__(*args, **kwargs)\n\n    def watch_value_view(self, value_view: Union[RenderableType, None]) -&gt; None:\n\"\"\"Update the data preview.\"\"\"\n\n        if not value_view:\n            self.update(\"-- no value --\")\n        else:\n            self.update(value_view)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewPane-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewPane.value_view","title":"<code>value_view = reactive(None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewPane-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewPane.watch_value_view","title":"<code>watch_value_view(value_view: Union[RenderableType, None]) -&gt; None</code>","text":"<p>Update the data preview.</p> Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def watch_value_view(self, value_view: Union[RenderableType, None]) -&gt; None:\n\"\"\"Update the data preview.\"\"\"\n\n    if not value_view:\n        self.update(\"-- no value --\")\n    else:\n        self.update(value_view)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl","title":"<code>DataViewControl</code>","text":"<p>         Bases: <code>Static</code></p> Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>class DataViewControl(Static):\n\n    current_value: Union[str, None] = None\n    related_scenes: Union[None, Mapping[str, Union[None, RenderScene]]] = None\n    scene_keys: Union[None, Dict[str, Union[None, RenderScene]]] = None\n    max_level: int = 0\n    control_table: Union[None, RenderableType] = None\n    reserved_keys: Tuple[str, ...] = ()\n\n    def on_mount(self):\n\n        self.compute_related_scenes(None)\n        self.commit()\n\n    def set_reserved_keys(self, keys: Iterable[str]):\n        self.reserved_keys = tuple(keys)\n\n    def get_title(\n        self,\n        key: str,\n        scene: Union[None, RenderScene],\n        scene_keys: Dict[str, Union[None, RenderScene]],\n    ) -&gt; RenderableType:\n\n        last_token = key.split(\".\")[-1]\n\n        title = None\n        found_key = None\n        for idx, command_key in enumerate(last_token):\n            if (\n                command_key.lower() not in self.reserved_keys\n                and command_key.lower() not in (x.lower() for x in scene_keys.keys())\n            ):\n                replaced = last_token.replace(command_key, f\"\\[{command_key}]\", 1)\n                if scene is None or scene.disabled:\n                    title = Text.from_markup(f\"[grey46]{replaced}[/grey46]\")\n                else:\n                    title = Text.from_markup(replaced)\n                found_key = command_key\n                break\n\n        if title is None:\n            raise NotImplementedError(\"Could not find free command key.\")\n        if found_key is None:\n            raise NotImplementedError(\"Invalid key.\")\n\n        scene_keys[found_key] = scene  # tpye: ignore\n        return title\n\n    def render_sub_command_table(\n        self,\n        scene: Union[None, RenderScene],\n        scene_keys: Dict[str, Union[None, RenderScene]],\n        forced_titles: Dict[str, RenderableType],\n        row_list: Union[None, List[List[RenderableType]]] = None,\n        level: int = 0,\n    ) -&gt; Tuple[List[List[RenderableType]], int]:\n\n        if row_list is None:\n            row_list = []\n\n        if not scene:\n            return (row_list, level)\n\n        if not scene.related_scenes:\n            return (row_list, level)\n\n        level = level + 1\n        sub_list: List[RenderableType] = []\n\n        for scene_key, sub_scene in scene.related_scenes.items():\n\n            if scene_key in forced_titles.keys():\n                new_scene_key: RenderableType = forced_titles[scene_key]\n            else:\n                new_scene_key = self.get_title(\n                    key=scene_key, scene=sub_scene, scene_keys=scene_keys\n                )\n\n            sub_list.append(new_scene_key)\n\n        row_list.append(sub_list)\n\n        for scene_key, sub_scene in scene.related_scenes.items():\n            _, level = self.render_sub_command_table(\n                scene=sub_scene,\n                scene_keys=scene_keys,\n                forced_titles=forced_titles,\n                row_list=row_list,\n                level=level,\n            )\n\n        return (row_list, level)\n\n    def render_sub_command_tree(\n        self,\n        key: str,\n        scene: Union[RenderScene, None],\n        scene_keys: Dict[str, Union[None, RenderScene]],\n        forced_titles: Dict[str, RenderableType],\n        node: Union[Tree, None] = None,\n        level: int = 0,\n    ):\n\n        if key in forced_titles.keys():\n            title: RenderableType = forced_titles[key]\n        else:\n            title = self.get_title(key=key, scene=scene, scene_keys=scene_keys)\n\n        if node is None:\n            node = Tree(title)\n        else:\n            node = node.add(title)\n\n        if scene:\n            for scene_key, sub_scene in scene.related_scenes.items():\n                _, level = self.render_sub_command_tree(\n                    key=f\"{key}.{scene_key}\",\n                    scene=sub_scene,\n                    scene_keys=scene_keys,\n                    forced_titles=forced_titles,\n                    node=node,\n                    level=level + 1,\n                )\n\n        return (node, level)\n\n    def render_command_table(self) -&gt; Tuple[RenderableType, int]:\n\n        max_level = 0\n\n        if self.related_scenes is None:\n            return \"\", max_level\n\n        scene_keys: Dict[str, Union[None, RenderScene]] = {}\n\n        forced_titles = {}\n        for key, scene in self.related_scenes.items():\n\n            title = self.get_title(key=key, scene=scene, scene_keys=scene_keys)\n            forced_titles[key] = title\n\n        render_as_tree = False\n        if render_as_tree:\n            row = []\n            table = Table(show_header=False, box=box.SIMPLE)\n            for key, scene in self.related_scenes.items():\n\n                table.add_column(f\"category: {key}\")\n                node, level = self.render_sub_command_tree(\n                    key=key,\n                    scene=scene,\n                    scene_keys=scene_keys,\n                    forced_titles=forced_titles,\n                )\n                row.append(node)\n\n                control_height = ((level * 2) - 1) + 2\n                if control_height &gt; max_level:\n                    max_level = control_height\n\n            table.add_row(*row)\n\n        else:\n            main_scene = RenderScene(\n                title=f\"Value: {self.current_value}\",\n                disabled=False,\n                description=f\"Preview of value: {self.current_value}\",\n                manifest_hash=\"\",\n                render_config={},\n                related_scenes=self.related_scenes,\n            )\n            row_list, level = self.render_sub_command_table(\n                scene=main_scene,\n                scene_keys=scene_keys,\n                forced_titles=forced_titles,\n            )\n\n            table = Table(show_header=False, box=box.SIMPLE, show_lines=True)\n            if not row_list:\n                max_level = 0\n            else:\n                max_len = max([len(x) for x in row_list])\n                for i in range(0, max_len):\n                    table.add_column(f\"col_{i}\")\n\n                for row in row_list:\n                    table.add_row(*row)\n\n            if level &gt; max_level:\n                max_level = level\n\n        self.scene_keys = scene_keys\n        return table, max_level\n\n    def compute_related_scenes(\n        self, related_scenes: Union[None, Mapping[str, Union[None, RenderScene]]]\n    ) -&gt; int:\n\n        self.related_scenes = related_scenes\n        self.control_table, self.max_level = self.render_command_table()\n\n        return self.max_level\n\n    def commit(self):\n\n        self.update(self.control_table)\n\n    def get_scene_for_key(self, key: str) -&gt; Union[None, RenderScene]:\n\n        if self.scene_keys is None:\n            return None\n\n        if key in self.scene_keys.keys():\n            return self.scene_keys[key]\n\n        for x in self.scene_keys.keys():\n            if x.lower() == key.lower():\n                return self.scene_keys[x]\n\n        return None\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl-attributes","title":"Attributes","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.current_value","title":"<code>current_value: Union[str, None] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.related_scenes","title":"<code>related_scenes: Union[None, Mapping[str, Union[None, RenderScene]]] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.scene_keys","title":"<code>scene_keys: Union[None, Dict[str, Union[None, RenderScene]]] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.max_level","title":"<code>max_level: int = 0</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.control_table","title":"<code>control_table: Union[None, RenderableType] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.reserved_keys","title":"<code>reserved_keys: Tuple[str, ...] = ()</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl-functions","title":"Functions","text":""},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.on_mount","title":"<code>on_mount()</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def on_mount(self):\n\n    self.compute_related_scenes(None)\n    self.commit()\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.set_reserved_keys","title":"<code>set_reserved_keys(keys: Iterable[str])</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def set_reserved_keys(self, keys: Iterable[str]):\n    self.reserved_keys = tuple(keys)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.get_title","title":"<code>get_title(key: str, scene: Union[None, RenderScene], scene_keys: Dict[str, Union[None, RenderScene]]) -&gt; RenderableType</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def get_title(\n    self,\n    key: str,\n    scene: Union[None, RenderScene],\n    scene_keys: Dict[str, Union[None, RenderScene]],\n) -&gt; RenderableType:\n\n    last_token = key.split(\".\")[-1]\n\n    title = None\n    found_key = None\n    for idx, command_key in enumerate(last_token):\n        if (\n            command_key.lower() not in self.reserved_keys\n            and command_key.lower() not in (x.lower() for x in scene_keys.keys())\n        ):\n            replaced = last_token.replace(command_key, f\"\\[{command_key}]\", 1)\n            if scene is None or scene.disabled:\n                title = Text.from_markup(f\"[grey46]{replaced}[/grey46]\")\n            else:\n                title = Text.from_markup(replaced)\n            found_key = command_key\n            break\n\n    if title is None:\n        raise NotImplementedError(\"Could not find free command key.\")\n    if found_key is None:\n        raise NotImplementedError(\"Invalid key.\")\n\n    scene_keys[found_key] = scene  # tpye: ignore\n    return title\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.render_sub_command_table","title":"<code>render_sub_command_table(scene: Union[None, RenderScene], scene_keys: Dict[str, Union[None, RenderScene]], forced_titles: Dict[str, RenderableType], row_list: Union[None, List[List[RenderableType]]] = None, level: int = 0) -&gt; Tuple[List[List[RenderableType]], int]</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def render_sub_command_table(\n    self,\n    scene: Union[None, RenderScene],\n    scene_keys: Dict[str, Union[None, RenderScene]],\n    forced_titles: Dict[str, RenderableType],\n    row_list: Union[None, List[List[RenderableType]]] = None,\n    level: int = 0,\n) -&gt; Tuple[List[List[RenderableType]], int]:\n\n    if row_list is None:\n        row_list = []\n\n    if not scene:\n        return (row_list, level)\n\n    if not scene.related_scenes:\n        return (row_list, level)\n\n    level = level + 1\n    sub_list: List[RenderableType] = []\n\n    for scene_key, sub_scene in scene.related_scenes.items():\n\n        if scene_key in forced_titles.keys():\n            new_scene_key: RenderableType = forced_titles[scene_key]\n        else:\n            new_scene_key = self.get_title(\n                key=scene_key, scene=sub_scene, scene_keys=scene_keys\n            )\n\n        sub_list.append(new_scene_key)\n\n    row_list.append(sub_list)\n\n    for scene_key, sub_scene in scene.related_scenes.items():\n        _, level = self.render_sub_command_table(\n            scene=sub_scene,\n            scene_keys=scene_keys,\n            forced_titles=forced_titles,\n            row_list=row_list,\n            level=level,\n        )\n\n    return (row_list, level)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.render_sub_command_tree","title":"<code>render_sub_command_tree(key: str, scene: Union[RenderScene, None], scene_keys: Dict[str, Union[None, RenderScene]], forced_titles: Dict[str, RenderableType], node: Union[Tree, None] = None, level: int = 0)</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def render_sub_command_tree(\n    self,\n    key: str,\n    scene: Union[RenderScene, None],\n    scene_keys: Dict[str, Union[None, RenderScene]],\n    forced_titles: Dict[str, RenderableType],\n    node: Union[Tree, None] = None,\n    level: int = 0,\n):\n\n    if key in forced_titles.keys():\n        title: RenderableType = forced_titles[key]\n    else:\n        title = self.get_title(key=key, scene=scene, scene_keys=scene_keys)\n\n    if node is None:\n        node = Tree(title)\n    else:\n        node = node.add(title)\n\n    if scene:\n        for scene_key, sub_scene in scene.related_scenes.items():\n            _, level = self.render_sub_command_tree(\n                key=f\"{key}.{scene_key}\",\n                scene=sub_scene,\n                scene_keys=scene_keys,\n                forced_titles=forced_titles,\n                node=node,\n                level=level + 1,\n            )\n\n    return (node, level)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.render_command_table","title":"<code>render_command_table() -&gt; Tuple[RenderableType, int]</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def render_command_table(self) -&gt; Tuple[RenderableType, int]:\n\n    max_level = 0\n\n    if self.related_scenes is None:\n        return \"\", max_level\n\n    scene_keys: Dict[str, Union[None, RenderScene]] = {}\n\n    forced_titles = {}\n    for key, scene in self.related_scenes.items():\n\n        title = self.get_title(key=key, scene=scene, scene_keys=scene_keys)\n        forced_titles[key] = title\n\n    render_as_tree = False\n    if render_as_tree:\n        row = []\n        table = Table(show_header=False, box=box.SIMPLE)\n        for key, scene in self.related_scenes.items():\n\n            table.add_column(f\"category: {key}\")\n            node, level = self.render_sub_command_tree(\n                key=key,\n                scene=scene,\n                scene_keys=scene_keys,\n                forced_titles=forced_titles,\n            )\n            row.append(node)\n\n            control_height = ((level * 2) - 1) + 2\n            if control_height &gt; max_level:\n                max_level = control_height\n\n        table.add_row(*row)\n\n    else:\n        main_scene = RenderScene(\n            title=f\"Value: {self.current_value}\",\n            disabled=False,\n            description=f\"Preview of value: {self.current_value}\",\n            manifest_hash=\"\",\n            render_config={},\n            related_scenes=self.related_scenes,\n        )\n        row_list, level = self.render_sub_command_table(\n            scene=main_scene,\n            scene_keys=scene_keys,\n            forced_titles=forced_titles,\n        )\n\n        table = Table(show_header=False, box=box.SIMPLE, show_lines=True)\n        if not row_list:\n            max_level = 0\n        else:\n            max_len = max([len(x) for x in row_list])\n            for i in range(0, max_len):\n                table.add_column(f\"col_{i}\")\n\n            for row in row_list:\n                table.add_row(*row)\n\n        if level &gt; max_level:\n            max_level = level\n\n    self.scene_keys = scene_keys\n    return table, max_level\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.compute_related_scenes","title":"<code>compute_related_scenes(related_scenes: Union[None, Mapping[str, Union[None, RenderScene]]]) -&gt; int</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def compute_related_scenes(\n    self, related_scenes: Union[None, Mapping[str, Union[None, RenderScene]]]\n) -&gt; int:\n\n    self.related_scenes = related_scenes\n    self.control_table, self.max_level = self.render_command_table()\n\n    return self.max_level\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.commit","title":"<code>commit()</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def commit(self):\n\n    self.update(self.control_table)\n</code></pre>"},{"location":"reference/kiara/interfaces/tui/widgets/pager/#kiara.interfaces.tui.widgets.pager.DataViewControl.get_scene_for_key","title":"<code>get_scene_for_key(key: str) -&gt; Union[None, RenderScene]</code>","text":"Source code in <code>kiara/interfaces/tui/widgets/pager.py</code> <pre><code>def get_scene_for_key(self, key: str) -&gt; Union[None, RenderScene]:\n\n    if self.scene_keys is None:\n        return None\n\n    if key in self.scene_keys.keys():\n        return self.scene_keys[key]\n\n    for x in self.scene_keys.keys():\n        if x.lower() == key.lower():\n            return self.scene_keys[x]\n\n    return None\n</code></pre>"},{"location":"reference/kiara/models/__init__/","title":"models","text":""},{"location":"reference/kiara/models/__init__/#kiara.models-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/__init__/#kiara.models-classes","title":"Classes","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel","title":"<code>KiaraModel</code>","text":"<p>         Bases: <code>ABC</code>, <code>BaseModel</code>, <code>JupyterMixin</code></p> <p>Base class that all models in kiara inherit from.</p> <p>This class provides utility functions for things like rendering the model on terminal or as html, integration into a tree hierarchy of the overall kiara context, hashing, etc.</p> Source code in <code>kiara/models/__init__.py</code> <pre><code>class KiaraModel(ABC, BaseModel, JupyterMixin):\n\"\"\"Base class that all models in kiara inherit from.\n\n    This class provides utility functions for things like rendering the model on terminal or as html, integration into\n    a tree hierarchy of the overall kiara context, hashing, etc.\n    \"\"\"\n\n    __slots__ = [\"__weakref__\"]\n\n    class Config(object):\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n        extra = Extra.forbid\n\n    # @classmethod\n    # def get_model_title(cls):\n    #\n    #     return to_camel_case(cls._kiara_model_name)\n\n    @classmethod\n    def get_schema_hash(cls) -&gt; int:\n        if cls._schema_hash_cache is not None:\n            return cls._schema_hash_cache\n\n        obj = cls.schema_json()\n        h = DeepHash(obj, hasher=KIARA_HASH_FUNCTION)\n        cls._schema_hash_cache = h[obj]\n        return cls._schema_hash_cache\n\n    _graph_cache: Union[nx.DiGraph, None] = PrivateAttr(default=None)\n    _subcomponent_names_cache: Union[List[str], None] = PrivateAttr(default=None)\n    _dynamic_subcomponents: Dict[str, \"KiaraModel\"] = PrivateAttr(default_factory=dict)\n    _id_cache: Union[str, None] = PrivateAttr(default=None)\n    _category_id_cache: Union[str, None] = PrivateAttr(default=None)\n    _schema_hash_cache: ClassVar = None\n    _cid_cache: Union[CID, None] = PrivateAttr(default=None)\n    _dag_cache: Union[bytes, None] = PrivateAttr(default=None)\n    _size_cache: Union[int, None] = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Kind:\n\"\"\"Return data important for hashing this model instance. Implemented by sub-classes.\n\n        This returns the relevant data that makes this model unique, excluding any secondary metadata that is not\n        necessary for this model to be used functionally. Like for example documentation.\n        \"\"\"\n\n        return self.dict()\n\n    @property\n    def instance_id(self) -&gt; str:\n\"\"\"The unique id of this model, within its category.\"\"\"\n\n        if self._id_cache is not None:\n            return self._id_cache\n\n        self._id_cache = self._retrieve_id()\n        return self._id_cache\n\n    @property\n    def instance_cid(self) -&gt; CID:\n        if self._cid_cache is None:\n            self._compute_cid()\n        return self._cid_cache  # type: ignore\n\n    @property\n    def instance_dag(self) -&gt; bytes:\n\n        if self._dag_cache is None:\n            self._compute_cid()\n        return self._dag_cache  # type: ignore\n\n    @property\n    def instance_size(self) -&gt; int:\n\n        if self._size_cache is None:\n            self._compute_cid()\n        return self._size_cache  # type: ignore\n\n    @property\n    def model_type_id(self) -&gt; str:\n\"\"\"The id of the category of this model.\"\"\"\n\n        if hasattr(self.__class__, \"_kiara_model_id\"):\n            return self._kiara_model_id  # type: ignore\n        else:\n            return _default_id_func(self.__class__)\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.instance_cid)\n\n    def _compute_cid(self):\n\"\"\"A hash for this model.\"\"\"\n        if self._cid_cache is not None:\n            return\n\n        obj = self._retrieve_data_to_hash()\n        dag, cid = compute_cid(data=obj)\n\n        self._cid_cache = cid\n        self._dag_cache = dag\n        self._size_cache = len(dag)\n\n    # ==========================================================================================\n    # subcomponent related methods\n    @property\n    def subcomponent_keys(self) -&gt; Iterable[str]:\n\"\"\"The keys of available sub-components of this model.\"\"\"\n\n        if self._subcomponent_names_cache is None:\n            self._subcomponent_names_cache = sorted(self._retrieve_subcomponent_keys())\n        return self._subcomponent_names_cache\n\n    @property\n    def subcomponent_tree(self) -&gt; Union[nx.DiGraph, None]:\n\"\"\"A tree structure, containing all sub-components (and their subcomponents) of this model.\"\"\"\n        if not self.subcomponent_keys:\n            return None\n\n        if self._graph_cache is None:\n            self._graph_cache = assemble_subcomponent_graph(self)\n        return self._graph_cache\n\n    def get_subcomponent(self, path: str) -&gt; \"KiaraModel\":\n\"\"\"Retrieve the subcomponent identified by the specified path.\"\"\"\n\n        if path not in self._dynamic_subcomponents.keys():\n            self._dynamic_subcomponents[path] = self._retrieve_subcomponent(path=path)\n        return self._dynamic_subcomponents[path]\n\n    def find_subcomponents(self, category: str) -&gt; Dict[str, \"KiaraModel\"]:\n\"\"\"Find and return all subcomponents of this model that are member of the specified category.\"\"\"\n        tree = self.subcomponent_tree\n        if tree is None:\n            raise Exception(f\"No subcomponents found for category: {category}\")\n\n        result = {}\n        for node_id, node in tree.nodes.items():\n            if not hasattr(node[\"obj\"], \"get_category_alias\"):\n                raise NotImplementedError()\n\n            if category != node[\"obj\"].get_category_alias():\n                continue\n\n            n_id = node_id[9:]  # remove the __self__. token\n            result[n_id] = node[\"obj\"]\n        return result\n\n    def _retrieve_subcomponent_keys(self) -&gt; Iterable[str]:\n\"\"\"Retrieve the keys of all subcomponents of this model.\n\n        Can be overwritten in sub-classes, by default it tries to automatically determine the subcomponents.\n        \"\"\"\n\n        return retrieve_data_subcomponent_keys(self)\n\n    def _retrieve_subcomponent(self, path: str) -&gt; \"KiaraModel\":\n\"\"\"Retrieve the subcomponent under the specified path.\n\n        Can be overwritten in sub-classes, by default it tries to automatically determine the subcomponents.\n        \"\"\"\n\n        m = get_subcomponent_from_model(self, path=path)\n        return m\n\n    # ==========================================================================================\n    # model rendering related methods\n    def create_panel(self, title: Union[str, None] = None, **config: Any) -&gt; Panel:\n\n        rend = self.create_renderable(**config)\n        return Panel(rend, box=box.ROUNDED, title=title, title_align=\"left\")\n\n    def create_html(self, **config) -&gt; str:\n\n        template_registry = TemplateRegistry.instance()\n        template = template_registry.get_template_for_model_type(\n            model_type=self.model_type_id, template_format=\"html\"\n        )\n\n        if template:\n            try:\n                result = template.render(instance=self)\n                return result\n            except Exception as e:\n                log_dev_message(\n                    title=\"html-rendering error\",\n                    msg=f\"Failed to render html for model '{self.instance_id}' type '{self.model_type_id}': {e}\",\n                )\n\n        try:\n            from kiara.utils.html import generate_html\n\n            html = generate_html(item=self, add_header=False)\n            return html\n        except Exception as e:\n            log_dev_message(\n                title=\"html-generation error\",\n                msg=f\"Failed to generate html for model '{self.instance_id}' type '{self.model_type_id}': {e}\",\n            )\n\n        r = self.create_renderable(**config)\n        mime_bundle = r._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n        return mime_bundle[\"text/html\"]\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        from kiara.utils.output import extract_renderable\n\n        include = config.get(\"include\", None)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n        for k in self.__fields__.keys():\n            if include is not None and k not in include:\n                continue\n            attr = getattr(self, k)\n            v = extract_renderable(attr)\n            table.add_row(k, v)\n        return table\n\n    def create_renderable_tree(self, **config: Any) -&gt; Tree:\n\n        show_data = config.get(\"show_data\", False)\n        tree = create_subcomponent_tree_renderable(data=self, show_data=show_data)\n        return tree\n\n    def create_info_data(self, **config) -&gt; Mapping[str, Any]:\n\n        include = config.get(\"include\", None)\n\n        result = {}\n        for k in self.__fields__.keys():\n            if include is not None and k not in include:\n                continue\n            attr = getattr(self, k)\n            v = attr\n            result[k] = v\n        return result\n\n    def as_dict_with_schema(self) -&gt; Dict[str, Dict[str, Any]]:\n        return {\"data\": self.dict(), \"schema\": self.schema()}\n\n    def as_json_with_schema(self) -&gt; str:\n\n        data_json = self.json()\n        schema_json = self.schema_json()\n        return '{\"data\": ' + data_json + ', \"schema\": ' + schema_json + \"}\"\n\n    def __hash__(self):\n        return int.from_bytes(self.instance_cid.digest, \"big\")\n\n    def __eq__(self, other):\n\n        if self.__class__ != other.__class__:\n            return False\n        else:\n            return (self.instance_id, self.instance_cid) == (\n                other.instance_id,\n                other.instance_cid,\n            )\n\n    def __repr__(self):\n\n        try:\n            model_id = self.instance_id\n        except Exception:\n            model_id = \"-- n/a --\"\n\n        return f\"{self.__class__.__name__}(model_id={model_id}, category={self.model_type_id}, fields=[{', '.join(self.__fields__.keys())}])\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def _repr_html_(self):\n        return str(self.create_html())\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n\n        yield self.create_renderable()\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.instance_id","title":"<code>instance_id: str</code>  <code>property</code>","text":"<p>The unique id of this model, within its category.</p>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.instance_cid","title":"<code>instance_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.instance_dag","title":"<code>instance_dag: bytes</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.instance_size","title":"<code>instance_size: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.model_type_id","title":"<code>model_type_id: str</code>  <code>property</code>","text":"<p>The id of the category of this model.</p>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.subcomponent_keys","title":"<code>subcomponent_keys: Iterable[str]</code>  <code>property</code>","text":"<p>The keys of available sub-components of this model.</p>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.subcomponent_tree","title":"<code>subcomponent_tree: Union[nx.DiGraph, None]</code>  <code>property</code>","text":"<p>A tree structure, containing all sub-components (and their subcomponents) of this model.</p>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.Config","title":"<code>Config</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/models/__init__.py</code> <pre><code>class Config(object):\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel-functions","title":"Functions","text":""},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.get_schema_hash","title":"<code>get_schema_hash() -&gt; int</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>@classmethod\ndef get_schema_hash(cls) -&gt; int:\n    if cls._schema_hash_cache is not None:\n        return cls._schema_hash_cache\n\n    obj = cls.schema_json()\n    h = DeepHash(obj, hasher=KIARA_HASH_FUNCTION)\n    cls._schema_hash_cache = h[obj]\n    return cls._schema_hash_cache\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.get_subcomponent","title":"<code>get_subcomponent(path: str) -&gt; KiaraModel</code>","text":"<p>Retrieve the subcomponent identified by the specified path.</p> Source code in <code>kiara/models/__init__.py</code> <pre><code>def get_subcomponent(self, path: str) -&gt; \"KiaraModel\":\n\"\"\"Retrieve the subcomponent identified by the specified path.\"\"\"\n\n    if path not in self._dynamic_subcomponents.keys():\n        self._dynamic_subcomponents[path] = self._retrieve_subcomponent(path=path)\n    return self._dynamic_subcomponents[path]\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.find_subcomponents","title":"<code>find_subcomponents(category: str) -&gt; Dict[str, KiaraModel]</code>","text":"<p>Find and return all subcomponents of this model that are member of the specified category.</p> Source code in <code>kiara/models/__init__.py</code> <pre><code>def find_subcomponents(self, category: str) -&gt; Dict[str, \"KiaraModel\"]:\n\"\"\"Find and return all subcomponents of this model that are member of the specified category.\"\"\"\n    tree = self.subcomponent_tree\n    if tree is None:\n        raise Exception(f\"No subcomponents found for category: {category}\")\n\n    result = {}\n    for node_id, node in tree.nodes.items():\n        if not hasattr(node[\"obj\"], \"get_category_alias\"):\n            raise NotImplementedError()\n\n        if category != node[\"obj\"].get_category_alias():\n            continue\n\n        n_id = node_id[9:]  # remove the __self__. token\n        result[n_id] = node[\"obj\"]\n    return result\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.create_panel","title":"<code>create_panel(title: Union[str, None] = None, **config: Any) -&gt; Panel</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def create_panel(self, title: Union[str, None] = None, **config: Any) -&gt; Panel:\n\n    rend = self.create_renderable(**config)\n    return Panel(rend, box=box.ROUNDED, title=title, title_align=\"left\")\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.create_html","title":"<code>create_html(**config) -&gt; str</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def create_html(self, **config) -&gt; str:\n\n    template_registry = TemplateRegistry.instance()\n    template = template_registry.get_template_for_model_type(\n        model_type=self.model_type_id, template_format=\"html\"\n    )\n\n    if template:\n        try:\n            result = template.render(instance=self)\n            return result\n        except Exception as e:\n            log_dev_message(\n                title=\"html-rendering error\",\n                msg=f\"Failed to render html for model '{self.instance_id}' type '{self.model_type_id}': {e}\",\n            )\n\n    try:\n        from kiara.utils.html import generate_html\n\n        html = generate_html(item=self, add_header=False)\n        return html\n    except Exception as e:\n        log_dev_message(\n            title=\"html-generation error\",\n            msg=f\"Failed to generate html for model '{self.instance_id}' type '{self.model_type_id}': {e}\",\n        )\n\n    r = self.create_renderable(**config)\n    mime_bundle = r._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n    return mime_bundle[\"text/html\"]\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    from kiara.utils.output import extract_renderable\n\n    include = config.get(\"include\", None)\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Key\", style=\"i\")\n    table.add_column(\"Value\")\n    for k in self.__fields__.keys():\n        if include is not None and k not in include:\n            continue\n        attr = getattr(self, k)\n        v = extract_renderable(attr)\n        table.add_row(k, v)\n    return table\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.create_renderable_tree","title":"<code>create_renderable_tree(**config: Any) -&gt; Tree</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def create_renderable_tree(self, **config: Any) -&gt; Tree:\n\n    show_data = config.get(\"show_data\", False)\n    tree = create_subcomponent_tree_renderable(data=self, show_data=show_data)\n    return tree\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.create_info_data","title":"<code>create_info_data(**config) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def create_info_data(self, **config) -&gt; Mapping[str, Any]:\n\n    include = config.get(\"include\", None)\n\n    result = {}\n    for k in self.__fields__.keys():\n        if include is not None and k not in include:\n            continue\n        attr = getattr(self, k)\n        v = attr\n        result[k] = v\n    return result\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.as_dict_with_schema","title":"<code>as_dict_with_schema() -&gt; Dict[str, Dict[str, Any]]</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def as_dict_with_schema(self) -&gt; Dict[str, Dict[str, Any]]:\n    return {\"data\": self.dict(), \"schema\": self.schema()}\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models.KiaraModel.as_json_with_schema","title":"<code>as_json_with_schema() -&gt; str</code>","text":"Source code in <code>kiara/models/__init__.py</code> <pre><code>def as_json_with_schema(self) -&gt; str:\n\n    data_json = self.json()\n    schema_json = self.schema_json()\n    return '{\"data\": ' + data_json + ', \"schema\": ' + schema_json + \"}\"\n</code></pre>"},{"location":"reference/kiara/models/__init__/#kiara.models-functions","title":"Functions","text":""},{"location":"reference/kiara/models/archives/","title":"archives","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives-classes","title":"Classes","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo","title":"<code>ArchiveTypeInfo</code>","text":"<p>         Bases: <code>TypeInfo</code></p> Source code in <code>kiara/models/archives.py</code> <pre><code>class ArchiveTypeInfo(TypeInfo):\n\n    _kiara_model_id = \"info.archive_type\"\n\n    @classmethod\n    def create_from_type_class(\n        self, type_cls: Type[KiaraArchive], kiara: \"Kiara\"\n    ) -&gt; \"ArchiveTypeInfo\":\n\n        authors_md = AuthorsMetadataModel.from_class(type_cls)\n        doc = DocumentationMetadataModel.from_class_doc(type_cls)\n        python_class = PythonClass.from_class(type_cls)\n        properties_md = ContextMetadataModel.from_class(type_cls)\n        type_name = type_cls._archive_type_name  # type: ignore\n\n        return ArchiveTypeInfo.construct(\n            type_name=type_name,\n            documentation=doc,\n            authors=authors_md,\n            context=properties_md,\n            python_class=python_class,\n            supported_item_types=list(type_cls.supported_item_types()),\n        )\n\n    @classmethod\n    def base_class(self) -&gt; Type[KiaraArchive]:\n        return KiaraArchive\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"archive_type\"\n\n    is_writable: bool = Field(\n        description=\"Whether this archive is writeable.\", default=False\n    )\n    supported_item_types: List[str] = Field(\n        description=\"The item types this archive suports.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        table.add_row(\"Python class\", self.python_class.create_renderable())\n\n        table.add_row(\"is_writeable\", \"yes\" if self.is_writable else \"no\")\n        table.add_row(\n            \"supported_item_types\", \", \".join(sorted(self.supported_item_types))\n        )\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.is_writable","title":"<code>is_writable: bool = Field(description='Whether this archive is writeable.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.supported_item_types","title":"<code>supported_item_types: List[str] = Field(description='The item types this archive suports.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: Type[KiaraArchive], kiara: Kiara) -&gt; ArchiveTypeInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef create_from_type_class(\n    self, type_cls: Type[KiaraArchive], kiara: \"Kiara\"\n) -&gt; \"ArchiveTypeInfo\":\n\n    authors_md = AuthorsMetadataModel.from_class(type_cls)\n    doc = DocumentationMetadataModel.from_class_doc(type_cls)\n    python_class = PythonClass.from_class(type_cls)\n    properties_md = ContextMetadataModel.from_class(type_cls)\n    type_name = type_cls._archive_type_name  # type: ignore\n\n    return ArchiveTypeInfo.construct(\n        type_name=type_name,\n        documentation=doc,\n        authors=authors_md,\n        context=properties_md,\n        python_class=python_class,\n        supported_item_types=list(type_cls.supported_item_types()),\n    )\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.base_class","title":"<code>base_class() -&gt; Type[KiaraArchive]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef base_class(self) -&gt; Type[KiaraArchive]:\n    return KiaraArchive\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"archive_type\"\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    table.add_row(\"Python class\", self.python_class.create_renderable())\n\n    table.add_row(\"is_writeable\", \"yes\" if self.is_writable else \"no\")\n    table.add_row(\n        \"supported_item_types\", \", \".join(sorted(self.supported_item_types))\n    )\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo","title":"<code>ArchiveTypeClassesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/models/archives.py</code> <pre><code>class ArchiveTypeClassesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.archive_types\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[ArchiveTypeInfo]:\n        return ArchiveTypeInfo\n\n    type_name: Literal[\"archive_type\"] = \"archive_type\"\n    item_infos: Mapping[str, ArchiveTypeInfo] = Field(  # type: ignore\n        description=\"The archive info instances for each type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo.type_name","title":"<code>type_name: Literal['archive_type'] = 'archive_type'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo.item_infos","title":"<code>item_infos: Mapping[str, ArchiveTypeInfo] = Field(description='The archive info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveTypeClassesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[ArchiveTypeInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[ArchiveTypeInfo]:\n    return ArchiveTypeInfo\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo","title":"<code>ArchiveInfo</code>","text":"<p>         Bases: <code>ItemInfo</code></p> Source code in <code>kiara/models/archives.py</code> <pre><code>class ArchiveInfo(ItemInfo):\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[KiaraArchive]:\n        return KiaraArchive\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: KiaraArchive, **kwargs):\n\n        return cls.create_from_archive(kiara=kiara, archive=instance, **kwargs)\n\n    @classmethod\n    def create_from_archive(\n        cls,\n        kiara: \"Kiara\",\n        archive: KiaraArchive,\n        archive_aliases: Union[Iterable[str], None] = None,\n    ):\n\n        archive_type_info = ArchiveTypeInfo.create_from_type_class(\n            archive.__class__, kiara=kiara\n        )\n        if archive_aliases is None:\n            archive_aliases = []\n        else:\n            archive_aliases = list(archive_aliases)\n        return ArchiveInfo(\n            archive_type_info=archive_type_info,\n            type_name=str(archive.archive_id),\n            documentation=archive_type_info.documentation,\n            authors=archive_type_info.authors,\n            context=archive_type_info.context,\n            archive_id=archive.archive_id,\n            details=archive.get_archive_details(),\n            config=archive.config.dict(),\n            aliases=archive_aliases,\n        )\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"info.archive\"\n\n    archive_id: uuid.UUID = Field(description=\"The (globally unique) archive id.\")\n    archive_type_info: ArchiveTypeInfo = Field(\n        description=\"Information about this archives' type.\"\n    )\n    config: Mapping[str, Any] = Field(description=\"The configuration of this archive.\")\n    details: ArchiveDetails = Field(\n        description=\"Type dependent (runtime) details for this archive.\"\n    )\n    aliases: List[str] = Field(\n        description=\"Aliases for this archive.\", default_factory=list\n    )\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.archive_id","title":"<code>archive_id: uuid.UUID = Field(description='The (globally unique) archive id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.archive_type_info","title":"<code>archive_type_info: ArchiveTypeInfo = Field(description=\"Information about this archives' type.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.config","title":"<code>config: Mapping[str, Any] = Field(description='The configuration of this archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.details","title":"<code>details: ArchiveDetails = Field(description='Type dependent (runtime) details for this archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.aliases","title":"<code>aliases: List[str] = Field(description='Aliases for this archive.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[KiaraArchive]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[KiaraArchive]:\n    return KiaraArchive\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: KiaraArchive, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: KiaraArchive, **kwargs):\n\n    return cls.create_from_archive(kiara=kiara, archive=instance, **kwargs)\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.create_from_archive","title":"<code>create_from_archive(kiara: Kiara, archive: KiaraArchive, archive_aliases: Union[Iterable[str], None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef create_from_archive(\n    cls,\n    kiara: \"Kiara\",\n    archive: KiaraArchive,\n    archive_aliases: Union[Iterable[str], None] = None,\n):\n\n    archive_type_info = ArchiveTypeInfo.create_from_type_class(\n        archive.__class__, kiara=kiara\n    )\n    if archive_aliases is None:\n        archive_aliases = []\n    else:\n        archive_aliases = list(archive_aliases)\n    return ArchiveInfo(\n        archive_type_info=archive_type_info,\n        type_name=str(archive.archive_id),\n        documentation=archive_type_info.documentation,\n        authors=archive_type_info.authors,\n        context=archive_type_info.context,\n        archive_id=archive.archive_id,\n        details=archive.get_archive_details(),\n        config=archive.config.dict(),\n        aliases=archive_aliases,\n    )\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"info.archive\"\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo","title":"<code>ArchiveGroupInfo</code>","text":"<p>         Bases: <code>InfoItemGroup</code></p> Source code in <code>kiara/models/archives.py</code> <pre><code>class ArchiveGroupInfo(InfoItemGroup):\n\n    _kiara_model_id = \"info.archives\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[ItemInfo]:\n        return ArchiveInfo\n\n    @classmethod\n    def create_from_context(\n        cls, kiara: \"Kiara\", group_title: Union[str, None] = None\n    ) -&gt; \"ArchiveGroupInfo\":\n\n        archives = {}\n        for archive, aliases in kiara.get_all_archives().items():\n            archives[str(archive.archive_id)] = ArchiveInfo.create_from_archive(\n                kiara=kiara, archive=archive, archive_aliases=aliases\n            )\n\n        info = cls(group_title=group_title, item_infos=archives)\n        return info\n\n    item_infos: Mapping[str, ArchiveInfo] = Field(\n        description=\"The info for each archive.\"\n    )\n\n    @property\n    def combined_size(self) -&gt; int:\n\n        combined = 0\n        for archive_info in self.item_infos.values():\n            size = archive_info.details.size\n            if size and size &gt; 0:\n                combined = combined + size\n\n        return combined\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        show_archive_id = config.get(\"show_archive_id\", False)\n        show_config = config.get(\"show_config\", True)\n        show_details = config.get(\"show_details\", False)\n\n        # by_type: Dict[str, Dict[str, ArchiveInfo]] = {}\n        # for archive_id, archive in sorted(self.item_infos.items()):\n        #     for item_type in archive.archive_type_info.supported_item_types:\n        #         by_type.setdefault(item_type, {})[archive.type_name] = archive\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        if show_archive_id:\n            table.add_column(\"archive id\")\n        table.add_column(\"alias(es)\", style=\"i\")\n        table.add_column(\"item type(s)\", style=\"i\")\n        if show_config:\n            table.add_column(\"config\")\n        if show_details:\n            table.add_column(\"details\")\n\n        for archive in self.item_infos.values():\n            row: List[RenderableType] = []\n            if show_archive_id:\n                row.append(str(archive.archive_id))\n            row.append(\"\\n\".join(archive.aliases))\n            row.append(\"\\n\".join(archive.archive_type_info.supported_item_types))\n\n            if show_config:\n                config_json = Syntax(\n                    orjson_dumps(archive.config, option=orjson.OPT_INDENT_2),\n                    \"json\",\n                    background_color=\"default\",\n                )\n                row.append(config_json)\n            if show_details:\n                details_json = Syntax(\n                    orjson_dumps(archive.details, option=orjson.OPT_INDENT_2),\n                    \"json\",\n                    background_color=\"default\",\n                )\n                row.append(details_json)\n\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo.item_infos","title":"<code>item_infos: Mapping[str, ArchiveInfo] = Field(description='The info for each archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo.combined_size","title":"<code>combined_size: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[ItemInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[ItemInfo]:\n    return ArchiveInfo\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo.create_from_context","title":"<code>create_from_context(kiara: Kiara, group_title: Union[str, None] = None) -&gt; ArchiveGroupInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>@classmethod\ndef create_from_context(\n    cls, kiara: \"Kiara\", group_title: Union[str, None] = None\n) -&gt; \"ArchiveGroupInfo\":\n\n    archives = {}\n    for archive, aliases in kiara.get_all_archives().items():\n        archives[str(archive.archive_id)] = ArchiveInfo.create_from_archive(\n            kiara=kiara, archive=archive, archive_aliases=aliases\n        )\n\n    info = cls(group_title=group_title, item_infos=archives)\n    return info\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives.ArchiveGroupInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/archives.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    show_archive_id = config.get(\"show_archive_id\", False)\n    show_config = config.get(\"show_config\", True)\n    show_details = config.get(\"show_details\", False)\n\n    # by_type: Dict[str, Dict[str, ArchiveInfo]] = {}\n    # for archive_id, archive in sorted(self.item_infos.items()):\n    #     for item_type in archive.archive_type_info.supported_item_types:\n    #         by_type.setdefault(item_type, {})[archive.type_name] = archive\n\n    table = Table(show_header=True, box=box.SIMPLE)\n    if show_archive_id:\n        table.add_column(\"archive id\")\n    table.add_column(\"alias(es)\", style=\"i\")\n    table.add_column(\"item type(s)\", style=\"i\")\n    if show_config:\n        table.add_column(\"config\")\n    if show_details:\n        table.add_column(\"details\")\n\n    for archive in self.item_infos.values():\n        row: List[RenderableType] = []\n        if show_archive_id:\n            row.append(str(archive.archive_id))\n        row.append(\"\\n\".join(archive.aliases))\n        row.append(\"\\n\".join(archive.archive_type_info.supported_item_types))\n\n        if show_config:\n            config_json = Syntax(\n                orjson_dumps(archive.config, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            row.append(config_json)\n        if show_details:\n            details_json = Syntax(\n                orjson_dumps(archive.details, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            row.append(details_json)\n\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/archives/#kiara.models.archives-functions","title":"Functions","text":""},{"location":"reference/kiara/models/context/","title":"context","text":""},{"location":"reference/kiara/models/context/#kiara.models.context-classes","title":"Classes","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo","title":"<code>ContextInfo</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/context.py</code> <pre><code>class ContextInfo(KiaraModel):\n    @classmethod\n    def create_from_context_config(\n        cls,\n        config: KiaraContextConfig,\n        context_name: Union[str, None] = None,\n        runtime_config: Union[KiaraRuntimeConfig, None] = None,\n    ):\n\n        from kiara.context import Kiara\n\n        kiara = Kiara(config=config, runtime_config=runtime_config)\n        return cls.create_from_context(kiara=kiara, context_name=context_name)\n\n    @classmethod\n    def create_from_context(cls, kiara: \"Kiara\", context_name: Union[str, None] = None):\n\n        errors = {}\n        try:\n            value_ids = list(kiara.data_registry.retrieve_all_available_value_ids())\n        except Exception as e:\n            errors[\"values\"] = e\n            value_ids = []\n\n        try:\n            aliases = {\n                a.full_alias: a.value_id for a in kiara.alias_registry.aliases.values()\n            }\n        except Exception as e:\n            errors[\"aliases\"] = e\n            aliases = {}\n\n        try:\n            archives_info = ArchiveGroupInfo.create_from_context(kiara=kiara)\n        except Exception as e:\n            errors[\"archives\"] = e\n            archives_info = ArchiveGroupInfo(item_infos={})\n\n        comment = None\n        invalid = False\n        if errors:\n            invalid = True\n            comment = \"Errors creating this context, this is most likely a bug:\\n\\n\"\n            for k, err in errors.items():\n                comment = f\"{comment}  - {k}: {err}\"\n\n        result = ContextInfo.construct(\n            kiara_id=kiara.id,\n            value_ids=value_ids,\n            aliases=aliases,\n            context_name=context_name,\n            archives=archives_info,\n            invalid=invalid,\n            comment=comment,\n        )\n        result._kiara = kiara\n        return result\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The (globally unique) id of the kiara context.\"\n    )\n    context_name: Union[str, None] = Field(\n        description=\"The local alias for this context.\"\n    )\n    value_ids: List[uuid.UUID] = Field(\n        description=\"The ids of all stored values in this context.\"\n    )\n    aliases: Dict[str, uuid.UUID] = Field(\n        description=\"All available aliases within this context (and the value ids they refer to).\"\n    )\n    archives: ArchiveGroupInfo = Field(\n        description=\"The archives registered in this context.\"\n    )\n    invalid: bool = Field(description=\"Whether this context has errors.\", bool=False)\n    comment: Union[str, None] = Field(\n        description=\"(Optional) comment about this context.\", default=None\n    )\n\n    _kiara: Union[\"Kiara\", None] = PrivateAttr()\n\n    @property\n    def kiara_context(self) -&gt; \"Kiara\":\n        if self._kiara is None:\n            raise Exception(\"Kiara context object not set.\")\n        return self._kiara\n\n    def value_summary(self) -&gt; Dict[str, Any]:\n\n        sum_size = 0\n        types: Dict[str, int] = {}\n        internal_types: Dict[str, int] = {}\n        no_of_values = len(self.value_ids)\n\n        for value_id in self.value_ids:\n            value = self.kiara_context.data_registry.get_value(value=value_id)\n            sum_size = sum_size + value.value_size\n            if self.kiara_context.type_registry.is_internal_type(value.data_type_name):\n                if value.data_type_name not in internal_types.keys():\n                    internal_types[value.data_type_name] = 1\n                else:\n                    internal_types[value.data_type_name] += 1\n            else:\n                if value.data_type_name not in types.keys():\n                    types[value.data_type_name] = 1\n                else:\n                    types[value.data_type_name] += 1\n\n            types.setdefault(value.data_type_name, 0)\n\n        return {\n            \"size\": sum_size,\n            \"no_values\": no_of_values,\n            \"types\": types,\n            \"internal_types\": internal_types,\n        }\n\n    def alias_summary(self) -&gt; Dict[str, Any]:\n\n        sum_size = 0\n        types: Dict[str, int] = {}\n        internal_types: Dict[str, int] = {}\n        no_of_values = len(self.value_ids)\n\n        for alias, value_id in self.aliases.items():\n            value = self.kiara_context.data_registry.get_value(value=value_id)\n            sum_size = sum_size + value.value_size\n            if self.kiara_context.type_registry.is_internal_type(value.data_type_name):\n                if value.data_type_name not in internal_types.keys():\n                    internal_types[value.data_type_name] = 1\n                else:\n                    internal_types[value.data_type_name] += 1\n            else:\n                if value.data_type_name not in types.keys():\n                    types[value.data_type_name] = 1\n                else:\n                    types[value.data_type_name] += 1\n\n            types.setdefault(value.data_type_name, 0)\n\n        return {\n            \"size\": sum_size,\n            \"no_values\": no_of_values,\n            \"types\": types,\n            \"internal_types\": internal_types,\n        }\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        full_details = config.get(\"full_details\", False)\n        show_value_ids = config.get(\"show_value_ids\", False)\n        show_archive_info = config.get(\"show_archive_info\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False)\n\n        table.add_column(\"Property\", style=\"i\")\n        table.add_column(\"Value\")\n\n        if self.invalid:\n            msg = \"[red]This context is invalid![/red]\\n\"\n            cmt = self.comment if self.comment else \"-- no details --\"\n            md = Markdown(cmt)\n            table.add_row(\n                \"\",\n                Group(msg, md, \"\"),\n            )\n\n        if self.context_name:\n            table.add_row(\"context name\", self.context_name)\n        table.add_row(\"kiara_id\", str(self.kiara_id))\n\n        size_on_disk = humanfriendly.format_size(self.archives.combined_size)\n        table.add_row(\"size on disk\", size_on_disk)\n\n        value_sum = self.value_summary()\n        v_table = Table(box=box.SIMPLE, show_header=False)\n        v_table.add_column(\"Property\")\n        v_table.add_column(\"Value\")\n        v_table.add_row(\"no. values\", str(value_sum[\"no_values\"]))\n        v_table.add_row(\"combined size\", format_size(value_sum[\"size\"]))\n        if full_details and show_value_ids:\n            if self.value_ids:\n                value_ids = sorted((str(v) for v in self.value_ids))\n                v_table.add_row(\"value_ids\", value_ids[0])\n                for v_id in value_ids[1:]:\n                    v_table.add_row(\"\", v_id)\n            else:\n                v_table.add_row(\"value_ids\", \"\")\n        table.add_row(\"values\", v_table)\n\n        alias_sum = self.alias_summary()\n        a_table = Table(box=box.SIMPLE, show_header=False)\n        a_table.add_column(\"Property\")\n        a_table.add_column(\"Value\")\n        a_table.add_row(\"no. aliases\", str(len(self.aliases)))\n        a_table.add_row(\"combined size\", format_size(alias_sum[\"size\"]))\n        if full_details:\n            if self.aliases:\n                aliases = sorted(self.aliases.keys())\n                a_table.add_row(\n                    \"aliases\", f\"{aliases[0]} -&gt; {self.aliases[aliases[0]]}\"\n                )\n                for alias in aliases[1:]:\n                    a_table.add_row(\"\", f\"{alias} -&gt; {self.aliases[alias]}\")\n            else:\n                a_table.add_row(\"aliases\", \"\")\n        table.add_row(\"aliases\", a_table)\n\n        if show_archive_info:\n            table.add_row(\"archives\", self.archives)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The (globally unique) id of the kiara context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.context_name","title":"<code>context_name: Union[str, None] = Field(description='The local alias for this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.value_ids","title":"<code>value_ids: List[uuid.UUID] = Field(description='The ids of all stored values in this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.aliases","title":"<code>aliases: Dict[str, uuid.UUID] = Field(description='All available aliases within this context (and the value ids they refer to).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.archives","title":"<code>archives: ArchiveGroupInfo = Field(description='The archives registered in this context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.invalid","title":"<code>invalid: bool = Field(description='Whether this context has errors.', bool=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.comment","title":"<code>comment: Union[str, None] = Field(description='(Optional) comment about this context.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.kiara_context","title":"<code>kiara_context: Kiara</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.create_from_context_config","title":"<code>create_from_context_config(config: KiaraContextConfig, context_name: Union[str, None] = None, runtime_config: Union[KiaraRuntimeConfig, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>@classmethod\ndef create_from_context_config(\n    cls,\n    config: KiaraContextConfig,\n    context_name: Union[str, None] = None,\n    runtime_config: Union[KiaraRuntimeConfig, None] = None,\n):\n\n    from kiara.context import Kiara\n\n    kiara = Kiara(config=config, runtime_config=runtime_config)\n    return cls.create_from_context(kiara=kiara, context_name=context_name)\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.create_from_context","title":"<code>create_from_context(kiara: Kiara, context_name: Union[str, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>@classmethod\ndef create_from_context(cls, kiara: \"Kiara\", context_name: Union[str, None] = None):\n\n    errors = {}\n    try:\n        value_ids = list(kiara.data_registry.retrieve_all_available_value_ids())\n    except Exception as e:\n        errors[\"values\"] = e\n        value_ids = []\n\n    try:\n        aliases = {\n            a.full_alias: a.value_id for a in kiara.alias_registry.aliases.values()\n        }\n    except Exception as e:\n        errors[\"aliases\"] = e\n        aliases = {}\n\n    try:\n        archives_info = ArchiveGroupInfo.create_from_context(kiara=kiara)\n    except Exception as e:\n        errors[\"archives\"] = e\n        archives_info = ArchiveGroupInfo(item_infos={})\n\n    comment = None\n    invalid = False\n    if errors:\n        invalid = True\n        comment = \"Errors creating this context, this is most likely a bug:\\n\\n\"\n        for k, err in errors.items():\n            comment = f\"{comment}  - {k}: {err}\"\n\n    result = ContextInfo.construct(\n        kiara_id=kiara.id,\n        value_ids=value_ids,\n        aliases=aliases,\n        context_name=context_name,\n        archives=archives_info,\n        invalid=invalid,\n        comment=comment,\n    )\n    result._kiara = kiara\n    return result\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.value_summary","title":"<code>value_summary() -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>def value_summary(self) -&gt; Dict[str, Any]:\n\n    sum_size = 0\n    types: Dict[str, int] = {}\n    internal_types: Dict[str, int] = {}\n    no_of_values = len(self.value_ids)\n\n    for value_id in self.value_ids:\n        value = self.kiara_context.data_registry.get_value(value=value_id)\n        sum_size = sum_size + value.value_size\n        if self.kiara_context.type_registry.is_internal_type(value.data_type_name):\n            if value.data_type_name not in internal_types.keys():\n                internal_types[value.data_type_name] = 1\n            else:\n                internal_types[value.data_type_name] += 1\n        else:\n            if value.data_type_name not in types.keys():\n                types[value.data_type_name] = 1\n            else:\n                types[value.data_type_name] += 1\n\n        types.setdefault(value.data_type_name, 0)\n\n    return {\n        \"size\": sum_size,\n        \"no_values\": no_of_values,\n        \"types\": types,\n        \"internal_types\": internal_types,\n    }\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.alias_summary","title":"<code>alias_summary() -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>def alias_summary(self) -&gt; Dict[str, Any]:\n\n    sum_size = 0\n    types: Dict[str, int] = {}\n    internal_types: Dict[str, int] = {}\n    no_of_values = len(self.value_ids)\n\n    for alias, value_id in self.aliases.items():\n        value = self.kiara_context.data_registry.get_value(value=value_id)\n        sum_size = sum_size + value.value_size\n        if self.kiara_context.type_registry.is_internal_type(value.data_type_name):\n            if value.data_type_name not in internal_types.keys():\n                internal_types[value.data_type_name] = 1\n            else:\n                internal_types[value.data_type_name] += 1\n        else:\n            if value.data_type_name not in types.keys():\n                types[value.data_type_name] = 1\n            else:\n                types[value.data_type_name] += 1\n\n        types.setdefault(value.data_type_name, 0)\n\n    return {\n        \"size\": sum_size,\n        \"no_values\": no_of_values,\n        \"types\": types,\n        \"internal_types\": internal_types,\n    }\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    full_details = config.get(\"full_details\", False)\n    show_value_ids = config.get(\"show_value_ids\", False)\n    show_archive_info = config.get(\"show_archive_info\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False)\n\n    table.add_column(\"Property\", style=\"i\")\n    table.add_column(\"Value\")\n\n    if self.invalid:\n        msg = \"[red]This context is invalid![/red]\\n\"\n        cmt = self.comment if self.comment else \"-- no details --\"\n        md = Markdown(cmt)\n        table.add_row(\n            \"\",\n            Group(msg, md, \"\"),\n        )\n\n    if self.context_name:\n        table.add_row(\"context name\", self.context_name)\n    table.add_row(\"kiara_id\", str(self.kiara_id))\n\n    size_on_disk = humanfriendly.format_size(self.archives.combined_size)\n    table.add_row(\"size on disk\", size_on_disk)\n\n    value_sum = self.value_summary()\n    v_table = Table(box=box.SIMPLE, show_header=False)\n    v_table.add_column(\"Property\")\n    v_table.add_column(\"Value\")\n    v_table.add_row(\"no. values\", str(value_sum[\"no_values\"]))\n    v_table.add_row(\"combined size\", format_size(value_sum[\"size\"]))\n    if full_details and show_value_ids:\n        if self.value_ids:\n            value_ids = sorted((str(v) for v in self.value_ids))\n            v_table.add_row(\"value_ids\", value_ids[0])\n            for v_id in value_ids[1:]:\n                v_table.add_row(\"\", v_id)\n        else:\n            v_table.add_row(\"value_ids\", \"\")\n    table.add_row(\"values\", v_table)\n\n    alias_sum = self.alias_summary()\n    a_table = Table(box=box.SIMPLE, show_header=False)\n    a_table.add_column(\"Property\")\n    a_table.add_column(\"Value\")\n    a_table.add_row(\"no. aliases\", str(len(self.aliases)))\n    a_table.add_row(\"combined size\", format_size(alias_sum[\"size\"]))\n    if full_details:\n        if self.aliases:\n            aliases = sorted(self.aliases.keys())\n            a_table.add_row(\n                \"aliases\", f\"{aliases[0]} -&gt; {self.aliases[aliases[0]]}\"\n            )\n            for alias in aliases[1:]:\n                a_table.add_row(\"\", f\"{alias} -&gt; {self.aliases[alias]}\")\n        else:\n            a_table.add_row(\"aliases\", \"\")\n    table.add_row(\"aliases\", a_table)\n\n    if show_archive_info:\n        table.add_row(\"archives\", self.archives)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfos","title":"<code>ContextInfos</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/context.py</code> <pre><code>class ContextInfos(BaseModel):\n    __root__: Dict[str, ContextInfo]\n\n    @classmethod\n    def create_context_infos(\n        cls, contexts: Union[Mapping[str, \"KiaraContextConfig\"], None] = None\n    ):\n\n        if not contexts:\n            kc = KiaraConfig()\n            contexts = kc.context_configs\n\n        return ContextInfos(\n            __root__={\n                a: ContextInfo.create_from_context_config(c, context_name=a)\n                for a, c in contexts.items()\n            }\n        )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        full_details = config.get(\"full_details\", False)\n\n        if not full_details:\n            table = Table(box=box.SIMPLE, show_header=True, show_lines=False)\n            table.add_column(\"context name\", style=\"i\")\n            table.add_column(\"context id\", style=\"i\")\n            table.add_column(\"size on disk\")\n            table.add_column(\"size of all values\")\n            table.add_column(\"no. values\")\n            table.add_column(\"no. aliaes\")\n            for context_name, context_summary in self.__root__.items():\n                size_on_disk = context_summary.archives.combined_size\n                value_summary = context_summary.value_summary()\n                size = humanfriendly.format_size(value_summary[\"size\"])\n                no_values = str(value_summary[\"no_values\"])\n                no_aliases = str(len(context_summary.aliases))\n                table.add_row(\n                    context_name,\n                    str(context_summary.kiara_id),\n                    humanfriendly.format_size(size_on_disk),\n                    size,\n                    no_values,\n                    no_aliases,\n                )\n        else:\n\n            table = Table(box=box.MINIMAL, show_header=True, show_lines=True)\n            table.add_column(\"context_name\", style=\"i\")\n            table.add_column(\"details\")\n\n            for context_name, context_summary in self.__root__.items():\n\n                table.add_row(context_name, context_summary.create_renderable(**config))\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfos-functions","title":"Functions","text":""},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfos.create_context_infos","title":"<code>create_context_infos(contexts: Union[Mapping[str, KiaraContextConfig], None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>@classmethod\ndef create_context_infos(\n    cls, contexts: Union[Mapping[str, \"KiaraContextConfig\"], None] = None\n):\n\n    if not contexts:\n        kc = KiaraConfig()\n        contexts = kc.context_configs\n\n    return ContextInfos(\n        __root__={\n            a: ContextInfo.create_from_context_config(c, context_name=a)\n            for a, c in contexts.items()\n        }\n    )\n</code></pre>"},{"location":"reference/kiara/models/context/#kiara.models.context.ContextInfos.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/context.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    full_details = config.get(\"full_details\", False)\n\n    if not full_details:\n        table = Table(box=box.SIMPLE, show_header=True, show_lines=False)\n        table.add_column(\"context name\", style=\"i\")\n        table.add_column(\"context id\", style=\"i\")\n        table.add_column(\"size on disk\")\n        table.add_column(\"size of all values\")\n        table.add_column(\"no. values\")\n        table.add_column(\"no. aliaes\")\n        for context_name, context_summary in self.__root__.items():\n            size_on_disk = context_summary.archives.combined_size\n            value_summary = context_summary.value_summary()\n            size = humanfriendly.format_size(value_summary[\"size\"])\n            no_values = str(value_summary[\"no_values\"])\n            no_aliases = str(len(context_summary.aliases))\n            table.add_row(\n                context_name,\n                str(context_summary.kiara_id),\n                humanfriendly.format_size(size_on_disk),\n                size,\n                no_values,\n                no_aliases,\n            )\n    else:\n\n        table = Table(box=box.MINIMAL, show_header=True, show_lines=True)\n        table.add_column(\"context_name\", style=\"i\")\n        table.add_column(\"details\")\n\n        for context_name, context_summary in self.__root__.items():\n\n            table.add_row(context_name, context_summary.create_renderable(**config))\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/data_types/","title":"data_types","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.core_types</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of kiara.metadata.MetadataModel. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara/models/data_types/#kiara.models.data_types-classes","title":"Classes","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel","title":"<code>DictModel</code>","text":"<p>         Bases: <code>BaseModel</code>, <code>Mapping</code></p> <p>A dict implentation that contains (optional) schema information of the dicts items.</p> Source code in <code>kiara/models/data_types.py</code> <pre><code>class DictModel(BaseModel, Mapping):\n\"\"\"A dict implentation that contains (optional) schema information of the dicts items.\"\"\"\n\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n\n    dict_data: Dict[str, Any] = Field(description=\"The data.\")\n    data_schema: Dict[str, Any] = Field(description=\"The schema.\")\n    python_class: PythonClass = Field(\n        description=\"The python class of which model instances are created. This is mostly meant as a hint for client applications.\"\n    )\n\n    _size_cache: int = PrivateAttr(default=None)\n    _hash_cache: int = PrivateAttr(default=None)\n    _data_hash: int = PrivateAttr(default=None)\n    _schema_hash: int = PrivateAttr(default=None)\n    _value_hash: int = PrivateAttr(default=None)\n\n    @property\n    def size(self):\n        if self._size_cache is not None:\n            return self._size_cache\n\n        self._size_cache = len(self.dict_data) + len(self.data_schema)\n        return self._size_cache\n\n    @property\n    def data_hash(self) -&gt; int:\n        if self._data_hash is not None:\n            return self._data_hash\n\n        self._data_hash = compute_cid(self.dict_data)\n        return self._data_hash\n\n    @property\n    def schema_hash(self) -&gt; int:\n        if self._schema_hash is not None:\n            return self._schema_hash\n\n        self._schema_hash = compute_cid(self.data_schema)\n        return self._schema_hash\n\n    @property\n    def value_hash(self) -&gt; int:\n        if self._value_hash is not None:\n            return self._value_hash\n\n        obj = {\"data\": self.data_hash, \"data_schema\": self.schema_hash}\n        self._value_hash = compute_cid(obj)\n        return self._value_hash\n\n    def __getitem__(self, item):\n        return self.dict_data.__getitem__(item)\n\n    def __iter__(self):\n        return self.dict_data.__iter__()\n\n    def __len__(self):\n        return self.dict_data.__len__()\n</code></pre>"},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.dict_data","title":"<code>dict_data: Dict[str, Any] = Field(description='The data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.data_schema","title":"<code>data_schema: Dict[str, Any] = Field(description='The schema.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.python_class","title":"<code>python_class: PythonClass = Field(description='The python class of which model instances are created. This is mostly meant as a hint for client applications.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.size","title":"<code>size</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.data_hash","title":"<code>data_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.schema_hash","title":"<code>schema_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.value_hash","title":"<code>value_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/data_types.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n</code></pre>"},{"location":"reference/kiara/models/data_types/#kiara.models.data_types.DictModel.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/data_types/#kiara.models.data_types-functions","title":"Functions","text":""},{"location":"reference/kiara/models/documentation/","title":"documentation","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel","title":"<code>AuthorModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Details about an author of a resource.</p> Source code in <code>kiara/models/documentation.py</code> <pre><code>class AuthorModel(BaseModel):\n\"\"\"Details about an author of a resource.\"\"\"\n\n    class Config:\n        title = \"Author\"\n\n    name: str = Field(description=\"The full name of the author.\")\n    email: Union[EmailStr, None] = Field(\n        description=\"The email address of the author\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel.name","title":"<code>name: str = Field(description='The full name of the author.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel.email","title":"<code>email: Union[EmailStr, None] = Field(description='The email address of the author', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>class Config:\n    title = \"Author\"\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorModel.Config-attributes","title":"Attributes","text":"<code>title = 'Author'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel","title":"<code>LinkModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>A description and url for a reference of any kind.</p> Source code in <code>kiara/models/documentation.py</code> <pre><code>class LinkModel(BaseModel):\n\"\"\"A description and url for a reference of any kind.\"\"\"\n\n    class Config:\n        title = \"Link\"\n\n    url: AnyUrl = Field(description=\"The url.\")\n    desc: Union[str, None] = Field(\n        description=\"A short description of the link content.\",\n        default=DEFAULT_NO_DESC_VALUE,\n    )\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel.url","title":"<code>url: AnyUrl = Field(description='The url.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel.desc","title":"<code>desc: Union[str, None] = Field(description='A short description of the link content.', default=DEFAULT_NO_DESC_VALUE)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>class Config:\n    title = \"Link\"\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.LinkModel.Config-attributes","title":"Attributes","text":"<code>title = 'Link'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel","title":"<code>AuthorsMetadataModel</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Information about all authors of a resource.</p> Source code in <code>kiara/models/documentation.py</code> <pre><code>class AuthorsMetadataModel(KiaraModel):\n\"\"\"Information about all authors of a resource.\"\"\"\n\n    _kiara_model_id = \"metadata.authors\"\n\n    class Config:\n        extra = Extra.ignore\n        title = \"Authors\"\n\n    _metadata_key = \"origin\"\n\n    @classmethod\n    def from_class(cls, item_cls: Type):\n\n        data = get_metadata_for_python_module_or_class(item_cls)  # type: ignore\n        merged = merge_dicts(*data)\n        return cls.parse_obj(merged)\n\n    authors: List[AuthorModel] = Field(\n        description=\"The authors/creators of this item.\", default_factory=list\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Name\")\n        table.add_column(\"Email\", style=\"i\")\n\n        for author in reversed(self.authors):\n            if author.email:\n                authors: Tuple[str, Union[str, EmailStr]] = (author.name, author.email)\n            else:\n                authors = (author.name, \"\")\n            table.add_row(*authors)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel.authors","title":"<code>authors: List[AuthorModel] = Field(description='The authors/creators of this item.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>class Config:\n    extra = Extra.ignore\n    title = \"Authors\"\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel.Config-attributes","title":"Attributes","text":"<code>extra = Extra.ignore</code> <code>class-attribute</code> \u00b6 <code>title = 'Authors'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel-functions","title":"Functions","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel.from_class","title":"<code>from_class(item_cls: Type)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_class(cls, item_cls: Type):\n\n    data = get_metadata_for_python_module_or_class(item_cls)  # type: ignore\n    merged = merge_dicts(*data)\n    return cls.parse_obj(merged)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.AuthorsMetadataModel.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Name\")\n    table.add_column(\"Email\", style=\"i\")\n\n    for author in reversed(self.authors):\n        if author.email:\n            authors: Tuple[str, Union[str, EmailStr]] = (author.name, author.email)\n        else:\n            authors = (author.name, \"\")\n        table.add_row(*authors)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel","title":"<code>ContextMetadataModel</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Information about the context of a resource.</p> Source code in <code>kiara/models/documentation.py</code> <pre><code>class ContextMetadataModel(KiaraModel):\n\"\"\"Information about the context of a resource.\"\"\"\n\n    _kiara_model_id = \"metadata.context\"\n\n    class Config:\n        extra = Extra.ignore\n        title = \"Context\"\n\n    @classmethod\n    def from_class(cls, item_cls: Type):\n\n        data = get_metadata_for_python_module_or_class(item_cls)  # type: ignore\n        merged = merge_dicts(*data)\n        return cls.parse_obj(merged)\n\n    _metadata_key = \"properties\"\n\n    references: Dict[str, LinkModel] = Field(\n        description=\"References for the item.\", default_factory=dict\n    )\n    tags: List[str] = Field(\n        description=\"A list of tags for the item.\", default_factory=list\n    )\n    labels: Dict[str, str] = Field(\n        description=\"A list of labels for the item.\", default_factory=dict\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n\n        if self.tags:\n            table.add_row(\"Tags\", \", \".join(self.tags))\n        if self.labels:\n            labels = []\n            for k, v in self.labels.items():\n                labels.append(f\"[i]{k}[/i]: {v}\")\n            table.add_row(\"Labels\", \"\\n\".join(labels))\n\n        if self.references:\n            references = []\n            for _k, _v in self.references.items():\n                link = f\"[link={_v.url}]{_v.url}[/link]\"\n                references.append(f\"[i]{_k}[/i]: {link}\")\n            table.add_row(\"References\", \"\\n\".join(references))\n\n        return table\n\n    def add_reference(\n        self,\n        ref_type: str,\n        url: str,\n        desc: Union[str, None] = None,\n        force: bool = False,\n    ):\n\n        if ref_type in self.references.keys() and not force:\n            raise Exception(f\"Reference of type '{ref_type}' already present.\")\n        link = LinkModel(url=url, desc=desc)\n        self.references[ref_type] = link\n\n    def get_url_for_reference(self, ref: str) -&gt; Union[str, None]:\n\n        link = self.references.get(ref, None)\n        if not link:\n            return None\n\n        return link.url\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.references","title":"<code>references: Dict[str, LinkModel] = Field(description='References for the item.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.tags","title":"<code>tags: List[str] = Field(description='A list of tags for the item.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.labels","title":"<code>labels: Dict[str, str] = Field(description='A list of labels for the item.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>class Config:\n    extra = Extra.ignore\n    title = \"Context\"\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.Config-attributes","title":"Attributes","text":"<code>extra = Extra.ignore</code> <code>class-attribute</code> \u00b6 <code>title = 'Context'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel-functions","title":"Functions","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.from_class","title":"<code>from_class(item_cls: Type)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_class(cls, item_cls: Type):\n\n    data = get_metadata_for_python_module_or_class(item_cls)  # type: ignore\n    merged = merge_dicts(*data)\n    return cls.parse_obj(merged)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Key\", style=\"i\")\n    table.add_column(\"Value\")\n\n    if self.tags:\n        table.add_row(\"Tags\", \", \".join(self.tags))\n    if self.labels:\n        labels = []\n        for k, v in self.labels.items():\n            labels.append(f\"[i]{k}[/i]: {v}\")\n        table.add_row(\"Labels\", \"\\n\".join(labels))\n\n    if self.references:\n        references = []\n        for _k, _v in self.references.items():\n            link = f\"[link={_v.url}]{_v.url}[/link]\"\n            references.append(f\"[i]{_k}[/i]: {link}\")\n        table.add_row(\"References\", \"\\n\".join(references))\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.add_reference","title":"<code>add_reference(ref_type: str, url: str, desc: Union[str, None] = None, force: bool = False)</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>def add_reference(\n    self,\n    ref_type: str,\n    url: str,\n    desc: Union[str, None] = None,\n    force: bool = False,\n):\n\n    if ref_type in self.references.keys() and not force:\n        raise Exception(f\"Reference of type '{ref_type}' already present.\")\n    link = LinkModel(url=url, desc=desc)\n    self.references[ref_type] = link\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.ContextMetadataModel.get_url_for_reference","title":"<code>get_url_for_reference(ref: str) -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>def get_url_for_reference(self, ref: str) -&gt; Union[str, None]:\n\n    link = self.references.get(ref, None)\n    if not link:\n        return None\n\n    return link.url\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel","title":"<code>DocumentationMetadataModel</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Documentation about a resource.</p> Source code in <code>kiara/models/documentation.py</code> <pre><code>class DocumentationMetadataModel(KiaraModel):\n\"\"\"Documentation about a resource.\"\"\"\n\n    class Config:\n        title = \"Documentation\"\n\n    _kiara_model_id = \"metadata.documentation\"\n\n    _metadata_key = \"documentation\"\n\n    @classmethod\n    def from_class_doc(cls, item_cls: Type):\n        doc = item_cls.__doc__\n\n        if not doc:\n            doc = DEFAULT_NO_DESC_VALUE\n\n        doc = inspect.cleandoc(doc)\n        return cls.from_string(doc)\n\n    @classmethod\n    def from_function(cls, func: Callable):\n\n        doc = func.__doc__\n\n        if not doc:\n            doc = DEFAULT_NO_DESC_VALUE\n\n        doc = inspect.cleandoc(doc)\n        return cls.from_string(doc)\n\n    @classmethod\n    def from_string(cls, doc: Union[str, None]):\n\n        if not doc:\n            doc = DEFAULT_NO_DESC_VALUE\n\n        if \"\\n\" in doc:\n            desc, doc = doc.split(\"\\n\", maxsplit=1)\n        else:\n            desc = doc\n            doc = None\n\n        if doc:\n            doc = doc.strip()\n\n        return cls(description=desc.strip(), doc=doc)\n\n    @classmethod\n    def from_dict(cls, data: Mapping):\n\n        doc = data.get(\"doc\", None)\n        desc = data.get(\"description\", None)\n        if desc is None:\n            desc = data.get(\"desc\", None)\n\n        if not doc and not desc:\n            return cls.from_string(DEFAULT_NO_DESC_VALUE)\n        elif doc and not desc:\n            return cls.from_string(doc)\n        elif desc and not doc:\n            return cls.from_string(desc)\n        else:\n            return cls(description=desc, doc=doc)\n\n    @classmethod\n    def create(cls, item: Union[Any, None] = None):\n\n        if not item:\n            return cls.from_string(DEFAULT_NO_DESC_VALUE)\n        elif isinstance(item, DocumentationMetadataModel):\n            return item\n        elif isinstance(item, Mapping):\n            return cls.from_dict(item)\n        if isinstance(item, type):\n            return cls.from_class_doc(item)\n        elif isinstance(item, str):\n            return cls.from_string(item)\n        else:\n            raise TypeError(f\"Can't create documentation from type '{type(item)}'.\")\n\n    description: str = Field(\n        description=\"Short description of the item.\", default=DEFAULT_NO_DESC_VALUE\n    )\n    doc: Union[str, None] = Field(\n        description=\"Detailed documentation of the item (in markdown).\", default=None\n    )\n\n    @property\n    def is_set(self) -&gt; bool:\n        if self.description and self.description != DEFAULT_NO_DESC_VALUE:\n            return True\n        else:\n            return False\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.full_doc\n\n    @property\n    def full_doc(self):\n\n        if self.doc:\n            return f\"{self.description}\\n\\n{self.doc}\"\n        else:\n            return self.description\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        return Markdown(self.full_doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.description","title":"<code>description: str = Field(description='Short description of the item.', default=DEFAULT_NO_DESC_VALUE)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.doc","title":"<code>doc: Union[str, None] = Field(description='Detailed documentation of the item (in markdown).', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.is_set","title":"<code>is_set: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.full_doc","title":"<code>full_doc</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel-classes","title":"Classes","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>class Config:\n    title = \"Documentation\"\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.Config-attributes","title":"Attributes","text":"<code>title = 'Documentation'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel-functions","title":"Functions","text":""},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.from_class_doc","title":"<code>from_class_doc(item_cls: Type)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_class_doc(cls, item_cls: Type):\n    doc = item_cls.__doc__\n\n    if not doc:\n        doc = DEFAULT_NO_DESC_VALUE\n\n    doc = inspect.cleandoc(doc)\n    return cls.from_string(doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.from_function","title":"<code>from_function(func: Callable)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_function(cls, func: Callable):\n\n    doc = func.__doc__\n\n    if not doc:\n        doc = DEFAULT_NO_DESC_VALUE\n\n    doc = inspect.cleandoc(doc)\n    return cls.from_string(doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.from_string","title":"<code>from_string(doc: Union[str, None])</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_string(cls, doc: Union[str, None]):\n\n    if not doc:\n        doc = DEFAULT_NO_DESC_VALUE\n\n    if \"\\n\" in doc:\n        desc, doc = doc.split(\"\\n\", maxsplit=1)\n    else:\n        desc = doc\n        doc = None\n\n    if doc:\n        doc = doc.strip()\n\n    return cls(description=desc.strip(), doc=doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.from_dict","title":"<code>from_dict(data: Mapping)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Mapping):\n\n    doc = data.get(\"doc\", None)\n    desc = data.get(\"description\", None)\n    if desc is None:\n        desc = data.get(\"desc\", None)\n\n    if not doc and not desc:\n        return cls.from_string(DEFAULT_NO_DESC_VALUE)\n    elif doc and not desc:\n        return cls.from_string(doc)\n    elif desc and not doc:\n        return cls.from_string(desc)\n    else:\n        return cls(description=desc, doc=doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.create","title":"<code>create(item: Union[Any, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>@classmethod\ndef create(cls, item: Union[Any, None] = None):\n\n    if not item:\n        return cls.from_string(DEFAULT_NO_DESC_VALUE)\n    elif isinstance(item, DocumentationMetadataModel):\n        return item\n    elif isinstance(item, Mapping):\n        return cls.from_dict(item)\n    if isinstance(item, type):\n        return cls.from_class_doc(item)\n    elif isinstance(item, str):\n        return cls.from_string(item)\n    else:\n        raise TypeError(f\"Can't create documentation from type '{type(item)}'.\")\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation.DocumentationMetadataModel.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/documentation.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    return Markdown(self.full_doc)\n</code></pre>"},{"location":"reference/kiara/models/documentation/#kiara.models.documentation-functions","title":"Functions","text":""},{"location":"reference/kiara/models/filesystem/","title":"filesystem","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS","title":"<code>FILE_BUNDLE_IMPORT_AVAILABLE_COLUMNS = ['id', 'rel_path', 'mime_type', 'size', 'content', 'file_name']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem-classes","title":"Classes","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel","title":"<code>FileModel</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Describes properties for the 'file' value type.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>class FileModel(KiaraModel):\n\"\"\"Describes properties for the 'file' value type.\"\"\"\n\n    _kiara_model_id = \"instance.data.file\"\n\n    @classmethod\n    def load_file(\n        cls,\n        source: str,\n        file_name: Union[str, None] = None,\n        # import_time: Optional[datetime.datetime] = None,\n    ):\n\"\"\"Utility method to read metadata of a file from disk.\"\"\"\n\n        import mimetypes\n\n        import filetype\n\n        if not source:\n            raise ValueError(\"No source path provided.\")\n\n        if not os.path.exists(os.path.realpath(source)):\n            raise ValueError(f\"Path does not exist: {source}\")\n\n        if not os.path.isfile(os.path.realpath(source)):\n            raise ValueError(f\"Path is not a file: {source}\")\n\n        if file_name is None:\n            file_name = os.path.basename(source)\n\n        path: str = os.path.abspath(source)\n        # if import_time:\n        #     file_import_time = import_time\n        # else:\n        #     file_import_time = datetime.datetime.now()  # TODO: timezone\n\n        file_stats = os.stat(path)\n        size = file_stats.st_size\n\n        r = mimetypes.guess_type(path)\n        if r[0] is not None:\n            mime_type = r[0]\n        else:\n            _mime_type = filetype.guess(path)\n            if not _mime_type:\n                mime_type = \"application/octet-stream\"\n            else:\n                mime_type = _mime_type.MIME\n\n        m = FileModel(\n            # import_time=file_import_time,\n            mime_type=mime_type,\n            size=size,\n            file_name=file_name,\n        )\n        m._path = path\n        return m\n\n    # import_time: datetime.datetime = Field(\n    #     description=\"The time when the file was imported.\"\n    # )\n    mime_type: str = Field(description=\"The mime type of the file.\")\n    file_name: str = Field(\"The name of the file.\")\n    size: int = Field(description=\"The size of the file.\")\n    metadata: Dict[str, Any] = Field(\n        description=\"Additional, ustructured, user-defined metadata.\",\n        default_factory=dict,\n    )\n\n    _path: Union[str, None] = PrivateAttr(default=None)\n    _file_hash: Union[str, None] = PrivateAttr(default=None)\n    _file_cid: Union[CID, None] = PrivateAttr(default=None)\n\n    # @validator(\"path\")\n    # def ensure_abs_path(cls, value):\n    #     return os.path.abspath(value)\n\n    @property\n    def path(self) -&gt; str:\n        if self._path is None:\n            raise Exception(\"File path not set for file model.\")\n        return self._path\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        data = {\n            \"file_name\": self.file_name,\n            \"file_cid\": self.file_cid,\n        }\n        return data\n\n    # def get_id(self) -&gt; str:\n    #     return self.path\n\n    def get_category_alias(self) -&gt; str:\n        return \"instance.file_model\"\n\n    def copy_file(self, target: str, new_name: Union[str, None] = None) -&gt; \"FileModel\":\n\n        target_path: str = os.path.abspath(target)\n        os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n        shutil.copy2(self.path, target_path)\n        fm = FileModel.load_file(target, file_name=new_name)\n\n        if self._file_hash is not None:\n            fm._file_hash = self._file_hash\n\n        return fm\n\n    @property\n    def file_hash(self) -&gt; str:\n\n        if self._file_hash is not None:\n            return self._file_hash\n\n        self._file_hash = str(self.file_cid)\n        return self._file_hash\n\n    @property\n    def file_cid(self) -&gt; CID:\n\n        if self._file_cid is not None:\n            return self._file_cid\n\n        # TODO: auto-set codec?\n        self._file_cid = compute_cid_from_file(file=self.path, codec=\"raw\")\n        return self._file_cid\n\n    @property\n    def file_name_without_extension(self) -&gt; str:\n\n        return self.file_name.split(\".\")[0]\n\n    def read_text(self, max_lines: int = -1) -&gt; str:\n\"\"\"Read the content of a file.\"\"\"\n\n        with open(self.path, \"rt\") as f:\n            if max_lines &lt;= 0:\n                content = f.read()\n            else:\n                content = \"\".join((next(f) for x in range(max_lines)))\n        return content\n\n    def read_bytes(self, length: int = -1) -&gt; bytes:\n\"\"\"Read the content of a file.\"\"\"\n\n        with open(self.path, \"rb\") as f:\n            if length &lt;= 0:\n                content = f.read()\n            else:\n                content = f.read(length)\n        return content\n\n    def __repr__(self):\n        return f\"FileModel(name={self.file_name})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.mime_type","title":"<code>mime_type: str = Field(description='The mime type of the file.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.file_name","title":"<code>file_name: str = Field('The name of the file.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.size","title":"<code>size: int = Field(description='The size of the file.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.metadata","title":"<code>metadata: Dict[str, Any] = Field(description='Additional, ustructured, user-defined metadata.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.path","title":"<code>path: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.file_hash","title":"<code>file_hash: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.file_cid","title":"<code>file_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.file_name_without_extension","title":"<code>file_name_without_extension: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel-functions","title":"Functions","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.load_file","title":"<code>load_file(source: str, file_name: Union[str, None] = None)</code>  <code>classmethod</code>","text":"<p>Utility method to read metadata of a file from disk.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>@classmethod\ndef load_file(\n    cls,\n    source: str,\n    file_name: Union[str, None] = None,\n    # import_time: Optional[datetime.datetime] = None,\n):\n\"\"\"Utility method to read metadata of a file from disk.\"\"\"\n\n    import mimetypes\n\n    import filetype\n\n    if not source:\n        raise ValueError(\"No source path provided.\")\n\n    if not os.path.exists(os.path.realpath(source)):\n        raise ValueError(f\"Path does not exist: {source}\")\n\n    if not os.path.isfile(os.path.realpath(source)):\n        raise ValueError(f\"Path is not a file: {source}\")\n\n    if file_name is None:\n        file_name = os.path.basename(source)\n\n    path: str = os.path.abspath(source)\n    # if import_time:\n    #     file_import_time = import_time\n    # else:\n    #     file_import_time = datetime.datetime.now()  # TODO: timezone\n\n    file_stats = os.stat(path)\n    size = file_stats.st_size\n\n    r = mimetypes.guess_type(path)\n    if r[0] is not None:\n        mime_type = r[0]\n    else:\n        _mime_type = filetype.guess(path)\n        if not _mime_type:\n            mime_type = \"application/octet-stream\"\n        else:\n            mime_type = _mime_type.MIME\n\n    m = FileModel(\n        # import_time=file_import_time,\n        mime_type=mime_type,\n        size=size,\n        file_name=file_name,\n    )\n    m._path = path\n    return m\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.get_category_alias","title":"<code>get_category_alias() -&gt; str</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def get_category_alias(self) -&gt; str:\n    return \"instance.file_model\"\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.copy_file","title":"<code>copy_file(target: str, new_name: Union[str, None] = None) -&gt; FileModel</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def copy_file(self, target: str, new_name: Union[str, None] = None) -&gt; \"FileModel\":\n\n    target_path: str = os.path.abspath(target)\n    os.makedirs(os.path.dirname(target_path), exist_ok=True)\n\n    shutil.copy2(self.path, target_path)\n    fm = FileModel.load_file(target, file_name=new_name)\n\n    if self._file_hash is not None:\n        fm._file_hash = self._file_hash\n\n    return fm\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.read_text","title":"<code>read_text(max_lines: int = -1) -&gt; str</code>","text":"<p>Read the content of a file.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>def read_text(self, max_lines: int = -1) -&gt; str:\n\"\"\"Read the content of a file.\"\"\"\n\n    with open(self.path, \"rt\") as f:\n        if max_lines &lt;= 0:\n            content = f.read()\n        else:\n            content = \"\".join((next(f) for x in range(max_lines)))\n    return content\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileModel.read_bytes","title":"<code>read_bytes(length: int = -1) -&gt; bytes</code>","text":"<p>Read the content of a file.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>def read_bytes(self, length: int = -1) -&gt; bytes:\n\"\"\"Read the content of a file.\"\"\"\n\n    with open(self.path, \"rb\") as f:\n        if length &lt;= 0:\n            content = f.read()\n        else:\n            content = f.read(length)\n    return content\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FolderImportConfig","title":"<code>FolderImportConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>class FolderImportConfig(BaseModel):\n\n    include_files: Union[List[str], None] = Field(\n        description=\"A list of strings, include all files where the filename ends with that string.\",\n        default=None,\n    )\n    exclude_dirs: Union[List[str], None] = Field(\n        description=\"A list of strings, exclude all folders whose name ends with that string.\",\n        default=None,\n    )\n    exclude_files: Union[List[str], None] = Field(\n        description=f\"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: {DEFAULT_EXCLUDE_FILES}.\",\n        default=DEFAULT_EXCLUDE_FILES,\n    )\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FolderImportConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FolderImportConfig.include_files","title":"<code>include_files: Union[List[str], None] = Field(description='A list of strings, include all files where the filename ends with that string.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FolderImportConfig.exclude_dirs","title":"<code>exclude_dirs: Union[List[str], None] = Field(description='A list of strings, exclude all folders whose name ends with that string.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FolderImportConfig.exclude_files","title":"<code>exclude_files: Union[List[str], None] = Field(description=f\"A list of strings, exclude all files that match those (takes precedence over 'include_files'). Defaults to: {DEFAULT_EXCLUDE_FILES}.\", default=DEFAULT_EXCLUDE_FILES)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle","title":"<code>FileBundle</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Describes properties for the 'file_bundle' value type.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>class FileBundle(KiaraModel):\n\"\"\"Describes properties for the 'file_bundle' value type.\"\"\"\n\n    _kiara_model_id = \"instance.data.file_bundle\"\n\n    @classmethod\n    def create_tmp_dir(self) -&gt; Path:\n\"\"\"Utility method to create a temp folder that gets deleted when kiara exits.\"\"\"\n\n        temp_f = tempfile.mkdtemp()\n\n        def cleanup():\n            shutil.rmtree(temp_f, ignore_errors=True)\n\n        atexit.register(cleanup)\n\n        return Path(temp_f)\n\n    @classmethod\n    def import_folder(\n        cls,\n        source: str,\n        bundle_name: Union[str, None] = None,\n        import_config: Union[None, Mapping[str, Any], FolderImportConfig] = None,\n        # import_time: Optional[datetime.datetime] = None,\n    ) -&gt; \"FileBundle\":\n\n        if not source:\n            raise ValueError(\"No source path provided.\")\n\n        if not os.path.exists(os.path.realpath(source)):\n            raise ValueError(f\"Path does not exist: {source}\")\n\n        if not os.path.isdir(os.path.realpath(source)):\n            raise ValueError(f\"Path is not a folder: {source}\")\n\n        if source.endswith(os.path.sep):\n            source = source[0:-1]\n\n        abs_path = os.path.abspath(source)\n\n        if import_config is None:\n            _import_config = FolderImportConfig()\n        elif isinstance(import_config, Mapping):\n            _import_config = FolderImportConfig(**import_config)\n        elif isinstance(import_config, FolderImportConfig):\n            _import_config = import_config\n        else:\n            raise TypeError(\n                f\"Invalid type for folder import config: {type(import_config)}.\"\n            )\n\n        included_files: Dict[str, FileModel] = {}\n        exclude_dirs = _import_config.exclude_dirs\n        invalid_extensions = _import_config.exclude_files\n\n        valid_extensions = _import_config.include_files\n\n        # if import_time:\n        #     bundle_import_time = import_time\n        # else:\n        #     bundle_import_time = datetime.datetime.now()  # TODO: timezone\n\n        sum_size = 0\n\n        def include_file(filename: str) -&gt; bool:\n\n            if invalid_extensions and any(\n                filename.endswith(ext) for ext in invalid_extensions\n            ):\n                return False\n            if not valid_extensions:\n                return True\n            else:\n                return any(filename.endswith(ext) for ext in valid_extensions)\n\n        for root, dirnames, filenames in os.walk(abs_path, topdown=True):\n\n            if exclude_dirs:\n                dirnames[:] = [d for d in dirnames if d not in exclude_dirs]\n\n            for filename in [\n                f\n                for f in filenames\n                if os.path.isfile(os.path.join(root, f)) and include_file(f)\n            ]:\n\n                full_path = os.path.join(root, filename)\n                rel_path = os.path.relpath(full_path, abs_path)\n\n                file_model = FileModel.load_file(full_path)\n                sum_size = sum_size + file_model.size\n                included_files[rel_path] = file_model\n\n        if bundle_name is None:\n            bundle_name = os.path.basename(source)\n\n        bundle = FileBundle.create_from_file_models(\n            files=included_files,\n            path=abs_path,\n            bundle_name=bundle_name,\n            sum_size=sum_size,\n        )\n        return bundle\n\n    @classmethod\n    def create_from_file_models(\n        cls,\n        files: Mapping[str, FileModel],\n        bundle_name: str,\n        path: Union[str, None] = None,\n        sum_size: Union[int, None] = None,\n        # import_time: Optional[datetime.datetime] = None,\n    ) -&gt; \"FileBundle\":\n\n        # if import_time:\n        #     bundle_import_time = import_time\n        # else:\n        #     bundle_import_time = datetime.datetime.now()  # TODO: timezone\n\n        result: Dict[str, Any] = {}\n\n        result[\"included_files\"] = files\n\n        # result[\"import_time\"] = datetime.datetime.now().isoformat()\n        result[\"number_of_files\"] = len(files)\n        result[\"bundle_name\"] = bundle_name\n        # result[\"import_time\"] = bundle_import_time\n\n        if sum_size is None:\n            sum_size = 0\n            for f in files.values():\n                sum_size = sum_size + f.size\n        result[\"size\"] = sum_size\n\n        bundle = FileBundle(**result)\n        bundle._path = path\n        return bundle\n\n    _file_bundle_hash: Union[int, None] = PrivateAttr(default=None)\n\n    bundle_name: str = Field(description=\"The name of this bundle.\")\n    # import_time: datetime.datetime = Field(\n    #     description=\"The time when the file bundle was imported.\"\n    # )\n    number_of_files: int = Field(\n        description=\"How many files are included in this bundle.\"\n    )\n    included_files: Dict[str, FileModel] = Field(\n        description=\"A map of all the included files, incl. their properties. Uses the relative path of each file as key.\"\n    )\n    size: int = Field(description=\"The size of all files in this folder, combined.\")\n    metadata: Dict[str, Any] = Field(\n        description=\"Additional, ustructured, user-defined metadata.\",\n        default_factory=dict,\n    )\n\n    _path: Union[str, None] = PrivateAttr(default=None)\n\n    @property\n    def path(self) -&gt; str:\n        if self._path is None:\n            # TODO: better explanation, offer remedy like copying into temp folder\n            raise Exception(\n                \"File bundle path not set, it appears this bundle is comprised of symlinks only.\"\n            )\n        return self._path\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.file_bundle_hash)\n\n    # @property\n    # def model_data_hash(self) -&gt; int:\n    #     return self.file_bundle_hash\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n\n        return {\n            \"bundle_name\": self.bundle_name,\n            \"included_files\": {\n                k: v.instance_cid for k, v in self.included_files.items()\n            },\n        }\n\n    def get_relative_path(self, file: FileModel):\n        return os.path.relpath(file.path, self.path)\n\n    def read_text_file_contents(self, ignore_errors: bool = False) -&gt; Mapping[str, str]:\n\n        content_dict: Dict[str, str] = {}\n\n        def read_file(rel_path: str, full_path: str):\n            with open(full_path, encoding=\"utf-8\") as f:\n                try:\n                    content = f.read()\n                    content_dict[rel_path] = content  # type: ignore\n                except Exception as e:\n                    if ignore_errors:\n                        log_message(f\"Can't read file: {e}\")\n                        logger.warning(\"ignore.file\", path=full_path, reason=str(e))\n                    else:\n                        raise Exception(f\"Can't read file (as text) '{full_path}: {e}\")\n\n        # TODO: common ignore files and folders\n        for rel_path, f in self.included_files.items():\n            if f._path:\n                path = f._path\n            else:\n                path = self.get_relative_path(f)\n            read_file(rel_path=rel_path, full_path=path)\n\n        return content_dict\n\n    @property\n    def file_bundle_hash(self) -&gt; int:\n\n        # TODO: use sha256?\n        if self._file_bundle_hash is not None:\n            return self._file_bundle_hash\n\n        obj = {k: v.file_hash for k, v in self.included_files.items()}\n        h = DeepHash(obj, hasher=KIARA_HASH_FUNCTION)\n\n        self._file_bundle_hash = h[obj]\n        return self._file_bundle_hash\n\n    def copy_bundle(\n        self, target_path: str, bundle_name: Union[str, None] = None\n    ) -&gt; \"FileBundle\":\n\n        if target_path == self.path:\n            raise Exception(f\"Target path and current path are the same: {target_path}\")\n\n        result = {}\n        for rel_path, item in self.included_files.items():\n            _target_path = os.path.join(target_path, rel_path)\n            new_fm = item.copy_file(_target_path)\n            result[rel_path] = new_fm\n\n        if bundle_name is None:\n            bundle_name = os.path.basename(target_path)\n\n        fb = FileBundle.create_from_file_models(\n            files=result,\n            bundle_name=bundle_name,\n            path=target_path,\n            sum_size=self.size,\n            # import_time=self.import_time,\n        )\n        if self._file_bundle_hash is not None:\n            fb._file_bundle_hash = self._file_bundle_hash\n\n        return fb\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        show_bundle_hash = config.get(\"show_bundle_hash\", False)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\")\n        table.add_column(\"value\", style=\"i\")\n\n        table.add_row(\"bundle name\", self.bundle_name)\n        # table.add_row(\"import_time\", str(self.import_time))\n        table.add_row(\"number_of_files\", str(self.number_of_files))\n        table.add_row(\"size\", str(self.size))\n        if show_bundle_hash:\n            table.add_row(\"bundle_hash\", str(self.file_bundle_hash))\n\n        content = self._create_content_table(**config)\n        table.add_row(\"included files\", content)\n\n        return table\n\n    def _create_content_table(self, **render_config: Any) -&gt; Table:\n\n        # show_content = render_config.get(\"show_content_preview\", False)\n        max_no_included_files = render_config.get(\"max_no_files\", 40)\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"(relative) path\")\n        table.add_column(\"size\")\n        # if show_content:\n        #     table.add_column(\"content preview\")\n\n        if (\n            max_no_included_files &lt; 0\n            or len(self.included_files) &lt;= max_no_included_files\n        ):\n            for f, model in self.included_files.items():\n                row = [f, str(model.size)]\n                table.add_row(*row)\n        else:\n            files = list(self.included_files.keys())\n            half = int((max_no_included_files - 1) / 2)\n            head = files[0:half]\n            tail = files[-1 * half :]\n            for rel_path in head:\n                model = self.included_files[rel_path]\n                row = [rel_path, str(model.size)]\n                table.add_row(*row)\n            table.add_row(\"   ... output skipped ...\", \"\")\n            table.add_row(\"   ... output skipped ...\", \"\")\n            for rel_path in tail:\n                model = self.included_files[rel_path]\n                row = [rel_path, str(model.size)]\n                table.add_row(*row)\n\n        return table\n\n    def __repr__(self):\n        return f\"FileBundle(name={self.bundle_name})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.bundle_name","title":"<code>bundle_name: str = Field(description='The name of this bundle.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.number_of_files","title":"<code>number_of_files: int = Field(description='How many files are included in this bundle.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.included_files","title":"<code>included_files: Dict[str, FileModel] = Field(description='A map of all the included files, incl. their properties. Uses the relative path of each file as key.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.size","title":"<code>size: int = Field(description='The size of all files in this folder, combined.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.metadata","title":"<code>metadata: Dict[str, Any] = Field(description='Additional, ustructured, user-defined metadata.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.path","title":"<code>path: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.file_bundle_hash","title":"<code>file_bundle_hash: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle-functions","title":"Functions","text":""},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.create_tmp_dir","title":"<code>create_tmp_dir() -&gt; Path</code>  <code>classmethod</code>","text":"<p>Utility method to create a temp folder that gets deleted when kiara exits.</p> Source code in <code>kiara/models/filesystem.py</code> <pre><code>@classmethod\ndef create_tmp_dir(self) -&gt; Path:\n\"\"\"Utility method to create a temp folder that gets deleted when kiara exits.\"\"\"\n\n    temp_f = tempfile.mkdtemp()\n\n    def cleanup():\n        shutil.rmtree(temp_f, ignore_errors=True)\n\n    atexit.register(cleanup)\n\n    return Path(temp_f)\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.import_folder","title":"<code>import_folder(source: str, bundle_name: Union[str, None] = None, import_config: Union[None, Mapping[str, Any], FolderImportConfig] = None) -&gt; FileBundle</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>@classmethod\ndef import_folder(\n    cls,\n    source: str,\n    bundle_name: Union[str, None] = None,\n    import_config: Union[None, Mapping[str, Any], FolderImportConfig] = None,\n    # import_time: Optional[datetime.datetime] = None,\n) -&gt; \"FileBundle\":\n\n    if not source:\n        raise ValueError(\"No source path provided.\")\n\n    if not os.path.exists(os.path.realpath(source)):\n        raise ValueError(f\"Path does not exist: {source}\")\n\n    if not os.path.isdir(os.path.realpath(source)):\n        raise ValueError(f\"Path is not a folder: {source}\")\n\n    if source.endswith(os.path.sep):\n        source = source[0:-1]\n\n    abs_path = os.path.abspath(source)\n\n    if import_config is None:\n        _import_config = FolderImportConfig()\n    elif isinstance(import_config, Mapping):\n        _import_config = FolderImportConfig(**import_config)\n    elif isinstance(import_config, FolderImportConfig):\n        _import_config = import_config\n    else:\n        raise TypeError(\n            f\"Invalid type for folder import config: {type(import_config)}.\"\n        )\n\n    included_files: Dict[str, FileModel] = {}\n    exclude_dirs = _import_config.exclude_dirs\n    invalid_extensions = _import_config.exclude_files\n\n    valid_extensions = _import_config.include_files\n\n    # if import_time:\n    #     bundle_import_time = import_time\n    # else:\n    #     bundle_import_time = datetime.datetime.now()  # TODO: timezone\n\n    sum_size = 0\n\n    def include_file(filename: str) -&gt; bool:\n\n        if invalid_extensions and any(\n            filename.endswith(ext) for ext in invalid_extensions\n        ):\n            return False\n        if not valid_extensions:\n            return True\n        else:\n            return any(filename.endswith(ext) for ext in valid_extensions)\n\n    for root, dirnames, filenames in os.walk(abs_path, topdown=True):\n\n        if exclude_dirs:\n            dirnames[:] = [d for d in dirnames if d not in exclude_dirs]\n\n        for filename in [\n            f\n            for f in filenames\n            if os.path.isfile(os.path.join(root, f)) and include_file(f)\n        ]:\n\n            full_path = os.path.join(root, filename)\n            rel_path = os.path.relpath(full_path, abs_path)\n\n            file_model = FileModel.load_file(full_path)\n            sum_size = sum_size + file_model.size\n            included_files[rel_path] = file_model\n\n    if bundle_name is None:\n        bundle_name = os.path.basename(source)\n\n    bundle = FileBundle.create_from_file_models(\n        files=included_files,\n        path=abs_path,\n        bundle_name=bundle_name,\n        sum_size=sum_size,\n    )\n    return bundle\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.create_from_file_models","title":"<code>create_from_file_models(files: Mapping[str, FileModel], bundle_name: str, path: Union[str, None] = None, sum_size: Union[int, None] = None) -&gt; FileBundle</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>@classmethod\ndef create_from_file_models(\n    cls,\n    files: Mapping[str, FileModel],\n    bundle_name: str,\n    path: Union[str, None] = None,\n    sum_size: Union[int, None] = None,\n    # import_time: Optional[datetime.datetime] = None,\n) -&gt; \"FileBundle\":\n\n    # if import_time:\n    #     bundle_import_time = import_time\n    # else:\n    #     bundle_import_time = datetime.datetime.now()  # TODO: timezone\n\n    result: Dict[str, Any] = {}\n\n    result[\"included_files\"] = files\n\n    # result[\"import_time\"] = datetime.datetime.now().isoformat()\n    result[\"number_of_files\"] = len(files)\n    result[\"bundle_name\"] = bundle_name\n    # result[\"import_time\"] = bundle_import_time\n\n    if sum_size is None:\n        sum_size = 0\n        for f in files.values():\n            sum_size = sum_size + f.size\n    result[\"size\"] = sum_size\n\n    bundle = FileBundle(**result)\n    bundle._path = path\n    return bundle\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.get_relative_path","title":"<code>get_relative_path(file: FileModel)</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def get_relative_path(self, file: FileModel):\n    return os.path.relpath(file.path, self.path)\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.read_text_file_contents","title":"<code>read_text_file_contents(ignore_errors: bool = False) -&gt; Mapping[str, str]</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def read_text_file_contents(self, ignore_errors: bool = False) -&gt; Mapping[str, str]:\n\n    content_dict: Dict[str, str] = {}\n\n    def read_file(rel_path: str, full_path: str):\n        with open(full_path, encoding=\"utf-8\") as f:\n            try:\n                content = f.read()\n                content_dict[rel_path] = content  # type: ignore\n            except Exception as e:\n                if ignore_errors:\n                    log_message(f\"Can't read file: {e}\")\n                    logger.warning(\"ignore.file\", path=full_path, reason=str(e))\n                else:\n                    raise Exception(f\"Can't read file (as text) '{full_path}: {e}\")\n\n    # TODO: common ignore files and folders\n    for rel_path, f in self.included_files.items():\n        if f._path:\n            path = f._path\n        else:\n            path = self.get_relative_path(f)\n        read_file(rel_path=rel_path, full_path=path)\n\n    return content_dict\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.copy_bundle","title":"<code>copy_bundle(target_path: str, bundle_name: Union[str, None] = None) -&gt; FileBundle</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def copy_bundle(\n    self, target_path: str, bundle_name: Union[str, None] = None\n) -&gt; \"FileBundle\":\n\n    if target_path == self.path:\n        raise Exception(f\"Target path and current path are the same: {target_path}\")\n\n    result = {}\n    for rel_path, item in self.included_files.items():\n        _target_path = os.path.join(target_path, rel_path)\n        new_fm = item.copy_file(_target_path)\n        result[rel_path] = new_fm\n\n    if bundle_name is None:\n        bundle_name = os.path.basename(target_path)\n\n    fb = FileBundle.create_from_file_models(\n        files=result,\n        bundle_name=bundle_name,\n        path=target_path,\n        sum_size=self.size,\n        # import_time=self.import_time,\n    )\n    if self._file_bundle_hash is not None:\n        fb._file_bundle_hash = self._file_bundle_hash\n\n    return fb\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem.FileBundle.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/filesystem.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    show_bundle_hash = config.get(\"show_bundle_hash\", False)\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\")\n    table.add_column(\"value\", style=\"i\")\n\n    table.add_row(\"bundle name\", self.bundle_name)\n    # table.add_row(\"import_time\", str(self.import_time))\n    table.add_row(\"number_of_files\", str(self.number_of_files))\n    table.add_row(\"size\", str(self.size))\n    if show_bundle_hash:\n        table.add_row(\"bundle_hash\", str(self.file_bundle_hash))\n\n    content = self._create_content_table(**config)\n    table.add_row(\"included files\", content)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/filesystem/#kiara.models.filesystem-functions","title":"Functions","text":""},{"location":"reference/kiara/models/python_class/","title":"python_class","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class-classes","title":"Classes","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass","title":"<code>PythonClass</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Python class and module information.</p> Source code in <code>kiara/models/python_class.py</code> <pre><code>class PythonClass(KiaraModel):\n\"\"\"Python class and module information.\"\"\"\n\n    _kiara_model_id = \"instance.wrapped_python_class\"\n\n    @classmethod\n    def from_class(cls, item_cls: Type, attach_context_metadata: bool = False):\n\n        cls_name = item_cls.__name__\n        module_name = item_cls.__module__\n\n        if module_name == \"builtins\":\n            full_name = cls_name\n        else:\n            full_name = f\"{item_cls.__module__}.{item_cls.__name__}\"\n\n        conf: Dict[str, Any] = {\n            \"python_class_name\": cls_name,\n            \"python_module_name\": module_name,\n            \"full_name\": full_name,\n        }\n\n        if attach_context_metadata:\n            raise NotImplementedError()\n            ctx_md = ContextMetadataModel.from_class(item_cls=item_cls)\n            conf[\"items\"] = ctx_md\n\n        result = PythonClass.construct(**conf)\n        result._cls_cache = item_cls\n        return result\n\n    python_class_name: str = Field(description=\"The name of the Python class.\")\n    python_module_name: str = Field(\n        description=\"The name of the Python module this class lives in.\"\n    )\n    full_name: str = Field(description=\"The full class namespace.\")\n\n    # context_metadata: Optional[ContextMetadataModel] = Field(\n    #     description=\"Context metadata for the class.\", default=None\n    # )\n\n    _module_cache: ModuleType = PrivateAttr(default=None)\n    _cls_cache: Type = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return self.full_name\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.full_name\n\n    def get_class(self) -&gt; Type:\n\n        if self._cls_cache is None:\n            m = self.get_python_module()\n            self._cls_cache = getattr(m, self.python_class_name)\n        return self._cls_cache\n\n    def get_python_module(self) -&gt; ModuleType:\n        if self._module_cache is None:\n            self._module_cache = importlib.import_module(self.python_module_name)\n        return self._module_cache\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.python_class_name","title":"<code>python_class_name: str = Field(description='The name of the Python class.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.python_module_name","title":"<code>python_module_name: str = Field(description='The name of the Python module this class lives in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.full_name","title":"<code>full_name: str = Field(description='The full class namespace.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass-functions","title":"Functions","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.from_class","title":"<code>from_class(item_cls: Type, attach_context_metadata: bool = False)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/python_class.py</code> <pre><code>@classmethod\ndef from_class(cls, item_cls: Type, attach_context_metadata: bool = False):\n\n    cls_name = item_cls.__name__\n    module_name = item_cls.__module__\n\n    if module_name == \"builtins\":\n        full_name = cls_name\n    else:\n        full_name = f\"{item_cls.__module__}.{item_cls.__name__}\"\n\n    conf: Dict[str, Any] = {\n        \"python_class_name\": cls_name,\n        \"python_module_name\": module_name,\n        \"full_name\": full_name,\n    }\n\n    if attach_context_metadata:\n        raise NotImplementedError()\n        ctx_md = ContextMetadataModel.from_class(item_cls=item_cls)\n        conf[\"items\"] = ctx_md\n\n    result = PythonClass.construct(**conf)\n    result._cls_cache = item_cls\n    return result\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.get_class","title":"<code>get_class() -&gt; Type</code>","text":"Source code in <code>kiara/models/python_class.py</code> <pre><code>def get_class(self) -&gt; Type:\n\n    if self._cls_cache is None:\n        m = self.get_python_module()\n        self._cls_cache = getattr(m, self.python_class_name)\n    return self._cls_cache\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.PythonClass.get_python_module","title":"<code>get_python_module() -&gt; ModuleType</code>","text":"Source code in <code>kiara/models/python_class.py</code> <pre><code>def get_python_module(self) -&gt; ModuleType:\n    if self._module_cache is None:\n        self._module_cache = importlib.import_module(self.python_module_name)\n    return self._module_cache\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance","title":"<code>KiaraModuleInstance</code>","text":"<p>         Bases: <code>PythonClass</code></p> Source code in <code>kiara/models/python_class.py</code> <pre><code>class KiaraModuleInstance(PythonClass):\n\n    _kiara_model_id: str = \"metadata.kiara_module_class\"\n\n    @classmethod\n    def from_module(cls, module: \"KiaraModule\"):\n\n        item_cls = module.__class__\n\n        cls_name = item_cls.__name__\n        module_name = item_cls.__module__\n        if module_name == \"builtins\":\n            full_name = cls_name\n        else:\n            full_name = f\"{item_cls.__module__}.{item_cls.__name__}\"\n\n        conf: Dict[str, Any] = {\n            \"python_class_name\": cls_name,\n            \"python_module_name\": module_name,\n            \"full_name\": full_name,\n        }\n\n        conf[\"module_config\"] = module.config\n        conf[\"inputs_schema\"] = module.inputs_schema\n        conf[\"outputs_schema\"] = module.outputs_schema\n\n        result = KiaraModuleInstance.construct(**conf)\n        result._cls_cache = item_cls\n        result._module_instance_cache = module\n        return result\n\n    module_config: Dict[str, Any] = Field(description=\"The module config.\")\n    inputs_schema: Dict[str, ValueSchema] = Field(\n        description=\"The schema for the module input(s).\"\n    )\n    outputs_schema: Dict[str, ValueSchema] = Field(\n        description=\"The schema for the module output(s).\"\n    )\n\n    _module_instance_cache: \"KiaraModule\" = PrivateAttr(default=None)\n\n    def get_kiara_module_instance(self) -&gt; \"KiaraModule\":\n\n        if self._module_instance_cache is not None:\n            return self._module_instance_cache\n\n        m_cls = self.get_class()\n        self._module_instance_cache = m_cls(module_config=self.module_config)\n        return self._module_instance_cache\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance.module_config","title":"<code>module_config: Dict[str, Any] = Field(description='The module config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance.inputs_schema","title":"<code>inputs_schema: Dict[str, ValueSchema] = Field(description='The schema for the module input(s).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance.outputs_schema","title":"<code>outputs_schema: Dict[str, ValueSchema] = Field(description='The schema for the module output(s).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance-functions","title":"Functions","text":""},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance.from_module","title":"<code>from_module(module: KiaraModule)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/python_class.py</code> <pre><code>@classmethod\ndef from_module(cls, module: \"KiaraModule\"):\n\n    item_cls = module.__class__\n\n    cls_name = item_cls.__name__\n    module_name = item_cls.__module__\n    if module_name == \"builtins\":\n        full_name = cls_name\n    else:\n        full_name = f\"{item_cls.__module__}.{item_cls.__name__}\"\n\n    conf: Dict[str, Any] = {\n        \"python_class_name\": cls_name,\n        \"python_module_name\": module_name,\n        \"full_name\": full_name,\n    }\n\n    conf[\"module_config\"] = module.config\n    conf[\"inputs_schema\"] = module.inputs_schema\n    conf[\"outputs_schema\"] = module.outputs_schema\n\n    result = KiaraModuleInstance.construct(**conf)\n    result._cls_cache = item_cls\n    result._module_instance_cache = module\n    return result\n</code></pre>"},{"location":"reference/kiara/models/python_class/#kiara.models.python_class.KiaraModuleInstance.get_kiara_module_instance","title":"<code>get_kiara_module_instance() -&gt; KiaraModule</code>","text":"Source code in <code>kiara/models/python_class.py</code> <pre><code>def get_kiara_module_instance(self) -&gt; \"KiaraModule\":\n\n    if self._module_instance_cache is not None:\n        return self._module_instance_cache\n\n    m_cls = self.get_class()\n    self._module_instance_cache = m_cls(module_config=self.module_config)\n    return self._module_instance_cache\n</code></pre>"},{"location":"reference/kiara/models/workflow/","title":"workflow","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow-classes","title":"Classes","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState","title":"<code>WorkflowState</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/workflow.py</code> <pre><code>class WorkflowState(KiaraModel):\n    @classmethod\n    def create_from_workflow(self, workflow: \"Workflow\"):\n\n        steps = list(workflow._steps.values())\n        inputs = dict(workflow.current_pipeline_inputs)\n        info = PipelineInfo.create_from_pipeline(\n            kiara=workflow._kiara, pipeline=workflow.pipeline\n        )\n        info._kiara = workflow._kiara\n\n        ws = WorkflowState(steps=steps, inputs=inputs, pipeline_info=info)\n        ws._kiara = workflow._kiara\n        ws.pipeline_info._kiara = workflow._kiara\n        return ws\n\n    steps: List[PipelineStep] = Field(\n        description=\"The current steps in the workflow.\", default_factory=list\n    )\n    inputs: Dict[str, uuid.UUID] = Field(\n        description=\"The current (pipeline) input values.\", default_factory=dict\n    )\n    pipeline_info: PipelineInfo = Field(\n        description=\"Details about the pipeline and its state.\"\n    )\n\n    _pipeline: Union[Pipeline, None] = PrivateAttr(default=None)\n    _kiara: \"Kiara\" = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Kind:\n        return {\n            \"steps\": [s.instance_cid for s in self.steps],\n            \"inputs\": {k: str(v) for k, v in self.inputs.items()},\n        }\n\n    def set_inputs(self, **inputs: uuid.UUID):\n\n        for k, v in inputs.items():\n            if k in self.pipeline_config.structure.pipeline_inputs_schema.keys():\n                self.inputs[k] = v\n\n    @property\n    def pipeline_config(self) -&gt; PipelineConfig:\n\n        return self.pipeline_info.pipeline_config\n\n    @property\n    def pipeline_structure(self) -&gt; PipelineStructure:\n        return self.pipeline_info.pipeline_config.structure\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        in_panel = config.get(\"in_panel\", None)\n        if in_panel is None:\n            if is_jupyter():\n                in_panel = True\n            else:\n                in_panel = False\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n        table.add_row(\"state id\", self.instance_id)\n\n        self.pipeline_info._fill_table(table=table, config=config)\n\n        if in_panel:\n            return Panel(table)\n        else:\n            return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.steps","title":"<code>steps: List[PipelineStep] = Field(description='The current steps in the workflow.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.inputs","title":"<code>inputs: Dict[str, uuid.UUID] = Field(description='The current (pipeline) input values.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.pipeline_info","title":"<code>pipeline_info: PipelineInfo = Field(description='Details about the pipeline and its state.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.pipeline_config","title":"<code>pipeline_config: PipelineConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.pipeline_structure","title":"<code>pipeline_structure: PipelineStructure</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState-functions","title":"Functions","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.create_from_workflow","title":"<code>create_from_workflow(workflow: Workflow)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef create_from_workflow(self, workflow: \"Workflow\"):\n\n    steps = list(workflow._steps.values())\n    inputs = dict(workflow.current_pipeline_inputs)\n    info = PipelineInfo.create_from_pipeline(\n        kiara=workflow._kiara, pipeline=workflow.pipeline\n    )\n    info._kiara = workflow._kiara\n\n    ws = WorkflowState(steps=steps, inputs=inputs, pipeline_info=info)\n    ws._kiara = workflow._kiara\n    ws.pipeline_info._kiara = workflow._kiara\n    return ws\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.set_inputs","title":"<code>set_inputs(**inputs: uuid.UUID)</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>def set_inputs(self, **inputs: uuid.UUID):\n\n    for k, v in inputs.items():\n        if k in self.pipeline_config.structure.pipeline_inputs_schema.keys():\n            self.inputs[k] = v\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowState.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    in_panel = config.get(\"in_panel\", None)\n    if in_panel is None:\n        if is_jupyter():\n            in_panel = True\n        else:\n            in_panel = False\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n    table.add_row(\"state id\", self.instance_id)\n\n    self.pipeline_info._fill_table(table=table, config=config)\n\n    if in_panel:\n        return Panel(table)\n    else:\n        return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata","title":"<code>WorkflowMetadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/workflow.py</code> <pre><code>class WorkflowMetadata(KiaraModel):\n    _kiara_model_id = \"instance.workflow\"\n\n    workflow_id: uuid.UUID = Field(\n        description=\"The globaly unique uuid for this workflow.\"\n    )\n    documentation: DocumentationMetadataModel = Field(\n        description=\"A description for this workflow.\",\n        default_factory=DocumentationMetadataModel.create,\n    )\n    authors: AuthorsMetadataModel = Field(\n        description=\"The author(s) of this workflow.\",\n        default_factory=AuthorsMetadataModel,\n    )\n    context: ContextMetadataModel = Field(\n        description=\"Workflow context details.\", default_factory=ContextMetadataModel\n    )\n    current_state: Union[str, None] = Field(\n        description=\"A reference to the current state of this workflow.\", default=None\n    )\n    workflow_history: Dict[datetime.datetime, str] = Field(\n        description=\"A history of all the states of this workflow.\",\n        default_factory=dict,\n    )\n\n    input_aliases: Dict[str, str] = Field(\n        description=\"A set of aliases that can be used to forward inputs to their (unaliased) pipeline inputs.\",\n        default_factory=dict,\n    )\n    output_aliases: Dict[str, str] = Field(\n        description=\"A set of aliases to make output field names more user friendly.\",\n        default_factory=dict,\n    )\n\n    is_persisted: bool = Field(\n        description=\"Whether this workflow is persisted in it's current state in a kiara store.\",\n        default=False,\n    )\n\n    _kiara: Union[\"Kiara\", None] = PrivateAttr(default=None)\n    # _last_update: datetime.datetime = PrivateAttr(default_factory=datetime.datetime.now)\n\n    @validator(\"documentation\", pre=True)\n    def validate_doc(cls, value):\n        if not isinstance(value, DocumentationMetadataModel):\n            return DocumentationMetadataModel.create(value)\n        else:\n            return value\n\n    @property\n    def last_state_id(self) -&gt; Union[None, str]:\n\n        if not self.workflow_history:\n            return None\n        last_date = max(self.workflow_history.keys())\n        workflow_state_id = self.workflow_history[last_date]\n        return workflow_state_id\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.workflow_id","title":"<code>workflow_id: uuid.UUID = Field(description='The globaly unique uuid for this workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.documentation","title":"<code>documentation: DocumentationMetadataModel = Field(description='A description for this workflow.', default_factory=DocumentationMetadataModel.create)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.authors","title":"<code>authors: AuthorsMetadataModel = Field(description='The author(s) of this workflow.', default_factory=AuthorsMetadataModel)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.context","title":"<code>context: ContextMetadataModel = Field(description='Workflow context details.', default_factory=ContextMetadataModel)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.current_state","title":"<code>current_state: Union[str, None] = Field(description='A reference to the current state of this workflow.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.workflow_history","title":"<code>workflow_history: Dict[datetime.datetime, str] = Field(description='A history of all the states of this workflow.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.input_aliases","title":"<code>input_aliases: Dict[str, str] = Field(description='A set of aliases that can be used to forward inputs to their (unaliased) pipeline inputs.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.output_aliases","title":"<code>output_aliases: Dict[str, str] = Field(description='A set of aliases to make output field names more user friendly.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.is_persisted","title":"<code>is_persisted: bool = Field(description=\"Whether this workflow is persisted in it's current state in a kiara store.\", default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.last_state_id","title":"<code>last_state_id: Union[None, str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowMetadata.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@validator(\"documentation\", pre=True)\ndef validate_doc(cls, value):\n    if not isinstance(value, DocumentationMetadataModel):\n        return DocumentationMetadataModel.create(value)\n    else:\n        return value\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo","title":"<code>WorkflowInfo</code>","text":"<p>         Bases: <code>ItemInfo</code></p> Source code in <code>kiara/models/workflow.py</code> <pre><code>class WorkflowInfo(ItemInfo):\n\n    _kiara_model_id = \"info.workflow\"\n\n    @classmethod\n    def create_from_workflow(cls, workflow: \"Workflow\"):\n\n        wf_info = WorkflowInfo.construct(\n            type_name=str(workflow.workflow_id),\n            workflow_metadata=workflow.workflow_metadata,\n            workflow_state_ids=workflow.all_state_ids,\n            pipeline_info=workflow.pipeline_info,\n            documentation=workflow.workflow_metadata.documentation,\n            authors=workflow.workflow_metadata.authors,\n            context=workflow.workflow_metadata.context,\n            current_input_values=workflow.current_input_values,\n            current_output_values=workflow.current_output_values,\n            input_aliases=dict(workflow.input_aliases),\n            output_aliases=dict(workflow.output_aliases),\n        )\n        return wf_info\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"workflow\"\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[\"Workflow\"]:\n        from kiara.interfaces.python_api.workflow import Workflow\n\n        return Workflow\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: \"Workflow\", **kwargs):\n\n        return cls.create_from_workflow(workflow=instance)\n\n    workflow_metadata: WorkflowMetadata = Field(description=\"The workflow details.\")\n    workflow_state_ids: List[str] = Field(description=\"All states for this workflow.\")\n    pipeline_info: PipelineInfo = Field(\n        description=\"The current state of the workflows' pipeline.\"\n    )\n    current_input_values: ValueMap = Field(\n        description=\"The current workflow inputs (after aliasing).\"\n    )\n    current_output_values: ValueMap = Field(\n        description=\"The current workflow outputs (after aliasing).\"\n    )\n    input_aliases: Dict[str, str] = Field(\n        description=\"The (current) input aliases for this workflow.\"\n    )\n    output_aliases: Dict[str, str] = Field(\n        description=\"The (current) output aliases for this workflow.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        in_panel = config.get(\"in_panel\", None)\n        if in_panel is None:\n            if is_jupyter():\n                in_panel = True\n            else:\n                in_panel = False\n\n        include_doc = config.get(\"include_doc\", True)\n        include_authors = config.get(\"include_authors\", True)\n        include_id = config.get(\"include_id\", True)\n        include_context = config.get(\"include_context\", True)\n        include_history = config.get(\"include_history\", True)\n        include_current_inputs = config.get(\"include_current_inputs\", True)\n        include_current_outputs = config.get(\"include_current_outputs\", True)\n        include_aliases = config.get(\"include_aliases\", True)\n        include_current_state = config.get(\"include_current_state\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        if include_authors:\n            table.add_row(\"author(s)\", self.authors.create_renderable(**config))\n        if include_id:\n            table.add_row(\"workflow id\", str(self.workflow_metadata.workflow_id))\n        if include_context:\n            table.add_row(\"context\", self.context.create_renderable(**config))\n        if include_aliases:\n            aliases = orjson_dumps(\n                {\"inputs\": self.input_aliases, \"outputs\": self.output_aliases}\n            )\n            table.add_row(\n                \"current aliases\", Syntax(aliases, \"json\", background_color=\"default\")\n            )\n        if include_current_inputs:\n            inputs_renderable = self.current_input_values.create_renderable(**config)\n            table.add_row(\"current inputs\", inputs_renderable)\n        if include_current_outputs:\n            outputs_renderable = self.current_output_values.create_renderable(**config)\n            table.add_row(\"current outputs\", outputs_renderable)\n        if include_history:\n            history_table = Table(show_header=False, box=box.SIMPLE)\n            history_table.add_column(\"date\", style=\"i\")\n            history_table.add_column(\"id\")\n            for d, s_id in self.workflow_metadata.workflow_history.items():\n                history_table.add_row(str(d), s_id)\n            table.add_row(\"snapshot timeline\", history_table)\n\n        if include_current_state:\n            current_state_id = (\n                \"-- n/a --\"\n                if not self.workflow_metadata.current_state\n                else self.workflow_metadata.current_state\n            )\n            table.add_row(\"current state id\", current_state_id)\n            table.add_row(\n                \"current state details\", self.pipeline_info.create_renderable(**config)\n            )\n\n        if in_panel:\n            return Panel(table)\n        else:\n            return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.workflow_metadata","title":"<code>workflow_metadata: WorkflowMetadata = Field(description='The workflow details.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.workflow_state_ids","title":"<code>workflow_state_ids: List[str] = Field(description='All states for this workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.pipeline_info","title":"<code>pipeline_info: PipelineInfo = Field(description=\"The current state of the workflows' pipeline.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.current_input_values","title":"<code>current_input_values: ValueMap = Field(description='The current workflow inputs (after aliasing).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.current_output_values","title":"<code>current_output_values: ValueMap = Field(description='The current workflow outputs (after aliasing).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.input_aliases","title":"<code>input_aliases: Dict[str, str] = Field(description='The (current) input aliases for this workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.output_aliases","title":"<code>output_aliases: Dict[str, str] = Field(description='The (current) output aliases for this workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.create_from_workflow","title":"<code>create_from_workflow(workflow: Workflow)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef create_from_workflow(cls, workflow: \"Workflow\"):\n\n    wf_info = WorkflowInfo.construct(\n        type_name=str(workflow.workflow_id),\n        workflow_metadata=workflow.workflow_metadata,\n        workflow_state_ids=workflow.all_state_ids,\n        pipeline_info=workflow.pipeline_info,\n        documentation=workflow.workflow_metadata.documentation,\n        authors=workflow.workflow_metadata.authors,\n        context=workflow.workflow_metadata.context,\n        current_input_values=workflow.current_input_values,\n        current_output_values=workflow.current_output_values,\n        input_aliases=dict(workflow.input_aliases),\n        output_aliases=dict(workflow.output_aliases),\n    )\n    return wf_info\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"workflow\"\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[Workflow]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[\"Workflow\"]:\n    from kiara.interfaces.python_api.workflow import Workflow\n\n    return Workflow\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: Workflow, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: \"Workflow\", **kwargs):\n\n    return cls.create_from_workflow(workflow=instance)\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    in_panel = config.get(\"in_panel\", None)\n    if in_panel is None:\n        if is_jupyter():\n            in_panel = True\n        else:\n            in_panel = False\n\n    include_doc = config.get(\"include_doc\", True)\n    include_authors = config.get(\"include_authors\", True)\n    include_id = config.get(\"include_id\", True)\n    include_context = config.get(\"include_context\", True)\n    include_history = config.get(\"include_history\", True)\n    include_current_inputs = config.get(\"include_current_inputs\", True)\n    include_current_outputs = config.get(\"include_current_outputs\", True)\n    include_aliases = config.get(\"include_aliases\", True)\n    include_current_state = config.get(\"include_current_state\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    if include_authors:\n        table.add_row(\"author(s)\", self.authors.create_renderable(**config))\n    if include_id:\n        table.add_row(\"workflow id\", str(self.workflow_metadata.workflow_id))\n    if include_context:\n        table.add_row(\"context\", self.context.create_renderable(**config))\n    if include_aliases:\n        aliases = orjson_dumps(\n            {\"inputs\": self.input_aliases, \"outputs\": self.output_aliases}\n        )\n        table.add_row(\n            \"current aliases\", Syntax(aliases, \"json\", background_color=\"default\")\n        )\n    if include_current_inputs:\n        inputs_renderable = self.current_input_values.create_renderable(**config)\n        table.add_row(\"current inputs\", inputs_renderable)\n    if include_current_outputs:\n        outputs_renderable = self.current_output_values.create_renderable(**config)\n        table.add_row(\"current outputs\", outputs_renderable)\n    if include_history:\n        history_table = Table(show_header=False, box=box.SIMPLE)\n        history_table.add_column(\"date\", style=\"i\")\n        history_table.add_column(\"id\")\n        for d, s_id in self.workflow_metadata.workflow_history.items():\n            history_table.add_row(str(d), s_id)\n        table.add_row(\"snapshot timeline\", history_table)\n\n    if include_current_state:\n        current_state_id = (\n            \"-- n/a --\"\n            if not self.workflow_metadata.current_state\n            else self.workflow_metadata.current_state\n        )\n        table.add_row(\"current state id\", current_state_id)\n        table.add_row(\n            \"current state details\", self.pipeline_info.create_renderable(**config)\n        )\n\n    if in_panel:\n        return Panel(table)\n    else:\n        return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo","title":"<code>WorkflowGroupInfo</code>","text":"<p>         Bases: <code>InfoItemGroup</code></p> Source code in <code>kiara/models/workflow.py</code> <pre><code>class WorkflowGroupInfo(InfoItemGroup):\n\n    _kiara_model_id = \"info.workflows\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[ItemInfo]:\n        return WorkflowInfo\n\n    @classmethod\n    def create_from_workflows(\n        cls,\n        *items: \"Workflow\",\n        group_title: Union[str, None] = None,\n        alias_map: Union[None, Mapping[str, uuid.UUID]] = None\n    ) -&gt; \"WorkflowGroupInfo\":\n\n        workflow_infos = {\n            str(w.workflow_id): WorkflowInfo.create_from_workflow(workflow=w)\n            for w in items\n        }\n        if alias_map is None:\n            alias_map = {}\n        workflow_group_info = cls.construct(\n            group_title=group_title, item_infos=workflow_infos, aliases=alias_map\n        )\n        return workflow_group_info\n\n    item_infos: Mapping[str, WorkflowInfo] = Field(\n        description=\"The workflow infos objects for each workflow.\"\n    )\n    aliases: Mapping[str, uuid.UUID] = Field(\n        description=\"The available aliases.\", default_factory=dict\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(box=box.SIMPLE, show_header=True)\n        table.add_column(\"alias(es)\", style=\"i\")\n        table.add_column(\"workflow_id\")\n        table.add_column(\"# steps\")\n        table.add_column(\"# stages\")\n        table.add_column(\"# states\")\n        table.add_column(\"description\")\n\n        for workflow_id, wf in self.item_infos.items():\n\n            aliases = [k for k, v in self.aliases.items() if str(v) == workflow_id]\n            steps = len(wf.pipeline_info.pipeline_config.structure.steps)\n            stages = len(wf.pipeline_info.pipeline_config.structure.processing_stages)\n            states = len(wf.workflow_state_ids)\n\n            if not aliases:\n                alias_str = \"\"\n            else:\n                alias_str = \", \".join(aliases)\n            table.add_row(\n                alias_str,\n                workflow_id,\n                str(steps),\n                str(stages),\n                str(states),\n                wf.documentation.description,\n            )\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo.item_infos","title":"<code>item_infos: Mapping[str, WorkflowInfo] = Field(description='The workflow infos objects for each workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo.aliases","title":"<code>aliases: Mapping[str, uuid.UUID] = Field(description='The available aliases.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[ItemInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[ItemInfo]:\n    return WorkflowInfo\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo.create_from_workflows","title":"<code>create_from_workflows(*items: Workflow, group_title: Union[str, None] = None, alias_map: Union[None, Mapping[str, uuid.UUID]] = None) -&gt; WorkflowGroupInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>@classmethod\ndef create_from_workflows(\n    cls,\n    *items: \"Workflow\",\n    group_title: Union[str, None] = None,\n    alias_map: Union[None, Mapping[str, uuid.UUID]] = None\n) -&gt; \"WorkflowGroupInfo\":\n\n    workflow_infos = {\n        str(w.workflow_id): WorkflowInfo.create_from_workflow(workflow=w)\n        for w in items\n    }\n    if alias_map is None:\n        alias_map = {}\n    workflow_group_info = cls.construct(\n        group_title=group_title, item_infos=workflow_infos, aliases=alias_map\n    )\n    return workflow_group_info\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow.WorkflowGroupInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/workflow.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(box=box.SIMPLE, show_header=True)\n    table.add_column(\"alias(es)\", style=\"i\")\n    table.add_column(\"workflow_id\")\n    table.add_column(\"# steps\")\n    table.add_column(\"# stages\")\n    table.add_column(\"# states\")\n    table.add_column(\"description\")\n\n    for workflow_id, wf in self.item_infos.items():\n\n        aliases = [k for k, v in self.aliases.items() if str(v) == workflow_id]\n        steps = len(wf.pipeline_info.pipeline_config.structure.steps)\n        stages = len(wf.pipeline_info.pipeline_config.structure.processing_stages)\n        states = len(wf.workflow_state_ids)\n\n        if not aliases:\n            alias_str = \"\"\n        else:\n            alias_str = \", \".join(aliases)\n        table.add_row(\n            alias_str,\n            workflow_id,\n            str(steps),\n            str(stages),\n            str(states),\n            wf.documentation.description,\n        )\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/workflow/#kiara.models.workflow-functions","title":"Functions","text":""},{"location":"reference/kiara/models/aliases/__init__/","title":"aliases","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.VALUE_ALIAS_SEPARATOR","title":"<code>VALUE_ALIAS_SEPARATOR = '.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases-classes","title":"Classes","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap","title":"<code>AliasValueMap</code>","text":"<p>         Bases: <code>ValueMap</code></p> <p>A model class that holds a tree of values and their schemas.</p> Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>class AliasValueMap(ValueMap):\n\"\"\"A model class that holds a tree of values and their schemas.\"\"\"\n\n    _kiara_model_id = \"instance.value_map.aliases\"\n\n    alias: Union[str, None] = Field(description=\"This maps own (full) alias.\")\n    version: int = Field(description=\"The version of this map (in this maps parent).\")\n    created: Union[datetime.datetime, None] = Field(\n        description=\"The time this map was created.\", default=None\n    )\n    assoc_schema: Union[ValueSchema, None] = Field(\n        description=\"The schema for this maps associated value.\"\n    )\n    assoc_value: Union[uuid.UUID, None] = Field(\n        description=\"The value that is associated with this map.\"\n    )\n\n    value_items: Dict[str, Dict[int, \"AliasValueMap\"]] = Field(\n        description=\"The values contained in this set.\", default_factory=dict\n    )\n\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n    _schema_locked: bool = PrivateAttr(default=False)\n    _auto_schema: bool = PrivateAttr(default=True)\n    _is_stored: bool = PrivateAttr(default=False)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        raise NotImplementedError()\n\n    @property\n    def is_stored(self) -&gt; bool:\n        return self._is_stored\n\n    def get_child_map(\n        self, field_name: str, version: Union[str, None] = None\n    ) -&gt; Union[\"AliasValueMap\", None]:\n\"\"\"Get the child map for the specified field / version combination.\n\n        Raises an error if the child field does not exist. Returns 'None' if not value is set yet (but schema is).\n        \"\"\"\n\n        if version is not None:\n            raise NotImplementedError()\n\n        if VALUE_ALIAS_SEPARATOR not in field_name:\n\n            if self.values_schema.get(field_name, None) is None:\n                if not self.values_schema:\n                    msg = \"No available fields\"\n                else:\n                    msg = \"Available fields: \" + \", \".join(self.values_schema.keys())\n                raise KeyError(f\"No field name '{field_name}'. {msg}\")\n\n            field_items = self.value_items[field_name]\n            if not field_items:\n                return None\n\n            max_version = max(field_items.keys())\n\n            item = field_items[max_version]\n            return item\n\n        else:\n            child, rest = field_name.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n            if child not in self.values_schema.keys():\n                raise Exception(\n                    f\"No field name '{child}'. Available fields: {', '.join(self.values_schema.keys())}\"\n                )\n            child_map = self.get_child_map(child)\n            assert child_map is not None\n            return child_map.get_child_map(rest)\n\n    def get_value_obj(self, field_name: str) -&gt; Value:\n\n        item = self.get_child_map(field_name=field_name)\n        if item is None:\n            return self._data_registry.NONE_VALUE\n        if item.assoc_value is None:\n            raise Exception(f\"No value associated for field '{field_name}'.\")\n\n        return self._data_registry.get_value(value=item.assoc_value)\n\n    def get_value_id(self, field_name: str) -&gt; uuid.UUID:\n\n        item = self.get_child_map(field_name=field_name)\n        if item is None:\n            result = NONE_VALUE_ID\n        else:\n            result = item.assoc_value if item.assoc_value is not None else NONE_VALUE_ID\n\n        return result\n\n    def get_all_value_ids(\n        self,\n    ) -&gt; Dict[str, uuid.UUID]:\n\n        result: Dict[str, uuid.UUID] = {}\n        for k in self.values_schema.keys():\n            v_id = self.get_value_id(field_name=k)\n            if v_id is None:\n                v_id = NONE_VALUE_ID\n            result[k] = v_id\n        return result\n\n    def set_alias_schema(self, alias: str, schema: ValueSchema):\n\n        if self._schema_locked:\n            raise Exception(f\"Can't add schema for alias '{alias}': schema locked.\")\n\n        if VALUE_ALIAS_SEPARATOR not in alias:\n\n            self._set_local_field_schema(field_name=alias, schema=schema)\n        else:\n            child, rest = alias.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n\n            if child in self.values_schema.keys():\n                child_map = self.get_child_map(child)\n            else:\n                self._set_local_field_schema(\n                    field_name=child, schema=ValueSchema(type=\"none\")\n                )\n                child_map = self._set_alias(alias=child, data=None)\n\n            assert child_map is not None\n\n            child_map.set_alias_schema(alias=rest, schema=schema)\n\n    def _set_local_field_schema(self, field_name: str, schema: ValueSchema):\n\n        assert field_name is not None\n        if VALUE_ALIAS_SEPARATOR in field_name:\n            raise Exception(\n                f\"Can't add schema, field name has alias separator in name: {field_name}. This is most likely a bug.\"\n            )\n\n        if field_name in self.values_schema.keys():\n            raise Exception(\n                f\"Can't set alias schema for '{field_name}' to map: schema already set.\"\n            )\n\n        try:\n            items = self.get_child_map(field_name)\n            if items is not None:\n                raise Exception(\n                    f\"Can't set schema for field '{field_name}': already at least one child set for this field.\"\n                )\n        except KeyError:\n            pass\n\n        self.values_schema[field_name] = schema\n        self.value_items[field_name] = {}\n\n    def get_alias(self, alias: str) -&gt; Union[\"AliasValueMap\", None]:\n\n        if VALUE_ALIAS_SEPARATOR not in alias:\n            if \"@\" in alias:\n                raise NotImplementedError()\n\n            child_map = self.get_child_map(alias)\n            if child_map is None:\n                return None\n\n            return child_map\n\n        else:\n            child, rest = alias.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n            if \"@\" in child:\n                raise NotImplementedError()\n\n            child_map = self.get_child_map(field_name=child)\n\n            if child_map is None:\n                return None\n\n            return child_map.get_alias(rest)\n\n    def set_value(self, field_name: str, data: Any) -&gt; None:\n\n        assert VALUE_ALIAS_SEPARATOR not in field_name\n\n        self._set_alias(alias=field_name, data=data)\n\n    def _set_aliases(self, **aliases: Any) -&gt; Mapping[str, \"AliasValueMap\"]:\n\n        result = {}\n        for k, v in aliases.items():\n            r = self._set_alias(alias=k, data=v)\n            result[k] = r\n\n        return result\n\n    def _set_alias(self, alias: str, data: Any) -&gt; \"AliasValueMap\":\n\n        if VALUE_ALIAS_SEPARATOR not in alias:\n            field_name: Union[str, None] = alias\n\n            # means we are setting the alias in this map\n            assert field_name is not None\n\n            vs = self.values_schema[alias]\n            if vs.type == \"none\":\n                assert data is None\n                value_id = None\n            else:\n\n                if data in [None, SpecialValue.NO_VALUE, SpecialValue.NOT_SET]:\n                    if vs.default:\n                        if callable(vs.default):\n                            data = vs.default()\n                        else:\n                            data = copy.deepcopy(vs.default)\n\n                value = self._data_registry.register_data(data=data, schema=vs)\n                value_id = value.value_id\n\n            new_map = self._set_local_value_item(\n                field_name=field_name, value_id=value_id\n            )\n            return new_map\n\n        else:\n            child, rest = alias.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n            field_name = None\n\n            # means we are dealing with an intermediate alias map\n            assert rest is not None\n            assert child is not None\n            assert field_name is None\n            if child not in self.value_items.keys():\n                if not self._auto_schema:\n                    raise Exception(\n                        f\"Can't set alias '{alias}', no schema set for field: '{child}'.\"\n                    )\n                else:\n                    self.set_alias_schema(alias=child, schema=ValueSchema(type=\"any\"))\n\n            field_item: Union[AliasValueMap, None] = None\n            try:\n                field_item = self.get_child_map(field_name=child)\n            except KeyError:\n                pass\n\n            if self.alias:\n                new_alias = f\"{self.alias}.{child}\"\n            else:\n                new_alias = child\n\n            if field_item is None:\n                new_version = 0\n                schemas = {}\n                self.value_items[child] = {}\n            else:\n                max_version = len(field_item.keys())\n                new_version = max_version + 1\n                assert field_item.alias == new_alias\n                assert field_item.version == max_version\n                schemas = field_item.values_schema\n\n            new_map = AliasValueMap(\n                alias=new_alias,\n                version=new_version,\n                assoc_schema=self.values_schema[child],\n                assoc_value=None,\n                values_schema=schemas,\n            )\n            new_map._data_registry = self._data_registry\n            self.value_items[child][new_version] = new_map\n\n            new_map._set_alias(alias=rest, data=data)\n\n        return new_map\n\n    def _set_local_value_item(\n        self, field_name: str, value_id: Union[uuid.UUID, None] = None\n    ) -&gt; \"AliasValueMap\":\n\n        assert VALUE_ALIAS_SEPARATOR not in field_name\n\n        value: Union[Value, None] = None\n        if value_id is not None:\n            value = self._data_registry.get_value(value=value_id)\n            assert value is not None\n            assert value.value_id == value_id\n\n        if field_name not in self.values_schema.keys():\n            if not self._auto_schema:\n                raise Exception(\n                    f\"Can't add value for field '{field_name}': field not in schema.\"\n                )\n            else:\n                if value_id is None:\n                    value_schema = ValueSchema(type=\"none\")\n                else:\n                    value_schema = value.value_schema  # type: ignore\n                self.set_alias_schema(alias=field_name, schema=value_schema)\n\n        field_items = self.value_items.get(field_name, None)\n        if not field_items:\n            assert field_items is not None\n            new_version = 0\n            values_schema = {}\n        else:\n            max_version = max(field_items.keys())\n            current_map = field_items[max_version]\n\n            if value_id == current_map.assoc_value:\n                logger.debug(\n                    \"set_field.skip\",\n                    value_id=None,\n                    reason=f\"Same value id: {value_id}\",\n                )\n                return current_map\n\n            # TODO: check schema\n            new_version = max(field_items.keys()) + 1\n            values_schema = current_map.values_schema\n\n        if self.alias:\n            new_alias = f\"{self.alias}.{field_name}\"\n        else:\n            new_alias = field_name\n        new_map = AliasValueMap(\n            alias=new_alias,\n            version=new_version,\n            assoc_schema=self.values_schema[field_name],\n            assoc_value=value_id,\n            values_schema=values_schema,\n        )\n        new_map._data_registry = self._data_registry\n        self.value_items[field_name][new_version] = new_map\n        return new_map\n\n    def print_tree(self):\n\n        t = self.get_tree(\"base\")\n        terminal_print(t)\n\n    def get_tree(self, base_name: str) -&gt; Tree:\n\n        if self.assoc_schema:\n            type_name = self.assoc_schema.type\n        else:\n            type_name = \"none\"\n\n        if type_name == \"none\":\n            type_str = \"\"\n        else:\n            type_str = f\" ({type_name})\"\n\n        tree = Tree(f\"{base_name}{type_str}\")\n        if self.assoc_value:\n            data = tree.add(\"__data__\")\n            value = self._data_registry.get_value(self.assoc_value)\n            data.add(str(value.data))\n\n        for field_name, schema in self.values_schema.items():\n\n            alias = self.get_alias(alias=field_name)\n            if alias is not None:\n                tree.add(alias.get_tree(base_name=field_name))\n            else:\n                if schema.type == \"none\":\n                    type_str = \"\"\n                else:\n                    type_str = f\" ({schema.type})\"\n\n                tree.add(f\"{field_name}{type_str}\")\n\n        return tree\n\n    def __repr__(self):\n\n        return f\"AliasMap(assoc_value={self.assoc_value}, field_names={self.value_items.keys()})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.alias","title":"<code>alias: Union[str, None] = Field(description='This maps own (full) alias.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.version","title":"<code>version: int = Field(description='The version of this map (in this maps parent).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.created","title":"<code>created: Union[datetime.datetime, None] = Field(description='The time this map was created.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.assoc_schema","title":"<code>assoc_schema: Union[ValueSchema, None] = Field(description='The schema for this maps associated value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.assoc_value","title":"<code>assoc_value: Union[uuid.UUID, None] = Field(description='The value that is associated with this map.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.value_items","title":"<code>value_items: Dict[str, Dict[int, AliasValueMap]] = Field(description='The values contained in this set.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.is_stored","title":"<code>is_stored: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap-functions","title":"Functions","text":""},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_child_map","title":"<code>get_child_map(field_name: str, version: Union[str, None] = None) -&gt; Union[AliasValueMap, None]</code>","text":"<p>Get the child map for the specified field / version combination.</p> <p>Raises an error if the child field does not exist. Returns 'None' if not value is set yet (but schema is).</p> Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_child_map(\n    self, field_name: str, version: Union[str, None] = None\n) -&gt; Union[\"AliasValueMap\", None]:\n\"\"\"Get the child map for the specified field / version combination.\n\n    Raises an error if the child field does not exist. Returns 'None' if not value is set yet (but schema is).\n    \"\"\"\n\n    if version is not None:\n        raise NotImplementedError()\n\n    if VALUE_ALIAS_SEPARATOR not in field_name:\n\n        if self.values_schema.get(field_name, None) is None:\n            if not self.values_schema:\n                msg = \"No available fields\"\n            else:\n                msg = \"Available fields: \" + \", \".join(self.values_schema.keys())\n            raise KeyError(f\"No field name '{field_name}'. {msg}\")\n\n        field_items = self.value_items[field_name]\n        if not field_items:\n            return None\n\n        max_version = max(field_items.keys())\n\n        item = field_items[max_version]\n        return item\n\n    else:\n        child, rest = field_name.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n        if child not in self.values_schema.keys():\n            raise Exception(\n                f\"No field name '{child}'. Available fields: {', '.join(self.values_schema.keys())}\"\n            )\n        child_map = self.get_child_map(child)\n        assert child_map is not None\n        return child_map.get_child_map(rest)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_value_obj","title":"<code>get_value_obj(field_name: str) -&gt; Value</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_value_obj(self, field_name: str) -&gt; Value:\n\n    item = self.get_child_map(field_name=field_name)\n    if item is None:\n        return self._data_registry.NONE_VALUE\n    if item.assoc_value is None:\n        raise Exception(f\"No value associated for field '{field_name}'.\")\n\n    return self._data_registry.get_value(value=item.assoc_value)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_value_id","title":"<code>get_value_id(field_name: str) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_value_id(self, field_name: str) -&gt; uuid.UUID:\n\n    item = self.get_child_map(field_name=field_name)\n    if item is None:\n        result = NONE_VALUE_ID\n    else:\n        result = item.assoc_value if item.assoc_value is not None else NONE_VALUE_ID\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_all_value_ids","title":"<code>get_all_value_ids() -&gt; Dict[str, uuid.UUID]</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_all_value_ids(\n    self,\n) -&gt; Dict[str, uuid.UUID]:\n\n    result: Dict[str, uuid.UUID] = {}\n    for k in self.values_schema.keys():\n        v_id = self.get_value_id(field_name=k)\n        if v_id is None:\n            v_id = NONE_VALUE_ID\n        result[k] = v_id\n    return result\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.set_alias_schema","title":"<code>set_alias_schema(alias: str, schema: ValueSchema)</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def set_alias_schema(self, alias: str, schema: ValueSchema):\n\n    if self._schema_locked:\n        raise Exception(f\"Can't add schema for alias '{alias}': schema locked.\")\n\n    if VALUE_ALIAS_SEPARATOR not in alias:\n\n        self._set_local_field_schema(field_name=alias, schema=schema)\n    else:\n        child, rest = alias.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n\n        if child in self.values_schema.keys():\n            child_map = self.get_child_map(child)\n        else:\n            self._set_local_field_schema(\n                field_name=child, schema=ValueSchema(type=\"none\")\n            )\n            child_map = self._set_alias(alias=child, data=None)\n\n        assert child_map is not None\n\n        child_map.set_alias_schema(alias=rest, schema=schema)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_alias","title":"<code>get_alias(alias: str) -&gt; Union[AliasValueMap, None]</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_alias(self, alias: str) -&gt; Union[\"AliasValueMap\", None]:\n\n    if VALUE_ALIAS_SEPARATOR not in alias:\n        if \"@\" in alias:\n            raise NotImplementedError()\n\n        child_map = self.get_child_map(alias)\n        if child_map is None:\n            return None\n\n        return child_map\n\n    else:\n        child, rest = alias.split(VALUE_ALIAS_SEPARATOR, maxsplit=1)\n        if \"@\" in child:\n            raise NotImplementedError()\n\n        child_map = self.get_child_map(field_name=child)\n\n        if child_map is None:\n            return None\n\n        return child_map.get_alias(rest)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.set_value","title":"<code>set_value(field_name: str, data: Any) -&gt; None</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def set_value(self, field_name: str, data: Any) -&gt; None:\n\n    assert VALUE_ALIAS_SEPARATOR not in field_name\n\n    self._set_alias(alias=field_name, data=data)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.print_tree","title":"<code>print_tree()</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def print_tree(self):\n\n    t = self.get_tree(\"base\")\n    terminal_print(t)\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases.AliasValueMap.get_tree","title":"<code>get_tree(base_name: str) -&gt; Tree</code>","text":"Source code in <code>kiara/models/aliases/__init__.py</code> <pre><code>def get_tree(self, base_name: str) -&gt; Tree:\n\n    if self.assoc_schema:\n        type_name = self.assoc_schema.type\n    else:\n        type_name = \"none\"\n\n    if type_name == \"none\":\n        type_str = \"\"\n    else:\n        type_str = f\" ({type_name})\"\n\n    tree = Tree(f\"{base_name}{type_str}\")\n    if self.assoc_value:\n        data = tree.add(\"__data__\")\n        value = self._data_registry.get_value(self.assoc_value)\n        data.add(str(value.data))\n\n    for field_name, schema in self.values_schema.items():\n\n        alias = self.get_alias(alias=field_name)\n        if alias is not None:\n            tree.add(alias.get_tree(base_name=field_name))\n        else:\n            if schema.type == \"none\":\n                type_str = \"\"\n            else:\n                type_str = f\" ({schema.type})\"\n\n            tree.add(f\"{field_name}{type_str}\")\n\n    return tree\n</code></pre>"},{"location":"reference/kiara/models/aliases/__init__/#kiara.models.aliases-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/__init__/","title":"events","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent","title":"<code>KiaraEvent</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/events/__init__.py</code> <pre><code>class KiaraEvent(BaseModel):\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n\n    def get_event_type(self) -&gt; str:\n\n        if hasattr(self, \"event_type\"):\n            return self.event_type  # type: ignore\n\n        name = camel_case_to_snake_case(self.__class__.__name__)\n        return name\n</code></pre>"},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/events/__init__.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n</code></pre>"},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.KiaraEvent.get_event_type","title":"<code>get_event_type() -&gt; str</code>","text":"Source code in <code>kiara/models/events/__init__.py</code> <pre><code>def get_event_type(self) -&gt; str:\n\n    if hasattr(self, \"event_type\"):\n        return self.event_type  # type: ignore\n\n    name = camel_case_to_snake_case(self.__class__.__name__)\n    return name\n</code></pre>"},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.RegistryEvent","title":"<code>RegistryEvent</code>","text":"<p>         Bases: <code>KiaraEvent</code></p> Source code in <code>kiara/models/events/__init__.py</code> <pre><code>class RegistryEvent(KiaraEvent):\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The id of the kiara context the value was created in.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.RegistryEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events.RegistryEvent.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context the value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/__init__/#kiara.models.events-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/alias_registry/","title":"alias_registry","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent","title":"<code>AliasArchiveAddedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/alias_registry.py</code> <pre><code>class AliasArchiveAddedEvent(RegistryEvent):\n\n    event_type: Literal[\"alias_archive_added\"] = \"alias_archive_added\"\n    alias_archive_id: uuid.UUID = Field(\n        description=\"The unique id of this data archive.\"\n    )\n    alias_archive_alias: str = Field(\n        description=\"The alias this data archive was added as.\"\n    )\n    is_store: bool = Field(\n        description=\"Whether this archive supports write operations (aka implements the 'DataStore' interface).\"\n    )\n    is_default_store: bool = Field(\n        description=\"Whether this store acts as default store.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent.event_type","title":"<code>event_type: Literal['alias_archive_added'] = 'alias_archive_added'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent.alias_archive_id","title":"<code>alias_archive_id: uuid.UUID = Field(description='The unique id of this data archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent.alias_archive_alias","title":"<code>alias_archive_alias: str = Field(description='The alias this data archive was added as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent.is_store","title":"<code>is_store: bool = Field(description=\"Whether this archive supports write operations (aka implements the 'DataStore' interface).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasArchiveAddedEvent.is_default_store","title":"<code>is_default_store: bool = Field(description='Whether this store acts as default store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasPreStoreEvent","title":"<code>AliasPreStoreEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/alias_registry.py</code> <pre><code>class AliasPreStoreEvent(RegistryEvent):\n\n    event_type: Literal[\"alias_pre_store\"] = \"alias_pre_store\"\n    aliases: Iterable[str] = Field(description=\"The alias.\")\n</code></pre>"},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasPreStoreEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasPreStoreEvent.event_type","title":"<code>event_type: Literal['alias_pre_store'] = 'alias_pre_store'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasPreStoreEvent.aliases","title":"<code>aliases: Iterable[str] = Field(description='The alias.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasStoredEvent","title":"<code>AliasStoredEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/alias_registry.py</code> <pre><code>class AliasStoredEvent(RegistryEvent):\n\n    event_type: Literal[\"alias_stored\"] = \"alias_stored\"\n    alias: str = Field(description=\"The alias.\")\n</code></pre>"},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasStoredEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasStoredEvent.event_type","title":"<code>event_type: Literal['alias_stored'] = 'alias_stored'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/alias_registry/#kiara.models.events.alias_registry.AliasStoredEvent.alias","title":"<code>alias: str = Field(description='The alias.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/","title":"data_registry","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent","title":"<code>DataArchiveAddedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/data_registry.py</code> <pre><code>class DataArchiveAddedEvent(RegistryEvent):\n\n    event_type: Literal[\"data_archive_added\"] = \"data_archive_added\"\n    data_archive_id: uuid.UUID = Field(\n        description=\"The unique id of this data archive.\"\n    )\n    data_archive_alias: str = Field(\n        description=\"The alias this data archive was added as.\"\n    )\n    is_store: bool = Field(\n        description=\"Whether this archive supports write operations (aka implements the 'DataStore' interface).\"\n    )\n    is_default_store: bool = Field(\n        description=\"Whether this store acts as default store.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent.event_type","title":"<code>event_type: Literal['data_archive_added'] = 'data_archive_added'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent.data_archive_id","title":"<code>data_archive_id: uuid.UUID = Field(description='The unique id of this data archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent.data_archive_alias","title":"<code>data_archive_alias: str = Field(description='The alias this data archive was added as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent.is_store","title":"<code>is_store: bool = Field(description=\"Whether this archive supports write operations (aka implements the 'DataStore' interface).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.DataArchiveAddedEvent.is_default_store","title":"<code>is_default_store: bool = Field(description='Whether this store acts as default store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueCreatedEvent","title":"<code>ValueCreatedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/data_registry.py</code> <pre><code>class ValueCreatedEvent(RegistryEvent):\n\n    event_type: Literal[\"value_created\"] = \"value_created\"\n    value: Value = Field(description=\"The value metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueCreatedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueCreatedEvent.event_type","title":"<code>event_type: Literal['value_created'] = 'value_created'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueCreatedEvent.value","title":"<code>value: Value = Field(description='The value metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueRegisteredEvent","title":"<code>ValueRegisteredEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/data_registry.py</code> <pre><code>class ValueRegisteredEvent(RegistryEvent):\n\n    event_type: Literal[\"value_registered\"] = \"value_registered\"\n    value: Value = Field(description=\"The value metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueRegisteredEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueRegisteredEvent.event_type","title":"<code>event_type: Literal['value_registered'] = 'value_registered'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueRegisteredEvent.value","title":"<code>value: Value = Field(description='The value metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValuePreStoreEvent","title":"<code>ValuePreStoreEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/data_registry.py</code> <pre><code>class ValuePreStoreEvent(RegistryEvent):\n\n    event_type: Literal[\"value_pre_store\"] = \"value_pre_store\"\n    value: Value = Field(description=\"The value metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValuePreStoreEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValuePreStoreEvent.event_type","title":"<code>event_type: Literal['value_pre_store'] = 'value_pre_store'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValuePreStoreEvent.value","title":"<code>value: Value = Field(description='The value metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueStoredEvent","title":"<code>ValueStoredEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/data_registry.py</code> <pre><code>class ValueStoredEvent(RegistryEvent):\n\n    event_type: Literal[\"value_stored\"] = \"value_stored\"\n    value: Value = Field(description=\"The value metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueStoredEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueStoredEvent.event_type","title":"<code>event_type: Literal['value_stored'] = 'value_stored'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/data_registry/#kiara.models.events.data_registry.ValueStoredEvent.value","title":"<code>value: Value = Field(description='The value metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/destiny_registry/","title":"destiny_registry","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent","title":"<code>DestinyArchiveAddedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/destiny_registry.py</code> <pre><code>class DestinyArchiveAddedEvent(RegistryEvent):\n\n    event_type: Literal[\"destiny_archive_added\"] = \"destiny_archive_added\"\n    destiny_archive_id: uuid.UUID = Field(\n        description=\"The unique id of this destiny archive.\"\n    )\n    destiny_archive_alias: str = Field(\n        description=\"The alias this destiny archive was added as.\"\n    )\n    is_store: bool = Field(\n        description=\"Whether this archive supports write operations (aka implements the 'DestinyStore' interface).\"\n    )\n    is_default_store: bool = Field(\n        description=\"Whether this store acts as default store.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent.event_type","title":"<code>event_type: Literal['destiny_archive_added'] = 'destiny_archive_added'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent.destiny_archive_id","title":"<code>destiny_archive_id: uuid.UUID = Field(description='The unique id of this destiny archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent.destiny_archive_alias","title":"<code>destiny_archive_alias: str = Field(description='The alias this destiny archive was added as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent.is_store","title":"<code>is_store: bool = Field(description=\"Whether this archive supports write operations (aka implements the 'DestinyStore' interface).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/destiny_registry/#kiara.models.events.destiny_registry.DestinyArchiveAddedEvent.is_default_store","title":"<code>is_default_store: bool = Field(description='Whether this store acts as default store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/","title":"job_registry","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent","title":"<code>JobArchiveAddedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/job_registry.py</code> <pre><code>class JobArchiveAddedEvent(RegistryEvent):\n\n    event_type: Literal[\"job_archive_added\"] = \"job_archive_added\"\n\n    job_archive_id: uuid.UUID = Field(description=\"The unique id of this job archive.\")\n    job_archive_alias: str = Field(\n        description=\"The alias this job archive was added as.\"\n    )\n    is_store: bool = Field(\n        description=\"Whether this archive supports write operations (aka implements the 'JobStore' interface).\"\n    )\n    is_default_store: bool = Field(\n        description=\"Whether this store acts as default store.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent.event_type","title":"<code>event_type: Literal['job_archive_added'] = 'job_archive_added'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent.job_archive_id","title":"<code>job_archive_id: uuid.UUID = Field(description='The unique id of this job archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent.job_archive_alias","title":"<code>job_archive_alias: str = Field(description='The alias this job archive was added as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent.is_store","title":"<code>is_store: bool = Field(description=\"Whether this archive supports write operations (aka implements the 'JobStore' interface).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobArchiveAddedEvent.is_default_store","title":"<code>is_default_store: bool = Field(description='Whether this store acts as default store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordPreStoreEvent","title":"<code>JobRecordPreStoreEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/job_registry.py</code> <pre><code>class JobRecordPreStoreEvent(RegistryEvent):\n\n    event_type: Literal[\"job_record_pre_store\"] = \"job_record_pre_store\"\n    job_record: JobRecord = Field(description=\"The job record.\")\n</code></pre>"},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordPreStoreEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordPreStoreEvent.event_type","title":"<code>event_type: Literal['job_record_pre_store'] = 'job_record_pre_store'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordPreStoreEvent.job_record","title":"<code>job_record: JobRecord = Field(description='The job record.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordStoredEvent","title":"<code>JobRecordStoredEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/job_registry.py</code> <pre><code>class JobRecordStoredEvent(RegistryEvent):\n\n    event_type: Literal[\"job_record_stored\"] = \"job_record_stored\"\n    job_record: JobRecord = Field(description=\"The job record.\")\n</code></pre>"},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordStoredEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordStoredEvent.event_type","title":"<code>event_type: Literal['job_record_stored'] = 'job_record_stored'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/job_registry/#kiara.models.events.job_registry.JobRecordStoredEvent.job_record","title":"<code>job_record: JobRecord = Field(description='The job record.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/","title":"pipeline","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.ChangedValue","title":"<code>ChangedValue</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class ChangedValue(BaseModel):\n\n    old: Union[uuid.UUID, None]\n    new: Union[uuid.UUID, None]\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.ChangedValue-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.ChangedValue.old","title":"<code>old: Union[uuid.UUID, None]</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.ChangedValue.new","title":"<code>new: Union[uuid.UUID, None]</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails","title":"<code>StepDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class StepDetails(BaseModel):\n\n    kiara_id: uuid.UUID = Field(description=\"The id of the kiara context.\")\n    pipeline_id: uuid.UUID = Field(description=\"The id of the pipeline.\")\n    step: PipelineStep = Field(description=\"The pipeline step details.\")\n    step_id: str = Field(description=\"The id of the step.\")\n    processing_stage: int = Field(\n        description=\"The execution stage where this step is executed.\"\n    )\n    status: StepStatus = Field(description=\"The current status of this step.\")\n    invalid_details: Dict[str, str] = Field(\n        description=\"Details about fields that are invalid (if status &lt; 'INPUTS_READY'.\",\n        default_factory=dict,\n    )\n    inputs: Dict[str, uuid.UUID] = Field(description=\"The current inputs of this step.\")\n    outputs: Dict[str, uuid.UUID] = Field(\n        description=\"The current outputs of this step.\"\n    )\n\n    @validator(\"inputs\")\n    def replace_none_values_inputs(cls, value):\n\n        result = {}\n        for k, v in value.items():\n            if v is None:\n                v = NONE_VALUE_ID\n            result[k] = v\n        return result\n\n    @validator(\"outputs\")\n    def replace_none_values_outputs(cls, value):\n\n        result = {}\n        for k, v in value.items():\n            if v is None:\n                v = NOT_SET_VALUE_ID\n            result[k] = v\n        return result\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return f\"{self.kiara_id}.{self.pipeline_id}.{self.step_id}\"\n\n    def _retrieve_id(self) -&gt; str:\n        return f\"{self.kiara_id}.{self.pipeline_id}.{self.step_id}\"\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.pipeline_id","title":"<code>pipeline_id: uuid.UUID = Field(description='The id of the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.step","title":"<code>step: PipelineStep = Field(description='The pipeline step details.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.step_id","title":"<code>step_id: str = Field(description='The id of the step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.processing_stage","title":"<code>processing_stage: int = Field(description='The execution stage where this step is executed.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.status","title":"<code>status: StepStatus = Field(description='The current status of this step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.invalid_details","title":"<code>invalid_details: Dict[str, str] = Field(description=\"Details about fields that are invalid (if status &lt; 'INPUTS_READY'.\", default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.inputs","title":"<code>inputs: Dict[str, uuid.UUID] = Field(description='The current inputs of this step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.outputs","title":"<code>outputs: Dict[str, uuid.UUID] = Field(description='The current outputs of this step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.replace_none_values_inputs","title":"<code>replace_none_values_inputs(value)</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>@validator(\"inputs\")\ndef replace_none_values_inputs(cls, value):\n\n    result = {}\n    for k, v in value.items():\n        if v is None:\n            v = NONE_VALUE_ID\n        result[k] = v\n    return result\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.StepDetails.replace_none_values_outputs","title":"<code>replace_none_values_outputs(value)</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>@validator(\"outputs\")\ndef replace_none_values_outputs(cls, value):\n\n    result = {}\n    for k, v in value.items():\n        if v is None:\n            v = NOT_SET_VALUE_ID\n        result[k] = v\n    return result\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState","title":"<code>PipelineState</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class PipelineState(KiaraModel):\n\n    _kiara_model_id = \"instance.pipeline_state\"\n\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n\n    kiara_id: uuid.UUID = Field(description=\"The id of the kiara context.\")\n    pipeline_id: uuid.UUID = Field(description=\"The id of the pipeline.\")\n\n    pipeline_status: StepStatus = Field(\n        description=\"The current status of this pipeline.\"\n    )\n    invalid_details: Dict[str, str] = Field(\n        description=\"Details about fields that are invalid (if status &lt; 'INPUTS_READY'.\",\n        default_factory=dict,\n    )\n\n    pipeline_inputs: Dict[str, uuid.UUID] = Field(\n        description=\"The current pipeline inputs.\"\n    )\n    pipeline_outputs: Dict[str, uuid.UUID] = Field(\n        description=\"The current pipeline outputs.\"\n    )\n\n    step_states: Dict[str, StepDetails] = Field(\n        description=\"The state of each step within this pipeline.\"\n    )\n\n    def get_steps_by_processing_stage(self) -&gt; MutableMapping[int, List[StepDetails]]:\n\n        result: MutableMapping[int, List[StepDetails]] = SortedDict()\n        for step_details in self.step_states.values():\n            result.setdefault(step_details.processing_stage, []).append(step_details)\n        return result\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.pipeline_id","title":"<code>pipeline_id: uuid.UUID = Field(description='The id of the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.pipeline_status","title":"<code>pipeline_status: StepStatus = Field(description='The current status of this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.invalid_details","title":"<code>invalid_details: Dict[str, str] = Field(description=\"Details about fields that are invalid (if status &lt; 'INPUTS_READY'.\", default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.pipeline_inputs","title":"<code>pipeline_inputs: Dict[str, uuid.UUID] = Field(description='The current pipeline inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.pipeline_outputs","title":"<code>pipeline_outputs: Dict[str, uuid.UUID] = Field(description='The current pipeline outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.step_states","title":"<code>step_states: Dict[str, StepDetails] = Field(description='The state of each step within this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineState.get_steps_by_processing_stage","title":"<code>get_steps_by_processing_stage() -&gt; MutableMapping[int, List[StepDetails]]</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>def get_steps_by_processing_stage(self) -&gt; MutableMapping[int, List[StepDetails]]:\n\n    result: MutableMapping[int, List[StepDetails]] = SortedDict()\n    for step_details in self.step_states.values():\n        result.setdefault(step_details.processing_stage, []).append(step_details)\n    return result\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent","title":"<code>PipelineEvent</code>","text":"<p>         Bases: <code>KiaraEvent</code></p> Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class PipelineEvent(KiaraEvent):\n    @classmethod\n    def create_event(\n        cls,\n        pipeline: \"Pipeline\",\n        changed: Mapping[str, Mapping[str, Mapping[str, ChangedValue]]],\n    ) -&gt; Union[\"PipelineEvent\", None]:\n\n        pipeline_inputs = changed.get(\"__pipeline__\", {}).get(\"inputs\", {})\n        pipeline_outputs = changed.get(\"__pipeline__\", {}).get(\"outputs\", {})\n\n        step_inputs = {}\n        step_outputs = {}\n\n        invalidated_steps: Set[str] = set()\n\n        for step_id, change_details in changed.items():\n            if step_id == \"__pipeline__\":\n                continue\n            inputs = change_details.get(\"inputs\", None)\n            if inputs:\n                invalidated_steps.add(step_id)\n                step_inputs[step_id] = inputs\n            outputs = change_details.get(\"outputs\", None)\n            if outputs:\n                invalidated_steps.add(step_id)\n                step_outputs[step_id] = outputs\n\n        if (\n            not pipeline_inputs\n            and not pipeline_outputs\n            and not step_inputs\n            and not step_outputs\n            and not invalidated_steps\n        ):\n            return None\n\n        event = PipelineEvent(\n            kiara_id=pipeline.kiara_id,\n            pipeline_id=pipeline.pipeline_id,\n            pipeline_inputs_changed=pipeline_inputs,\n            pipeline_outputs_changed=pipeline_outputs,\n            step_inputs_changed=step_inputs,\n            step_outputs_changed=step_outputs,\n            changed_steps=sorted(invalidated_steps),\n        )\n        return event\n\n    class Config:\n        allow_mutation = False\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The id of the kiara context that created the pipeline.\"\n    )\n    pipeline_id: uuid.UUID = Field(description=\"The pipeline id.\")\n\n    pipeline_inputs_changed: Dict[str, ChangedValue] = Field(\n        description=\"Details about changed pipeline input values.\", default_factory=dict\n    )\n    pipeline_outputs_changed: Dict[str, ChangedValue] = Field(\n        description=\"Details about changed pipeline output values.\",\n        default_factory=dict,\n    )\n\n    step_inputs_changed: Dict[str, Mapping[str, ChangedValue]] = Field(\n        description=\"Details about changed step input values.\", default_factory=dict\n    )\n    step_outputs_changed: Dict[str, Mapping[str, ChangedValue]] = Field(\n        description=\"Details about changed step output values.\", default_factory=dict\n    )\n\n    changed_steps: List[str] = Field(\n        description=\"A list of all step ids that have newly invalidated outputs.\"\n    )\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(pipeline_id={self.pipeline_id}, invalidated_steps={', '.join(self.changed_steps)})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context that created the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.pipeline_id","title":"<code>pipeline_id: uuid.UUID = Field(description='The pipeline id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.pipeline_inputs_changed","title":"<code>pipeline_inputs_changed: Dict[str, ChangedValue] = Field(description='Details about changed pipeline input values.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.pipeline_outputs_changed","title":"<code>pipeline_outputs_changed: Dict[str, ChangedValue] = Field(description='Details about changed pipeline output values.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.step_inputs_changed","title":"<code>step_inputs_changed: Dict[str, Mapping[str, ChangedValue]] = Field(description='Details about changed step input values.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.step_outputs_changed","title":"<code>step_outputs_changed: Dict[str, Mapping[str, ChangedValue]] = Field(description='Details about changed step output values.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.changed_steps","title":"<code>changed_steps: List[str] = Field(description='A list of all step ids that have newly invalidated outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>class Config:\n    allow_mutation = False\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.Config-attributes","title":"Attributes","text":"<code>allow_mutation = False</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline.PipelineEvent.create_event","title":"<code>create_event(pipeline: Pipeline, changed: Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]) -&gt; Union[PipelineEvent, None]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/events/pipeline.py</code> <pre><code>@classmethod\ndef create_event(\n    cls,\n    pipeline: \"Pipeline\",\n    changed: Mapping[str, Mapping[str, Mapping[str, ChangedValue]]],\n) -&gt; Union[\"PipelineEvent\", None]:\n\n    pipeline_inputs = changed.get(\"__pipeline__\", {}).get(\"inputs\", {})\n    pipeline_outputs = changed.get(\"__pipeline__\", {}).get(\"outputs\", {})\n\n    step_inputs = {}\n    step_outputs = {}\n\n    invalidated_steps: Set[str] = set()\n\n    for step_id, change_details in changed.items():\n        if step_id == \"__pipeline__\":\n            continue\n        inputs = change_details.get(\"inputs\", None)\n        if inputs:\n            invalidated_steps.add(step_id)\n            step_inputs[step_id] = inputs\n        outputs = change_details.get(\"outputs\", None)\n        if outputs:\n            invalidated_steps.add(step_id)\n            step_outputs[step_id] = outputs\n\n    if (\n        not pipeline_inputs\n        and not pipeline_outputs\n        and not step_inputs\n        and not step_outputs\n        and not invalidated_steps\n    ):\n        return None\n\n    event = PipelineEvent(\n        kiara_id=pipeline.kiara_id,\n        pipeline_id=pipeline.pipeline_id,\n        pipeline_inputs_changed=pipeline_inputs,\n        pipeline_outputs_changed=pipeline_outputs,\n        step_inputs_changed=step_inputs,\n        step_outputs_changed=step_outputs,\n        changed_steps=sorted(invalidated_steps),\n    )\n    return event\n</code></pre>"},{"location":"reference/kiara/models/events/pipeline/#kiara.models.events.pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/models/events/workflow_registry/","title":"workflow_registry","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry-classes","title":"Classes","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent","title":"<code>WorkflowArchiveAddedEvent</code>","text":"<p>         Bases: <code>RegistryEvent</code></p> Source code in <code>kiara/models/events/workflow_registry.py</code> <pre><code>class WorkflowArchiveAddedEvent(RegistryEvent):\n\n    event_type: Literal[\"workflow_archive_added\"] = \"workflow_archive_added\"\n    workflow_archive_id: uuid.UUID = Field(\n        description=\"The unique id of this data archive.\"\n    )\n    workflow_archive_alias: str = Field(\n        description=\"The alias this workflow archive was added as.\"\n    )\n    is_store: bool = Field(\n        description=\"Whether this archive supports write operations (aka implements the 'WorkflowStore' interface).\"\n    )\n    is_default_store: bool = Field(\n        description=\"Whether this store acts as default store.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent.event_type","title":"<code>event_type: Literal['workflow_archive_added'] = 'workflow_archive_added'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent.workflow_archive_id","title":"<code>workflow_archive_id: uuid.UUID = Field(description='The unique id of this data archive.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent.workflow_archive_alias","title":"<code>workflow_archive_alias: str = Field(description='The alias this workflow archive was added as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent.is_store","title":"<code>is_store: bool = Field(description=\"Whether this archive supports write operations (aka implements the 'WorkflowStore' interface).\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/events/workflow_registry/#kiara.models.events.workflow_registry.WorkflowArchiveAddedEvent.is_default_store","title":"<code>is_default_store: bool = Field(description='Whether this store acts as default store.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/__init__/","title":"module","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig","title":"<code>KiaraModuleConfig</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Base class that describes the configuration a <code>KiaraModule</code> class accepts.</p> <p>This is stored in the <code>_config_cls</code> class attribute in each <code>KiaraModule</code> class.</p> <p>There are two config options every <code>KiaraModule</code> supports:</p> <ul> <li><code>constants</code>, and</li> <li><code>defaults</code></li> </ul> <p>Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default  values that override the schema defaults, and those can be overwritten by users. If both a constant and a default  value is set for an input field, an error is thrown.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>class KiaraModuleConfig(KiaraModel):\n\"\"\"Base class that describes the configuration a [``KiaraModule``][kiara.module.KiaraModule] class accepts.\n\n    This is stored in the ``_config_cls`` class attribute in each ``KiaraModule`` class.\n\n    There are two config options every ``KiaraModule`` supports:\n\n     - ``constants``, and\n     - ``defaults``\n\n     Constants are pre-set inputs, and users can't change them and an error is thrown if they try. Defaults are default\n     values that override the schema defaults, and those can be overwritten by users. If both a constant and a default\n     value is set for an input field, an error is thrown.\n    \"\"\"\n\n    _kiara_model_id = \"instance.module_config\"\n\n    @classmethod\n    def requires_config(cls, config: Union[Mapping[str, Any], None] = None) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n        for field_name, field in cls.__fields__.items():\n            if field.required and field.default is None:\n                if config:\n                    if config.get(field_name, None) is None:\n                        return True\n                else:\n                    return True\n        return False\n\n    _config_hash: str = PrivateAttr(default=None)\n    constants: Dict[str, Any] = Field(\n        default_factory=dict, description=\"Value constants for this module.\"\n    )\n    defaults: Dict[str, Any] = Field(\n        default_factory=dict, description=\"Value defaults for this module.\"\n    )\n\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n\n    def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n        if key not in self.__fields__:\n            raise Exception(\n                f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n            )\n\n        return getattr(self, key)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        my_table = Table(box=box.MINIMAL, show_header=False)\n        my_table.add_column(\"Field name\", style=\"i\")\n        my_table.add_column(\"Value\")\n        for field in self.__fields__:\n            attr = getattr(self, field)\n            if isinstance(attr, str):\n                attr_str = attr\n            elif hasattr(attr, \"create_renderable\"):\n                attr_str = attr.create_renderable()\n            elif isinstance(attr, BaseModel):\n                attr_str = attr.json(option=orjson.orjson.OPT_INDENT_2)\n            else:\n                attr_str = str(attr)\n            my_table.add_row(field, attr_str)\n\n        return my_table\n</code></pre>"},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.constants","title":"<code>constants: Dict[str, Any] = Field(default_factory=dict, description='Value constants for this module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.defaults","title":"<code>defaults: Dict[str, Any] = Field(default_factory=dict, description='Value defaults for this module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/__init__.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n</code></pre>"},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.requires_config","title":"<code>requires_config(config: Union[Mapping[str, Any], None] = None) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Return whether this class can be used as-is, or requires configuration before an instance can be created.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>@classmethod\ndef requires_config(cls, config: Union[Mapping[str, Any], None] = None) -&gt; bool:\n\"\"\"Return whether this class can be used as-is, or requires configuration before an instance can be created.\"\"\"\n\n    for field_name, field in cls.__fields__.items():\n        if field.required and field.default is None:\n            if config:\n                if config.get(field_name, None) is None:\n                    return True\n            else:\n                return True\n    return False\n</code></pre>"},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Get the value for the specified configuation key.</p> Source code in <code>kiara/models/module/__init__.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified configuation key.\"\"\"\n\n    if key not in self.__fields__:\n        raise Exception(\n            f\"No config value '{key}' in module config class '{self.__class__.__name__}'.\"\n        )\n\n    return getattr(self, key)\n</code></pre>"},{"location":"reference/kiara/models/module/__init__/#kiara.models.module.KiaraModuleConfig.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    my_table = Table(box=box.MINIMAL, show_header=False)\n    my_table.add_column(\"Field name\", style=\"i\")\n    my_table.add_column(\"Value\")\n    for field in self.__fields__:\n        attr = getattr(self, field)\n        if isinstance(attr, str):\n            attr_str = attr\n        elif hasattr(attr, \"create_renderable\"):\n            attr_str = attr.create_renderable()\n        elif isinstance(attr, BaseModel):\n            attr_str = attr.json(option=orjson.orjson.OPT_INDENT_2)\n        else:\n            attr_str = str(attr)\n        my_table.add_row(field, attr_str)\n\n    return my_table\n</code></pre>"},{"location":"reference/kiara/models/module/destiny/","title":"destiny","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny","title":"<code>Destiny</code>","text":"<p>         Bases: <code>Manifest</code></p> <p>A destiny is basically a link to a potential future transformation result involving one or several values as input.</p> <p>It is immutable, once executed, each of the input values can only have one destiny with a specific alias. This is similar to what is usually called a 'future' in programming languages, but more deterministic, sorta.</p> Source code in <code>kiara/models/module/destiny.py</code> <pre><code>class Destiny(Manifest):\n\"\"\"A destiny is basically a link to a potential future transformation result involving one or several values as input.\n\n    It is immutable, once executed, each of the input values can only have one destiny with a specific alias.\n    This is similar to what is usually called a 'future' in programming languages, but more deterministic, sorta.\n    \"\"\"\n\n    _kiara_model_id = \"instance.destiny\"\n\n    @classmethod\n    def create_from_values(\n        cls,\n        kiara: \"Kiara\",\n        destiny_alias: str,\n        values: Mapping[str, uuid.UUID],\n        manifest: Manifest,\n        result_field_name: Union[str, None] = None,\n    ):\n\n        module = kiara.module_registry.create_module(manifest=manifest)\n\n        if result_field_name is None:\n            if len(module.outputs_schema) != 1:\n                raise Exception(\n                    f\"Can't determine result field name for module, not provided, and multiple outputs available for module '{module.module_type_name}': {', '.join(module.outputs_schema.keys())}.\"\n                )\n\n            result_field_name = next(iter(module.outputs_schema.keys()))\n\n        result_schema = module.outputs_schema.get(result_field_name, None)\n        if result_schema is None:\n            raise Exception(\n                f\"Can't determine result schema for module '{module.module_type_name}', result field '{result_field_name}' not available. Available field: {', '.join(module.outputs_schema.keys())}\"\n            )\n\n        fixed_inputs = {}\n        deferred_inputs: Dict[str, None] = {}\n        for field in module.inputs_schema.keys():\n            if field in values.keys():\n                fixed_inputs[field] = values[field]\n            else:\n                deferred_inputs[field] = None\n\n        module_details = KiaraModuleInstance.from_module(module=module)\n\n        # TODO: check whether it'd be better to 'resolve' the module config, as this might change the resulting hash\n        destiny_id: uuid.UUID = ID_REGISTRY.generate(obj_type=Destiny)\n        destiny = Destiny(\n            destiny_id=destiny_id,\n            destiny_alias=destiny_alias,\n            module_details=module_details,\n            module_type=manifest.module_type,\n            module_config=manifest.module_config,\n            result_field_name=result_field_name,\n            result_schema=result_schema,\n            fixed_inputs=fixed_inputs,\n            inputs_schema=dict(module.inputs_schema),\n            deferred_inputs=deferred_inputs,\n            result_value_id=None,\n        )\n        destiny._module = module\n        ID_REGISTRY.update_metadata(destiny_id, obj=destiny)\n        return destiny\n\n    destiny_id: uuid.UUID = Field(description=\"The id of this destiny.\")\n\n    destiny_alias: str = Field(description=\"The path to (the) destiny.\")\n    module_details: KiaraModuleInstance = Field(\n        description=\"The class of the underlying module.\"\n    )\n    fixed_inputs: Dict[str, uuid.UUID] = Field(\n        description=\"Inputs that are known in advance.\"\n    )\n    inputs_schema: Dict[str, ValueSchema] = Field(\n        description=\"The schemas of all deferred input fields.\"\n    )\n    deferred_inputs: Dict[str, Union[uuid.UUID, None]] = Field(\n        description=\"Potentially required external inputs that are needed for this destiny to materialize.\"\n    )\n    result_field_name: str = Field(description=\"The name of the result field.\")\n    result_schema: ValueSchema = Field(description=\"The value schema of the result.\")\n    result_value_id: Union[uuid.UUID, None] = Field(\n        description=\"The value id of the result.\"\n    )\n\n    _is_stored: bool = PrivateAttr(default=False)\n    _job_id: Union[uuid.UUID, None] = PrivateAttr(default=None)\n\n    _merged_inputs: Union[Dict[str, uuid.UUID], None] = PrivateAttr(default=None)\n    # _job_config_hash: Optional[int] = PrivateAttr(default=None)\n    _module: Union[\"KiaraModule\", None] = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.destiny_id)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.destiny_id.bytes\n\n    # @property\n    # def job_config_hash(self) -&gt; int:\n    #     if self._job_config_hash is None:\n    #         self._job_config_hash = self._retrieve_job_config_hash()\n    #     return self._job_config_hash\n\n    @property\n    def merged_inputs(self) -&gt; Mapping[str, uuid.UUID]:\n\n        if self._merged_inputs is not None:\n            return self._merged_inputs\n\n        result = copy.copy(self.fixed_inputs)\n        missing = []\n        for k in self.inputs_schema.keys():\n            if k in self.fixed_inputs.keys():\n                if k in self.deferred_inputs.keys():\n                    raise Exception(\n                        f\"Destiny input field '{k}' present in both fixed and deferred inputs, this is invalid.\"\n                    )\n                else:\n                    continue\n            v = self.deferred_inputs.get(k, None)\n            if v is None or isinstance(v, SpecialValue):\n                missing.append(k)\n            else:\n                result[k] = v\n\n        if missing:\n            raise Exception(\n                f\"Destiny not valid (yet), missing inputs: {', '.join(missing)}\"\n            )\n\n        self._merged_inputs = result\n        return self._merged_inputs\n\n    @property\n    def module(self) -&gt; \"KiaraModule\":\n        if self._module is None:\n            m_cls = self.module_details.get_class()\n            self._module = m_cls(module_config=self.module_config)\n        return self._module\n</code></pre>"},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.destiny_id","title":"<code>destiny_id: uuid.UUID = Field(description='The id of this destiny.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.destiny_alias","title":"<code>destiny_alias: str = Field(description='The path to (the) destiny.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.module_details","title":"<code>module_details: KiaraModuleInstance = Field(description='The class of the underlying module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.fixed_inputs","title":"<code>fixed_inputs: Dict[str, uuid.UUID] = Field(description='Inputs that are known in advance.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.inputs_schema","title":"<code>inputs_schema: Dict[str, ValueSchema] = Field(description='The schemas of all deferred input fields.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.deferred_inputs","title":"<code>deferred_inputs: Dict[str, Union[uuid.UUID, None]] = Field(description='Potentially required external inputs that are needed for this destiny to materialize.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.result_field_name","title":"<code>result_field_name: str = Field(description='The name of the result field.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.result_schema","title":"<code>result_schema: ValueSchema = Field(description='The value schema of the result.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.result_value_id","title":"<code>result_value_id: Union[uuid.UUID, None] = Field(description='The value id of the result.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.merged_inputs","title":"<code>merged_inputs: Mapping[str, uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.module","title":"<code>module: KiaraModule</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/destiny/#kiara.models.module.destiny.Destiny.create_from_values","title":"<code>create_from_values(kiara: Kiara, destiny_alias: str, values: Mapping[str, uuid.UUID], manifest: Manifest, result_field_name: Union[str, None] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/destiny.py</code> <pre><code>@classmethod\ndef create_from_values(\n    cls,\n    kiara: \"Kiara\",\n    destiny_alias: str,\n    values: Mapping[str, uuid.UUID],\n    manifest: Manifest,\n    result_field_name: Union[str, None] = None,\n):\n\n    module = kiara.module_registry.create_module(manifest=manifest)\n\n    if result_field_name is None:\n        if len(module.outputs_schema) != 1:\n            raise Exception(\n                f\"Can't determine result field name for module, not provided, and multiple outputs available for module '{module.module_type_name}': {', '.join(module.outputs_schema.keys())}.\"\n            )\n\n        result_field_name = next(iter(module.outputs_schema.keys()))\n\n    result_schema = module.outputs_schema.get(result_field_name, None)\n    if result_schema is None:\n        raise Exception(\n            f\"Can't determine result schema for module '{module.module_type_name}', result field '{result_field_name}' not available. Available field: {', '.join(module.outputs_schema.keys())}\"\n        )\n\n    fixed_inputs = {}\n    deferred_inputs: Dict[str, None] = {}\n    for field in module.inputs_schema.keys():\n        if field in values.keys():\n            fixed_inputs[field] = values[field]\n        else:\n            deferred_inputs[field] = None\n\n    module_details = KiaraModuleInstance.from_module(module=module)\n\n    # TODO: check whether it'd be better to 'resolve' the module config, as this might change the resulting hash\n    destiny_id: uuid.UUID = ID_REGISTRY.generate(obj_type=Destiny)\n    destiny = Destiny(\n        destiny_id=destiny_id,\n        destiny_alias=destiny_alias,\n        module_details=module_details,\n        module_type=manifest.module_type,\n        module_config=manifest.module_config,\n        result_field_name=result_field_name,\n        result_schema=result_schema,\n        fixed_inputs=fixed_inputs,\n        inputs_schema=dict(module.inputs_schema),\n        deferred_inputs=deferred_inputs,\n        result_value_id=None,\n    )\n    destiny._module = module\n    ID_REGISTRY.update_metadata(destiny_id, obj=destiny)\n    return destiny\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/","title":"jobs","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ExecutionContext","title":"<code>ExecutionContext</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class ExecutionContext(KiaraModel):\n\n    _kiara_model_id = \"instance.execution_context\"\n\n    working_dir: str = Field(\n        description=\"The path of the working directory.\", default_factory=os.getcwd\n    )\n    pipeline_dir: Union[str, None] = Field(\n        description=\"The path of the pipeline file that is being executed (if applicable).\",\n        default=None,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ExecutionContext-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ExecutionContext.working_dir","title":"<code>working_dir: str = Field(description='The path of the working directory.', default_factory=os.getcwd)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ExecutionContext.pipeline_dir","title":"<code>pipeline_dir: Union[str, None] = Field(description='The path of the pipeline file that is being executed (if applicable).', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus","title":"<code>JobStatus</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class JobStatus(Enum):\n\n    CREATED = \"__job_created__\"\n    STARTED = \"__job_started__\"\n    SUCCESS = \"__job_success__\"\n    FAILED = \"__job_failed__\"\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus.CREATED","title":"<code>CREATED = '__job_created__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus.STARTED","title":"<code>STARTED = '__job_started__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus.SUCCESS","title":"<code>SUCCESS = '__job_success__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobStatus.FAILED","title":"<code>FAILED = '__job_failed__'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.LogMessage","title":"<code>LogMessage</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class LogMessage(BaseModel):\n\n    timestamp: datetime = Field(\n        description=\"The time the message was logged.\", default_factory=datetime.now\n    )\n    log_level: int = Field(description=\"The log level.\")\n    msg: str = Field(description=\"The log message\")\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.LogMessage-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.LogMessage.timestamp","title":"<code>timestamp: datetime = Field(description='The time the message was logged.', default_factory=datetime.now)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.LogMessage.log_level","title":"<code>log_level: int = Field(description='The log level.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.LogMessage.msg","title":"<code>msg: str = Field(description='The log message')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog","title":"<code>JobLog</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class JobLog(BaseModel):\n\n    log: List[LogMessage] = Field(\n        description=\"The logs for this job.\", default_factory=list\n    )\n    percent_finished: int = Field(\n        description=\"Describes how much of the job is finished. A negative number means the module does not support progress tracking.\",\n        default=-1,\n    )\n\n    def add_log(self, msg: str, log_level: int = logging.DEBUG):\n\n        _msg = LogMessage(msg=msg, log_level=log_level)\n        self.log.append(_msg)\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog.log","title":"<code>log: List[LogMessage] = Field(description='The logs for this job.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog.percent_finished","title":"<code>percent_finished: int = Field(description='Describes how much of the job is finished. A negative number means the module does not support progress tracking.', default=-1)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobLog.add_log","title":"<code>add_log(msg: str, log_level: int = logging.DEBUG)</code>","text":"Source code in <code>kiara/models/module/jobs.py</code> <pre><code>def add_log(self, msg: str, log_level: int = logging.DEBUG):\n\n    _msg = LogMessage(msg=msg, log_level=log_level)\n    self.log.append(_msg)\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobConfig","title":"<code>JobConfig</code>","text":"<p>         Bases: <code>InputsManifest</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class JobConfig(InputsManifest):\n\n    _kiara_model_id = \"instance.job_config\"\n\n    @classmethod\n    def create_from_module(\n        cls,\n        data_registry: \"DataRegistry\",\n        module: \"KiaraModule\",\n        inputs: Mapping[str, Any],\n    ):\n\n        augmented = module.augment_module_inputs(inputs=inputs)\n\n        values = data_registry.create_valuemap(\n            data=augmented, schema=module.full_inputs_schema\n        )\n        invalid = values.check_invalid()\n        if invalid:\n            raise InvalidValuesException(invalid_values=invalid)\n\n        value_ids = values.get_all_value_ids()\n        return JobConfig.construct(\n            module_type=module.module_type_name,\n            module_config=module.config.dict(),\n            inputs=value_ids,\n        )\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\"manifest\": self.manifest_cid, \"inputs\": self.inputs_cid}\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobConfig.create_from_module","title":"<code>create_from_module(data_registry: DataRegistry, module: KiaraModule, inputs: Mapping[str, Any])</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/jobs.py</code> <pre><code>@classmethod\ndef create_from_module(\n    cls,\n    data_registry: \"DataRegistry\",\n    module: \"KiaraModule\",\n    inputs: Mapping[str, Any],\n):\n\n    augmented = module.augment_module_inputs(inputs=inputs)\n\n    values = data_registry.create_valuemap(\n        data=augmented, schema=module.full_inputs_schema\n    )\n    invalid = values.check_invalid()\n    if invalid:\n        raise InvalidValuesException(invalid_values=invalid)\n\n    value_ids = values.get_all_value_ids()\n    return JobConfig.construct(\n        module_type=module.module_type_name,\n        module_config=module.config.dict(),\n        inputs=value_ids,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob","title":"<code>ActiveJob</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class ActiveJob(KiaraModel):\n\n    _kiara_model_id = \"instance.active_job\"\n\n    job_id: uuid.UUID = Field(description=\"The job id.\")\n\n    job_config: JobConfig = Field(description=\"The job details.\")\n    status: JobStatus = Field(\n        description=\"The current status of the job.\", default=JobStatus.CREATED\n    )\n    job_log: JobLog = Field(description=\"The lob jog.\")\n    submitted: datetime = Field(\n        description=\"When the job was submitted.\", default_factory=datetime.now\n    )\n    started: Union[datetime, None] = Field(\n        description=\"When the job was started.\", default=None\n    )\n    finished: Union[datetime, None] = Field(\n        description=\"When the job was finished.\", default=None\n    )\n    results: Union[Dict[str, uuid.UUID], None] = Field(\n        description=\"The result(s).\", default=None\n    )\n    error: Union[str, None] = Field(\n        description=\"Potential error message.\", default=None\n    )\n    _exception: Union[Exception, None] = PrivateAttr(default=None)\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.job_id)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.job_id.bytes\n\n    @property\n    def exception(self) -&gt; Union[Exception, None]:\n        return self._exception\n\n    @property\n    def runtime(self) -&gt; Union[float, None]:\n\n        if self.started is None or self.finished is None:\n            return None\n\n        runtime = self.finished - self.started\n        return runtime.total_seconds()\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.job_id","title":"<code>job_id: uuid.UUID = Field(description='The job id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.job_config","title":"<code>job_config: JobConfig = Field(description='The job details.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.status","title":"<code>status: JobStatus = Field(description='The current status of the job.', default=JobStatus.CREATED)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.job_log","title":"<code>job_log: JobLog = Field(description='The lob jog.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.submitted","title":"<code>submitted: datetime = Field(description='When the job was submitted.', default_factory=datetime.now)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.started","title":"<code>started: Union[datetime, None] = Field(description='When the job was started.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.finished","title":"<code>finished: Union[datetime, None] = Field(description='When the job was finished.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.results","title":"<code>results: Union[Dict[str, uuid.UUID], None] = Field(description='The result(s).', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.error","title":"<code>error: Union[str, None] = Field(description='Potential error message.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.exception","title":"<code>exception: Union[Exception, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.ActiveJob.runtime","title":"<code>runtime: Union[float, None]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails","title":"<code>JobRuntimeDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class JobRuntimeDetails(BaseModel):\n\n    # @classmethod\n    # def from_manifest(\n    #     cls,\n    #     manifest: Manifest,\n    #     inputs: Mapping[str, Value],\n    #     outputs: Mapping[str, Value],\n    # ):\n    #\n    #     return JobRecord(\n    #         module_type=manifest.module_type,\n    #         module_config=manifest.module_config,\n    #         inputs={k: v.value_id for k, v in inputs.items()},\n    #         outputs={k: v.value_id for k, v in outputs.items()},\n    #     )\n\n    job_log: JobLog = Field(description=\"The lob jog.\")\n    submitted: datetime = Field(description=\"When the job was submitted.\")\n    started: datetime = Field(description=\"When the job was started.\")\n    finished: datetime = Field(description=\"When the job was finished.\")\n    runtime: float = Field(description=\"The duration of the job.\")\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails.job_log","title":"<code>job_log: JobLog = Field(description='The lob jog.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails.submitted","title":"<code>submitted: datetime = Field(description='When the job was submitted.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails.started","title":"<code>started: datetime = Field(description='When the job was started.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails.finished","title":"<code>finished: datetime = Field(description='When the job was finished.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRuntimeDetails.runtime","title":"<code>runtime: float = Field(description='The duration of the job.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord","title":"<code>JobRecord</code>","text":"<p>         Bases: <code>JobConfig</code></p> Source code in <code>kiara/models/module/jobs.py</code> <pre><code>class JobRecord(JobConfig):\n\n    _kiara_model_id = \"instance.job_record\"\n\n    @classmethod\n    def from_active_job(self, kiara: \"Kiara\", active_job: ActiveJob):\n\n        assert active_job.status == JobStatus.SUCCESS\n        assert active_job.results is not None\n\n        job_details = JobRuntimeDetails.construct(\n            job_log=active_job.job_log,\n            submitted=active_job.submitted,\n            started=active_job.started,  # type: ignore\n            finished=active_job.finished,  # type: ignore\n            runtime=active_job.runtime,  # type: ignore\n        )\n\n        inputs_data_cid = active_job.job_config.calculate_inputs_data_cid(\n            data_registry=kiara.data_registry\n        )\n\n        job_record = JobRecord(\n            job_id=active_job.job_id,\n            module_type=active_job.job_config.module_type,\n            module_config=active_job.job_config.module_config,\n            inputs=active_job.job_config.inputs,\n            outputs=active_job.results,\n            runtime_details=job_details,\n            environment_hashes=kiara.environment_registry.environment_hashes,\n            inputs_data_hash=str(inputs_data_cid)\n            if inputs_data_cid is not None\n            else None,\n        )\n        return job_record\n\n    job_id: uuid.UUID = Field(description=\"The globally unique id for this job.\")\n    environment_hashes: Mapping[str, Mapping[str, str]] = Field(\n        description=\"Hashes for the environments this value was created in.\"\n    )\n    enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(\n        description=\"Information about the environments this value was created in.\",\n        default=None,\n    )\n    inputs_data_hash: Union[str, None] = Field(\n        description=\"A map of the hashes of this jobs inputs.\"\n    )\n\n    outputs: Dict[str, uuid.UUID] = Field(description=\"References to the job outputs.\")\n    runtime_details: Union[JobRuntimeDetails, None] = Field(\n        description=\"Runtime details for the job.\"\n    )\n    job_metadata: Mapping[str, Any] = Field(\n        description=\"Optional metadata for this job.\", default_factory=dict\n    )\n\n    _is_stored: bool = PrivateAttr(default=None)\n    _outputs_hash: Union[int, None] = PrivateAttr(default=None)\n\n    @validator(\"job_metadata\", pre=True)\n    def validate_metadata(cls, value):\n\n        if value is None:\n            value = {}\n        return value\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            \"manifest\": self.manifest_cid,\n            \"inputs\": self.inputs_cid,\n            \"outputs\": {k: v.bytes for k, v in self.outputs.items()},\n        }\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        from kiara.utils.output import extract_renderable\n\n        include = config.get(\"include\", None)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n        for k in self.__fields__.keys():\n            if include is not None and k not in include:\n                continue\n            attr = getattr(self, k)\n            v = extract_renderable(attr)\n            table.add_row(k, v)\n        table.add_row(\"job hash\", self.job_hash)\n        table.add_row(\"inputs hash\", self.inputs_hash)\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.job_id","title":"<code>job_id: uuid.UUID = Field(description='The globally unique id for this job.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.environment_hashes","title":"<code>environment_hashes: Mapping[str, Mapping[str, str]] = Field(description='Hashes for the environments this value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.enviroments","title":"<code>enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(description='Information about the environments this value was created in.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.inputs_data_hash","title":"<code>inputs_data_hash: Union[str, None] = Field(description='A map of the hashes of this jobs inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.outputs","title":"<code>outputs: Dict[str, uuid.UUID] = Field(description='References to the job outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.runtime_details","title":"<code>runtime_details: Union[JobRuntimeDetails, None] = Field(description='Runtime details for the job.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.job_metadata","title":"<code>job_metadata: Mapping[str, Any] = Field(description='Optional metadata for this job.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.from_active_job","title":"<code>from_active_job(kiara: Kiara, active_job: ActiveJob)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/jobs.py</code> <pre><code>@classmethod\ndef from_active_job(self, kiara: \"Kiara\", active_job: ActiveJob):\n\n    assert active_job.status == JobStatus.SUCCESS\n    assert active_job.results is not None\n\n    job_details = JobRuntimeDetails.construct(\n        job_log=active_job.job_log,\n        submitted=active_job.submitted,\n        started=active_job.started,  # type: ignore\n        finished=active_job.finished,  # type: ignore\n        runtime=active_job.runtime,  # type: ignore\n    )\n\n    inputs_data_cid = active_job.job_config.calculate_inputs_data_cid(\n        data_registry=kiara.data_registry\n    )\n\n    job_record = JobRecord(\n        job_id=active_job.job_id,\n        module_type=active_job.job_config.module_type,\n        module_config=active_job.job_config.module_config,\n        inputs=active_job.job_config.inputs,\n        outputs=active_job.results,\n        runtime_details=job_details,\n        environment_hashes=kiara.environment_registry.environment_hashes,\n        inputs_data_hash=str(inputs_data_cid)\n        if inputs_data_cid is not None\n        else None,\n    )\n    return job_record\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.validate_metadata","title":"<code>validate_metadata(value)</code>","text":"Source code in <code>kiara/models/module/jobs.py</code> <pre><code>@validator(\"job_metadata\", pre=True)\ndef validate_metadata(cls, value):\n\n    if value is None:\n        value = {}\n    return value\n</code></pre>"},{"location":"reference/kiara/models/module/jobs/#kiara.models.module.jobs.JobRecord.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/jobs.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    from kiara.utils.output import extract_renderable\n\n    include = config.get(\"include\", None)\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Key\", style=\"i\")\n    table.add_column(\"Value\")\n    for k in self.__fields__.keys():\n        if include is not None and k not in include:\n            continue\n        attr = getattr(self, k)\n        v = extract_renderable(attr)\n        table.add_row(k, v)\n    table.add_row(\"job hash\", self.job_hash)\n    table.add_row(\"inputs hash\", self.inputs_hash)\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/","title":"manifest","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest","title":"<code>Manifest</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A class to hold the type and configuration for a module instance.</p> Source code in <code>kiara/models/module/manifest.py</code> <pre><code>class Manifest(KiaraModel):\n\"\"\"A class to hold the type and configuration for a module instance.\"\"\"\n\n    _kiara_model_id = \"instance.manifest\"\n\n    class Config:\n        extra = Extra.forbid\n        validate_all = True\n\n    _manifest_data: Union[Mapping[str, Any], None] = PrivateAttr(default=None)\n    _manifest_cid: Union[CID, None] = PrivateAttr(default=None)\n\n    module_type: str = Field(description=\"The module type.\")\n    module_config: Mapping[str, Any] = Field(\n        default_factory=dict, description=\"The configuration for the module.\"\n    )\n    is_resolved: bool = Field(\n        description=\"Whether the configuration of this module was augmented with the module type defaults etc.\",\n        default=False,\n    )\n    # python_class: PythonClass = Field(description=\"The python class that implements this module.\")\n    # doc: DocumentationMetadataModel = Field(\n    #     description=\"Documentation for this module instance.\", default=None\n    # )\n\n    # @validator(\"module_config\")\n    # def _validate_module_config(cls, value):\n    #\n    #     return value\n\n    @property\n    def manifest_data(self):\n\"\"\"The configuration data for this module instance.\"\"\"\n        if self._manifest_data is not None:\n            return self._manifest_data\n\n        self._manifest_data = {\n            \"module_type\": self.module_type,\n            \"module_config\": self.module_config,\n        }\n        return self._manifest_data\n\n    @property\n    def manifest_cid(self) -&gt; CID:\n        if self._manifest_cid is not None:\n            return self._manifest_cid\n\n        _, self._manifest_cid = compute_cid(self.manifest_data)\n        return self._manifest_cid\n\n    @property\n    def manifest_hash(self) -&gt; str:\n        return str(self.manifest_cid)\n\n    def manifest_data_as_json(self):\n\n        return self.json(include={\"module_type\", \"module_config\"})\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.manifest_data\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n        data = self.dict(exclude_none=True)\n        conf = Syntax(\n            orjson_dumps(data, option=orjson.OPT_INDENT_2),\n            \"json\",\n            background_color=\"default\",\n        )\n        return conf\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(module_type={self.module_type}, module_config={self.module_config})\"\n\n    def __str__(self):\n\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.module_type","title":"<code>module_type: str = Field(description='The module type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.module_config","title":"<code>module_config: Mapping[str, Any] = Field(default_factory=dict, description='The configuration for the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.is_resolved","title":"<code>is_resolved: bool = Field(description='Whether the configuration of this module was augmented with the module type defaults etc.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.manifest_data","title":"<code>manifest_data</code>  <code>property</code>","text":"<p>The configuration data for this module instance.</p>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.manifest_cid","title":"<code>manifest_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.manifest_hash","title":"<code>manifest_hash: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/manifest.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_all = True\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_all = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.manifest_data_as_json","title":"<code>manifest_data_as_json()</code>","text":"Source code in <code>kiara/models/module/manifest.py</code> <pre><code>def manifest_data_as_json(self):\n\n    return self.json(include={\"module_type\", \"module_config\"})\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.Manifest.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"<p>Create a renderable for this module configuration.</p> Source code in <code>kiara/models/module/manifest.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n    data = self.dict(exclude_none=True)\n    conf = Syntax(\n        orjson_dumps(data, option=orjson.OPT_INDENT_2),\n        \"json\",\n        background_color=\"default\",\n    )\n    return conf\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest","title":"<code>InputsManifest</code>","text":"<p>         Bases: <code>Manifest</code></p> Source code in <code>kiara/models/module/manifest.py</code> <pre><code>class InputsManifest(Manifest):\n\n    _kiara_model_id = \"instance.manifest_with_inputs\"\n\n    inputs: Mapping[str, uuid.UUID] = Field(\n        description=\"A map of all the input fields and value references.\"\n    )\n    _inputs_cid: Union[CID, None] = PrivateAttr(default=None)\n    _jobs_cid: Union[CID, None] = PrivateAttr(default=None)\n    _inputs_data_cid: Union[bool, CID, None] = PrivateAttr(default=None)\n\n    @validator(\"inputs\")\n    def replace_none_values(cls, value):\n        result = {}\n        for k, v in value.items():\n            if v is None:\n                v = NONE_VALUE_ID\n            result[k] = v\n        return result\n\n    @property\n    def job_hash(self) -&gt; str:\n\n        return str(self.job_cid)\n\n    @property\n    def job_cid(self) -&gt; CID:\n\n        if self._jobs_cid is not None:\n            return self._jobs_cid\n\n        obj: Kind = {\"manifest\": self.manifest_cid, \"inputs\": self.inputs_cid}\n        _, self._jobs_cid = compute_cid(data=obj)\n        return self._jobs_cid\n\n    @property\n    def inputs_cid(self) -&gt; CID:\n        if self._inputs_cid is not None:\n            return self._inputs_cid\n\n        _, cid = compute_cid(data={k: v.bytes for k, v in self.inputs.items()})\n        self._inputs_cid = cid\n        return self._inputs_cid\n\n    @property\n    def inputs_hash(self) -&gt; str:\n        return str(self.inputs_cid)\n\n    def calculate_inputs_data_cid(\n        self, data_registry: \"DataRegistry\"\n    ) -&gt; Union[CID, None]:\n\n        if self._inputs_data_cid is not None:\n            if self._inputs_data_cid is False:\n                return None\n            return self._inputs_data_cid  # type: ignore\n\n        data_hashes: Dict[str, Any] = {}\n        invalid = False\n\n        for k, v in self.inputs.items():\n            value = data_registry.get_value(v)\n            if value.value_hash == INVALID_HASH_MARKER:\n                invalid = True\n                break\n            data_hashes[k] = CID.decode(value.value_hash)\n\n        if invalid:\n            self._inputs_data_cid = False\n            return None\n\n        _, cid = compute_cid(data=data_hashes)\n        self._inputs_data_cid = cid\n        return cid\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.inputs","title":"<code>inputs: Mapping[str, uuid.UUID] = Field(description='A map of all the input fields and value references.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.job_hash","title":"<code>job_hash: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.job_cid","title":"<code>job_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.inputs_cid","title":"<code>inputs_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.inputs_hash","title":"<code>inputs_hash: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.replace_none_values","title":"<code>replace_none_values(value)</code>","text":"Source code in <code>kiara/models/module/manifest.py</code> <pre><code>@validator(\"inputs\")\ndef replace_none_values(cls, value):\n    result = {}\n    for k, v in value.items():\n        if v is None:\n            v = NONE_VALUE_ID\n        result[k] = v\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest.InputsManifest.calculate_inputs_data_cid","title":"<code>calculate_inputs_data_cid(data_registry: DataRegistry) -&gt; Union[CID, None]</code>","text":"Source code in <code>kiara/models/module/manifest.py</code> <pre><code>def calculate_inputs_data_cid(\n    self, data_registry: \"DataRegistry\"\n) -&gt; Union[CID, None]:\n\n    if self._inputs_data_cid is not None:\n        if self._inputs_data_cid is False:\n            return None\n        return self._inputs_data_cid  # type: ignore\n\n    data_hashes: Dict[str, Any] = {}\n    invalid = False\n\n    for k, v in self.inputs.items():\n        value = data_registry.get_value(v)\n        if value.value_hash == INVALID_HASH_MARKER:\n            invalid = True\n            break\n        data_hashes[k] = CID.decode(value.value_hash)\n\n    if invalid:\n        self._inputs_data_cid = False\n        return None\n\n    _, cid = compute_cid(data=data_hashes)\n    self._inputs_data_cid = cid\n    return cid\n</code></pre>"},{"location":"reference/kiara/models/module/manifest/#kiara.models.module.manifest-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/","title":"operation","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationSchema","title":"<code>OperationSchema</code>","text":"<p>         Bases: <code>InputOutputObject</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class OperationSchema(InputOutputObject):\n    def __init__(\n        self, alias: str, inputs_schema: ValueMapSchema, outputs_schema: ValueMapSchema\n    ):\n\n        allow_empty_inputs = True\n        allow_empty_outputs = True\n\n        self._inputs_schema_static: ValueMapSchema = inputs_schema\n        self._outputs_schema_static: ValueMapSchema = outputs_schema\n        super().__init__(\n            alias=alias,\n            allow_empty_inputs_schema=allow_empty_inputs,\n            allow_empty_outputs_schema=allow_empty_outputs,\n        )\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n        return self._inputs_schema_static\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        return self._outputs_schema_static\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationSchema-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationSchema.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n    return self._inputs_schema_static\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationSchema.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    return self._outputs_schema_static\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails","title":"<code>OperationDetails</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class OperationDetails(KiaraModel):\n\n    _kiara_model_id = \"instance.operation_details\"\n\n    # inputs_map: Dict[str, str] = Field(description=\"A map with the operations input fields as keys, and the underlying modules input fields as values, used to translate input value maps.\")\n    # outputs_map: Dict[str, str] = Field(description=\"A map with the operations input fields as keys, and the underlying modules input fields as values, used to translate input value maps.\")\n\n    @classmethod\n    def create_operation_details(cls, **details: Any):\n\n        if PYDANTIC_USE_CONSTRUCT:\n            result = cls.construct(**details)\n        else:\n            result = cls(**details)\n\n        return result\n\n    operation_id: str = Field(description=\"The id of the operation.\")\n    is_internal_operation: bool = Field(\n        description=\"Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.).\",\n        default=False,\n    )\n\n    def _retrieve_id(self) -&gt; str:\n        return self.operation_id\n\n    @property\n    def inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\"\"\"The input schema for this module.\"\"\"\n\n        return self.get_operation_schema().inputs_schema\n\n    @property\n    def outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\"\"\"The input schema for this module.\"\"\"\n\n        return self.get_operation_schema().outputs_schema\n\n    def get_operation_schema(self) -&gt; OperationSchema:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.operation_id","title":"<code>operation_id: str = Field(description='The id of the operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.is_internal_operation","title":"<code>is_internal_operation: bool = Field(description='Whether this operation is mainly used kiara-internally. Helps to hide it in UIs (operation lists etc.).', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.inputs_schema","title":"<code>inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":"<p>The input schema for this module.</p>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.outputs_schema","title":"<code>outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":"<p>The input schema for this module.</p>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.create_operation_details","title":"<code>create_operation_details(**details: Any)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@classmethod\ndef create_operation_details(cls, **details: Any):\n\n    if PYDANTIC_USE_CONSTRUCT:\n        result = cls.construct(**details)\n    else:\n        result = cls(**details)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationDetails.get_operation_schema","title":"<code>get_operation_schema() -&gt; OperationSchema</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def get_operation_schema(self) -&gt; OperationSchema:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails","title":"<code>BaseOperationDetails</code>","text":"<p>         Bases: <code>OperationDetails</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class BaseOperationDetails(OperationDetails):\n\n    _kiara_model_id = \"instance.operation_details.base\"\n\n    module_inputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The input schemas of the module.\"\n    )\n    module_outputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The output schemas of the module.\"\n    )\n    _op_schema: OperationSchema = PrivateAttr(default=None)\n\n    def get_operation_schema(self) -&gt; OperationSchema:\n\n        if self._op_schema is not None:\n            return self._op_schema\n\n        self._op_schema = OperationSchema(\n            alias=self.operation_id,\n            inputs_schema=self.module_inputs_schema,\n            outputs_schema=self.module_outputs_schema,\n        )\n        return self._op_schema\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails.module_inputs_schema","title":"<code>module_inputs_schema: Mapping[str, ValueSchema] = Field(description='The input schemas of the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails.module_outputs_schema","title":"<code>module_outputs_schema: Mapping[str, ValueSchema] = Field(description='The output schemas of the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.BaseOperationDetails.get_operation_schema","title":"<code>get_operation_schema() -&gt; OperationSchema</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def get_operation_schema(self) -&gt; OperationSchema:\n\n    if self._op_schema is not None:\n        return self._op_schema\n\n    self._op_schema = OperationSchema(\n        alias=self.operation_id,\n        inputs_schema=self.module_inputs_schema,\n        outputs_schema=self.module_outputs_schema,\n    )\n    return self._op_schema\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig","title":"<code>OperationConfig</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class OperationConfig(KiaraModel):\n\n    doc: DocumentationMetadataModel = Field(\n        description=\"Documentation for this operation.\"\n    )\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n\n    @abc.abstractmethod\n    def retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n        pass\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Documentation for this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig.retrieve_module_type","title":"<code>retrieve_module_type(kiara: Kiara) -&gt; str</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.OperationConfig.retrieve_module_config","title":"<code>retrieve_module_config(kiara: Kiara) -&gt; Mapping[str, Any]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig","title":"<code>ManifestOperationConfig</code>","text":"<p>         Bases: <code>OperationConfig</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class ManifestOperationConfig(OperationConfig):\n\n    _kiara_model_id = \"instance.operation_config.manifest\"\n\n    module_type: str = Field(description=\"The module type.\")\n    module_config: Dict[str, Any] = Field(\n        default_factory=dict, description=\"The configuration for the module.\"\n    )\n\n    def retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n        return self.module_type\n\n    def retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n        return self.module_config\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig.module_type","title":"<code>module_type: str = Field(description='The module type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig.module_config","title":"<code>module_config: Dict[str, Any] = Field(default_factory=dict, description='The configuration for the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig.retrieve_module_type","title":"<code>retrieve_module_type(kiara: Kiara) -&gt; str</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n    return self.module_type\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.ManifestOperationConfig.retrieve_module_config","title":"<code>retrieve_module_config(kiara: Kiara) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n    return self.module_config\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig","title":"<code>PipelineOperationConfig</code>","text":"<p>         Bases: <code>OperationConfig</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class PipelineOperationConfig(OperationConfig):\n\n    _kiara_model_id = \"instance.operation_config.pipeline\"\n\n    pipeline_name: str = Field(description=\"The pipeline id.\")\n    pipeline_config: Mapping[str, Any] = Field(description=\"The pipeline config data.\")\n    module_map: Dict[str, Any] = Field(\n        description=\"A lookup map to resolves operation ids to module names/configs.\",\n        default_factory=dict,\n    )\n    metadata: Mapping[str, Any] = Field(\n        description=\"Additional metadata for the pipeline.\", default_factory=dict\n    )\n\n    @validator(\"pipeline_config\")\n    def validate_pipeline_config(cls, value):\n        # TODO\n        assert isinstance(value, Mapping)\n        assert \"steps\" in value.keys()\n\n        return value\n\n    def retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n        return \"pipeline\"\n\n    def retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n\n        # using _from_config here because otherwise we'd enter an infinite loop\n        pipeline_config = PipelineConfig._from_config(\n            pipeline_name=self.pipeline_name,\n            data=self.pipeline_config,\n            kiara=kiara,\n            module_map=self.module_map,\n        )\n        return pipeline_config.dict()\n\n    @property\n    def required_module_types(self) -&gt; Iterable[str]:\n\n        return [step[\"module_type\"] for step in self.pipeline_config[\"steps\"]]\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(pipeline_name={self.pipeline_name} required_modules={list(self.required_module_types)} instance_id={self.instance_id} fields=[{', '.join(self.__fields__.keys())}])\"\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.pipeline_name","title":"<code>pipeline_name: str = Field(description='The pipeline id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.pipeline_config","title":"<code>pipeline_config: Mapping[str, Any] = Field(description='The pipeline config data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.module_map","title":"<code>module_map: Dict[str, Any] = Field(description='A lookup map to resolves operation ids to module names/configs.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.metadata","title":"<code>metadata: Mapping[str, Any] = Field(description='Additional metadata for the pipeline.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.required_module_types","title":"<code>required_module_types: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.validate_pipeline_config","title":"<code>validate_pipeline_config(value)</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@validator(\"pipeline_config\")\ndef validate_pipeline_config(cls, value):\n    # TODO\n    assert isinstance(value, Mapping)\n    assert \"steps\" in value.keys()\n\n    return value\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.retrieve_module_type","title":"<code>retrieve_module_type(kiara: Kiara) -&gt; str</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def retrieve_module_type(self, kiara: \"Kiara\") -&gt; str:\n    return \"pipeline\"\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.PipelineOperationConfig.retrieve_module_config","title":"<code>retrieve_module_config(kiara: Kiara) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def retrieve_module_config(self, kiara: \"Kiara\") -&gt; Mapping[str, Any]:\n\n    # using _from_config here because otherwise we'd enter an infinite loop\n    pipeline_config = PipelineConfig._from_config(\n        pipeline_name=self.pipeline_name,\n        data=self.pipeline_config,\n        kiara=kiara,\n        module_map=self.module_map,\n    )\n    return pipeline_config.dict()\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation","title":"<code>Operation</code>","text":"<p>         Bases: <code>Manifest</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class Operation(Manifest):\n\n    _kiara_model_id = \"instance.operation\"\n\n    @classmethod\n    def create_from_module(\n        cls, module: KiaraModule, doc: Union[Any, None] = None\n    ) -&gt; \"Operation\":\n\n        from kiara.operations.included_core_operations import (\n            CustomModuleOperationDetails,\n        )\n\n        op_id = f\"{module.module_type_name}._{module.module_instance_cid}\"\n        if module.is_pipeline():\n            from kiara.operations.included_core_operations.pipeline import (\n                PipelineOperationDetails,\n            )\n\n            details = PipelineOperationDetails.create_operation_details(\n                operation_id=module.config.pipeline_name,\n                pipeline_inputs_schema=module.inputs_schema,\n                pipeline_outputs_schema=module.outputs_schema,\n                pipeline_config=module.config,\n            )\n        else:\n            details = CustomModuleOperationDetails.create_from_module(module=module)\n\n        if doc is not None:\n            doc = DocumentationMetadataModel.create(doc)\n        else:\n            doc = DocumentationMetadataModel.from_class_doc(module.__class__)\n\n        operation = Operation(\n            module_type=module.module_type_name,\n            module_config=module.config.dict(),\n            operation_id=op_id,\n            operation_details=details,\n            module_details=KiaraModuleInstance.from_module(module),\n            doc=doc,\n        )\n        operation._module = module\n        return operation\n\n    operation_id: str = Field(description=\"The (unique) id of this operation.\")\n    operation_details: OperationDetails = Field(\n        description=\"The operation specific details of this operation.\"\n    )\n    doc: DocumentationMetadataModel = Field(\n        description=\"Documentation for this operation.\"\n    )\n\n    module_details: KiaraModuleInstance = Field(\n        description=\"The class of the underlying module.\"\n    )\n    metadata: Mapping[str, Any] = Field(\n        description=\"Additional metadata for this operation.\", default_factory=dict\n    )\n\n    _module: Union[\"KiaraModule\", None] = PrivateAttr(default=None)\n    _pipeline_config: Union[None, PipelineConfig] = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\"operation_id\": self.operation_id, \"manifest\": self.manifest_cid}\n\n    def _retrieve_id(self) -&gt; str:\n        return self.operation_id\n\n    @property\n    def module(self) -&gt; \"KiaraModule\":\n        if self._module is None:\n            m_cls = self.module_details.get_class()\n            self._module = m_cls(module_config=self.module_config)\n        return self._module\n\n    @property\n    def inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n        return self.operation_details.inputs_schema\n\n    @property\n    def outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n        return self.operation_details.outputs_schema\n\n    def prepare_job_config(\n        self, kiara: \"Kiara\", inputs: Mapping[str, Any]\n    ) -&gt; JobConfig:\n\n        augmented_inputs = (\n            self.operation_details.get_operation_schema().augment_module_inputs(\n                inputs=inputs\n            )\n        )\n\n        # module_inputs = self.operation_details.create_module_inputs(\n        #     inputs=augmented_inputs\n        # )\n\n        job_config = kiara.job_registry.prepare_job_config(\n            manifest=self, inputs=augmented_inputs\n        )\n        return job_config\n\n    def run(self, kiara: \"Kiara\", inputs: Mapping[str, Any]) -&gt; ValueMap:\n\n        logger.debug(\"run.operation\", operation_id=self.operation_id)\n        job_config = self.prepare_job_config(kiara=kiara, inputs=inputs)\n\n        job_id = kiara.job_registry.execute_job(job_config=job_config)\n        outputs: ValueMap = kiara.job_registry.retrieve_result(job_id=job_id)\n\n        result = self.process_job_outputs(outputs=outputs)\n\n        return result\n\n    def process_job_outputs(self, outputs: ValueMap) -&gt; ValueMap:\n\n        # op_outputs = self.operation_details.create_operation_outputs(outputs=outputs)\n\n        value_set = ValueMapReadOnly(value_items=outputs, values_schema=self.outputs_schema)  # type: ignore\n        return value_set\n\n    # def run(self, _attach_lineage: bool = True, **inputs: Any) -&gt; ValueMap:\n    #\n    #     return self.module.run(_attach_lineage=_attach_lineage, **inputs)\n\n    # def create_html(self, **config) -&gt; str:\n    #\n    #     r = self.create_renderable(**config)\n    #     p = Panel(r, title=f\"Operation: {self.operation_id}\", title_align=\"left\")\n    #     mime_bundle = p._repr_mimebundle_(include=[], exclude=[])  # type: ignore\n    #     return mime_bundle[\"text/html\"]\n\n    @property\n    def pipeline_config(self) -&gt; PipelineConfig:\n\n        if not self.module.is_pipeline():\n            raise Exception(\n                f\"Can't retrieve pipeline details from operation '{self.operation_id}: not a pipeline operation type.'\"\n            )\n\n        op_details = self.operation_details\n        return op_details.pipeline_config  # type: ignore\n\n    @property\n    def pipeline_structure(self) -&gt; \"PipelineStructure\":\n        return self.pipeline_config.structure\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a printable overview of this operations details.\n\n        Available render_config options:\n          - 'include_full_doc' (default: True): whether to include the full documentation, or just a description\n          - 'include_src' (default: False): whether to include the module source code\n        \"\"\"\n\n        include_full_doc = config.get(\"include_full_doc\", True)\n        include_src = config.get(\"include_src\", False)\n        include_inputs = config.get(\"include_inputs\", True)\n        include_outputs = config.get(\"include_outputs\", True)\n        include_module_details = config.get(\"include_module_details\", False)\n\n        table = Table(box=box.SIMPLE, show_header=False, show_lines=True)\n        table.add_column(\"Property\", style=\"i\")\n        table.add_column(\"Value\")\n\n        if self.doc:\n            if include_full_doc:\n                table.add_row(\"Documentation\", self.doc.full_doc)\n            else:\n                table.add_row(\"Description\", self.doc.description)\n\n        # module_type_md = self.module.get_type_metadata()\n\n        if include_inputs:\n            inputs_table = create_table_from_field_schemas(\n                _add_required=True,\n                _add_default=True,\n                _show_header=True,\n                _constants=None,\n                fields=self.operation_details.inputs_schema,\n            )\n            table.add_row(\"Inputs\", inputs_table)\n        if include_outputs:\n            outputs_table = create_table_from_field_schemas(\n                _add_required=False,\n                _add_default=False,\n                _show_header=True,\n                _constants=None,\n                fields=self.operation_details.outputs_schema,\n            )\n            table.add_row(\"Outputs\", outputs_table)\n\n        if include_module_details:\n            table.add_row(\"Module type\", self.module_type)\n\n            module_config = self.module.config.json(option=orjson.OPT_INDENT_2)\n            conf = Syntax(\n                module_config,\n                \"json\",\n                background_color=\"default\",\n            )\n            table.add_row(\"Module config\", conf)\n\n            from kiara.interfaces.python_api import ModuleTypeInfo\n\n            module_type_md = ModuleTypeInfo.create_from_type_class(\n                type_cls=self.module_details.get_class(),  # type: ignore\n                kiara=None,  # type: ignore\n            )\n\n            desc = module_type_md.documentation.description\n            module_md = module_type_md.create_renderable(\n                include_doc=False, include_src=False, include_config_schema=False\n            )\n            m_md = Group(desc, module_md)\n            table.add_row(\"Module metadata\", m_md)\n\n        if include_src:\n            table.add_row(\"Source code\", module_type_md.module_src)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.operation_id","title":"<code>operation_id: str = Field(description='The (unique) id of this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.operation_details","title":"<code>operation_details: OperationDetails = Field(description='The operation specific details of this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Documentation for this operation.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.module_details","title":"<code>module_details: KiaraModuleInstance = Field(description='The class of the underlying module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.metadata","title":"<code>metadata: Mapping[str, Any] = Field(description='Additional metadata for this operation.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.module","title":"<code>module: KiaraModule</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.inputs_schema","title":"<code>inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.outputs_schema","title":"<code>outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.pipeline_config","title":"<code>pipeline_config: PipelineConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.pipeline_structure","title":"<code>pipeline_structure: PipelineStructure</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.create_from_module","title":"<code>create_from_module(module: KiaraModule, doc: Union[Any, None] = None) -&gt; Operation</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>@classmethod\ndef create_from_module(\n    cls, module: KiaraModule, doc: Union[Any, None] = None\n) -&gt; \"Operation\":\n\n    from kiara.operations.included_core_operations import (\n        CustomModuleOperationDetails,\n    )\n\n    op_id = f\"{module.module_type_name}._{module.module_instance_cid}\"\n    if module.is_pipeline():\n        from kiara.operations.included_core_operations.pipeline import (\n            PipelineOperationDetails,\n        )\n\n        details = PipelineOperationDetails.create_operation_details(\n            operation_id=module.config.pipeline_name,\n            pipeline_inputs_schema=module.inputs_schema,\n            pipeline_outputs_schema=module.outputs_schema,\n            pipeline_config=module.config,\n        )\n    else:\n        details = CustomModuleOperationDetails.create_from_module(module=module)\n\n    if doc is not None:\n        doc = DocumentationMetadataModel.create(doc)\n    else:\n        doc = DocumentationMetadataModel.from_class_doc(module.__class__)\n\n    operation = Operation(\n        module_type=module.module_type_name,\n        module_config=module.config.dict(),\n        operation_id=op_id,\n        operation_details=details,\n        module_details=KiaraModuleInstance.from_module(module),\n        doc=doc,\n    )\n    operation._module = module\n    return operation\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.prepare_job_config","title":"<code>prepare_job_config(kiara: Kiara, inputs: Mapping[str, Any]) -&gt; JobConfig</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def prepare_job_config(\n    self, kiara: \"Kiara\", inputs: Mapping[str, Any]\n) -&gt; JobConfig:\n\n    augmented_inputs = (\n        self.operation_details.get_operation_schema().augment_module_inputs(\n            inputs=inputs\n        )\n    )\n\n    # module_inputs = self.operation_details.create_module_inputs(\n    #     inputs=augmented_inputs\n    # )\n\n    job_config = kiara.job_registry.prepare_job_config(\n        manifest=self, inputs=augmented_inputs\n    )\n    return job_config\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.run","title":"<code>run(kiara: Kiara, inputs: Mapping[str, Any]) -&gt; ValueMap</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def run(self, kiara: \"Kiara\", inputs: Mapping[str, Any]) -&gt; ValueMap:\n\n    logger.debug(\"run.operation\", operation_id=self.operation_id)\n    job_config = self.prepare_job_config(kiara=kiara, inputs=inputs)\n\n    job_id = kiara.job_registry.execute_job(job_config=job_config)\n    outputs: ValueMap = kiara.job_registry.retrieve_result(job_id=job_id)\n\n    result = self.process_job_outputs(outputs=outputs)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.process_job_outputs","title":"<code>process_job_outputs(outputs: ValueMap) -&gt; ValueMap</code>","text":"Source code in <code>kiara/models/module/operation.py</code> <pre><code>def process_job_outputs(self, outputs: ValueMap) -&gt; ValueMap:\n\n    # op_outputs = self.operation_details.create_operation_outputs(outputs=outputs)\n\n    value_set = ValueMapReadOnly(value_items=outputs, values_schema=self.outputs_schema)  # type: ignore\n    return value_set\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Operation.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"<p>Create a printable overview of this operations details.</p> Available render_config options <ul> <li>'include_full_doc' (default: True): whether to include the full documentation, or just a description</li> <li>'include_src' (default: False): whether to include the module source code</li> </ul> Source code in <code>kiara/models/module/operation.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a printable overview of this operations details.\n\n    Available render_config options:\n      - 'include_full_doc' (default: True): whether to include the full documentation, or just a description\n      - 'include_src' (default: False): whether to include the module source code\n    \"\"\"\n\n    include_full_doc = config.get(\"include_full_doc\", True)\n    include_src = config.get(\"include_src\", False)\n    include_inputs = config.get(\"include_inputs\", True)\n    include_outputs = config.get(\"include_outputs\", True)\n    include_module_details = config.get(\"include_module_details\", False)\n\n    table = Table(box=box.SIMPLE, show_header=False, show_lines=True)\n    table.add_column(\"Property\", style=\"i\")\n    table.add_column(\"Value\")\n\n    if self.doc:\n        if include_full_doc:\n            table.add_row(\"Documentation\", self.doc.full_doc)\n        else:\n            table.add_row(\"Description\", self.doc.description)\n\n    # module_type_md = self.module.get_type_metadata()\n\n    if include_inputs:\n        inputs_table = create_table_from_field_schemas(\n            _add_required=True,\n            _add_default=True,\n            _show_header=True,\n            _constants=None,\n            fields=self.operation_details.inputs_schema,\n        )\n        table.add_row(\"Inputs\", inputs_table)\n    if include_outputs:\n        outputs_table = create_table_from_field_schemas(\n            _add_required=False,\n            _add_default=False,\n            _show_header=True,\n            _constants=None,\n            fields=self.operation_details.outputs_schema,\n        )\n        table.add_row(\"Outputs\", outputs_table)\n\n    if include_module_details:\n        table.add_row(\"Module type\", self.module_type)\n\n        module_config = self.module.config.json(option=orjson.OPT_INDENT_2)\n        conf = Syntax(\n            module_config,\n            \"json\",\n            background_color=\"default\",\n        )\n        table.add_row(\"Module config\", conf)\n\n        from kiara.interfaces.python_api import ModuleTypeInfo\n\n        module_type_md = ModuleTypeInfo.create_from_type_class(\n            type_cls=self.module_details.get_class(),  # type: ignore\n            kiara=None,  # type: ignore\n        )\n\n        desc = module_type_md.documentation.description\n        module_md = module_type_md.create_renderable(\n            include_doc=False, include_src=False, include_config_schema=False\n        )\n        m_md = Group(desc, module_md)\n        table.add_row(\"Module metadata\", m_md)\n\n    if include_src:\n        table.add_row(\"Source code\", module_type_md.module_src)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter","title":"<code>Filter</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/operation.py</code> <pre><code>class Filter(KiaraModel):\n\n    operation: Operation = Field(\n        description=\"The underlying operation providing which does the filtering.\"\n    )\n    input_name: str = Field(\n        description=\"The input name to use for the dataset to filter.\"\n    )\n    output_name: str = Field(\n        description=\"The output name to use for the dataset to filter.\"\n    )\n    data_type: str = Field(description=\"The type of the dataset that gets filtered.\")\n</code></pre>"},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter.operation","title":"<code>operation: Operation = Field(description='The underlying operation providing which does the filtering.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter.input_name","title":"<code>input_name: str = Field(description='The input name to use for the dataset to filter.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter.output_name","title":"<code>output_name: str = Field(description='The output name to use for the dataset to filter.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation.Filter.data_type","title":"<code>data_type: str = Field(description='The type of the dataset that gets filtered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/operation/#kiara.models.module.operation-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/persistence/","title":"persistence","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy","title":"<code>ByteProvisioningStrategy</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/models/module/persistence.py</code> <pre><code>class ByteProvisioningStrategy(Enum):\n\n    INLINE = \"INLINE\"\n    BYTES = \"bytes\"\n    FILE_PATH_MAP = \"link_map\"\n    LINK_FOLDER = \"folder\"\n    COPIED_FOLDER = \"copied_folder\"\n</code></pre>"},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy.INLINE","title":"<code>INLINE = 'INLINE'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy.BYTES","title":"<code>BYTES = 'bytes'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy.FILE_PATH_MAP","title":"<code>FILE_PATH_MAP = 'link_map'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy.LINK_FOLDER","title":"<code>LINK_FOLDER = 'folder'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.ByteProvisioningStrategy.COPIED_FOLDER","title":"<code>COPIED_FOLDER = 'copied_folder'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesStructure","title":"<code>BytesStructure</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>A data structure that</p> Source code in <code>kiara/models/module/persistence.py</code> <pre><code>class BytesStructure(BaseModel):\n\"\"\"A data structure that\"\"\"\n\n    data_type: str = Field(description=\"The data type.\")\n    data_type_config: Mapping[str, Any] = Field(description=\"The data type config.\")\n    chunk_map: Mapping[str, List[Union[str, bytes]]] = Field(\n        description=\"References to byte arrays, Keys are field names, values are a list of hash-ids that the data is composed of.\",\n        default_factory=dict,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesStructure-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesStructure.data_type","title":"<code>data_type: str = Field(description='The data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesStructure.data_type_config","title":"<code>data_type_config: Mapping[str, Any] = Field(description='The data type config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesStructure.chunk_map","title":"<code>chunk_map: Mapping[str, List[Union[str, bytes]]] = Field(description='References to byte arrays, Keys are field names, values are a list of hash-ids that the data is composed of.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesAliasStructure","title":"<code>BytesAliasStructure</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/module/persistence.py</code> <pre><code>class BytesAliasStructure(BaseModel):\n\n    data_type: str = Field(description=\"The data type.\")\n    data_type_config: Mapping[str, Any] = Field(description=\"The data type config.\")\n    chunk_id_map: Mapping[str, List[str]] = Field(\n        description=\"References to byte arrays, Keys are field names, values are a list of hash-ids that the data is composed of.\",\n        default_factory=dict,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesAliasStructure-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesAliasStructure.data_type","title":"<code>data_type: str = Field(description='The data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesAliasStructure.data_type_config","title":"<code>data_type_config: Mapping[str, Any] = Field(description='The data type config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/persistence/#kiara.models.module.persistence.BytesAliasStructure.chunk_id_map","title":"<code>chunk_id_map: Mapping[str, List[str]] = Field(description='References to byte arrays, Keys are field names, values are a list of hash-ids that the data is composed of.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/","title":"pipeline","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.StepStatus","title":"<code>StepStatus</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum to describe the state of a workflow.</p> Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>class StepStatus(Enum):\n\"\"\"Enum to describe the state of a workflow.\"\"\"\n\n    INPUTS_INVALID = \"inputs_invalid\"\n    INPUTS_READY = \"inputs_ready\"\n    RESULTS_READY = \"results_ready\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.StepStatus-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.StepStatus.INPUTS_INVALID","title":"<code>INPUTS_INVALID = 'inputs_invalid'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.StepStatus.INPUTS_READY","title":"<code>INPUTS_READY = 'inputs_ready'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.StepStatus.RESULTS_READY","title":"<code>RESULTS_READY = 'results_ready'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep","title":"<code>PipelineStep</code>","text":"<p>         Bases: <code>Manifest</code></p> <p>A step within a pipeline-structure, includes information about it's connection(s) and other metadata.</p> Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>class PipelineStep(Manifest):\n\"\"\"A step within a pipeline-structure, includes information about it's connection(s) and other metadata.\"\"\"\n\n    _kiara_model_id = \"instance.pipeline_step\"\n\n    class Config:\n        validate_assignment = True\n        extra = Extra.forbid\n\n    @classmethod\n    def create_step(\n        cls,\n        step: Union[\"PipelineStep\", Mapping[str, Any]],\n        kiara: \"Kiara\",\n        module_map: Union[Mapping[str, Any], None] = None,\n        auto_step_id: bool = False,\n        taken_step_ids: Union[List[str], None] = None,\n    ):\n\"\"\"Create a step object from step data.\n\n        Beware: the provided 'module_map' dictionary will be modified, as will the 'taken_step_ids'.\n        \"\"\"\n\n        if module_map is None:\n            module_map = {}\n\n        if taken_step_ids is None:\n            taken_step_ids = []\n\n        if not isinstance(step, PipelineStep):\n\n            module_type = step.get(\"module_type\", None)\n\n            if not module_type:\n                raise InvalidPipelineStepConfig(\n                    \"Can't create step, no 'module_type' specified.\", step_config=step\n                )\n\n            module_config = step.get(\"module_config\", {})\n\n            src_manifest = Manifest(\n                module_type=module_type, module_config=module_config\n            )\n\n            if module_type not in kiara.module_type_names:\n\n                if module_type in module_map.keys():\n                    resolved_module_type = module_map[module_type][\"module_type\"]\n                    resolved_module_config = module_map[module_type][\"module_config\"]\n                    manifest = kiara.create_manifest(\n                        module_or_operation=resolved_module_type,\n                        config=resolved_module_config,\n                    )\n                elif (\n                    kiara.operation_registry.is_initialized\n                    and module_type in kiara.operation_registry.operation_ids\n                ):\n                    op = kiara.operation_registry.operations[module_type]\n                    resolved_module_type = op.module_type\n                    resolved_module_config = op.module_config\n                    manifest = kiara.create_manifest(\n                        module_or_operation=resolved_module_type,\n                        config=resolved_module_config,\n                    )\n                else:\n                    raise InvalidPipelineStepConfig(\n                        f\"Can't resolve module type: {module_type}\", step_config=step\n                    )\n            else:\n                manifest = kiara.create_manifest(\n                    module_or_operation=module_type, config=module_config\n                )\n                resolved_module_type = module_type\n                resolved_module_config = module_config\n\n            module = kiara.module_registry.create_module(manifest=manifest)\n\n            step_id = step.get(\"step_id\", None)\n            if not step_id:\n                if not auto_step_id:\n                    raise InvalidPipelineStepConfig(\n                        \"Can't create step, no 'step_id' specified in config.\",\n                        step_config=step,\n                    )\n\n                else:\n                    step_id = find_free_id(\n                        slugify(manifest.module_type, delim=\"_\"),\n                        current_ids=taken_step_ids,\n                    )\n\n            if step_id in taken_step_ids:\n                raise ValueError(f\"Can't create step: duplicate step id '{step_id}'.\")\n\n            taken_step_ids.append(step_id)\n\n            input_links = {}\n            for input_field, sources in step.get(\"input_links\", {}).items():\n                if isinstance(sources, str):\n                    sources = [sources]\n                input_links[input_field] = sources\n\n            doc = step.get(\"doc\", None)\n\n            # TODO: do we really need the deepcopy here?\n            _s = PipelineStep(\n                step_id=step_id,\n                module_type=resolved_module_type,\n                module_config=dict(resolved_module_config),\n                input_links=input_links,  # type: ignore\n                doc=doc,\n                module_details=KiaraModuleInstance.from_module(module=module),\n                manifest_src=src_manifest,\n            )\n            _s._module = module\n        else:\n            _s = step\n\n        return _s\n\n    @classmethod\n    def create_steps(\n        cls,\n        *steps: Union[\"PipelineStep\", Mapping[str, Any]],\n        kiara: \"Kiara\",\n        module_map: Union[Mapping[str, Any], None] = None,\n        auto_step_ids: bool = False,\n    ) -&gt; List[\"PipelineStep\"]:\n\n        if module_map is None:\n            module_map = {}\n        else:\n            module_map = dict(module_map)\n\n        result: List[PipelineStep] = []\n\n        step_ids: List[str] = []\n        for step in steps:\n\n            _s = cls.create_step(\n                step=step,\n                kiara=kiara,\n                module_map=module_map,\n                auto_step_id=auto_step_ids,\n                taken_step_ids=step_ids,\n            )\n            result.append(_s)\n\n        return result\n\n    @validator(\"step_id\")\n    def _validate_step_id(cls, v):\n\n        assert isinstance(v, str)\n        if \".\" in v:\n            raise ValueError(\"Step ids can't contain '.' characters.\")\n\n        return v\n\n    step_id: str = Field(\n        description=\"Locally unique id (within a pipeline) of this step.\"\n    )\n\n    module_type: str = Field(description=\"The module type.\")\n    module_config: Dict[str, Any] = Field(\n        description=\"The module config.\", default_factory=dict\n    )\n    manifest_src: Manifest = Field(\n        description=\"The original manfifest provided by the user.\"\n    )\n\n    # required: bool = Field(\n    #     description=\"Whether this step is required within the workflow.\\n\\nIn some cases, when none of the pipeline outputs have a required input that connects to a step, then it is not necessary for this step to have been executed, even if it is placed before a step in the execution hierarchy. This also means that the pipeline inputs that are connected to this step might not be required.\",\n    #     default=True,\n    # )\n    # processing_stage: Optional[int] = Field(\n    #     default=None,\n    #     description=\"The stage number this step is executed within the pipeline.\",\n    # )\n    input_links: Mapping[str, List[StepValueAddress]] = Field(\n        description=\"The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs.\",\n        default_factory=dict,\n    )\n    module_details: KiaraModuleInstance = Field(\n        description=\"The class of the underlying module.\"\n    )\n    doc: DocumentationMetadataModel = Field(\n        description=\"A description what this step does.\"\n    )\n    _module: Union[\"KiaraModule\", None] = PrivateAttr(default=None)\n\n    @root_validator(pre=True)\n    def create_step_id(cls, values):\n\n        if \"module_type\" not in values:\n            raise ValueError(\"No 'module_type' specified.\")\n        if \"step_id\" not in values or not values[\"step_id\"]:\n            values[\"step_id\"] = slugify(values[\"module_type\"], delim=\"_\")\n\n        return values\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        doc = DocumentationMetadataModel.create(value)\n        return doc\n\n    @validator(\"step_id\")\n    def ensure_valid_id(cls, v):\n\n        # TODO: check with regex\n        if \".\" in v or \" \" in v:\n            raise ValueError(\n                f\"Step id can't contain special characters or whitespaces: {v}\"\n            )\n\n        return v\n\n    @validator(\"module_config\", pre=True)\n    def ensure_dict(cls, v):\n\n        if v is None:\n            v = {}\n        return v\n\n    @validator(\"input_links\", pre=True)\n    def ensure_input_links_valid(cls, v):\n\n        if v is None:\n            v = {}\n\n        result = {}\n        for input_name, output in v.items():\n\n            input_links = ensure_step_value_addresses(\n                default_field_name=input_name, link=output\n            )\n            result[input_name] = input_links\n\n        return result\n\n    @property\n    def module(self) -&gt; \"KiaraModule\":\n        if self._module is None:\n            m_cls = self.module_details.get_class()\n            self._module = m_cls(module_config=self.module_config)\n        return self._module\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(step_id={self.step_id} module_type={self.module_type})\"\n\n    def __str__(self):\n        return f\"step: {self.step_id} (module: {self.module_type})\"\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        in_panel = config.get(\"in_panel\", None)\n        if in_panel is None:\n            if is_jupyter():\n                in_panel = True\n            else:\n                in_panel = False\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        if self.doc.is_set:\n            table.add_row(\"\", Markdown(self.doc.full_doc))\n        table.add_row(\"step_id\", self.step_id)\n        table.add_row(\"module type\", self.module_type)\n        if not module_config_is_empty(self.module_config):\n            mc = dict(self.module_config)\n            if not mc.get(\"defaults\", None):\n                mc.pop(\"defaults\", None)\n            if not mc.get(\"constants\", None):\n                mc.pop(\"constants\", None)\n\n            if \"steps\" in mc.keys():\n                _steps = []\n                for step in mc[\"steps\"]:\n                    _s = {\n                        \"step_id\": step[\"step_id\"],\n                        \"module_type\": step[\"manifest_src\"][\"module_type\"],\n                    }\n                    sc = step.get(\"module_config\", {})\n                    if sc:\n                        _s[\"module_config\"] = sc\n                    _steps.append(_s)\n                mc[\"steps\"] = _steps\n            config_str = orjson_dumps(mc, option=orjson.OPT_INDENT_2)\n            table.add_row(\n                \"module_config\",\n                Syntax(config_str, \"json\", background_color=\"default\", theme=\"default\"),\n            )\n        module_doc = DocumentationMetadataModel.from_class_doc(self.module.__class__)\n        table.add_row(\"module doc\", Markdown(module_doc.full_doc))\n        inputs = create_table_from_field_schemas(\n            _add_default=True,\n            _add_required=True,\n            _show_header=True,\n            fields={\n                f\"{self.step_id}.{k}\": v for k, v in self.module.inputs_schema.items()\n            },\n        )\n        table.add_row(\"inputs\", inputs)\n        outputs = create_table_from_field_schemas(\n            _add_default=False,\n            _add_required=False,\n            _show_header=True,\n            fields={\n                f\"{self.step_id}.{k}\": v for k, v in self.module.outputs_schema.items()\n            },\n        )\n        table.add_row(\"outputs\", outputs)\n\n        if in_panel:\n            return Panel(table, title=f\"Step: {self.step_id}\", title_align=\"left\")\n        else:\n            return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.step_id","title":"<code>step_id: str = Field(description='Locally unique id (within a pipeline) of this step.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.module_type","title":"<code>module_type: str = Field(description='The module type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.module_config","title":"<code>module_config: Dict[str, Any] = Field(description='The module config.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.manifest_src","title":"<code>manifest_src: Manifest = Field(description='The original manfifest provided by the user.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.input_links","title":"<code>input_links: Mapping[str, List[StepValueAddress]] = Field(description='The links that connect to inputs of the module. Keys are field names, value(s) are connected outputs.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.module_details","title":"<code>module_details: KiaraModuleInstance = Field(description='The class of the underlying module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='A description what this step does.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.module","title":"<code>module: KiaraModule</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>class Config:\n    validate_assignment = True\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.Config-attributes","title":"Attributes","text":"<code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.create_step","title":"<code>create_step(step: Union[PipelineStep, Mapping[str, Any]], kiara: Kiara, module_map: Union[Mapping[str, Any], None] = None, auto_step_id: bool = False, taken_step_ids: Union[List[str], None] = None)</code>  <code>classmethod</code>","text":"<p>Create a step object from step data.</p> <p>Beware: the provided 'module_map' dictionary will be modified, as will the 'taken_step_ids'.</p> Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@classmethod\ndef create_step(\n    cls,\n    step: Union[\"PipelineStep\", Mapping[str, Any]],\n    kiara: \"Kiara\",\n    module_map: Union[Mapping[str, Any], None] = None,\n    auto_step_id: bool = False,\n    taken_step_ids: Union[List[str], None] = None,\n):\n\"\"\"Create a step object from step data.\n\n    Beware: the provided 'module_map' dictionary will be modified, as will the 'taken_step_ids'.\n    \"\"\"\n\n    if module_map is None:\n        module_map = {}\n\n    if taken_step_ids is None:\n        taken_step_ids = []\n\n    if not isinstance(step, PipelineStep):\n\n        module_type = step.get(\"module_type\", None)\n\n        if not module_type:\n            raise InvalidPipelineStepConfig(\n                \"Can't create step, no 'module_type' specified.\", step_config=step\n            )\n\n        module_config = step.get(\"module_config\", {})\n\n        src_manifest = Manifest(\n            module_type=module_type, module_config=module_config\n        )\n\n        if module_type not in kiara.module_type_names:\n\n            if module_type in module_map.keys():\n                resolved_module_type = module_map[module_type][\"module_type\"]\n                resolved_module_config = module_map[module_type][\"module_config\"]\n                manifest = kiara.create_manifest(\n                    module_or_operation=resolved_module_type,\n                    config=resolved_module_config,\n                )\n            elif (\n                kiara.operation_registry.is_initialized\n                and module_type in kiara.operation_registry.operation_ids\n            ):\n                op = kiara.operation_registry.operations[module_type]\n                resolved_module_type = op.module_type\n                resolved_module_config = op.module_config\n                manifest = kiara.create_manifest(\n                    module_or_operation=resolved_module_type,\n                    config=resolved_module_config,\n                )\n            else:\n                raise InvalidPipelineStepConfig(\n                    f\"Can't resolve module type: {module_type}\", step_config=step\n                )\n        else:\n            manifest = kiara.create_manifest(\n                module_or_operation=module_type, config=module_config\n            )\n            resolved_module_type = module_type\n            resolved_module_config = module_config\n\n        module = kiara.module_registry.create_module(manifest=manifest)\n\n        step_id = step.get(\"step_id\", None)\n        if not step_id:\n            if not auto_step_id:\n                raise InvalidPipelineStepConfig(\n                    \"Can't create step, no 'step_id' specified in config.\",\n                    step_config=step,\n                )\n\n            else:\n                step_id = find_free_id(\n                    slugify(manifest.module_type, delim=\"_\"),\n                    current_ids=taken_step_ids,\n                )\n\n        if step_id in taken_step_ids:\n            raise ValueError(f\"Can't create step: duplicate step id '{step_id}'.\")\n\n        taken_step_ids.append(step_id)\n\n        input_links = {}\n        for input_field, sources in step.get(\"input_links\", {}).items():\n            if isinstance(sources, str):\n                sources = [sources]\n            input_links[input_field] = sources\n\n        doc = step.get(\"doc\", None)\n\n        # TODO: do we really need the deepcopy here?\n        _s = PipelineStep(\n            step_id=step_id,\n            module_type=resolved_module_type,\n            module_config=dict(resolved_module_config),\n            input_links=input_links,  # type: ignore\n            doc=doc,\n            module_details=KiaraModuleInstance.from_module(module=module),\n            manifest_src=src_manifest,\n        )\n        _s._module = module\n    else:\n        _s = step\n\n    return _s\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.create_steps","title":"<code>create_steps(*steps: Union[PipelineStep, Mapping[str, Any]], kiara: Kiara, module_map: Union[Mapping[str, Any], None] = None, auto_step_ids: bool = False) -&gt; List[PipelineStep]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@classmethod\ndef create_steps(\n    cls,\n    *steps: Union[\"PipelineStep\", Mapping[str, Any]],\n    kiara: \"Kiara\",\n    module_map: Union[Mapping[str, Any], None] = None,\n    auto_step_ids: bool = False,\n) -&gt; List[\"PipelineStep\"]:\n\n    if module_map is None:\n        module_map = {}\n    else:\n        module_map = dict(module_map)\n\n    result: List[PipelineStep] = []\n\n    step_ids: List[str] = []\n    for step in steps:\n\n        _s = cls.create_step(\n            step=step,\n            kiara=kiara,\n            module_map=module_map,\n            auto_step_id=auto_step_ids,\n            taken_step_ids=step_ids,\n        )\n        result.append(_s)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.create_step_id","title":"<code>create_step_id(values)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@root_validator(pre=True)\ndef create_step_id(cls, values):\n\n    if \"module_type\" not in values:\n        raise ValueError(\"No 'module_type' specified.\")\n    if \"step_id\" not in values or not values[\"step_id\"]:\n        values[\"step_id\"] = slugify(values[\"module_type\"], delim=\"_\")\n\n    return values\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    doc = DocumentationMetadataModel.create(value)\n    return doc\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.ensure_valid_id","title":"<code>ensure_valid_id(v)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@validator(\"step_id\")\ndef ensure_valid_id(cls, v):\n\n    # TODO: check with regex\n    if \".\" in v or \" \" in v:\n        raise ValueError(\n            f\"Step id can't contain special characters or whitespaces: {v}\"\n        )\n\n    return v\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.ensure_dict","title":"<code>ensure_dict(v)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@validator(\"module_config\", pre=True)\ndef ensure_dict(cls, v):\n\n    if v is None:\n        v = {}\n    return v\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.ensure_input_links_valid","title":"<code>ensure_input_links_valid(v)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@validator(\"input_links\", pre=True)\ndef ensure_input_links_valid(cls, v):\n\n    if v is None:\n        v = {}\n\n    result = {}\n    for input_name, output in v.items():\n\n        input_links = ensure_step_value_addresses(\n            default_field_name=input_name, link=output\n        )\n        result[input_name] = input_links\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineStep.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    in_panel = config.get(\"in_panel\", None)\n    if in_panel is None:\n        if is_jupyter():\n            in_panel = True\n        else:\n            in_panel = False\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    if self.doc.is_set:\n        table.add_row(\"\", Markdown(self.doc.full_doc))\n    table.add_row(\"step_id\", self.step_id)\n    table.add_row(\"module type\", self.module_type)\n    if not module_config_is_empty(self.module_config):\n        mc = dict(self.module_config)\n        if not mc.get(\"defaults\", None):\n            mc.pop(\"defaults\", None)\n        if not mc.get(\"constants\", None):\n            mc.pop(\"constants\", None)\n\n        if \"steps\" in mc.keys():\n            _steps = []\n            for step in mc[\"steps\"]:\n                _s = {\n                    \"step_id\": step[\"step_id\"],\n                    \"module_type\": step[\"manifest_src\"][\"module_type\"],\n                }\n                sc = step.get(\"module_config\", {})\n                if sc:\n                    _s[\"module_config\"] = sc\n                _steps.append(_s)\n            mc[\"steps\"] = _steps\n        config_str = orjson_dumps(mc, option=orjson.OPT_INDENT_2)\n        table.add_row(\n            \"module_config\",\n            Syntax(config_str, \"json\", background_color=\"default\", theme=\"default\"),\n        )\n    module_doc = DocumentationMetadataModel.from_class_doc(self.module.__class__)\n    table.add_row(\"module doc\", Markdown(module_doc.full_doc))\n    inputs = create_table_from_field_schemas(\n        _add_default=True,\n        _add_required=True,\n        _show_header=True,\n        fields={\n            f\"{self.step_id}.{k}\": v for k, v in self.module.inputs_schema.items()\n        },\n    )\n    table.add_row(\"inputs\", inputs)\n    outputs = create_table_from_field_schemas(\n        _add_default=False,\n        _add_required=False,\n        _show_header=True,\n        fields={\n            f\"{self.step_id}.{k}\": v for k, v in self.module.outputs_schema.items()\n        },\n    )\n    table.add_row(\"outputs\", outputs)\n\n    if in_panel:\n        return Panel(table, title=f\"Step: {self.step_id}\", title_align=\"left\")\n    else:\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig","title":"<code>PipelineConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> <p>A class to hold the configuration for a PipelineModule.</p> <p>If you want to control the pipeline input and output names, you need to have to provide a map that uses the autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure the uniqueness of each field; some steps can have the same input field names, but will need different input values. In some cases, some inputs of different steps need the same input. Those sorts of things. So, to make sure that we always use the right values, I chose to implement a conservative default approach, accepting that in some cases the user will be prompted for duplicate inputs for the same value.</p> <p>To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of the input/output fields.</p> <p>Further, because in a lot of cases there won't be any overlapping fields, the creator can specify <code>auto</code>, in which case Kiara will automatically create a mapping that tries to map autogenerated field names to the shortest possible names for each case.</p> <p>Examples:</p> <p>Configuration for a pipeline module that functions as a <code>nand</code> logic gate (in Python):</p> <pre><code>and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")\nnot_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}\nnand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",\n                    steps=[and_step, not_step],\n                    input_aliases={\n                        \"and__a\": \"a\",\n                        \"and__b\": \"b\"\n                    },\n                    output_aliases={\n                        \"not__y\": \"y\"\n                    }}\n</code></pre> <p>Or, the same thing in json:</p> <pre><code>{\n\"module_type_name\": \"nand\",\n\"doc\": \"Returns 'False' if both inputs are 'True'.\",\n\"steps\": [\n{\n\"module_type\": \"and\",\n\"step_id\": \"and\"\n},\n{\n\"module_type\": \"not\",\n\"step_id\": \"not\",\n\"input_links\": {\n\"a\": \"and.y\"\n}\n}\n],\n\"input_aliases\": {\n\"and__a\": \"a\",\n\"and__b\": \"b\"\n},\n\"output_aliases\": {\n\"not__y\": \"y\"\n}\n}\n</code></pre> Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>class PipelineConfig(KiaraModuleConfig):\n\"\"\"A class to hold the configuration for a [PipelineModule][kiara.pipeline.module.PipelineModule].\n\n    If you want to control the pipeline input and output names, you need to have to provide a map that uses the\n    autogenerated field name ([step_id]__[alias] -- 2 underscores!!) as key, and the desired field name\n    as value. The reason that schema for the autogenerated field names exist is that it's hard to ensure\n    the uniqueness of each field; some steps can have the same input field names, but will need different input\n    values. In some cases, some inputs of different steps need the same input. Those sorts of things.\n    So, to make sure that we always use the right values, I chose to implement a conservative default approach,\n    accepting that in some cases the user will be prompted for duplicate inputs for the same value.\n\n    To remedy that, the pipeline creator has the option to manually specify a mapping to rename some or all of\n    the input/output fields.\n\n    Further, because in a lot of cases there won't be any overlapping fields, the creator can specify ``auto``,\n    in which case *Kiara* will automatically create a mapping that tries to map autogenerated field names\n    to the shortest possible names for each case.\n\n    Examples:\n\n        Configuration for a pipeline module that functions as a ``nand`` logic gate (in Python):\n\n        ``` python\n        and_step = PipelineStepConfig(module_type=\"and\", step_id=\"and\")\n        not_step = PipelineStepConfig(module_type=\"not\", step_id=\"not\", input_links={\"a\": [\"and.y\"]}\n        nand_p_conf = PipelineConfig(doc=\"Returns 'False' if both inputs are 'True'.\",\n                            steps=[and_step, not_step],\n                            input_aliases={\n                                \"and__a\": \"a\",\n                                \"and__b\": \"b\"\n                            },\n                            output_aliases={\n                                \"not__y\": \"y\"\n                            }}\n        ```\n\n        Or, the same thing in json:\n\n        ``` json\n        {\n          \"module_type_name\": \"nand\",\n          \"doc\": \"Returns 'False' if both inputs are 'True'.\",\n          \"steps\": [\n            {\n              \"module_type\": \"and\",\n              \"step_id\": \"and\"\n            },\n            {\n              \"module_type\": \"not\",\n              \"step_id\": \"not\",\n              \"input_links\": {\n                \"a\": \"and.y\"\n              }\n            }\n          ],\n          \"input_aliases\": {\n            \"and__a\": \"a\",\n            \"and__b\": \"b\"\n          },\n          \"output_aliases\": {\n            \"not__y\": \"y\"\n          }\n        }\n        ```\n    \"\"\"\n\n    _kiara_model_id = \"instance.module_config.pipeline\"\n\n    @classmethod\n    def from_file(\n        cls,\n        path: str,\n        kiara: Union[\"Kiara\", None] = None,\n        pipeline_name: Union[None, str] = None,\n        # module_map: Optional[Mapping[str, Any]] = None,\n    ):\n\n        data = get_data_from_file(path)\n        _pipeline_name = data.pop(\"pipeline_name\", None)\n\n        if pipeline_name:\n            _pipeline_name = pipeline_name\n\n        if _pipeline_name is None:\n            _pipeline_name = os.path.basename(path)\n\n        pipeline_dir = os.path.abspath(os.path.dirname(path))\n\n        execution_context = ExecutionContext(pipeline_dir=pipeline_dir)\n        return cls.from_config(\n            pipeline_name=_pipeline_name,\n            data=data,\n            kiara=kiara,\n            execution_context=execution_context,\n        )\n\n    @classmethod\n    def from_string(\n        cls,\n        string_data: str,\n        kiara: Union[\"Kiara\", None] = None,\n        pipeline_name: Union[None, str] = None,\n        # module_map: Optional[Mapping[str, Any]] = None,\n    ):\n\n        data = get_data_from_string(string_data)\n        _pipeline_name = data.pop(\"pipeline_name\", None)\n\n        if pipeline_name:\n            _pipeline_name = pipeline_name\n\n        return cls.from_config(\n            pipeline_name=_pipeline_name,\n            data=data,\n            kiara=kiara,\n        )\n\n    @classmethod\n    def from_config(\n        cls,\n        data: Mapping[str, Any],\n        pipeline_name: Union[str, None] = None,\n        kiara: Union[\"Kiara\", None] = None,\n        module_map: Union[Mapping[str, Any], None] = None,\n        execution_context: Union[ExecutionContext, None] = None,\n        auto_step_ids: bool = False,\n    ):\n\n        if kiara is None:\n            from kiara.context import Kiara\n\n            kiara = Kiara.instance()\n\n        if not kiara.operation_registry.is_initialized:\n            kiara.operation_registry.operations\n\n        if execution_context is None:\n            execution_context = ExecutionContext()\n\n        config = cls._from_config(\n            pipeline_name=pipeline_name,\n            data=data,\n            kiara=kiara,\n            module_map=module_map,\n            execution_context=execution_context,\n            auto_step_ids=auto_step_ids,\n        )\n        return config\n\n    @classmethod\n    def _from_config(\n        cls,\n        data: Mapping[str, Any],\n        kiara: \"Kiara\",\n        pipeline_name: Union[str, None] = None,\n        module_map: Union[Mapping[str, Any], None] = None,\n        execution_context: Union[ExecutionContext, None] = None,\n        auto_step_ids: bool = False,\n    ):\n\n        if execution_context is None:\n            execution_context = ExecutionContext()\n\n        repl_dict = execution_context.dict()\n\n        data = dict(data)\n\n        _pipeline_name = data.pop(\"pipeline_name\", None)\n        if pipeline_name:\n            _pipeline_name = pipeline_name\n\n        if not _pipeline_name:\n            _pipeline_name = str(uuid.uuid4())\n\n        _steps = data.pop(\"steps\")\n        steps = PipelineStep.create_steps(\n            *_steps, kiara=kiara, module_map=module_map, auto_step_ids=auto_step_ids\n        )\n        data[\"steps\"] = steps\n        if not data.get(\"input_aliases\"):\n            data[\"input_aliases\"] = create_input_alias_map(steps)\n        if not data.get(\"output_aliases\"):\n            data[\"output_aliases\"] = create_output_alias_map(steps)\n\n        if \"defaults\" in data.keys():\n            defaults = data.pop(\"defaults\")\n            replaced = replace_var_names_in_obj(defaults, repl_dict=repl_dict)\n            data[\"defaults\"] = replaced\n\n        if \"constants\" in data.keys():\n            constants = data.pop(\"constants\")\n            replaced = replace_var_names_in_obj(constants, repl_dict=repl_dict)\n            data[\"constants\"] = replaced\n\n        if \"inputs\" in data.keys():\n            inputs = data.pop(\"inputs\")\n            replaced = replace_var_names_in_obj(inputs, repl_dict=repl_dict)\n            data[\"inputs\"] = replaced\n\n        if \"doc\" not in data.keys():\n            data[\"doc\"] = None\n\n        result = cls(pipeline_name=_pipeline_name, **data)\n        return result\n\n    class Config:\n        extra = Extra.ignore\n        validate_assignment = True\n\n    pipeline_name: str = Field(description=\"The name of this pipeline.\")\n    steps: List[PipelineStep] = Field(\n        description=\"A list of steps/modules of this pipeline, and their connections.\",\n    )\n    input_aliases: Dict[str, str] = Field(\n        description=\"A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value.\",\n    )\n    output_aliases: Dict[str, str] = Field(\n        description=\"A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value.\",\n    )\n    doc: DocumentationMetadataModel = Field(\n        default=\"-- n/a --\", description=\"Documentation about what the pipeline does.\"  # type: ignore\n    )\n    context: Dict[str, Any] = Field(\n        default_factory=dict, description=\"Metadata for this workflow.\"\n    )\n    _structure: Union[\"PipelineStructure\", None] = PrivateAttr(default=None)\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n\n    @validator(\"steps\", pre=True)\n    def _validate_steps(cls, v):\n\n        steps = []\n        for step in v:\n            if not step:\n                raise ValueError(\"No step data provided.\")\n            if isinstance(step, PipelineStep):\n                steps.append(step)\n            elif isinstance(step, Mapping):\n                steps.append(PipelineStep(**step))  # type: ignore\n            else:\n                raise TypeError(step)\n        return steps\n\n    @property\n    def structure(self) -&gt; \"PipelineStructure\":\n\n        if self._structure is not None:\n            return self._structure\n\n        from kiara.models.module.pipeline.structure import PipelineStructure\n\n        self._structure = PipelineStructure(pipeline_config=self)  # type: ignore\n        return self._structure\n\n    def get_raw_config(self) -&gt; Dict[str, Any]:\n\n        steps = []\n        for step in self.steps:\n            src: Dict[str, Any] = {\n                \"module_type\": step.manifest_src.module_type,\n            }\n            if step.manifest_src.module_config:\n                src[\"module_config\"] = step.manifest_src.module_config\n            src[\"step_id\"] = step.step_id\n            for field, links in step.input_links.items():\n                for link in links:\n                    src.setdefault(\"input_links\", {})[\n                        field\n                    ] = f\"{link.step_id}.{link.value_name}\"\n            steps.append(src)\n\n        return {\n            \"pipeline_name\": self.pipeline_name,\n            \"doc\": self.doc.full_doc,\n            \"steps\": steps,\n            \"input_aliases\": self.input_aliases,\n            \"output_aliases\": self.output_aliases,\n        }\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\", style=\"i\")\n        table.add_column(\"value\")\n\n        table.add_row(\"doc\", self.doc.full_doc)\n        table.add_row(\"structure\", self.structure.create_renderable(**config))\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.pipeline_name","title":"<code>pipeline_name: str = Field(description='The name of this pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.steps","title":"<code>steps: List[PipelineStep] = Field(description='A list of steps/modules of this pipeline, and their connections.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.input_aliases","title":"<code>input_aliases: Dict[str, str] = Field(description=\"A map of input aliases, with the location of the input (in the format '[step_id].[input_field]') as key, and the pipeline input field name as value.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.output_aliases","title":"<code>output_aliases: Dict[str, str] = Field(description=\"A map of output aliases, with the location of the output (in the format '[step_id].[output_field]') as key, and the pipeline output field name as value.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.doc","title":"<code>doc: DocumentationMetadataModel = Field(default='-- n/a --', description='Documentation about what the pipeline does.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.context","title":"<code>context: Dict[str, Any] = Field(default_factory=dict, description='Metadata for this workflow.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.structure","title":"<code>structure: PipelineStructure</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>class Config:\n    extra = Extra.ignore\n    validate_assignment = True\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.Config-attributes","title":"Attributes","text":"<code>extra = Extra.ignore</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.from_file","title":"<code>from_file(path: str, kiara: Union[Kiara, None] = None, pipeline_name: Union[None, str] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@classmethod\ndef from_file(\n    cls,\n    path: str,\n    kiara: Union[\"Kiara\", None] = None,\n    pipeline_name: Union[None, str] = None,\n    # module_map: Optional[Mapping[str, Any]] = None,\n):\n\n    data = get_data_from_file(path)\n    _pipeline_name = data.pop(\"pipeline_name\", None)\n\n    if pipeline_name:\n        _pipeline_name = pipeline_name\n\n    if _pipeline_name is None:\n        _pipeline_name = os.path.basename(path)\n\n    pipeline_dir = os.path.abspath(os.path.dirname(path))\n\n    execution_context = ExecutionContext(pipeline_dir=pipeline_dir)\n    return cls.from_config(\n        pipeline_name=_pipeline_name,\n        data=data,\n        kiara=kiara,\n        execution_context=execution_context,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.from_string","title":"<code>from_string(string_data: str, kiara: Union[Kiara, None] = None, pipeline_name: Union[None, str] = None)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    string_data: str,\n    kiara: Union[\"Kiara\", None] = None,\n    pipeline_name: Union[None, str] = None,\n    # module_map: Optional[Mapping[str, Any]] = None,\n):\n\n    data = get_data_from_string(string_data)\n    _pipeline_name = data.pop(\"pipeline_name\", None)\n\n    if pipeline_name:\n        _pipeline_name = pipeline_name\n\n    return cls.from_config(\n        pipeline_name=_pipeline_name,\n        data=data,\n        kiara=kiara,\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.from_config","title":"<code>from_config(data: Mapping[str, Any], pipeline_name: Union[str, None] = None, kiara: Union[Kiara, None] = None, module_map: Union[Mapping[str, Any], None] = None, execution_context: Union[ExecutionContext, None] = None, auto_step_ids: bool = False)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@classmethod\ndef from_config(\n    cls,\n    data: Mapping[str, Any],\n    pipeline_name: Union[str, None] = None,\n    kiara: Union[\"Kiara\", None] = None,\n    module_map: Union[Mapping[str, Any], None] = None,\n    execution_context: Union[ExecutionContext, None] = None,\n    auto_step_ids: bool = False,\n):\n\n    if kiara is None:\n        from kiara.context import Kiara\n\n        kiara = Kiara.instance()\n\n    if not kiara.operation_registry.is_initialized:\n        kiara.operation_registry.operations\n\n    if execution_context is None:\n        execution_context = ExecutionContext()\n\n    config = cls._from_config(\n        pipeline_name=pipeline_name,\n        data=data,\n        kiara=kiara,\n        module_map=module_map,\n        execution_context=execution_context,\n        auto_step_ids=auto_step_ids,\n    )\n    return config\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.get_raw_config","title":"<code>get_raw_config() -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def get_raw_config(self) -&gt; Dict[str, Any]:\n\n    steps = []\n    for step in self.steps:\n        src: Dict[str, Any] = {\n            \"module_type\": step.manifest_src.module_type,\n        }\n        if step.manifest_src.module_config:\n            src[\"module_config\"] = step.manifest_src.module_config\n        src[\"step_id\"] = step.step_id\n        for field, links in step.input_links.items():\n            for link in links:\n                src.setdefault(\"input_links\", {})[\n                    field\n                ] = f\"{link.step_id}.{link.value_name}\"\n        steps.append(src)\n\n    return {\n        \"pipeline_name\": self.pipeline_name,\n        \"doc\": self.doc.full_doc,\n        \"steps\": steps,\n        \"input_aliases\": self.input_aliases,\n        \"output_aliases\": self.output_aliases,\n    }\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.PipelineConfig.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"doc\", self.doc.full_doc)\n    table.add_row(\"structure\", self.structure.create_renderable(**config))\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.create_input_alias_map","title":"<code>create_input_alias_map(steps: Iterable[PipelineStep]) -&gt; Dict[str, str]</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def create_input_alias_map(steps: Iterable[PipelineStep]) -&gt; Dict[str, str]:\n\n    aliases: Dict[str, str] = {}\n    for step in steps:\n        field_names = step.module.input_names\n        for field_name in field_names:\n            alias = generate_pipeline_endpoint_name(\n                step_id=step.step_id, value_name=field_name\n            )\n            assert alias not in aliases.keys()\n            aliases[f\"{step.step_id}.{field_name}\"] = alias\n\n    return aliases\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.create_output_alias_map","title":"<code>create_output_alias_map(steps: Iterable[PipelineStep]) -&gt; Dict[str, str]</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def create_output_alias_map(steps: Iterable[PipelineStep]) -&gt; Dict[str, str]:\n\n    aliases: Dict[str, str] = {}\n    for step in steps:\n        field_names = step.module.output_names\n        for field_name in field_names:\n            alias = generate_pipeline_endpoint_name(\n                step_id=step.step_id, value_name=field_name\n            )\n            assert alias not in aliases.keys()\n            aliases[f\"{step.step_id}.{field_name}\"] = alias\n\n    return aliases\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/__init__/#kiara.models.module.pipeline.generate_pipeline_endpoint_name","title":"<code>generate_pipeline_endpoint_name(step_id: str, value_name: str)</code>","text":"Source code in <code>kiara/models/module/pipeline/__init__.py</code> <pre><code>def generate_pipeline_endpoint_name(step_id: str, value_name: str):\n\n    return f\"{step_id}__{value_name}\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/","title":"controller","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.PipelineController","title":"<code>PipelineController</code>","text":"<p>         Bases: <code>PipelineListener</code></p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>class PipelineController(PipelineListener):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController","title":"<code>SinglePipelineController</code>","text":"<p>         Bases: <code>PipelineController</code></p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>class SinglePipelineController(PipelineController):\n    def __init__(\n        self, job_registry: JobRegistry, pipeline: Union[Pipeline, None] = None\n    ):\n\n        self._pipeline: Union[Pipeline, None] = None\n        self._job_registry: JobRegistry = job_registry\n        self._pipeline_details: Union[PipelineState, None] = None\n\n        if pipeline is not None:\n            self.pipeline = pipeline\n\n    @property\n    def pipeline(self) -&gt; Pipeline:\n\n        if self._pipeline is None:\n            raise Exception(\"Pipeline not set (yet).\")\n        return self._pipeline\n\n    @pipeline.setter\n    def pipeline(self, pipeline: Pipeline):\n\n        if self._pipeline is not None:\n            # TODO: destroy object?\n            self._pipeline._listeners.clear()\n\n        self._pipeline = pipeline\n        if self._pipeline is not None:\n            self._pipeline.add_listener(self)\n\n    def current_pipeline_state(self) -&gt; PipelineState:\n\n        if self._pipeline_details is None:\n            self._pipeline_details = self.pipeline.get_pipeline_details()\n        return self._pipeline_details\n\n    def can_be_processed(self, step_id: str) -&gt; bool:\n\"\"\"Check whether the step with the provided id is ready to be processed.\"\"\"\n\n        pipeline_state = self.current_pipeline_state()\n        step_state = pipeline_state.step_states[step_id]\n\n        return not step_state.invalid_details\n\n    def can_be_skipped(self, step_id: str) -&gt; bool:\n\"\"\"Check whether the processing of a step can be skipped.\"\"\"\n\n        required = self.pipeline.structure.step_is_required(step_id=step_id)\n        if required:\n            required = self.can_be_processed(step_id)\n        return required\n\n    def _pipeline_event_occurred(self, event: PipelineEvent):\n\n        if event.pipeline_id != self.pipeline.pipeline_id:\n            return\n\n        self._pipeline_details = None\n\n    def set_processing_results(\n        self, job_ids: Mapping[str, uuid.UUID]\n    ) -&gt; Mapping[uuid.UUID, uuid.UUID]:\n\"\"\"Set the processing results as values of the approrpiate step outputs.\n\n        Returns:\n            a dict with the result value id as key, and the id of the job that produced it as value\n        \"\"\"\n\n        self._job_registry.wait_for(*job_ids.values())\n\n        result: Dict[uuid.UUID, uuid.UUID] = {}\n        combined_outputs = {}\n        for step_id, job_id in job_ids.items():\n            record = self._job_registry.get_job_record(job_id=job_id)\n            if record is None:\n                continue\n            combined_outputs[step_id] = record.outputs\n            for output_id in record.outputs.values():\n                result[output_id] = job_id\n\n        self.pipeline.set_multiple_step_outputs(\n            changed_outputs=combined_outputs, notify_listeners=True\n        )\n\n        return result\n\n    def pipeline_is_ready(self) -&gt; bool:\n\"\"\"Return whether the pipeline is ready to be processed.\n\n        A ``True`` result means that all pipeline inputs are set with valid values, and therefore every step within the\n        pipeline can be processed.\n\n        Returns:\n            whether the pipeline can be processed as a whole (``True``) or not (``False``)\n        \"\"\"\n\n        pipeline_inputs = self.pipeline._all_values.get_alias(\"pipeline.inputs\")\n        assert pipeline_inputs is not None\n        return pipeline_inputs.all_items_valid\n\n    def process_step(self, step_id: str, wait: bool = False) -&gt; uuid.UUID:\n\"\"\"Kick off processing for the step with the provided id.\n\n        Arguments:\n            step_id: the id of the step that should be started\n        \"\"\"\n\n        job_config = self.pipeline.create_job_config_for_step(step_id)\n\n        job_metadata = {\"is_pipeline_step\": True, \"step_id\": step_id}\n        job_id = self._job_registry.execute_job(\n            job_config=job_config, job_metadata=job_metadata\n        )\n        # job_id = self._processor.create_job(job_config=job_config)\n        # self._processor.queue_job(job_id=job_id)\n\n        if wait:\n            self._job_registry.wait_for(job_id)\n\n        return job_id\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.pipeline","title":"<code>pipeline: Pipeline</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.current_pipeline_state","title":"<code>current_pipeline_state() -&gt; PipelineState</code>","text":"Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def current_pipeline_state(self) -&gt; PipelineState:\n\n    if self._pipeline_details is None:\n        self._pipeline_details = self.pipeline.get_pipeline_details()\n    return self._pipeline_details\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.can_be_processed","title":"<code>can_be_processed(step_id: str) -&gt; bool</code>","text":"<p>Check whether the step with the provided id is ready to be processed.</p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def can_be_processed(self, step_id: str) -&gt; bool:\n\"\"\"Check whether the step with the provided id is ready to be processed.\"\"\"\n\n    pipeline_state = self.current_pipeline_state()\n    step_state = pipeline_state.step_states[step_id]\n\n    return not step_state.invalid_details\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.can_be_skipped","title":"<code>can_be_skipped(step_id: str) -&gt; bool</code>","text":"<p>Check whether the processing of a step can be skipped.</p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def can_be_skipped(self, step_id: str) -&gt; bool:\n\"\"\"Check whether the processing of a step can be skipped.\"\"\"\n\n    required = self.pipeline.structure.step_is_required(step_id=step_id)\n    if required:\n        required = self.can_be_processed(step_id)\n    return required\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.set_processing_results","title":"<code>set_processing_results(job_ids: Mapping[str, uuid.UUID]) -&gt; Mapping[uuid.UUID, uuid.UUID]</code>","text":"<p>Set the processing results as values of the approrpiate step outputs.</p> <p>Returns:</p> Type Description <code>Mapping[uuid.UUID, uuid.UUID]</code> <p>a dict with the result value id as key, and the id of the job that produced it as value</p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def set_processing_results(\n    self, job_ids: Mapping[str, uuid.UUID]\n) -&gt; Mapping[uuid.UUID, uuid.UUID]:\n\"\"\"Set the processing results as values of the approrpiate step outputs.\n\n    Returns:\n        a dict with the result value id as key, and the id of the job that produced it as value\n    \"\"\"\n\n    self._job_registry.wait_for(*job_ids.values())\n\n    result: Dict[uuid.UUID, uuid.UUID] = {}\n    combined_outputs = {}\n    for step_id, job_id in job_ids.items():\n        record = self._job_registry.get_job_record(job_id=job_id)\n        if record is None:\n            continue\n        combined_outputs[step_id] = record.outputs\n        for output_id in record.outputs.values():\n            result[output_id] = job_id\n\n    self.pipeline.set_multiple_step_outputs(\n        changed_outputs=combined_outputs, notify_listeners=True\n    )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.pipeline_is_ready","title":"<code>pipeline_is_ready() -&gt; bool</code>","text":"<p>Return whether the pipeline is ready to be processed.</p> <p>A <code>True</code> result means that all pipeline inputs are set with valid values, and therefore every step within the pipeline can be processed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether the pipeline can be processed as a whole (<code>True</code>) or not (<code>False</code>)</p> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def pipeline_is_ready(self) -&gt; bool:\n\"\"\"Return whether the pipeline is ready to be processed.\n\n    A ``True`` result means that all pipeline inputs are set with valid values, and therefore every step within the\n    pipeline can be processed.\n\n    Returns:\n        whether the pipeline can be processed as a whole (``True``) or not (``False``)\n    \"\"\"\n\n    pipeline_inputs = self.pipeline._all_values.get_alias(\"pipeline.inputs\")\n    assert pipeline_inputs is not None\n    return pipeline_inputs.all_items_valid\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineController.process_step","title":"<code>process_step(step_id: str, wait: bool = False) -&gt; uuid.UUID</code>","text":"<p>Kick off processing for the step with the provided id.</p> <p>Parameters:</p> Name Type Description Default <code>step_id</code> <code>str</code> <p>the id of the step that should be started</p> required Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def process_step(self, step_id: str, wait: bool = False) -&gt; uuid.UUID:\n\"\"\"Kick off processing for the step with the provided id.\n\n    Arguments:\n        step_id: the id of the step that should be started\n    \"\"\"\n\n    job_config = self.pipeline.create_job_config_for_step(step_id)\n\n    job_metadata = {\"is_pipeline_step\": True, \"step_id\": step_id}\n    job_id = self._job_registry.execute_job(\n        job_config=job_config, job_metadata=job_metadata\n    )\n    # job_id = self._processor.create_job(job_config=job_config)\n    # self._processor.queue_job(job_id=job_id)\n\n    if wait:\n        self._job_registry.wait_for(job_id)\n\n    return job_id\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineBatchController","title":"<code>SinglePipelineBatchController</code>","text":"<p>         Bases: <code>SinglePipelineController</code></p> <p>A PipelineController that executes all pipeline steps non-interactively.</p> <p>This is the default implementation of a <code>PipelineController</code>, and probably the most simple implementation of one. It waits until all inputs are set, after which it executes all pipeline steps in the required order.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>Pipeline</code> <p>the pipeline to control</p> required <code>auto_process</code> <code>bool</code> <p>whether to automatically start processing the pipeline as soon as the input set is valid</p> <code>True</code> Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>class SinglePipelineBatchController(SinglePipelineController):\n\"\"\"A [PipelineController][kiara.models.modules.pipeline.controller.PipelineController] that executes all pipeline steps non-interactively.\n\n    This is the default implementation of a ``PipelineController``, and probably the most simple implementation of one.\n    It waits until all inputs are set, after which it executes all pipeline steps in the required order.\n\n    Arguments:\n        pipeline: the pipeline to control\n        auto_process: whether to automatically start processing the pipeline as soon as the input set is valid\n    \"\"\"\n\n    def __init__(\n        self,\n        pipeline: Pipeline,\n        job_registry: JobRegistry,\n        auto_process: bool = True,\n    ):\n\n        self._auto_process: bool = auto_process\n        self._is_running: bool = False\n        super().__init__(pipeline=pipeline, job_registry=job_registry)\n\n    @property\n    def auto_process(self) -&gt; bool:\n        return self._auto_process\n\n    @auto_process.setter\n    def auto_process(self, auto_process: bool):\n        self._auto_process = auto_process\n\n    def process_pipeline(self) -&gt; Mapping[str, Union[uuid.UUID, Exception]]:\n\n        log = logger.bind(pipeline_id=self.pipeline.pipeline_id)\n        if self._is_running:\n            log.debug(\n                \"ignore.pipeline_process\",\n                reason=\"Pipeline already running.\",\n            )\n            raise Exception(\"Pipeline already running.\")\n\n        log.debug(\"execute.pipeline\")\n        self._is_running = True\n        all_job_ids: Dict[str, Union[Exception, uuid.UUID]] = {}\n        try:\n            for idx, stage in enumerate(\n                self.pipeline.structure.processing_stages, start=1\n            ):\n\n                log.debug(\n                    \"execute.pipeline.stage\",\n                    stage=idx,\n                )\n\n                job_ids = {}\n                for step_id in stage:\n\n                    log.debug(\n                        \"execute.pipeline.step\",\n                        step_id=step_id,\n                    )\n\n                    try:\n                        job_id = self.process_step(step_id)\n                        job_ids[step_id] = job_id\n                    except Exception as e:\n                        all_job_ids[step_id] = e\n                        # TODO: cancel running jobs?\n                        log_exception(e)\n                        log.error(\n                            \"error.processing.pipeline\",\n                            step_id=step_id,\n                            error=e,\n                        )\n\n                self.set_processing_results(job_ids=job_ids)\n                log.debug(\n                    \"execute_finished.pipeline.stage\",\n                    stage=idx,\n                )\n                all_job_ids.update(job_ids)\n\n        finally:\n            self._is_running = False\n\n        log.debug(\"execute_finished.pipeline\")\n        return all_job_ids\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineBatchController-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineBatchController.auto_process","title":"<code>auto_process: bool</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineBatchController-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller.SinglePipelineBatchController.process_pipeline","title":"<code>process_pipeline() -&gt; Mapping[str, Union[uuid.UUID, Exception]]</code>","text":"Source code in <code>kiara/models/module/pipeline/controller.py</code> <pre><code>def process_pipeline(self) -&gt; Mapping[str, Union[uuid.UUID, Exception]]:\n\n    log = logger.bind(pipeline_id=self.pipeline.pipeline_id)\n    if self._is_running:\n        log.debug(\n            \"ignore.pipeline_process\",\n            reason=\"Pipeline already running.\",\n        )\n        raise Exception(\"Pipeline already running.\")\n\n    log.debug(\"execute.pipeline\")\n    self._is_running = True\n    all_job_ids: Dict[str, Union[Exception, uuid.UUID]] = {}\n    try:\n        for idx, stage in enumerate(\n            self.pipeline.structure.processing_stages, start=1\n        ):\n\n            log.debug(\n                \"execute.pipeline.stage\",\n                stage=idx,\n            )\n\n            job_ids = {}\n            for step_id in stage:\n\n                log.debug(\n                    \"execute.pipeline.step\",\n                    step_id=step_id,\n                )\n\n                try:\n                    job_id = self.process_step(step_id)\n                    job_ids[step_id] = job_id\n                except Exception as e:\n                    all_job_ids[step_id] = e\n                    # TODO: cancel running jobs?\n                    log_exception(e)\n                    log.error(\n                        \"error.processing.pipeline\",\n                        step_id=step_id,\n                        error=e,\n                    )\n\n            self.set_processing_results(job_ids=job_ids)\n            log.debug(\n                \"execute_finished.pipeline.stage\",\n                stage=idx,\n            )\n            all_job_ids.update(job_ids)\n\n    finally:\n        self._is_running = False\n\n    log.debug(\"execute_finished.pipeline\")\n    return all_job_ids\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/controller/#kiara.models.module.pipeline.controller-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/","title":"pipeline","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.yaml","title":"<code>yaml = StringYAML()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineListener","title":"<code>PipelineListener</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>class PipelineListener(abc.ABC):\n    @abc.abstractmethod\n    def _pipeline_event_occurred(self, event: PipelineEvent):\n        pass\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>         Bases: <code>object</code></p> <p>An instance of a PipelineStructure that holds state for all of the inputs/outputs of the steps within.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>class Pipeline(object):\n\"\"\"An instance of a [PipelineStructure][kiara.pipeline.structure.PipelineStructure] that holds state for all of the inputs/outputs of the steps within.\"\"\"\n\n    @classmethod\n    def create_pipeline(\n        cls,\n        kiara: \"Kiara\",\n        pipeline: Union[PipelineConfig, PipelineStructure, Mapping, str],\n    ) -&gt; \"Pipeline\":\n\n        if isinstance(pipeline, Mapping):\n            pipeline_structure: PipelineStructure = PipelineConfig.from_config(\n                pipeline_name=\"__pipeline__\", data=pipeline, kiara=kiara\n            ).structure\n        elif isinstance(pipeline, PipelineConfig):\n            pipeline_structure = pipeline.structure\n        elif isinstance(pipeline, PipelineStructure):\n            pipeline_structure = pipeline\n        elif isinstance(pipeline, str):\n            operation = create_operation(module_or_operation=pipeline, kiara=kiara)\n            module = operation.module\n            if isinstance(module.config, PipelineConfig):\n                config: PipelineConfig = module.config\n            else:\n                raise NotImplementedError()\n            pipeline_structure = config.structure\n        else:\n            raise Exception(f\"Invalid type for argument 'pipeline': {type(pipeline)}\")\n\n        pipeline_obj = Pipeline(kiara=kiara, structure=pipeline_structure)\n        return pipeline_obj\n\n    def __init__(self, structure: PipelineStructure, kiara: \"Kiara\"):\n\n        self._id: uuid.UUID = uuid.uuid4()\n\n        self._structure: PipelineStructure = structure\n\n        self._value_refs: Mapping[AliasValueMap, Iterable[ValueRef]] = None  # type: ignore\n        # self._status: StepStatus = StepStatus.STALE\n\n        self._steps_by_stage: Dict[int, Dict[str, PipelineStep]] = None  # type: ignore\n        self._inputs_by_stage: Dict[int, List[str]] = None  # type: ignore\n        self._outputs_by_stage: Dict[int, List[str]] = None  # type: ignore\n\n        self._kiara: Kiara = kiara\n        self._data_registry: DataRegistry = kiara.data_registry\n\n        self._all_values: AliasValueMap = None  # type: ignore\n\n        self._listeners: List[PipelineListener] = []\n\n        self._init_values()\n\n        # self._update_status()\n\n    @property\n    def pipeline_id(self) -&gt; uuid.UUID:\n        return self._id\n\n    # @property\n    # def pipeline_name(self) -&gt; str:\n    #     return self.structure.pipeline_config.pipeline_name\n\n    @property\n    def kiara_id(self) -&gt; uuid.UUID:\n        return self._kiara.id\n\n    def _init_values(self):\n\"\"\"Initialize this object. This should only be called once.\n\n        Basically, this goes through all the inputs and outputs of all steps, and 'allocates' a PipelineValueInfo object\n        for each of them. In case where output/input or pipeline-input/input points are connected, only one\n        value item is allocated, since those refer to the same value.\n        \"\"\"\n\n        values = AliasValueMap(\n            alias=str(self.id), version=0, assoc_value=None, values_schema={}\n        )\n        values._data_registry = self._data_registry\n        inputs_schema = self._structure.pipeline_inputs_schema\n        outputs_schema = self._structure.pipeline_outputs_schema\n        if inputs_schema:\n            for field_name, schema in inputs_schema.items():\n                values.set_alias_schema(f\"pipeline.inputs.{field_name}\", schema=schema)\n        else:\n            values.set_alias_schema(\"pipeline.inputs\", schema=ValueSchema(type=\"none\"))\n        if outputs_schema:\n            for field_name, schema in outputs_schema.items():\n                values.set_alias_schema(f\"pipeline.outputs.{field_name}\", schema=schema)\n        else:\n            values.set_alias_schema(\"pipeline.outputs\", schema=ValueSchema(type=\"none\"))\n        for step_id in self.step_ids:\n            step = self.get_step(step_id)\n            for field_name, value_schema in step.module.inputs_schema.items():\n                values.set_alias_schema(\n                    f\"steps.{step_id}.inputs.{field_name}\", schema=value_schema\n                )\n            for field_name, value_schema in step.module.outputs_schema.items():\n                values.set_alias_schema(\n                    f\"steps.{step_id}.outputs.{field_name}\", schema=value_schema\n                )\n\n        self._all_values = values\n\n        initial_inputs = {\n            k: SpecialValue.NOT_SET\n            for k in self._structure.pipeline_inputs_schema.keys()\n        }\n        self.set_pipeline_inputs(inputs=initial_inputs)\n\n    def __eq__(self, other):\n\n        if not isinstance(other, Pipeline):\n            return False\n\n        return self._id == other._id\n\n    def __hash__(self):\n\n        return hash(self._id)\n\n    def add_listener(self, listener: PipelineListener):\n\n        self._listeners.append(listener)\n\n    @property\n    def id(self) -&gt; uuid.UUID:\n        return self._id\n\n    @property\n    def structure(self) -&gt; PipelineStructure:\n        return self._structure\n\n    @property\n    def config(self) -&gt; PipelineConfig:\n        return self._structure.pipeline_config\n\n    @property\n    def doc(self) -&gt; DocumentationMetadataModel:\n        return self.structure.pipeline_config.doc\n\n    def get_current_pipeline_inputs(self) -&gt; Dict[str, uuid.UUID]:\n\"\"\"All (pipeline) input values of this pipeline.\"\"\"\n\n        if not self._structure.steps:\n            return {}\n\n        alias_map = self._all_values.get_alias(\"pipeline.inputs\")\n        return alias_map.get_all_value_ids()  # type: ignore\n\n    def get_current_pipeline_outputs(self) -&gt; Dict[str, uuid.UUID]:\n\"\"\"All (pipeline) output values of this pipeline.\"\"\"\n\n        if not self._structure.steps:\n            return {}\n\n        alias_map = self._all_values.get_alias(\"pipeline.outputs\")\n        return alias_map.get_all_value_ids()  # type: ignore\n\n    def get_current_step_inputs(self, step_id) -&gt; Dict[str, uuid.UUID]:\n\n        alias_map = self._all_values.get_alias(f\"steps.{step_id}.inputs\")\n        return alias_map.get_all_value_ids()  # type: ignore\n\n    def get_current_step_outputs(self, step_id) -&gt; Dict[str, uuid.UUID]:\n\n        alias_map = self._all_values.get_alias(f\"steps.{step_id}.outputs\")\n        return alias_map.get_all_value_ids()  # type: ignore\n\n    def get_inputs_for_steps(self, *step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]:\n\"\"\"Retrieve value ids for the inputs of the specified steps (or all steps, if no argument provided.\"\"\"\n\n        result = {}\n        for step_id in self._structure.step_ids:\n            if step_ids and step_id not in step_ids:\n                continue\n            ids = self.get_current_step_inputs(step_id=step_id)\n            result[step_id] = ids\n        return result\n\n    def get_outputs_for_steps(self, *step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]:\n\"\"\"Retrieve value ids for the outputs of the specified steps (or all steps, if no argument provided.\"\"\"\n\n        result = {}\n        for step_id in self._structure.step_ids:\n            if step_ids and step_id not in step_ids:\n                continue\n            ids = self.get_current_step_outputs(step_id=step_id)\n            result[step_id] = ids\n        return result\n\n    def _notify_pipeline_listeners(self, event: PipelineEvent):\n\n        for listener in self._listeners:\n            listener._pipeline_event_occurred(event=event)\n\n    def get_pipeline_details(self) -&gt; PipelineState:\n\n        pipeline_inputs = self._all_values.get_alias(\"pipeline.inputs\")\n        pipeline_outputs = self._all_values.get_alias(\"pipeline.outputs\")\n\n        if pipeline_inputs:\n            invalid = pipeline_inputs.check_invalid()\n            if not invalid:\n                status = StepStatus.INPUTS_READY\n                step_outputs = self._all_values.get_alias(\"pipeline.outputs\")\n                assert step_outputs is not None\n                invalid_outputs = step_outputs.check_invalid()\n                # TODO: also check that all the pedigrees match up with current inputs\n                if not invalid_outputs:\n                    status = StepStatus.RESULTS_READY\n            else:\n                status = StepStatus.INPUTS_INVALID\n            _pipeline_inputs = pipeline_inputs.get_all_value_ids()\n        else:\n            _pipeline_inputs = {}\n            invalid = {}\n            status = StepStatus.INPUTS_READY\n\n        if pipeline_outputs:\n            _pipeline_outputs = pipeline_outputs.get_all_value_ids()\n        else:\n            _pipeline_outputs = {}\n\n        step_states = {}\n        for step_id in self._structure.step_ids:\n            d = self.get_step_details(step_id)\n            step_states[step_id] = d\n\n        details = PipelineState.construct(\n            kiara_id=self._data_registry.kiara_id,\n            pipeline_id=self.pipeline_id,\n            pipeline_status=status,\n            pipeline_inputs=_pipeline_inputs,\n            pipeline_outputs=_pipeline_outputs,\n            invalid_details=invalid,\n            step_states=step_states,\n        )\n\n        return details\n\n    def get_step_details(self, step_id: str) -&gt; StepDetails:\n\n        step_input_ids = self.get_current_step_inputs(step_id=step_id)\n        step_output_ids = self.get_current_step_outputs(step_id=step_id)\n        step_inputs = self._all_values.get_alias(f\"steps.{step_id}.inputs\")\n\n        assert step_inputs is not None\n        invalid = step_inputs.check_invalid()\n\n        processing_stage = self._structure.get_processing_stage(step_id)\n\n        if not invalid:\n            status = StepStatus.INPUTS_READY\n            step_outputs = self._all_values.get_alias(f\"steps.{step_id}.outputs\")\n            assert step_outputs is not None\n            invalid_outputs = step_outputs.check_invalid()\n            # TODO: also check that all the pedigrees match up with current inputs\n            if not invalid_outputs:\n                status = StepStatus.RESULTS_READY\n        else:\n            status = StepStatus.INPUTS_INVALID\n\n        details = StepDetails.construct(\n            kiara_id=self._data_registry.kiara_id,\n            pipeline_id=self.pipeline_id,\n            step=self._structure.get_step(step_id=step_id),\n            step_id=step_id,\n            status=status,\n            inputs=step_input_ids,\n            outputs=step_output_ids,\n            invalid_details=invalid,\n            processing_stage=processing_stage,\n        )\n        return details\n\n    def set_pipeline_inputs(\n        self,\n        inputs: Mapping[str, Any],\n        sync_to_step_inputs: bool = True,\n        notify_listeners: bool = True,\n    ) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        values_to_set: Dict[str, uuid.UUID] = {}\n\n        for k, v in inputs.items():\n            if v is SpecialValue.NOT_SET:\n                values_to_set[k] = NOT_SET_VALUE_ID\n            elif v in [None, SpecialValue.NO_VALUE]:\n                values_to_set[k] = NONE_VALUE_ID\n            else:\n                alias_map = self._all_values.get_alias(\"pipeline.inputs\")\n                assert alias_map is not None\n                # dbg(alias_map.__dict__)\n                schema = alias_map.values_schema.get(k, None)\n                if schema is None:\n                    raise Exception(\n                        f\"Can't set pipeline input for input '{k}': no such input field. Available fields: {', '.join(alias_map.values_schema.keys())}\"\n                    )\n                value = self._data_registry.register_data(\n                    data=v, schema=schema, pedigree=ORPHAN, reuse_existing=True\n                )\n                values_to_set[k] = value.value_id\n\n        if not values_to_set:\n            return {}\n\n        changed_pipeline_inputs = self._set_values(\"pipeline.inputs\", **values_to_set)\n\n        changed_results = {\"__pipeline__\": {\"inputs\": changed_pipeline_inputs}}\n\n        if sync_to_step_inputs:\n            changed = self.sync_pipeline_inputs(notify_listeners=False)\n            dpath.merge(changed_results, changed)  # type: ignore\n\n        if notify_listeners:\n            event = PipelineEvent.create_event(pipeline=self, changed=changed_results)\n            if event:\n                self._notify_pipeline_listeners(event)\n\n        return changed_results\n\n    def sync_pipeline_inputs(\n        self, notify_listeners: bool = True\n    ) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        pipeline_inputs = self.get_current_pipeline_inputs()\n\n        values_to_sync: Dict[str, Dict[str, Union[uuid.UUID, None]]] = {}\n\n        for field_name, ref in self._structure.pipeline_input_refs.items():\n            for step_input in ref.connected_inputs:\n                step_inputs = self.get_current_step_inputs(step_input.step_id)\n\n                if step_inputs[step_input.value_name] != pipeline_inputs[field_name]:\n                    values_to_sync.setdefault(step_input.step_id, {})[\n                        step_input.value_name\n                    ] = pipeline_inputs[field_name]\n\n        results: Dict[str, Mapping[str, Mapping[str, ChangedValue]]] = {}\n        for step_id in values_to_sync.keys():\n            values = values_to_sync[step_id]\n            step_changed = self._set_step_inputs(step_id=step_id, inputs=values)\n            dpath.merge(results, step_changed)  # type: ignore\n\n        if notify_listeners:\n            event = PipelineEvent.create_event(pipeline=self, changed=results)\n            if event:\n                self._notify_pipeline_listeners(event)\n\n        return results\n\n    def _set_step_inputs(\n        self, step_id: str, inputs: Mapping[str, Union[uuid.UUID, None]]\n    ) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        changed_step_inputs = self._set_values(f\"steps.{step_id}.inputs\", **inputs)\n        if not changed_step_inputs:\n            return {}\n\n        result: Dict[str, Dict[str, Dict[str, ChangedValue]]] = {\n            step_id: {\"inputs\": changed_step_inputs}\n        }\n\n        step_outputs = self._structure.get_step_output_refs(step_id=step_id)\n        null_outputs = {k: NOT_SET_VALUE_ID for k in step_outputs.keys()}\n\n        changed_outputs = self.set_step_outputs(\n            step_id=step_id, outputs=null_outputs, notify_listeners=False\n        )\n        # assert step_id in changed_outputs.keys()\n\n        result.update(changed_outputs)  # type: ignore\n\n        return result\n\n    def set_multiple_step_outputs(\n        self,\n        changed_outputs: Mapping[str, Mapping[str, Union[uuid.UUID, None]]],\n        notify_listeners: bool = True,\n    ) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        results: Dict[str, Dict[str, Dict[str, ChangedValue]]] = {}\n        for step_id, outputs in changed_outputs.items():\n            step_results = self.set_step_outputs(\n                step_id=step_id, outputs=outputs, notify_listeners=False\n            )\n            dpath.merge(results, step_results)  # type: ignore\n\n        if notify_listeners:\n            event = PipelineEvent.create_event(pipeline=self, changed=results)\n            if event:\n                self._notify_pipeline_listeners(event)\n\n        return results\n\n    def set_step_outputs(\n        self,\n        step_id: str,\n        outputs: Mapping[str, Union[uuid.UUID, None]],\n        notify_listeners: bool = True,\n    ) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n        # make sure pedigrees match with respective inputs?\n\n        changed_step_outputs = self._set_values(f\"steps.{step_id}.outputs\", **outputs)\n        if not changed_step_outputs:\n            return {}\n\n        result: Dict[str, Dict[str, Dict[str, ChangedValue]]] = {\n            step_id: {\"outputs\": changed_step_outputs}\n        }\n\n        output_refs = self._structure.get_step_output_refs(step_id=step_id)\n\n        pipeline_outputs: Dict[str, Union[uuid.UUID, None]] = {}\n\n        inputs_to_set: Dict[str, Dict[str, Union[uuid.UUID, None]]] = {}\n\n        for field_name, ref in output_refs.items():\n            if ref.pipeline_output:\n                assert ref.pipeline_output not in pipeline_outputs.keys()\n                pipeline_outputs[ref.pipeline_output] = outputs[field_name]\n            for input_ref in ref.connected_inputs:\n                inputs_to_set.setdefault(input_ref.step_id, {})[\n                    input_ref.value_name\n                ] = outputs[field_name]\n\n        for step_id, step_inputs in inputs_to_set.items():\n            changed_step_fields = self._set_step_inputs(\n                step_id=step_id, inputs=step_inputs\n            )\n            dpath.merge(result, changed_step_fields)  # type: ignore\n\n        if pipeline_outputs:\n            changed_pipeline_outputs = self._set_pipeline_outputs(**pipeline_outputs)\n            dpath.merge(  # type: ignore\n                result, {\"__pipeline__\": {\"outputs\": changed_pipeline_outputs}}\n            )\n\n        if notify_listeners:\n            event = PipelineEvent.create_event(pipeline=self, changed=result)\n            if event:\n                self._notify_pipeline_listeners(event)\n\n        return result\n\n    def _set_pipeline_outputs(\n        self, **outputs: Union[uuid.UUID, None]\n    ) -&gt; Mapping[str, ChangedValue]:\n\n        changed_pipeline_outputs = self._set_values(\"pipeline.outputs\", **outputs)\n        return changed_pipeline_outputs\n\n    def _set_values(\n        self, alias: str, **values: Union[uuid.UUID, None]\n    ) -&gt; Dict[str, ChangedValue]:\n\"\"\"Set values (value-ids) for the sub-alias-map with the specified alias path.\"\"\"\n\n        invalid = {}\n        for k in values.keys():\n            _alias = self._all_values.get_alias(alias)\n            assert _alias is not None\n            if k not in _alias.values_schema.keys():\n                invalid[\n                    k\n                ] = f\"Invalid field '{k}'. Available fields: {', '.join(self.get_current_pipeline_inputs().keys())}\"\n\n        if invalid:\n            raise InvalidValuesException(invalid_values=invalid)\n\n        alias_map: Union[AliasValueMap, None] = self._all_values.get_alias(alias)\n        assert alias_map is not None\n\n        values_to_set: Dict[str, Union[uuid.UUID, None]] = {}\n        current: Dict[str, Union[uuid.UUID, None]] = {}\n        changed: Dict[str, ChangedValue] = {}\n\n        for field_name, new_value in values.items():\n\n            current_value = self._all_values.get_alias(f\"{alias}.{field_name}\")\n            if current_value is not None:\n                current_value_id = current_value.assoc_value\n            else:\n                current_value_id = None\n            current[field_name] = current_value_id\n\n            if current_value_id != new_value:\n                values_to_set[field_name] = new_value\n                changed[field_name] = ChangedValue(old=current_value_id, new=new_value)\n\n        _alias = self._all_values.get_alias(alias)\n        assert _alias is not None\n        _alias._set_aliases(**values_to_set)\n\n        return changed\n\n    @property\n    def step_ids(self) -&gt; Iterable[str]:\n\"\"\"Return all ids of the steps of this pipeline.\"\"\"\n        return self._structure.step_ids\n\n    @property\n    def execution_graph(self) -&gt; nx.DiGraph:\n        return self._structure.execution_graph\n\n    @property\n    def data_flow_graph(self) -&gt; nx.DiGraph:\n        return self._structure.data_flow_graph\n\n    @property\n    def data_flow_graph_simple(self) -&gt; nx.DiGraph:\n        return self._structure.data_flow_graph_simple\n\n    def get_step(self, step_id: str) -&gt; PipelineStep:\n\"\"\"Return the object representing a step in this workflow, identified by the step id.\"\"\"\n        return self._structure.get_step(step_id)\n\n    def get_steps_by_stage(\n        self,\n    ) -&gt; Mapping[int, Mapping[str, PipelineStep]]:\n\"\"\"Return a all pipeline steps, ordered by stage they belong to.\"\"\"\n\n        if self._steps_by_stage is not None:\n            return self._steps_by_stage\n\n        result: Dict[int, Dict[str, PipelineStep]] = {}\n        for step_id in self.step_ids:\n            step = self.get_step(step_id)\n            stage = self._structure.get_processing_stage(step.step_id)\n            assert stage is not None\n            result.setdefault(stage, {})[step_id] = step\n\n        self._steps_by_stage = result\n        return self._steps_by_stage\n\n    def create_job_config_for_step(self, step_id: str) -&gt; JobConfig:\n\n        step_inputs: Mapping[str, uuid.UUID] = self.get_current_step_inputs(step_id)\n        step_details: StepDetails = self.get_step_details(step_id=step_id)\n        step: PipelineStep = self.get_step(step_id=step_id)\n\n        # if the inputs are not valid, ignore this step\n        if step_details.status == StepStatus.INPUTS_INVALID:\n            invalid_details = step_details.invalid_details\n            assert invalid_details is not None\n            msg = f\"Can't execute step '{step_id}', invalid inputs: {', '.join(invalid_details.keys())}\"\n            raise InvalidValuesException(msg=msg, invalid_values=invalid_details)\n\n        job_config = JobConfig.create_from_module(\n            data_registry=self._data_registry, module=step.module, inputs=step_inputs\n        )\n\n        return job_config\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        return PipelineInfo.create_from_pipeline(\n            kiara=self._kiara, pipeline=self\n        ).create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.pipeline_id","title":"<code>pipeline_id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.kiara_id","title":"<code>kiara_id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.id","title":"<code>id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.structure","title":"<code>structure: PipelineStructure</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.config","title":"<code>config: PipelineConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.doc","title":"<code>doc: DocumentationMetadataModel</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.step_ids","title":"<code>step_ids: Iterable[str]</code>  <code>property</code>","text":"<p>Return all ids of the steps of this pipeline.</p>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.execution_graph","title":"<code>execution_graph: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.data_flow_graph","title":"<code>data_flow_graph: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.data_flow_graph_simple","title":"<code>data_flow_graph_simple: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.create_pipeline","title":"<code>create_pipeline(kiara: Kiara, pipeline: Union[PipelineConfig, PipelineStructure, Mapping, str]) -&gt; Pipeline</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>@classmethod\ndef create_pipeline(\n    cls,\n    kiara: \"Kiara\",\n    pipeline: Union[PipelineConfig, PipelineStructure, Mapping, str],\n) -&gt; \"Pipeline\":\n\n    if isinstance(pipeline, Mapping):\n        pipeline_structure: PipelineStructure = PipelineConfig.from_config(\n            pipeline_name=\"__pipeline__\", data=pipeline, kiara=kiara\n        ).structure\n    elif isinstance(pipeline, PipelineConfig):\n        pipeline_structure = pipeline.structure\n    elif isinstance(pipeline, PipelineStructure):\n        pipeline_structure = pipeline\n    elif isinstance(pipeline, str):\n        operation = create_operation(module_or_operation=pipeline, kiara=kiara)\n        module = operation.module\n        if isinstance(module.config, PipelineConfig):\n            config: PipelineConfig = module.config\n        else:\n            raise NotImplementedError()\n        pipeline_structure = config.structure\n    else:\n        raise Exception(f\"Invalid type for argument 'pipeline': {type(pipeline)}\")\n\n    pipeline_obj = Pipeline(kiara=kiara, structure=pipeline_structure)\n    return pipeline_obj\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.add_listener","title":"<code>add_listener(listener: PipelineListener)</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def add_listener(self, listener: PipelineListener):\n\n    self._listeners.append(listener)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_current_pipeline_inputs","title":"<code>get_current_pipeline_inputs() -&gt; Dict[str, uuid.UUID]</code>","text":"<p>All (pipeline) input values of this pipeline.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_current_pipeline_inputs(self) -&gt; Dict[str, uuid.UUID]:\n\"\"\"All (pipeline) input values of this pipeline.\"\"\"\n\n    if not self._structure.steps:\n        return {}\n\n    alias_map = self._all_values.get_alias(\"pipeline.inputs\")\n    return alias_map.get_all_value_ids()  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_current_pipeline_outputs","title":"<code>get_current_pipeline_outputs() -&gt; Dict[str, uuid.UUID]</code>","text":"<p>All (pipeline) output values of this pipeline.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_current_pipeline_outputs(self) -&gt; Dict[str, uuid.UUID]:\n\"\"\"All (pipeline) output values of this pipeline.\"\"\"\n\n    if not self._structure.steps:\n        return {}\n\n    alias_map = self._all_values.get_alias(\"pipeline.outputs\")\n    return alias_map.get_all_value_ids()  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_current_step_inputs","title":"<code>get_current_step_inputs(step_id) -&gt; Dict[str, uuid.UUID]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_current_step_inputs(self, step_id) -&gt; Dict[str, uuid.UUID]:\n\n    alias_map = self._all_values.get_alias(f\"steps.{step_id}.inputs\")\n    return alias_map.get_all_value_ids()  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_current_step_outputs","title":"<code>get_current_step_outputs(step_id) -&gt; Dict[str, uuid.UUID]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_current_step_outputs(self, step_id) -&gt; Dict[str, uuid.UUID]:\n\n    alias_map = self._all_values.get_alias(f\"steps.{step_id}.outputs\")\n    return alias_map.get_all_value_ids()  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_inputs_for_steps","title":"<code>get_inputs_for_steps(*step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]</code>","text":"<p>Retrieve value ids for the inputs of the specified steps (or all steps, if no argument provided.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_inputs_for_steps(self, *step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]:\n\"\"\"Retrieve value ids for the inputs of the specified steps (or all steps, if no argument provided.\"\"\"\n\n    result = {}\n    for step_id in self._structure.step_ids:\n        if step_ids and step_id not in step_ids:\n            continue\n        ids = self.get_current_step_inputs(step_id=step_id)\n        result[step_id] = ids\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_outputs_for_steps","title":"<code>get_outputs_for_steps(*step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]</code>","text":"<p>Retrieve value ids for the outputs of the specified steps (or all steps, if no argument provided.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_outputs_for_steps(self, *step_ids: str) -&gt; Dict[str, Dict[str, uuid.UUID]]:\n\"\"\"Retrieve value ids for the outputs of the specified steps (or all steps, if no argument provided.\"\"\"\n\n    result = {}\n    for step_id in self._structure.step_ids:\n        if step_ids and step_id not in step_ids:\n            continue\n        ids = self.get_current_step_outputs(step_id=step_id)\n        result[step_id] = ids\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_pipeline_details","title":"<code>get_pipeline_details() -&gt; PipelineState</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_pipeline_details(self) -&gt; PipelineState:\n\n    pipeline_inputs = self._all_values.get_alias(\"pipeline.inputs\")\n    pipeline_outputs = self._all_values.get_alias(\"pipeline.outputs\")\n\n    if pipeline_inputs:\n        invalid = pipeline_inputs.check_invalid()\n        if not invalid:\n            status = StepStatus.INPUTS_READY\n            step_outputs = self._all_values.get_alias(\"pipeline.outputs\")\n            assert step_outputs is not None\n            invalid_outputs = step_outputs.check_invalid()\n            # TODO: also check that all the pedigrees match up with current inputs\n            if not invalid_outputs:\n                status = StepStatus.RESULTS_READY\n        else:\n            status = StepStatus.INPUTS_INVALID\n        _pipeline_inputs = pipeline_inputs.get_all_value_ids()\n    else:\n        _pipeline_inputs = {}\n        invalid = {}\n        status = StepStatus.INPUTS_READY\n\n    if pipeline_outputs:\n        _pipeline_outputs = pipeline_outputs.get_all_value_ids()\n    else:\n        _pipeline_outputs = {}\n\n    step_states = {}\n    for step_id in self._structure.step_ids:\n        d = self.get_step_details(step_id)\n        step_states[step_id] = d\n\n    details = PipelineState.construct(\n        kiara_id=self._data_registry.kiara_id,\n        pipeline_id=self.pipeline_id,\n        pipeline_status=status,\n        pipeline_inputs=_pipeline_inputs,\n        pipeline_outputs=_pipeline_outputs,\n        invalid_details=invalid,\n        step_states=step_states,\n    )\n\n    return details\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_step_details","title":"<code>get_step_details(step_id: str) -&gt; StepDetails</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_step_details(self, step_id: str) -&gt; StepDetails:\n\n    step_input_ids = self.get_current_step_inputs(step_id=step_id)\n    step_output_ids = self.get_current_step_outputs(step_id=step_id)\n    step_inputs = self._all_values.get_alias(f\"steps.{step_id}.inputs\")\n\n    assert step_inputs is not None\n    invalid = step_inputs.check_invalid()\n\n    processing_stage = self._structure.get_processing_stage(step_id)\n\n    if not invalid:\n        status = StepStatus.INPUTS_READY\n        step_outputs = self._all_values.get_alias(f\"steps.{step_id}.outputs\")\n        assert step_outputs is not None\n        invalid_outputs = step_outputs.check_invalid()\n        # TODO: also check that all the pedigrees match up with current inputs\n        if not invalid_outputs:\n            status = StepStatus.RESULTS_READY\n    else:\n        status = StepStatus.INPUTS_INVALID\n\n    details = StepDetails.construct(\n        kiara_id=self._data_registry.kiara_id,\n        pipeline_id=self.pipeline_id,\n        step=self._structure.get_step(step_id=step_id),\n        step_id=step_id,\n        status=status,\n        inputs=step_input_ids,\n        outputs=step_output_ids,\n        invalid_details=invalid,\n        processing_stage=processing_stage,\n    )\n    return details\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.set_pipeline_inputs","title":"<code>set_pipeline_inputs(inputs: Mapping[str, Any], sync_to_step_inputs: bool = True, notify_listeners: bool = True) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def set_pipeline_inputs(\n    self,\n    inputs: Mapping[str, Any],\n    sync_to_step_inputs: bool = True,\n    notify_listeners: bool = True,\n) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n    values_to_set: Dict[str, uuid.UUID] = {}\n\n    for k, v in inputs.items():\n        if v is SpecialValue.NOT_SET:\n            values_to_set[k] = NOT_SET_VALUE_ID\n        elif v in [None, SpecialValue.NO_VALUE]:\n            values_to_set[k] = NONE_VALUE_ID\n        else:\n            alias_map = self._all_values.get_alias(\"pipeline.inputs\")\n            assert alias_map is not None\n            # dbg(alias_map.__dict__)\n            schema = alias_map.values_schema.get(k, None)\n            if schema is None:\n                raise Exception(\n                    f\"Can't set pipeline input for input '{k}': no such input field. Available fields: {', '.join(alias_map.values_schema.keys())}\"\n                )\n            value = self._data_registry.register_data(\n                data=v, schema=schema, pedigree=ORPHAN, reuse_existing=True\n            )\n            values_to_set[k] = value.value_id\n\n    if not values_to_set:\n        return {}\n\n    changed_pipeline_inputs = self._set_values(\"pipeline.inputs\", **values_to_set)\n\n    changed_results = {\"__pipeline__\": {\"inputs\": changed_pipeline_inputs}}\n\n    if sync_to_step_inputs:\n        changed = self.sync_pipeline_inputs(notify_listeners=False)\n        dpath.merge(changed_results, changed)  # type: ignore\n\n    if notify_listeners:\n        event = PipelineEvent.create_event(pipeline=self, changed=changed_results)\n        if event:\n            self._notify_pipeline_listeners(event)\n\n    return changed_results\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.sync_pipeline_inputs","title":"<code>sync_pipeline_inputs(notify_listeners: bool = True) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def sync_pipeline_inputs(\n    self, notify_listeners: bool = True\n) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n    pipeline_inputs = self.get_current_pipeline_inputs()\n\n    values_to_sync: Dict[str, Dict[str, Union[uuid.UUID, None]]] = {}\n\n    for field_name, ref in self._structure.pipeline_input_refs.items():\n        for step_input in ref.connected_inputs:\n            step_inputs = self.get_current_step_inputs(step_input.step_id)\n\n            if step_inputs[step_input.value_name] != pipeline_inputs[field_name]:\n                values_to_sync.setdefault(step_input.step_id, {})[\n                    step_input.value_name\n                ] = pipeline_inputs[field_name]\n\n    results: Dict[str, Mapping[str, Mapping[str, ChangedValue]]] = {}\n    for step_id in values_to_sync.keys():\n        values = values_to_sync[step_id]\n        step_changed = self._set_step_inputs(step_id=step_id, inputs=values)\n        dpath.merge(results, step_changed)  # type: ignore\n\n    if notify_listeners:\n        event = PipelineEvent.create_event(pipeline=self, changed=results)\n        if event:\n            self._notify_pipeline_listeners(event)\n\n    return results\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.set_multiple_step_outputs","title":"<code>set_multiple_step_outputs(changed_outputs: Mapping[str, Mapping[str, Union[uuid.UUID, None]]], notify_listeners: bool = True) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def set_multiple_step_outputs(\n    self,\n    changed_outputs: Mapping[str, Mapping[str, Union[uuid.UUID, None]]],\n    notify_listeners: bool = True,\n) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n    results: Dict[str, Dict[str, Dict[str, ChangedValue]]] = {}\n    for step_id, outputs in changed_outputs.items():\n        step_results = self.set_step_outputs(\n            step_id=step_id, outputs=outputs, notify_listeners=False\n        )\n        dpath.merge(results, step_results)  # type: ignore\n\n    if notify_listeners:\n        event = PipelineEvent.create_event(pipeline=self, changed=results)\n        if event:\n            self._notify_pipeline_listeners(event)\n\n    return results\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.set_step_outputs","title":"<code>set_step_outputs(step_id: str, outputs: Mapping[str, Union[uuid.UUID, None]], notify_listeners: bool = True) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def set_step_outputs(\n    self,\n    step_id: str,\n    outputs: Mapping[str, Union[uuid.UUID, None]],\n    notify_listeners: bool = True,\n) -&gt; Mapping[str, Mapping[str, Mapping[str, ChangedValue]]]:\n\n    # make sure pedigrees match with respective inputs?\n\n    changed_step_outputs = self._set_values(f\"steps.{step_id}.outputs\", **outputs)\n    if not changed_step_outputs:\n        return {}\n\n    result: Dict[str, Dict[str, Dict[str, ChangedValue]]] = {\n        step_id: {\"outputs\": changed_step_outputs}\n    }\n\n    output_refs = self._structure.get_step_output_refs(step_id=step_id)\n\n    pipeline_outputs: Dict[str, Union[uuid.UUID, None]] = {}\n\n    inputs_to_set: Dict[str, Dict[str, Union[uuid.UUID, None]]] = {}\n\n    for field_name, ref in output_refs.items():\n        if ref.pipeline_output:\n            assert ref.pipeline_output not in pipeline_outputs.keys()\n            pipeline_outputs[ref.pipeline_output] = outputs[field_name]\n        for input_ref in ref.connected_inputs:\n            inputs_to_set.setdefault(input_ref.step_id, {})[\n                input_ref.value_name\n            ] = outputs[field_name]\n\n    for step_id, step_inputs in inputs_to_set.items():\n        changed_step_fields = self._set_step_inputs(\n            step_id=step_id, inputs=step_inputs\n        )\n        dpath.merge(result, changed_step_fields)  # type: ignore\n\n    if pipeline_outputs:\n        changed_pipeline_outputs = self._set_pipeline_outputs(**pipeline_outputs)\n        dpath.merge(  # type: ignore\n            result, {\"__pipeline__\": {\"outputs\": changed_pipeline_outputs}}\n        )\n\n    if notify_listeners:\n        event = PipelineEvent.create_event(pipeline=self, changed=result)\n        if event:\n            self._notify_pipeline_listeners(event)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_step","title":"<code>get_step(step_id: str) -&gt; PipelineStep</code>","text":"<p>Return the object representing a step in this workflow, identified by the step id.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_step(self, step_id: str) -&gt; PipelineStep:\n\"\"\"Return the object representing a step in this workflow, identified by the step id.\"\"\"\n    return self._structure.get_step(step_id)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.get_steps_by_stage","title":"<code>get_steps_by_stage() -&gt; Mapping[int, Mapping[str, PipelineStep]]</code>","text":"<p>Return a all pipeline steps, ordered by stage they belong to.</p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def get_steps_by_stage(\n    self,\n) -&gt; Mapping[int, Mapping[str, PipelineStep]]:\n\"\"\"Return a all pipeline steps, ordered by stage they belong to.\"\"\"\n\n    if self._steps_by_stage is not None:\n        return self._steps_by_stage\n\n    result: Dict[int, Dict[str, PipelineStep]] = {}\n    for step_id in self.step_ids:\n        step = self.get_step(step_id)\n        stage = self._structure.get_processing_stage(step.step_id)\n        assert stage is not None\n        result.setdefault(stage, {})[step_id] = step\n\n    self._steps_by_stage = result\n    return self._steps_by_stage\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.create_job_config_for_step","title":"<code>create_job_config_for_step(step_id: str) -&gt; JobConfig</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def create_job_config_for_step(self, step_id: str) -&gt; JobConfig:\n\n    step_inputs: Mapping[str, uuid.UUID] = self.get_current_step_inputs(step_id)\n    step_details: StepDetails = self.get_step_details(step_id=step_id)\n    step: PipelineStep = self.get_step(step_id=step_id)\n\n    # if the inputs are not valid, ignore this step\n    if step_details.status == StepStatus.INPUTS_INVALID:\n        invalid_details = step_details.invalid_details\n        assert invalid_details is not None\n        msg = f\"Can't execute step '{step_id}', invalid inputs: {', '.join(invalid_details.keys())}\"\n        raise InvalidValuesException(msg=msg, invalid_values=invalid_details)\n\n    job_config = JobConfig.create_from_module(\n        data_registry=self._data_registry, module=step.module, inputs=step_inputs\n    )\n\n    return job_config\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.Pipeline.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    return PipelineInfo.create_from_pipeline(\n        kiara=self._kiara, pipeline=self\n    ).create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo","title":"<code>PipelineInfo</code>","text":"<p>         Bases: <code>ItemInfo[Pipeline]</code></p> Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>class PipelineInfo(ItemInfo[Pipeline]):\n\n    _kiara_model_id = \"info.pipeline\"\n\n    @classmethod\n    def base_instance_class(cls) -&gt; Type[Pipeline]:\n        return Pipeline\n\n    @classmethod\n    def create_from_instance(cls, kiara: \"Kiara\", instance: Pipeline, **kwargs):\n\n        return cls.create_from_pipeline(kiara=kiara, pipeline=instance)\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"pipeline\"\n\n    @classmethod\n    def create_from_pipeline(cls, kiara: \"Kiara\", pipeline: Pipeline):\n\n        doc = DocumentationMetadataModel.create(None)\n        authors = AuthorsMetadataModel()\n        context = ContextMetadataModel()\n\n        # stages = PipelineStage.from_pipeline_structure(structure=pipeline.structure)\n\n        pipeline_info = PipelineInfo(\n            type_name=str(pipeline.pipeline_id),\n            documentation=doc,\n            authors=authors,\n            context=context,\n            # pipeline_structure=pipeline.structure,\n            pipeline_config=pipeline.structure.pipeline_config,\n            pipeline_state=pipeline.get_pipeline_details(),\n            # stages=stages\n        )\n        pipeline_info._kiara = kiara\n        return pipeline_info\n\n    # pipeline_structure: PipelineStructure = Field(description=\"The pipeline structure.\")\n    pipeline_config: PipelineConfig = Field(\n        description=\"The configuration of the pipeline.\"\n    )\n    pipeline_state: PipelineState = Field(description=\"The current input details.\")\n    # stages: Mapping[int, PipelineStage] = Field(description=\"Details about this pipelines stages/execution order.\")\n    _kiara: \"Kiara\" = PrivateAttr(default=None)\n    _structure: \"PipelineStructure\" = PrivateAttr(default=None)\n\n    @property\n    def pipeline_structure(self):\n        return self.pipeline_config.structure\n\n    def create_pipeline_table(self, **config: Any) -&gt; Table:\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        self._fill_table(table=table, config=config)\n        return table\n\n    def _fill_table(self, table: Table, config: Mapping[str, Any]):\n\n        include_pipeline_inputs = config.get(\"include_pipeline_inputs\", True)\n        include_pipeline_outputs = config.get(\"include_pipeline_outputs\", True)\n        include_steps = config.get(\"include_steps\", True)\n\n        if include_pipeline_inputs:\n            input_values = self._kiara.data_registry.create_valuemap(\n                data=self.pipeline_state.pipeline_inputs,\n                schema=self.pipeline_structure.pipeline_inputs_schema,\n            )\n\n            ordered_fields: Dict[str, List[str]] = {}\n            for field_name, ref in self.pipeline_structure.pipeline_input_refs.items():\n                for con_input in ref.connected_inputs:\n                    details = self.pipeline_structure.get_step_details(\n                        step_id=con_input.step_id\n                    )\n                    stage = details.processing_stage\n                    ordered_fields.setdefault(stage, []).append(field_name)\n\n            fields = []\n            for stage in sorted(ordered_fields.keys()):\n\n                for f in sorted(ordered_fields[stage]):\n                    if f not in fields:\n                        fields.append(f)\n\n            inputs = create_value_map_status_renderable(\n                input_values,\n                render_config={\n                    \"show_description\": False,\n                    \"show_type\": False,\n                    \"show_default\": True,\n                    \"show_value_ids\": True,\n                },\n                fields=fields,\n            )\n\n            table.add_row(\"pipeline inputs\", inputs)\n        if include_steps:\n            steps = create_pipeline_steps_tree(\n                pipeline_structure=self.pipeline_structure,\n                pipeline_details=self.pipeline_state,\n            )\n            table.add_row(\"steps\", steps)\n\n        if include_pipeline_outputs:\n            output_values = self._kiara.data_registry.load_values(\n                values=self.pipeline_state.pipeline_outputs\n            )\n            ordered_fields = {}\n            for (\n                field_name,\n                o_ref,\n            ) in self.pipeline_structure.pipeline_output_refs.items():\n                con_step_id = o_ref.connected_output.step_id\n                details = self.pipeline_structure.get_step_details(step_id=con_step_id)\n                stage = details.processing_stage\n                ordered_fields.setdefault(stage, []).append(field_name)\n\n            fields = []\n            for stage in sorted(ordered_fields.keys()):\n                for f in sorted(ordered_fields[stage]):\n                    fields.append(f)\n\n            t_outputs = create_value_map_status_renderable(\n                output_values,\n                render_config={\n                    \"show_description\": False,\n                    \"show_type\": True,\n                    \"show_default\": False,\n                    \"show_required\": False,\n                    \"show_value_ids\": True,\n                },\n                fields=fields,\n            )\n\n            table.add_row(\"pipeline outputs\", t_outputs)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_details = config.get(\"include_details\", False)\n        include_doc = config.get(\"include_doc\", False)\n        include_authors = config.get(\"include_authors\", False)\n        include_context = config.get(\"include_context\", False)\n        include_structure = config.get(\"include_structure\", False)\n\n        table = self.create_pipeline_table(**config)\n\n        if include_details:\n            t_details = create_table_from_model_object(\n                self.pipeline_state, render_config=config\n            )\n            table.add_row(\"details\", t_details)\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        if include_authors:\n            table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n        if include_context:\n            table.add_row(\"Context\", self.context.create_renderable(**config))\n\n        if include_structure:\n            table.add_row(\n                \"Pipeline structure\",\n                self.pipeline_structure.create_renderable(**config),\n            )\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.pipeline_config","title":"<code>pipeline_config: PipelineConfig = Field(description='The configuration of the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.pipeline_state","title":"<code>pipeline_state: PipelineState = Field(description='The current input details.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.pipeline_structure","title":"<code>pipeline_structure</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.base_instance_class","title":"<code>base_instance_class() -&gt; Type[Pipeline]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>@classmethod\ndef base_instance_class(cls) -&gt; Type[Pipeline]:\n    return Pipeline\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.create_from_instance","title":"<code>create_from_instance(kiara: Kiara, instance: Pipeline, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>@classmethod\ndef create_from_instance(cls, kiara: \"Kiara\", instance: Pipeline, **kwargs):\n\n    return cls.create_from_pipeline(kiara=kiara, pipeline=instance)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"pipeline\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.create_from_pipeline","title":"<code>create_from_pipeline(kiara: Kiara, pipeline: Pipeline)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>@classmethod\ndef create_from_pipeline(cls, kiara: \"Kiara\", pipeline: Pipeline):\n\n    doc = DocumentationMetadataModel.create(None)\n    authors = AuthorsMetadataModel()\n    context = ContextMetadataModel()\n\n    # stages = PipelineStage.from_pipeline_structure(structure=pipeline.structure)\n\n    pipeline_info = PipelineInfo(\n        type_name=str(pipeline.pipeline_id),\n        documentation=doc,\n        authors=authors,\n        context=context,\n        # pipeline_structure=pipeline.structure,\n        pipeline_config=pipeline.structure.pipeline_config,\n        pipeline_state=pipeline.get_pipeline_details(),\n        # stages=stages\n    )\n    pipeline_info._kiara = kiara\n    return pipeline_info\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.create_pipeline_table","title":"<code>create_pipeline_table(**config: Any) -&gt; Table</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def create_pipeline_table(self, **config: Any) -&gt; Table:\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    self._fill_table(table=table, config=config)\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline.PipelineInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/pipeline.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_details = config.get(\"include_details\", False)\n    include_doc = config.get(\"include_doc\", False)\n    include_authors = config.get(\"include_authors\", False)\n    include_context = config.get(\"include_context\", False)\n    include_structure = config.get(\"include_structure\", False)\n\n    table = self.create_pipeline_table(**config)\n\n    if include_details:\n        t_details = create_table_from_model_object(\n            self.pipeline_state, render_config=config\n        )\n        table.add_row(\"details\", t_details)\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    if include_authors:\n        table.add_row(\"Author(s)\", self.authors.create_renderable(**config))\n    if include_context:\n        table.add_row(\"Context\", self.context.create_renderable(**config))\n\n    if include_structure:\n        table.add_row(\n            \"Pipeline structure\",\n            self.pipeline_structure.create_renderable(**config),\n        )\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/pipeline/#kiara.models.module.pipeline.pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/stages/","title":"stages","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage","title":"<code>PipelineStage</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>class PipelineStage(KiaraModel):\n\n    _kiara_model_id = \"info.pipeline_stage\"\n\n    @classmethod\n    def extract_stages(\n        cls, structure: \"PipelineStructure\", stages_extraction_type: str = \"late\"\n    ) -&gt; List[List[str]]:\n\n        func_name = f\"extract_stages__{stages_extraction_type}\"\n        if not hasattr(cls, func_name):\n            msg = f\"Invalid stages extraction type: {stages_extraction_type}.\"\n            available = [x for x in dir(cls) if x.startswith(\"extract_stages__\")]\n            details = \"Available stages extraction types:\\n\"\n            for avail in available:\n                details += f\" - {avail.replace('extract_stages__', '')}\\n\"\n            raise KiaraException(msg, details=details)\n\n        result = getattr(cls, func_name)(structure=structure)\n        return result\n\n    @classmethod\n    def extract_stages__single_stage(\n        cls, structure: \"PipelineStructure\"\n    ) -&gt; List[List[str]]:\n\"\"\"Extract a single stage from the pipeline structure..\"\"\"\n\n        return [[step.step_id for step in structure.steps]]\n\n    @classmethod\n    def extract_stages__stage_per_step(\n        cls, structure: \"PipelineStructure\"\n    ) -&gt; List[List[str]]:\n\"\"\"Extract a stage for each step in the pipeline structure.\"\"\"\n\n        flat_list = [\n            [item] for sublist in structure.processing_stages for item in sublist\n        ]\n        return flat_list\n\n    @classmethod\n    def extract_stages__late(cls, structure: \"PipelineStructure\") -&gt; List[List[str]]:\n\"\"\"Extract stages in a way so that steps are processed as late as possible.\"\"\"\n\n        execution_graph = structure.execution_graph\n        leaf_nodes = [\n            node\n            for node in execution_graph.nodes()\n            if execution_graph.in_degree(node) != 0\n            and execution_graph.out_degree(node) == 0\n        ]\n\n        layers = {}\n        for leaf_node in leaf_nodes:\n            node_layers = nx.bfs_layers(execution_graph.reverse(), leaf_node)\n            layers[leaf_node] = list(node_layers)\n\n        stages: Dict[int, List[str]] = {}\n        for step in structure.steps:\n            step_id = step.step_id\n            max_idx = 0\n            for node_layers in layers.values():\n                for idx, node_layer in enumerate(node_layers):\n                    if step_id in node_layer:\n                        if idx &gt; max_idx:\n                            max_idx = idx\n                        break\n            stages.setdefault(max_idx, []).append(step_id)\n\n        processing_stages = []\n        for stage_idx in sorted(stages.keys(), reverse=True):\n            stage = stages[stage_idx]\n            processing_stages.append(stage)\n\n        return processing_stages\n\n    @classmethod\n    def extract_stages__early(cls, structure: \"PipelineStructure\") -&gt; List[List[str]]:\n\"\"\"Extract stages in a way so that steps are processed as early as possible.\"\"\"\n\n        execution_graph = structure.execution_graph\n        processing_stages = []\n        path_lengths: Dict[str, int] = {}\n        for step in structure.steps:\n\n            step_id = step.step_id\n\n            paths = list(nx.all_simple_paths(execution_graph, \"__root__\", step_id))\n            max_steps = max(paths, key=lambda x: len(x))\n            path_lengths[step_id] = len(max_steps) - 1\n\n        if path_lengths.values():\n            max_length = max(path_lengths.values())\n\n            for i in range(1, max_length + 1):\n                stage: List[str] = [\n                    m for m, length in path_lengths.items() if length == i\n                ]\n                processing_stages.append(stage)\n                # for _step_id in stage:\n                #     steps_details[_step_id][\"processing_stage\"] = i\n\n        return processing_stages\n\n    @classmethod\n    def stages_info_from_pipeline_structure(\n        cls,\n        structure: \"PipelineStructure\",\n        stages: Union[List[List[str]], str] = \"late\",\n    ) -&gt; List[\"PipelineStage\"]:\n\n        if isinstance(stages, str):\n            if stages == \"late\":\n                stages = cls.extract_stages__late(structure=structure)\n            elif stages == \"early\":\n                stages = cls.extract_stages__early(structure=structure)\n            else:\n                raise Exception(\n                    \"Invalid value for 'stages': {stages!r} (must be 'late' or 'early'.\"\n                )\n\n        used_pipeline_inputs: Set[str] = set()\n        used_pipeline_outputs: Set[str] = set()\n        result = []\n        for idx, stage in enumerate(stages, start=1):\n            stage_steps = []\n            pipeline_inputs = []\n            pipeline_outputs = []\n            connected_outputs = []\n            stage_outputs = []\n\n            for step_id in stage:\n                step = structure.get_step(step_id=step_id)\n                stage_steps.append(step.step_id)\n\n                for pipeline_output, out_ref in structure.pipeline_output_refs.items():\n                    if pipeline_output in used_pipeline_outputs:\n                        continue\n                    if out_ref.connected_output.step_id == step_id:\n                        pipeline_outputs.append(pipeline_output)\n\n                for field_name, input_ref in structure.get_step_input_refs(\n                    step_id=step_id\n                ).items():\n                    if input_ref.connected_pipeline_input:\n                        pipeline_inputs.append(input_ref.connected_pipeline_input)\n                    elif input_ref.connected_outputs:\n                        for con_out in input_ref.connected_outputs:\n                            connected_outputs.append(con_out.alias)\n\n                for field_name, output_ref in structure.get_step_output_refs(\n                    step_id=step_id\n                ).items():\n                    if output_ref.pipeline_output:\n                        pipeline_outputs.append(output_ref.pipeline_output)\n                    if output_ref.connected_inputs:\n                        stage_outputs.append(output_ref.alias)\n\n            stage_used_pipeline_inputs = list(used_pipeline_inputs)\n            stage_used_pipeline_outputs = list(used_pipeline_outputs)\n\n            result.append(\n                PipelineStage(\n                    stage_index=idx,\n                    steps=stage_steps,\n                    connected_outputs=connected_outputs,\n                    stage_outputs=stage_outputs,\n                    pipeline_inputs=pipeline_inputs,\n                    pipeline_outputs=pipeline_outputs,\n                    previous_pipeline_inputs=stage_used_pipeline_inputs,\n                    previous_pipeline_outputs=stage_used_pipeline_outputs,\n                )\n            )\n\n            used_pipeline_inputs.update(pipeline_inputs)\n            used_pipeline_outputs.update(pipeline_outputs)\n\n        return result\n\n    stage_index: int = Field(description=\"The index of this stage.\")\n    steps: List[str] = Field(\n        description=\"The pipeline steps that are executed in this stage.\"\n    )\n    connected_outputs: List[str] = Field(\n        description=\"Previous step outputs that are connected to this stage.\"\n    )\n    stage_outputs: List[str] = Field(description=\"The outputs of this stage.\")\n    pipeline_inputs: List[str] = Field(\n        description=\"The pipeline inputs required for this stage.\"\n    )\n    pipeline_outputs: List[str] = Field(\n        description=\"The pipeline outputs that are ready once this stage is processed.\"\n    )\n    previous_pipeline_inputs: List[str] = Field(\n        description=\"Pipeline inputs that are already set by this stage.\"\n    )\n    previous_pipeline_outputs: List[str] = Field(\n        description=\"Pipeline outputs that are already computed by this stage.\"\n    )\n\n    _graph: Union[None, nx.DiGraph] = PrivateAttr(default=None)\n\n    def get_graph_fragment(self) -&gt; nx.DiGraph:\n        if self._graph is not None:\n            return self._graph\n\n        fragment = nx.DiGraph()\n        stage_id = f\"Stage: {self.stage_index}\"\n        fragment.add_node(stage_id, type=\"stage\", stage_index=self.stage_index)\n\n        for pi in self.pipeline_inputs:\n            node_id = f\"Input: {pi}\"\n            fragment.add_node(node_id, type=\"pipeline_input\")\n            fragment.add_edge(node_id, stage_id, type=\"pipeline_input\")\n        for co in self.connected_outputs:\n            fragment.add_node(co, type=\"connected_output\")\n            fragment.add_edge(co, stage_id, type=\"connected_output\")\n        for so in self.stage_outputs:\n            fragment.add_node(so, type=\"stage_output\")\n            fragment.add_edge(stage_id, so, type=\"stage_output\")\n        for po in self.pipeline_outputs:\n            node_id = f\"Output: {po}\"\n            fragment.add_node(node_id, type=\"pipeline_output\")\n            fragment.add_edge(stage_id, node_id, type=\"pipeline_output\")\n\n        self._graph = fragment\n        return self._graph\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.stage_index","title":"<code>stage_index: int = Field(description='The index of this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.steps","title":"<code>steps: List[str] = Field(description='The pipeline steps that are executed in this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.connected_outputs","title":"<code>connected_outputs: List[str] = Field(description='Previous step outputs that are connected to this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.stage_outputs","title":"<code>stage_outputs: List[str] = Field(description='The outputs of this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.pipeline_inputs","title":"<code>pipeline_inputs: List[str] = Field(description='The pipeline inputs required for this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.pipeline_outputs","title":"<code>pipeline_outputs: List[str] = Field(description='The pipeline outputs that are ready once this stage is processed.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.previous_pipeline_inputs","title":"<code>previous_pipeline_inputs: List[str] = Field(description='Pipeline inputs that are already set by this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.previous_pipeline_outputs","title":"<code>previous_pipeline_outputs: List[str] = Field(description='Pipeline outputs that are already computed by this stage.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.extract_stages","title":"<code>extract_stages(structure: PipelineStructure, stages_extraction_type: str = 'late') -&gt; List[List[str]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef extract_stages(\n    cls, structure: \"PipelineStructure\", stages_extraction_type: str = \"late\"\n) -&gt; List[List[str]]:\n\n    func_name = f\"extract_stages__{stages_extraction_type}\"\n    if not hasattr(cls, func_name):\n        msg = f\"Invalid stages extraction type: {stages_extraction_type}.\"\n        available = [x for x in dir(cls) if x.startswith(\"extract_stages__\")]\n        details = \"Available stages extraction types:\\n\"\n        for avail in available:\n            details += f\" - {avail.replace('extract_stages__', '')}\\n\"\n        raise KiaraException(msg, details=details)\n\n    result = getattr(cls, func_name)(structure=structure)\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.extract_stages__single_stage","title":"<code>extract_stages__single_stage(structure: PipelineStructure) -&gt; List[List[str]]</code>  <code>classmethod</code>","text":"<p>Extract a single stage from the pipeline structure..</p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef extract_stages__single_stage(\n    cls, structure: \"PipelineStructure\"\n) -&gt; List[List[str]]:\n\"\"\"Extract a single stage from the pipeline structure..\"\"\"\n\n    return [[step.step_id for step in structure.steps]]\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.extract_stages__stage_per_step","title":"<code>extract_stages__stage_per_step(structure: PipelineStructure) -&gt; List[List[str]]</code>  <code>classmethod</code>","text":"<p>Extract a stage for each step in the pipeline structure.</p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef extract_stages__stage_per_step(\n    cls, structure: \"PipelineStructure\"\n) -&gt; List[List[str]]:\n\"\"\"Extract a stage for each step in the pipeline structure.\"\"\"\n\n    flat_list = [\n        [item] for sublist in structure.processing_stages for item in sublist\n    ]\n    return flat_list\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.extract_stages__late","title":"<code>extract_stages__late(structure: PipelineStructure) -&gt; List[List[str]]</code>  <code>classmethod</code>","text":"<p>Extract stages in a way so that steps are processed as late as possible.</p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef extract_stages__late(cls, structure: \"PipelineStructure\") -&gt; List[List[str]]:\n\"\"\"Extract stages in a way so that steps are processed as late as possible.\"\"\"\n\n    execution_graph = structure.execution_graph\n    leaf_nodes = [\n        node\n        for node in execution_graph.nodes()\n        if execution_graph.in_degree(node) != 0\n        and execution_graph.out_degree(node) == 0\n    ]\n\n    layers = {}\n    for leaf_node in leaf_nodes:\n        node_layers = nx.bfs_layers(execution_graph.reverse(), leaf_node)\n        layers[leaf_node] = list(node_layers)\n\n    stages: Dict[int, List[str]] = {}\n    for step in structure.steps:\n        step_id = step.step_id\n        max_idx = 0\n        for node_layers in layers.values():\n            for idx, node_layer in enumerate(node_layers):\n                if step_id in node_layer:\n                    if idx &gt; max_idx:\n                        max_idx = idx\n                    break\n        stages.setdefault(max_idx, []).append(step_id)\n\n    processing_stages = []\n    for stage_idx in sorted(stages.keys(), reverse=True):\n        stage = stages[stage_idx]\n        processing_stages.append(stage)\n\n    return processing_stages\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.extract_stages__early","title":"<code>extract_stages__early(structure: PipelineStructure) -&gt; List[List[str]]</code>  <code>classmethod</code>","text":"<p>Extract stages in a way so that steps are processed as early as possible.</p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef extract_stages__early(cls, structure: \"PipelineStructure\") -&gt; List[List[str]]:\n\"\"\"Extract stages in a way so that steps are processed as early as possible.\"\"\"\n\n    execution_graph = structure.execution_graph\n    processing_stages = []\n    path_lengths: Dict[str, int] = {}\n    for step in structure.steps:\n\n        step_id = step.step_id\n\n        paths = list(nx.all_simple_paths(execution_graph, \"__root__\", step_id))\n        max_steps = max(paths, key=lambda x: len(x))\n        path_lengths[step_id] = len(max_steps) - 1\n\n    if path_lengths.values():\n        max_length = max(path_lengths.values())\n\n        for i in range(1, max_length + 1):\n            stage: List[str] = [\n                m for m, length in path_lengths.items() if length == i\n            ]\n            processing_stages.append(stage)\n            # for _step_id in stage:\n            #     steps_details[_step_id][\"processing_stage\"] = i\n\n    return processing_stages\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.stages_info_from_pipeline_structure","title":"<code>stages_info_from_pipeline_structure(structure: PipelineStructure, stages: Union[List[List[str]], str] = 'late') -&gt; List[PipelineStage]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef stages_info_from_pipeline_structure(\n    cls,\n    structure: \"PipelineStructure\",\n    stages: Union[List[List[str]], str] = \"late\",\n) -&gt; List[\"PipelineStage\"]:\n\n    if isinstance(stages, str):\n        if stages == \"late\":\n            stages = cls.extract_stages__late(structure=structure)\n        elif stages == \"early\":\n            stages = cls.extract_stages__early(structure=structure)\n        else:\n            raise Exception(\n                \"Invalid value for 'stages': {stages!r} (must be 'late' or 'early'.\"\n            )\n\n    used_pipeline_inputs: Set[str] = set()\n    used_pipeline_outputs: Set[str] = set()\n    result = []\n    for idx, stage in enumerate(stages, start=1):\n        stage_steps = []\n        pipeline_inputs = []\n        pipeline_outputs = []\n        connected_outputs = []\n        stage_outputs = []\n\n        for step_id in stage:\n            step = structure.get_step(step_id=step_id)\n            stage_steps.append(step.step_id)\n\n            for pipeline_output, out_ref in structure.pipeline_output_refs.items():\n                if pipeline_output in used_pipeline_outputs:\n                    continue\n                if out_ref.connected_output.step_id == step_id:\n                    pipeline_outputs.append(pipeline_output)\n\n            for field_name, input_ref in structure.get_step_input_refs(\n                step_id=step_id\n            ).items():\n                if input_ref.connected_pipeline_input:\n                    pipeline_inputs.append(input_ref.connected_pipeline_input)\n                elif input_ref.connected_outputs:\n                    for con_out in input_ref.connected_outputs:\n                        connected_outputs.append(con_out.alias)\n\n            for field_name, output_ref in structure.get_step_output_refs(\n                step_id=step_id\n            ).items():\n                if output_ref.pipeline_output:\n                    pipeline_outputs.append(output_ref.pipeline_output)\n                if output_ref.connected_inputs:\n                    stage_outputs.append(output_ref.alias)\n\n        stage_used_pipeline_inputs = list(used_pipeline_inputs)\n        stage_used_pipeline_outputs = list(used_pipeline_outputs)\n\n        result.append(\n            PipelineStage(\n                stage_index=idx,\n                steps=stage_steps,\n                connected_outputs=connected_outputs,\n                stage_outputs=stage_outputs,\n                pipeline_inputs=pipeline_inputs,\n                pipeline_outputs=pipeline_outputs,\n                previous_pipeline_inputs=stage_used_pipeline_inputs,\n                previous_pipeline_outputs=stage_used_pipeline_outputs,\n            )\n        )\n\n        used_pipeline_inputs.update(pipeline_inputs)\n        used_pipeline_outputs.update(pipeline_outputs)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStage.get_graph_fragment","title":"<code>get_graph_fragment() -&gt; nx.DiGraph</code>","text":"Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>def get_graph_fragment(self) -&gt; nx.DiGraph:\n    if self._graph is not None:\n        return self._graph\n\n    fragment = nx.DiGraph()\n    stage_id = f\"Stage: {self.stage_index}\"\n    fragment.add_node(stage_id, type=\"stage\", stage_index=self.stage_index)\n\n    for pi in self.pipeline_inputs:\n        node_id = f\"Input: {pi}\"\n        fragment.add_node(node_id, type=\"pipeline_input\")\n        fragment.add_edge(node_id, stage_id, type=\"pipeline_input\")\n    for co in self.connected_outputs:\n        fragment.add_node(co, type=\"connected_output\")\n        fragment.add_edge(co, stage_id, type=\"connected_output\")\n    for so in self.stage_outputs:\n        fragment.add_node(so, type=\"stage_output\")\n        fragment.add_edge(stage_id, so, type=\"stage_output\")\n    for po in self.pipeline_outputs:\n        node_id = f\"Output: {po}\"\n        fragment.add_node(node_id, type=\"pipeline_output\")\n        fragment.add_edge(stage_id, node_id, type=\"pipeline_output\")\n\n    self._graph = fragment\n    return self._graph\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages","title":"<code>PipelineStages</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>class PipelineStages(KiaraModel):\n    @classmethod\n    def create(\n        cls, structure: \"PipelineStructure\", stages_extraction_type: str = \"late\"\n    ) -&gt; \"PipelineStages\":\n\n        stages_info = structure.extract_processing_stages_info(\n            stages_extraction_type=stages_extraction_type\n        )\n\n        result = cls(stages=stages_info)\n        result._structure = structure\n        return result\n\n    stages: List[PipelineStage] = Field(description=\"The pipeline stages.\")\n    _structure: Union[None, \"PipelineStructure\"] = PrivateAttr(default=None)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"Stage\")\n        table.add_column(\"Details\")\n\n        for stage in self.stages:\n            row = [f\"Stage {stage.stage_index}\", stage.create_renderable(**config)]\n            table.add_row(*row)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages.stages","title":"<code>stages: List[PipelineStage] = Field(description='The pipeline stages.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages.create","title":"<code>create(structure: PipelineStructure, stages_extraction_type: str = 'late') -&gt; PipelineStages</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>@classmethod\ndef create(\n    cls, structure: \"PipelineStructure\", stages_extraction_type: str = \"late\"\n) -&gt; \"PipelineStages\":\n\n    stages_info = structure.extract_processing_stages_info(\n        stages_extraction_type=stages_extraction_type\n    )\n\n    result = cls(stages=stages_info)\n    result._structure = structure\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/stages/#kiara.models.module.pipeline.stages.PipelineStages.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/stages.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=True, box=box.SIMPLE)\n    table.add_column(\"Stage\")\n    table.add_column(\"Details\")\n\n    for stage in self.stages:\n        row = [f\"Stage {stage.stage_index}\", stage.create_renderable(**config)]\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/","title":"structure","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo","title":"<code>StepInfo</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>class StepInfo(KiaraModel):\n\n    _kiara_model_id = \"info.pipeline_step\"\n\n    step: PipelineStep = Field(description=\"The pipeline step object.\")\n    inputs: Dict[str, StepInputRef] = Field(\n        description=\"Reference(s) to the fields that feed this steps inputs.\"\n    )\n    outputs: Dict[str, StepOutputRef] = Field(\n        description=\"Reference(s) to the fields that are fed by this steps outputs.\"\n    )\n    required: bool = Field(\n        description=\"Whether this step is always required or whether all his outputs feed into optional input fields.\"\n    )\n    # processing_stage: int = Field(\n    #     description=\"The index of the processing stage of this step.\"\n    # )\n    _processing_stage: Union[None, int] = PrivateAttr(default=None)\n    _structure: Union[None, \"PipelineStructure\"] = PrivateAttr(default=None)\n\n    @property\n    def step_id(self) -&gt; str:\n        return self.step.step_id\n\n    @property\n    def processing_stage(self) -&gt; int:\n\n        if self._processing_stage is not None:\n            return self._processing_stage\n\n        if not self._structure:\n            raise Exception(\n                f\"Can't look up processing stage for step '{self.step_id}': no structure assigned for those step details, set for this step info.\"\n            )\n\n        for idx, stage in enumerate(self._structure.processing_stages, start=1):\n            if self.step_id in stage:\n                self._processing_stage = idx\n                return idx\n\n        raise Exception(\n            f\"Can't look up processing stage for step '{self.step_id}': pipeline structure does not contain step.\"\n        )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n        return self.step.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.step","title":"<code>step: PipelineStep = Field(description='The pipeline step object.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.inputs","title":"<code>inputs: Dict[str, StepInputRef] = Field(description='Reference(s) to the fields that feed this steps inputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.outputs","title":"<code>outputs: Dict[str, StepOutputRef] = Field(description='Reference(s) to the fields that are fed by this steps outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.required","title":"<code>required: bool = Field(description='Whether this step is always required or whether all his outputs feed into optional input fields.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.step_id","title":"<code>step_id: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.processing_stage","title":"<code>processing_stage: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.StepInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n    return self.step.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure","title":"<code>PipelineStructure</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>An object that holds one or several steps, and describes the connections between them.</p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>class PipelineStructure(KiaraModel):\n\"\"\"An object that holds one or several steps, and describes the connections between them.\"\"\"\n\n    _kiara_model_id = \"instance.pipeline_structure\"\n\n    pipeline_config: PipelineConfig = Field(\n        description=\"The underlying pipeline config.\"\n    )\n    steps: List[PipelineStep] = Field(description=\"The pipeline steps \")\n    # stages: Mapping[int, PipelineStage] = Field(description=\"Details about each of the pipeline stages.\")\n    input_aliases: Dict[str, str] = Field(description=\"The input aliases.\")\n    output_aliases: Dict[str, str] = Field(description=\"The output aliases.\")\n\n    @root_validator(pre=True)\n    def validate_pipeline_config(cls, values) -&gt; Dict[str, Any]:\n\n        pipeline_config = values.get(\"pipeline_config\", None)\n        if not pipeline_config:\n            raise ValueError(\"No 'pipeline_config' provided.\")\n\n        if len(values) != 1:\n            raise ValueError(\n                \"Only 'pipeline_config' key allowed when creating a pipeline structure object.\"\n            )\n\n        if isinstance(pipeline_config, Mapping):\n            pipeline_config = PipelineConfig(**pipeline_config)\n        _config: PipelineConfig = pipeline_config\n        _steps: List[PipelineStep] = list(_config.steps)\n\n        _input_aliases: Dict[str, str] = dict(_config.input_aliases)\n        _output_aliases: Dict[str, str] = dict(_config.output_aliases)\n\n        invalid_input_aliases = [a for a in _input_aliases.values() if \".\" in a]\n        if invalid_input_aliases:\n            raise InvalidPipelineConfig(\n                f\"Invalid input aliases, aliases can't contain special characters: {', '.join(invalid_input_aliases)}.\",\n                config=values.get(\"pipeline_config\", None),\n                details=f\"Invalid characters: {', '.join(invalid_input_aliases)}.\",\n            )\n        invalid_output_aliases = [a for a in _input_aliases.values() if \".\" in a]\n        if invalid_input_aliases:\n            raise InvalidPipelineConfig(\n                f\"Invalid input aliases, aliases can't contain special characters: {', '.join(invalid_output_aliases)}.\",\n                config=values.get(\"pipeline_config\"),\n                details=f\"Invalid characters: {', '.join(invalid_output_aliases)}.\",\n            )\n\n        valid_input_names = set()\n        for step in _steps:\n            for input_name in step.module.input_names:\n                valid_input_names.add(f\"{step.step_id}.{input_name}\")\n        invalid_input_aliases = [\n            a for a in _input_aliases.keys() if a not in valid_input_names\n        ]\n        if invalid_input_aliases:\n            msg = \"Invalid input reference(s).\"\n            details = \"Invalid reference(s):\\n\"\n            for iia in invalid_input_aliases:\n                details += f\" - {iia}\\n\"\n            details += \"\\nMust be one of: \\n\"\n            for name in valid_input_names:\n                details += f\"  - {name}\\n\"\n\n            raise InvalidPipelineConfig(\n                msg, config=values.get(\"pipeline_config\", {}), details=details\n            )\n\n        valid_output_names = set()\n        for step in _steps:\n            for output_name in step.module.output_names:\n                valid_output_names.add(f\"{step.step_id}.{output_name}\")\n        invalid_output_names = [\n            a for a in _output_aliases.keys() if a not in valid_output_names\n        ]\n        if invalid_output_names:\n\n            msg = \"Invalid output reference(s).\"\n            details = \"Invalid reference(s):\\n\"\n            for iia in invalid_output_names:\n                details += f\" - {iia}\\n\"\n            details += \"\\nMust be one of: \\n\"\n            for name in valid_output_names:\n                details += f\"  - {name}\\n\"\n\n            raise InvalidPipelineConfig(msg, values.get(\"pipeline_config\", {}), details)\n\n        # stages = PipelineStage.from_pipeline_structure(stages=)\n\n        # values[\"steps\"] = {step.step_id: step for step in _steps}\n        values[\"steps\"] = _steps\n        values[\"input_aliases\"] = _input_aliases\n        values[\"output_aliases\"] = _output_aliases\n        return values\n\n    # this is hardcoded for now\n    _add_all_workflow_outputs: bool = PrivateAttr(default=False)\n    _constants: Dict[str, Any] = PrivateAttr(default=None)  # type: ignore\n    _defaults: Dict[str, Any] = PrivateAttr(None)  # type: ignore\n\n    _execution_graph: nx.DiGraph = PrivateAttr(None)  # type: ignore\n    _data_flow_graph: nx.DiGraph = PrivateAttr(None)  # type: ignore\n    _data_flow_graph_simple: nx.DiGraph = PrivateAttr(None)  # type: ignore\n\n    _processing_stages: List[List[str]] = PrivateAttr(None)  # type: ignore\n    # _stages_info: Mapping[int, PipelineStage] = PrivateAttr(None)  # type: ignore\n\n    # holds details about the (current) processing steps contained in this workflow\n    _steps_details: Dict[str, StepInfo] = PrivateAttr(None)  # type: ignore\n    # _info: \"PipelineStructureInfo\" = PrivateAttr(None)  # type: ignore\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            \"steps\": [step.instance_cid for step in self.steps],\n            \"input_aliases\": self.input_aliases,\n            \"output_aliases\": self.output_aliases,\n        }\n\n    def _retrieve_id(self) -&gt; str:\n        return self.pipeline_config.instance_id\n\n    @property\n    def steps_details(self) -&gt; Mapping[str, StepInfo]:\n\n        if self._steps_details is None:\n            self._process_steps()\n        return self._steps_details  # type: ignore\n\n    @property\n    def step_ids(self) -&gt; Iterable[str]:\n        if self._steps_details is None:\n            self._process_steps()\n        return self._steps_details.keys()  # type: ignore\n\n    @property\n    def constants(self) -&gt; Mapping[str, Any]:\n\n        if self._constants is None:\n            self._process_steps()\n        return self._constants  # type: ignore\n\n    @property\n    def defaults(self) -&gt; Mapping[str, Any]:\n\n        if self._defaults is None:\n            self._process_steps()\n        return self._defaults  # type: ignore\n\n    def get_step(self, step_id: str) -&gt; PipelineStep:\n\n        d = self.steps_details.get(step_id, None)\n        if d is None:\n            raise Exception(f\"No step with id: {step_id}\")\n\n        return d.step\n\n    def get_step_input_refs(self, step_id: str) -&gt; Mapping[str, StepInputRef]:\n\n        d = self.steps_details.get(step_id, None)\n        if d is None:\n            raise Exception(f\"No step with id: {step_id}\")\n\n        return d.inputs\n\n    def get_step_output_refs(self, step_id: str) -&gt; Mapping[str, StepOutputRef]:\n\n        d = self.steps_details.get(step_id, None)\n        if d is None:\n            raise Exception(f\"No step with id: {step_id}\")\n\n        return d.outputs\n\n    def get_step_details(self, step_id: str) -&gt; StepInfo:\n\n        d = self.steps_details.get(step_id, None)\n        if d is None:\n            raise Exception(f\"No step with id: {step_id}\")\n\n        return d\n\n    @property\n    def execution_graph(self) -&gt; nx.DiGraph:\n        if self._execution_graph is None:\n            self._process_steps()\n        return self._execution_graph\n\n    @property\n    def data_flow_graph(self) -&gt; nx.DiGraph:\n        if self._data_flow_graph is None:\n            self._process_steps()\n        return self._data_flow_graph\n\n    @property\n    def data_flow_graph_simple(self) -&gt; nx.DiGraph:\n        if self._data_flow_graph_simple is None:\n            self._process_steps()\n        return self._data_flow_graph_simple\n\n    @property\n    def processing_stages(self) -&gt; List[List[str]]:\n        if self._processing_stages is not None:\n            return self._processing_stages\n\n        # calculate execution order\n        # process_late = self.pipeline_config.pipeline_name == \"topic_modeling\"\n        processing_stages = []\n\n        processing_stages = PipelineStage.extract_stages(self)\n        self._processing_stages = processing_stages\n        return self._processing_stages\n\n    def extract_processing_stages(\n        self, stages_extraction_type: str = \"late\"\n    ) -&gt; List[List[str]]:\n\"\"\"Extract a list of lists of steps, representing the order of groups in which they will be executed.\n\n        It is possible to extract the stages in different ways, depending on the use-case you have in mind. For most cases,\n        'late' will be appropriate. Currently available:\n        - 'late': process steps as late in the process as possible\n        - 'early': process steps as early in the process as possible\n        \"\"\"\n\n        return PipelineStage.extract_stages(\n            self, stages_extraction_type=stages_extraction_type\n        )\n\n    def extract_processing_stages_info(\n        self, stages_extraction_type: str = \"late\"\n    ) -&gt; List[PipelineStage]:\n\n        stages = self.extract_processing_stages(\n            stages_extraction_type=stages_extraction_type\n        )\n        return PipelineStage.stages_info_from_pipeline_structure(self, stages)\n\n    def get_stages_graph(\n        self, stages_extraction_type: str = \"late\", flatten: bool = True\n    ) -&gt; nx.DiGraph:\n\"\"\"Creates a networx graph that represents the processing stages of the pipeline and how they are connecte.\n\n        Arguments:\n            stages_extraction_type: how to extract the stages\n            flatten: if True, the nodes representing connections between stages will be removed, leaving only the edge\n\n        Returns:\n            a networkx graph object\n        \"\"\"\n\n        stages = self.extract_processing_stages_info(\n            stages_extraction_type=stages_extraction_type\n        )\n\n        graph = nx.DiGraph()\n        for stage in stages:\n            fragment = stage.get_graph_fragment()\n            graph = nx.compose(graph, fragment)\n\n        if flatten:\n            to_flatten = []\n            for node_id in graph.nodes:\n                if graph.nodes[node_id][\"type\"] in [\"stage_output\", \"connected_output\"]:\n                    to_flatten.append(node_id)\n\n            for f in to_flatten:\n\n                in_edges = tuple(graph.in_edges(f))[0]\n                out_edges = tuple(graph.out_edges(f))[0]\n                assert in_edges[1] == out_edges[0]\n                graph.remove_edge(in_edges[0], in_edges[1])\n                graph.remove_edge(out_edges[0], out_edges[1])\n                graph.remove_node(f)\n                graph.add_edge(\n                    in_edges[0],\n                    out_edges[1],\n                    type=\"stage_connection\",\n                    output_name=in_edges[1],\n                )\n\n        return graph\n\n    @lru_cache()\n    def _get_node_of_type(self, node_type: str):\n        if self._steps_details is None:\n            self._process_steps()\n\n        return [\n            node\n            for node, attr in self._data_flow_graph.nodes(data=True)\n            if attr[\"type\"] == node_type\n        ]\n\n    @property\n    def steps_input_refs(self) -&gt; Dict[str, StepInputRef]:\n        return {\n            node.alias: node\n            for node in self._get_node_of_type(node_type=StepInputRef.__name__)\n        }\n\n    @property\n    def steps_output_refs(self) -&gt; Dict[str, StepOutputRef]:\n        return {\n            node.alias: node\n            for node in self._get_node_of_type(node_type=StepOutputRef.__name__)\n        }\n\n    @property\n    def pipeline_input_refs(self) -&gt; Dict[str, PipelineInputRef]:\n        return {\n            node.value_name: node\n            for node in self._get_node_of_type(node_type=PipelineInputRef.__name__)\n        }\n\n    @property\n    def pipeline_output_refs(self) -&gt; Dict[str, PipelineOutputRef]:\n        return {\n            node.value_name: node\n            for node in self._get_node_of_type(node_type=PipelineOutputRef.__name__)\n        }\n\n    @property\n    def pipeline_inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\n        schemas = {\n            input_name: w_in.value_schema\n            for input_name, w_in in self.pipeline_input_refs.items()\n        }\n        return schemas\n\n    @property\n    def pipeline_outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n        return {\n            output_name: w_out.value_schema\n            for output_name, w_out in self.pipeline_output_refs.items()\n        }\n\n    def get_pipeline_inputs_schema_for_step(\n        self, step_id: str\n    ) -&gt; Mapping[str, ValueSchema]:\n\n        result = {}\n        for field, ref in self.pipeline_input_refs.items():\n            for con in ref.connected_inputs:\n                if con.step_id == step_id:\n                    result[field] = ref.value_schema\n                    break\n        return result\n\n    def get_pipeline_outputs_schema_for_step(\n        self, step_id: str\n    ) -&gt; Mapping[str, ValueSchema]:\n\n        result = {}\n        for field, ref in self.pipeline_output_refs.items():\n            if ref.connected_output.step_id == step_id:\n                result[field] = ref.value_schema\n\n        return result\n\n    def get_processing_stage(self, step_id: str) -&gt; int:\n\"\"\"Return the processing stage for the specified step_id.\n\n        Returns the stage nr (starting with '1').\n        \"\"\"\n\n        for index, stage in enumerate(self.processing_stages, start=1):\n            if step_id in stage:\n                return index\n\n        raise Exception(f\"Invalid step id '{step_id}'.\")\n\n    def step_is_required(self, step_id: str) -&gt; bool:\n\"\"\"Check if the specified step is required, or can be omitted.\"\"\"\n\n        return self.get_step_details(step_id=step_id).required\n\n    def _process_steps(self) -&gt; None:\n\"\"\"The core method of this class, it connects all the processing modules, their inputs and outputs.\"\"\"\n\n        steps_details: Dict[str, Any] = {}\n        execution_graph = nx.DiGraph()\n        execution_graph.add_node(\"__root__\")\n        data_flow_graph = nx.DiGraph()\n        data_flow_graph_simple = nx.DiGraph()\n        constants = {}\n        structure_defaults = {}\n\n        # temp variable, to hold all outputs\n        outputs: Dict[str, StepOutputRef] = {}\n\n        # process all pipeline and step outputs first\n        _temp_steps_map: Dict[str, PipelineStep] = {}\n        pipeline_outputs: Dict[str, PipelineOutputRef] = {}\n        for step in self.steps:\n\n            _temp_steps_map[step.step_id] = step\n\n            if step.step_id in steps_details.keys():\n                raise Exception(\n                    f\"Can't process steps: duplicate step_id '{step.step_id}'\"\n                )\n\n            steps_details[step.step_id] = {\n                \"step\": step,\n                \"outputs\": {},\n                \"inputs\": {},\n                \"required\": True,\n            }\n\n            data_flow_graph.add_node(step, type=\"step\")\n            data_flow_graph_simple.add_node(step, type=\"step\")\n\n            # go through all the module outputs, create points for them and connect them to pipeline outputs\n            for output_name, schema in step.module.outputs_schema.items():\n\n                step_output = StepOutputRef(\n                    value_name=output_name,\n                    value_schema=schema,\n                    step_id=step.step_id,\n                    pipeline_output=None,\n                )\n\n                steps_details[step.step_id][\"outputs\"][output_name] = step_output\n                step_alias = generate_step_alias(step.step_id, output_name)\n                outputs[step_alias] = step_output\n\n                # step_output_name = generate_pipeline_endpoint_name(\n                #     step_id=step.step_id, value_name=output_name\n                # )\n                step_output_name: Union[None, str] = f\"{step.step_id}.{output_name}\"\n                if not self.output_aliases:\n                    raise NotImplementedError()\n                if step_output_name in self.output_aliases.keys():\n                    step_output_name = self.output_aliases[step_output_name]  # type: ignore\n                else:\n                    if not self._add_all_workflow_outputs:\n                        # this output is not interesting for the workflow\n                        step_output_name = None\n\n                if step_output_name:\n                    step_output_address = StepValueAddress(\n                        step_id=step.step_id, value_name=output_name\n                    )\n                    pipeline_output = PipelineOutputRef(\n                        value_name=step_output_name,\n                        connected_output=step_output_address,\n                        value_schema=schema,\n                    )\n                    pipeline_outputs[step_output_name] = pipeline_output\n                    step_output.pipeline_output = pipeline_output.value_name\n\n                    data_flow_graph.add_node(\n                        pipeline_output, type=PipelineOutputRef.__name__\n                    )\n                    data_flow_graph.add_edge(step_output, pipeline_output)\n\n                    data_flow_graph_simple.add_node(\n                        pipeline_output, type=PipelineOutputRef.__name__\n                    )\n                    data_flow_graph_simple.add_edge(step, pipeline_output)\n\n                data_flow_graph.add_node(step_output, type=StepOutputRef.__name__)\n                data_flow_graph.add_edge(step, step_output)\n\n        # now process inputs, and connect them to the appropriate output/pipeline-input points\n        existing_pipeline_input_points: Dict[str, PipelineInputRef] = {}\n        for step in self.steps:\n\n            other_step_dependency: Set = set()\n            # go through all the inputs of a module, create input points and connect them to either\n            # other module outputs, or pipeline inputs (which need to be created)\n\n            module_constants: Mapping[str, Any] = step.module.get_config_value(\n                \"constants\"\n            )\n\n            for input_name, schema in step.module.inputs_schema.items():\n\n                matching_input_links: List[StepValueAddress] = []\n                is_constant = input_name in module_constants.keys()\n\n                for value_name, input_links in step.input_links.items():\n                    if value_name == input_name:\n                        for input_link in input_links:\n                            if input_link in matching_input_links:\n                                raise Exception(f\"Duplicate input link: {input_link}\")\n                            matching_input_links.append(input_link)\n\n                if matching_input_links:\n                    # this means we connect to other steps output\n\n                    connected_output_points: List[StepOutputRef] = []\n                    connected_outputs: List[StepValueAddress] = []\n\n                    for input_link in matching_input_links:\n                        output_id = generate_step_alias(\n                            input_link.step_id, input_link.value_name\n                        )\n\n                        if output_id not in outputs.keys():\n                            raise Exception(\n                                f\"Can't connect input '{input_name}' for step '{step.step_id}': no output '{output_id}' available. Available output names: {', '.join(outputs.keys())}\"\n                            )\n                        connected_output_points.append(outputs[output_id])\n                        connected_outputs.append(input_link)\n\n                        other_step_dependency.add(input_link.step_id)\n\n                    step_input_point = StepInputRef(\n                        step_id=step.step_id,\n                        value_name=input_name,\n                        value_schema=schema,\n                        is_constant=is_constant,\n                        connected_pipeline_input=None,\n                        connected_outputs=connected_outputs,\n                    )\n\n                    for op in connected_output_points:\n                        op.connected_inputs.append(step_input_point.address)\n                        data_flow_graph.add_edge(op, step_input_point)\n                        data_flow_graph_simple.add_edge(\n                            _temp_steps_map[op.step_id], step_input_point\n                        )  # TODO: name edge\n                        data_flow_graph_simple.add_edge(\n                            step_input_point, step\n                        )  # TODO: name edge\n\n                else:\n                    # this means we connect to pipeline input\n                    # pipeline_input_name = generate_pipeline_endpoint_name(\n                    #     step_id=step.step_id, value_name=input_name\n                    # )\n                    pipeline_input_ref = f\"{step.step_id}.{input_name}\"\n\n                    # check whether this input has an alias associated with it\n                    if not self.input_aliases:\n                        raise NotImplementedError()\n\n                    if pipeline_input_ref in self.input_aliases.keys():\n                        # this means we use the pipeline alias\n                        pipeline_input_name = self.input_aliases[pipeline_input_ref]\n                    else:\n                        pipeline_input_name = generate_pipeline_endpoint_name(\n                            step_id=step.step_id, value_name=input_name\n                        )\n\n                    if pipeline_input_name in existing_pipeline_input_points.keys():\n                        # we already created a pipeline input with this name\n                        # TODO: check whether schema fits\n                        connected_pipeline_input = existing_pipeline_input_points[\n                            pipeline_input_name\n                        ]\n                        assert connected_pipeline_input.is_constant == is_constant\n                    else:\n                        # we need to create the pipeline input\n                        connected_pipeline_input = PipelineInputRef(\n                            value_name=pipeline_input_name,\n                            value_schema=schema,\n                            is_constant=is_constant,\n                        )\n\n                        existing_pipeline_input_points[\n                            pipeline_input_name\n                        ] = connected_pipeline_input\n\n                        data_flow_graph.add_node(\n                            connected_pipeline_input, type=PipelineInputRef.__name__\n                        )\n                        data_flow_graph_simple.add_node(\n                            connected_pipeline_input, type=PipelineInputRef.__name__\n                        )\n                        if is_constant:\n                            constants[\n                                pipeline_input_name\n                            ] = step.module.get_config_value(\"constants\")[input_name]\n\n                        default_val = step.module.get_config_value(\"defaults\").get(\n                            input_name, None\n                        )\n                        if is_constant and default_val is not None:\n                            raise Exception(\n                                f\"Module config invalid for step '{step.step_id}': both default value and constant provided for input '{input_name}'.\"\n                            )\n                        elif default_val is not None:\n                            structure_defaults[pipeline_input_name] = default_val\n\n                    step_input_point = StepInputRef(\n                        step_id=step.step_id,\n                        value_name=input_name,\n                        value_schema=schema,\n                        connected_pipeline_input=connected_pipeline_input.value_name,\n                        connected_outputs=None,\n                        is_constant=is_constant,\n                    )\n                    connected_pipeline_input.connected_inputs.append(\n                        step_input_point.address\n                    )\n                    data_flow_graph.add_edge(connected_pipeline_input, step_input_point)\n                    data_flow_graph_simple.add_edge(connected_pipeline_input, step)\n\n                data_flow_graph.add_node(step_input_point, type=StepInputRef.__name__)\n\n                steps_details[step.step_id][\"inputs\"][input_name] = step_input_point\n\n                data_flow_graph.add_edge(step_input_point, step)\n\n            if other_step_dependency:\n                for module_id in other_step_dependency:\n                    execution_graph.add_edge(module_id, step.step_id)\n            else:\n                execution_graph.add_edge(\"__root__\", step.step_id)\n\n        self._constants = constants\n        self._defaults = structure_defaults\n        self._steps_details = {}\n        for step_id, data in steps_details.items():\n            _step = StepInfo(**data)\n            _step._structure = self\n            self._steps_details[step_id] = _step\n\n        self._execution_graph = execution_graph\n        self._data_flow_graph = data_flow_graph\n        self._data_flow_graph_simple = data_flow_graph_simple\n        self._processing_stages = None  # type: ignore\n\n        self._get_node_of_type.cache_clear()\n\n    def export_stages(self):\n\n        # TODO: implement different processing stages possibilities\n        processing_stages = self.processing_stages\n\n        for stage in processing_stages:\n\n            input_links = []\n\n            for step_id in stage:\n                step = self.get_step(step_id=step_id)\n                for input_link in step.input_links:\n                    input_links.append(input_link)\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        show_pipeline_inputs_for_steps = config.get(\n            \"show_pipeline_inputs_for_steps\", False\n        )\n        stages_extraction_type = config.get(\"stages_extraction_type\", \"late\")\n\n        tree = Tree(\"pipeline\")\n        inputs = tree.add(\"inputs\")\n        for field_name, schema in self.pipeline_inputs_schema.items():\n            inputs.add(f\"[i]{field_name}[i] (type: {schema.type})\")\n\n        steps = tree.add(\"steps\")\n        processing_stages = PipelineStage.extract_stages(\n            structure=self, stages_extraction_type=stages_extraction_type\n        )\n        for idx, stage in enumerate(processing_stages, start=1):\n            stage_node = steps.add(f\"stage {idx}\")\n            for step_id in stage:\n                step_node = stage_node.add(f\"step: {step_id}\")\n                step = self.get_step(step_id=step_id)\n                if show_pipeline_inputs_for_steps:\n                    pipeline_inputs = self.get_pipeline_inputs_schema_for_step(\n                        step_id=step_id\n                    )\n                    if pipeline_inputs:\n                        inps = step_node.add(\"pipeline inputs\")\n                        for pi in pipeline_inputs:\n                            inps.add(f\"[i]{pi}[i]\")\n                if step.doc.is_set:\n                    step_node.add(f\"desc: {step.doc.description}\")\n                step_node.add(f\"module: {step.manifest_src.module_type}\")\n\n        outputs = tree.add(\"outputs\")\n        for field_name, schema in self.pipeline_outputs_schema.items():\n            outputs.add(f\"[i]{field_name}[i] (type: {schema.type})\")\n\n        return tree\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.pipeline_config","title":"<code>pipeline_config: PipelineConfig = Field(description='The underlying pipeline config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.steps","title":"<code>steps: List[PipelineStep] = Field(description='The pipeline steps ')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.input_aliases","title":"<code>input_aliases: Dict[str, str] = Field(description='The input aliases.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.output_aliases","title":"<code>output_aliases: Dict[str, str] = Field(description='The output aliases.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.steps_details","title":"<code>steps_details: Mapping[str, StepInfo]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.step_ids","title":"<code>step_ids: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.constants","title":"<code>constants: Mapping[str, Any]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.defaults","title":"<code>defaults: Mapping[str, Any]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.execution_graph","title":"<code>execution_graph: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.data_flow_graph","title":"<code>data_flow_graph: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.data_flow_graph_simple","title":"<code>data_flow_graph_simple: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.processing_stages","title":"<code>processing_stages: List[List[str]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.steps_input_refs","title":"<code>steps_input_refs: Dict[str, StepInputRef]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.steps_output_refs","title":"<code>steps_output_refs: Dict[str, StepOutputRef]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.pipeline_input_refs","title":"<code>pipeline_input_refs: Dict[str, PipelineInputRef]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.pipeline_output_refs","title":"<code>pipeline_output_refs: Dict[str, PipelineOutputRef]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.pipeline_inputs_schema","title":"<code>pipeline_inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.pipeline_outputs_schema","title":"<code>pipeline_outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.validate_pipeline_config","title":"<code>validate_pipeline_config(values) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>@root_validator(pre=True)\ndef validate_pipeline_config(cls, values) -&gt; Dict[str, Any]:\n\n    pipeline_config = values.get(\"pipeline_config\", None)\n    if not pipeline_config:\n        raise ValueError(\"No 'pipeline_config' provided.\")\n\n    if len(values) != 1:\n        raise ValueError(\n            \"Only 'pipeline_config' key allowed when creating a pipeline structure object.\"\n        )\n\n    if isinstance(pipeline_config, Mapping):\n        pipeline_config = PipelineConfig(**pipeline_config)\n    _config: PipelineConfig = pipeline_config\n    _steps: List[PipelineStep] = list(_config.steps)\n\n    _input_aliases: Dict[str, str] = dict(_config.input_aliases)\n    _output_aliases: Dict[str, str] = dict(_config.output_aliases)\n\n    invalid_input_aliases = [a for a in _input_aliases.values() if \".\" in a]\n    if invalid_input_aliases:\n        raise InvalidPipelineConfig(\n            f\"Invalid input aliases, aliases can't contain special characters: {', '.join(invalid_input_aliases)}.\",\n            config=values.get(\"pipeline_config\", None),\n            details=f\"Invalid characters: {', '.join(invalid_input_aliases)}.\",\n        )\n    invalid_output_aliases = [a for a in _input_aliases.values() if \".\" in a]\n    if invalid_input_aliases:\n        raise InvalidPipelineConfig(\n            f\"Invalid input aliases, aliases can't contain special characters: {', '.join(invalid_output_aliases)}.\",\n            config=values.get(\"pipeline_config\"),\n            details=f\"Invalid characters: {', '.join(invalid_output_aliases)}.\",\n        )\n\n    valid_input_names = set()\n    for step in _steps:\n        for input_name in step.module.input_names:\n            valid_input_names.add(f\"{step.step_id}.{input_name}\")\n    invalid_input_aliases = [\n        a for a in _input_aliases.keys() if a not in valid_input_names\n    ]\n    if invalid_input_aliases:\n        msg = \"Invalid input reference(s).\"\n        details = \"Invalid reference(s):\\n\"\n        for iia in invalid_input_aliases:\n            details += f\" - {iia}\\n\"\n        details += \"\\nMust be one of: \\n\"\n        for name in valid_input_names:\n            details += f\"  - {name}\\n\"\n\n        raise InvalidPipelineConfig(\n            msg, config=values.get(\"pipeline_config\", {}), details=details\n        )\n\n    valid_output_names = set()\n    for step in _steps:\n        for output_name in step.module.output_names:\n            valid_output_names.add(f\"{step.step_id}.{output_name}\")\n    invalid_output_names = [\n        a for a in _output_aliases.keys() if a not in valid_output_names\n    ]\n    if invalid_output_names:\n\n        msg = \"Invalid output reference(s).\"\n        details = \"Invalid reference(s):\\n\"\n        for iia in invalid_output_names:\n            details += f\" - {iia}\\n\"\n        details += \"\\nMust be one of: \\n\"\n        for name in valid_output_names:\n            details += f\"  - {name}\\n\"\n\n        raise InvalidPipelineConfig(msg, values.get(\"pipeline_config\", {}), details)\n\n    # stages = PipelineStage.from_pipeline_structure(stages=)\n\n    # values[\"steps\"] = {step.step_id: step for step in _steps}\n    values[\"steps\"] = _steps\n    values[\"input_aliases\"] = _input_aliases\n    values[\"output_aliases\"] = _output_aliases\n    return values\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_step","title":"<code>get_step(step_id: str) -&gt; PipelineStep</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_step(self, step_id: str) -&gt; PipelineStep:\n\n    d = self.steps_details.get(step_id, None)\n    if d is None:\n        raise Exception(f\"No step with id: {step_id}\")\n\n    return d.step\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_step_input_refs","title":"<code>get_step_input_refs(step_id: str) -&gt; Mapping[str, StepInputRef]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_step_input_refs(self, step_id: str) -&gt; Mapping[str, StepInputRef]:\n\n    d = self.steps_details.get(step_id, None)\n    if d is None:\n        raise Exception(f\"No step with id: {step_id}\")\n\n    return d.inputs\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_step_output_refs","title":"<code>get_step_output_refs(step_id: str) -&gt; Mapping[str, StepOutputRef]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_step_output_refs(self, step_id: str) -&gt; Mapping[str, StepOutputRef]:\n\n    d = self.steps_details.get(step_id, None)\n    if d is None:\n        raise Exception(f\"No step with id: {step_id}\")\n\n    return d.outputs\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_step_details","title":"<code>get_step_details(step_id: str) -&gt; StepInfo</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_step_details(self, step_id: str) -&gt; StepInfo:\n\n    d = self.steps_details.get(step_id, None)\n    if d is None:\n        raise Exception(f\"No step with id: {step_id}\")\n\n    return d\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.extract_processing_stages","title":"<code>extract_processing_stages(stages_extraction_type: str = 'late') -&gt; List[List[str]]</code>","text":"<p>Extract a list of lists of steps, representing the order of groups in which they will be executed.</p> <p>It is possible to extract the stages in different ways, depending on the use-case you have in mind. For most cases, 'late' will be appropriate. Currently available: - 'late': process steps as late in the process as possible - 'early': process steps as early in the process as possible</p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def extract_processing_stages(\n    self, stages_extraction_type: str = \"late\"\n) -&gt; List[List[str]]:\n\"\"\"Extract a list of lists of steps, representing the order of groups in which they will be executed.\n\n    It is possible to extract the stages in different ways, depending on the use-case you have in mind. For most cases,\n    'late' will be appropriate. Currently available:\n    - 'late': process steps as late in the process as possible\n    - 'early': process steps as early in the process as possible\n    \"\"\"\n\n    return PipelineStage.extract_stages(\n        self, stages_extraction_type=stages_extraction_type\n    )\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.extract_processing_stages_info","title":"<code>extract_processing_stages_info(stages_extraction_type: str = 'late') -&gt; List[PipelineStage]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def extract_processing_stages_info(\n    self, stages_extraction_type: str = \"late\"\n) -&gt; List[PipelineStage]:\n\n    stages = self.extract_processing_stages(\n        stages_extraction_type=stages_extraction_type\n    )\n    return PipelineStage.stages_info_from_pipeline_structure(self, stages)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_stages_graph","title":"<code>get_stages_graph(stages_extraction_type: str = 'late', flatten: bool = True) -&gt; nx.DiGraph</code>","text":"<p>Creates a networx graph that represents the processing stages of the pipeline and how they are connecte.</p> <p>Parameters:</p> Name Type Description Default <code>stages_extraction_type</code> <code>str</code> <p>how to extract the stages</p> <code>'late'</code> <code>flatten</code> <code>bool</code> <p>if True, the nodes representing connections between stages will be removed, leaving only the edge</p> <code>True</code> <p>Returns:</p> Type Description <code>nx.DiGraph</code> <p>a networkx graph object</p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_stages_graph(\n    self, stages_extraction_type: str = \"late\", flatten: bool = True\n) -&gt; nx.DiGraph:\n\"\"\"Creates a networx graph that represents the processing stages of the pipeline and how they are connecte.\n\n    Arguments:\n        stages_extraction_type: how to extract the stages\n        flatten: if True, the nodes representing connections between stages will be removed, leaving only the edge\n\n    Returns:\n        a networkx graph object\n    \"\"\"\n\n    stages = self.extract_processing_stages_info(\n        stages_extraction_type=stages_extraction_type\n    )\n\n    graph = nx.DiGraph()\n    for stage in stages:\n        fragment = stage.get_graph_fragment()\n        graph = nx.compose(graph, fragment)\n\n    if flatten:\n        to_flatten = []\n        for node_id in graph.nodes:\n            if graph.nodes[node_id][\"type\"] in [\"stage_output\", \"connected_output\"]:\n                to_flatten.append(node_id)\n\n        for f in to_flatten:\n\n            in_edges = tuple(graph.in_edges(f))[0]\n            out_edges = tuple(graph.out_edges(f))[0]\n            assert in_edges[1] == out_edges[0]\n            graph.remove_edge(in_edges[0], in_edges[1])\n            graph.remove_edge(out_edges[0], out_edges[1])\n            graph.remove_node(f)\n            graph.add_edge(\n                in_edges[0],\n                out_edges[1],\n                type=\"stage_connection\",\n                output_name=in_edges[1],\n            )\n\n    return graph\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_pipeline_inputs_schema_for_step","title":"<code>get_pipeline_inputs_schema_for_step(step_id: str) -&gt; Mapping[str, ValueSchema]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_pipeline_inputs_schema_for_step(\n    self, step_id: str\n) -&gt; Mapping[str, ValueSchema]:\n\n    result = {}\n    for field, ref in self.pipeline_input_refs.items():\n        for con in ref.connected_inputs:\n            if con.step_id == step_id:\n                result[field] = ref.value_schema\n                break\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_pipeline_outputs_schema_for_step","title":"<code>get_pipeline_outputs_schema_for_step(step_id: str) -&gt; Mapping[str, ValueSchema]</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_pipeline_outputs_schema_for_step(\n    self, step_id: str\n) -&gt; Mapping[str, ValueSchema]:\n\n    result = {}\n    for field, ref in self.pipeline_output_refs.items():\n        if ref.connected_output.step_id == step_id:\n            result[field] = ref.value_schema\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.get_processing_stage","title":"<code>get_processing_stage(step_id: str) -&gt; int</code>","text":"<p>Return the processing stage for the specified step_id.</p> <p>Returns the stage nr (starting with '1').</p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def get_processing_stage(self, step_id: str) -&gt; int:\n\"\"\"Return the processing stage for the specified step_id.\n\n    Returns the stage nr (starting with '1').\n    \"\"\"\n\n    for index, stage in enumerate(self.processing_stages, start=1):\n        if step_id in stage:\n            return index\n\n    raise Exception(f\"Invalid step id '{step_id}'.\")\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.step_is_required","title":"<code>step_is_required(step_id: str) -&gt; bool</code>","text":"<p>Check if the specified step is required, or can be omitted.</p> Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def step_is_required(self, step_id: str) -&gt; bool:\n\"\"\"Check if the specified step is required, or can be omitted.\"\"\"\n\n    return self.get_step_details(step_id=step_id).required\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.export_stages","title":"<code>export_stages()</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def export_stages(self):\n\n    # TODO: implement different processing stages possibilities\n    processing_stages = self.processing_stages\n\n    for stage in processing_stages:\n\n        input_links = []\n\n        for step_id in stage:\n            step = self.get_step(step_id=step_id)\n            for input_link in step.input_links:\n                input_links.append(input_link)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.PipelineStructure.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    show_pipeline_inputs_for_steps = config.get(\n        \"show_pipeline_inputs_for_steps\", False\n    )\n    stages_extraction_type = config.get(\"stages_extraction_type\", \"late\")\n\n    tree = Tree(\"pipeline\")\n    inputs = tree.add(\"inputs\")\n    for field_name, schema in self.pipeline_inputs_schema.items():\n        inputs.add(f\"[i]{field_name}[i] (type: {schema.type})\")\n\n    steps = tree.add(\"steps\")\n    processing_stages = PipelineStage.extract_stages(\n        structure=self, stages_extraction_type=stages_extraction_type\n    )\n    for idx, stage in enumerate(processing_stages, start=1):\n        stage_node = steps.add(f\"stage {idx}\")\n        for step_id in stage:\n            step_node = stage_node.add(f\"step: {step_id}\")\n            step = self.get_step(step_id=step_id)\n            if show_pipeline_inputs_for_steps:\n                pipeline_inputs = self.get_pipeline_inputs_schema_for_step(\n                    step_id=step_id\n                )\n                if pipeline_inputs:\n                    inps = step_node.add(\"pipeline inputs\")\n                    for pi in pipeline_inputs:\n                        inps.add(f\"[i]{pi}[i]\")\n            if step.doc.is_set:\n                step_node.add(f\"desc: {step.doc.description}\")\n            step_node.add(f\"module: {step.manifest_src.module_type}\")\n\n    outputs = tree.add(\"outputs\")\n    for field_name, schema in self.pipeline_outputs_schema.items():\n        outputs.add(f\"[i]{field_name}[i] (type: {schema.type})\")\n\n    return tree\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/structure/#kiara.models.module.pipeline.structure.generate_pipeline_endpoint_name","title":"<code>generate_pipeline_endpoint_name(step_id: str, value_name: str)</code>","text":"Source code in <code>kiara/models/module/pipeline/structure.py</code> <pre><code>def generate_pipeline_endpoint_name(step_id: str, value_name: str):\n\n    return f\"{step_id}__{value_name}\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/","title":"value_refs","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress","title":"<code>StepValueAddress</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure.</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class StepValueAddress(BaseModel):\n\"\"\"Small model to describe the address of a value of a step, within a Pipeline/PipelineStructure.\"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    step_id: str = Field(description=\"The id of a step within a pipeline.\")\n    value_name: str = Field(\n        description=\"The name of the value (output name or pipeline input name).\"\n    )\n    sub_value: Union[Dict[str, Any], None] = Field(\n        default=None,\n        description=\"A reference to a subitem of a value (e.g. column, list item)\",\n    )\n\n    @property\n    def alias(self):\n\"\"\"An alias string for this address (in the form ``[step_id].[value_name]``).\"\"\"\n        return generate_step_alias(self.step_id, self.value_name)\n\n    def __eq__(self, other):\n\n        if not isinstance(other, StepValueAddress):\n            return False\n\n        return (self.step_id, self.value_name, self.sub_value) == (\n            other.step_id,\n            other.value_name,\n            other.sub_value,\n        )\n\n    def __hash__(self):\n\n        return hash((self.step_id, self.value_name, self.sub_value))\n\n    def __repr__(self):\n\n        if self.sub_value:\n            sub_value = f\" sub_value={self.sub_value}\"\n        else:\n            sub_value = \"\"\n        return f\"{self.__class__.__name__}(step_id={self.step_id}, value_name={self.value_name}{sub_value})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.step_id","title":"<code>step_id: str = Field(description='The id of a step within a pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.value_name","title":"<code>value_name: str = Field(description='The name of the value (output name or pipeline input name).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.sub_value","title":"<code>sub_value: Union[Dict[str, Any], None] = Field(default=None, description='A reference to a subitem of a value (e.g. column, list item)')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.alias","title":"<code>alias</code>  <code>property</code>","text":"<p>An alias string for this address (in the form <code>[step_id].[value_name]</code>).</p>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepValueAddress.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef","title":"<code>ValueRef</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>An object that holds information about the location of a value within a pipeline (or other structure).</p> <p>Basically, a <code>ValueRef</code> helps the containing object where in its structure the value belongs (for example so it can update dependent other values). A <code>ValueRef</code> object (obviously) does not contain the value itself.</p> <p>There are four different ValueRef type that are relevant for pipelines:</p> <ul> <li>kiara.pipeline.values.StepInputRef: an input to a step</li> <li>kiara.pipeline.values.StepOutputRef: an output of a step</li> <li>kiara.pipeline.values.PipelineInputRef: an input to a pipeline</li> <li>kiara.pipeline.values.PipelineOutputRef: an output for a pipeline</li> </ul> <p>Several <code>ValueRef</code> objects can target the same value, for example a step output and a connected step input would reference the same <code>Value</code> (in most cases)..</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class ValueRef(BaseModel):\n\"\"\"An object that holds information about the location of a value within a pipeline (or other structure).\n\n    Basically, a `ValueRef` helps the containing object where in its structure the value belongs (for example so\n    it can update dependent other values). A `ValueRef` object (obviously) does not contain the value itself.\n\n    There are four different ValueRef type that are relevant for pipelines:\n\n    - [kiara.pipeline.values.StepInputRef][]: an input to a step\n    - [kiara.pipeline.values.StepOutputRef][]: an output of a step\n    - [kiara.pipeline.values.PipelineInputRef][]: an input to a pipeline\n    - [kiara.pipeline.values.PipelineOutputRef][]: an output for a pipeline\n\n    Several `ValueRef` objects can target the same value, for example a step output and a connected step input would\n    reference the same `Value` (in most cases)..\n    \"\"\"\n\n    class Config:\n        allow_mutation = True\n        extra = Extra.forbid\n\n    _id: uuid.UUID = PrivateAttr(default_factory=uuid.uuid4)\n    value_name: str\n    value_schema: ValueSchema\n\n    def __eq__(self, other):\n\n        if not isinstance(other, self.__class__):\n            return False\n\n        return self._id == other._id\n\n    def __hash__(self):\n        return hash(self._id)\n\n    def __repr__(self):\n        step_id = \"\"\n        if hasattr(self, \"step_id\"):\n            step_id = f\" step_id='{self.step_id}'\"\n        return f\"{self.__class__.__name__}(value_name='{self.value_name}' {step_id})\"\n\n    def __str__(self):\n        name = camel_case_to_snake_case(self.__class__.__name__[0:-5], repl=\" \")\n        return f\"{name}: {self.value_name} ({self.value_schema.type})\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef.value_name","title":"<code>value_name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef.value_schema","title":"<code>value_schema: ValueSchema</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class Config:\n    allow_mutation = True\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.ValueRef.Config-attributes","title":"Attributes","text":"<code>allow_mutation = True</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef","title":"<code>StepInputRef</code>","text":"<p>         Bases: <code>ValueRef</code></p> <p>An input to a step.</p> <p>This object can either have a 'connected_outputs' set, or a 'connected_pipeline_input', not both.</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class StepInputRef(ValueRef):\n\"\"\"An input to a step.\n\n    This object can either have a 'connected_outputs' set, or a 'connected_pipeline_input', not both.\n    \"\"\"\n\n    step_id: str = Field(description=\"The step id.\")\n    connected_outputs: Union[List[StepValueAddress], None] = Field(\n        default=None,\n        description=\"A potential connected list of one or several module outputs.\",\n    )\n    connected_pipeline_input: Union[str, None] = Field(\n        default=None, description=\"A potential pipeline input.\"\n    )\n    is_constant: bool = Field(\n        description=\"Whether this input is a constant and can't be changed by the user.\"\n    )\n\n    @root_validator(pre=True)\n    def ensure_single_connected_item(cls, values):\n\n        if values.get(\"connected_outputs\", None) and values.get(\n            \"connected_pipeline_input\"\n        ):\n            raise ValueError(\"Multiple connected items, only one allowed.\")\n\n        return values\n\n    @property\n    def alias(self) -&gt; str:\n        return generate_step_alias(self.step_id, self.value_name)\n\n    @property\n    def address(self) -&gt; StepValueAddress:\n        return StepValueAddress(step_id=self.step_id, value_name=self.value_name)\n\n    def __str__(self):\n        name = camel_case_to_snake_case(self.__class__.__name__[0:-5], repl=\" \")\n        return f\"{name}: {self.step_id}.{self.value_name} ({self.value_schema.type})\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.step_id","title":"<code>step_id: str = Field(description='The step id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.connected_outputs","title":"<code>connected_outputs: Union[List[StepValueAddress], None] = Field(default=None, description='A potential connected list of one or several module outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.connected_pipeline_input","title":"<code>connected_pipeline_input: Union[str, None] = Field(default=None, description='A potential pipeline input.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.is_constant","title":"<code>is_constant: bool = Field(description=\"Whether this input is a constant and can't be changed by the user.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.alias","title":"<code>alias: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.address","title":"<code>address: StepValueAddress</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepInputRef.ensure_single_connected_item","title":"<code>ensure_single_connected_item(values)</code>","text":"Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>@root_validator(pre=True)\ndef ensure_single_connected_item(cls, values):\n\n    if values.get(\"connected_outputs\", None) and values.get(\n        \"connected_pipeline_input\"\n    ):\n        raise ValueError(\"Multiple connected items, only one allowed.\")\n\n    return values\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef","title":"<code>StepOutputRef</code>","text":"<p>         Bases: <code>ValueRef</code></p> <p>An output to a step.</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class StepOutputRef(ValueRef):\n\"\"\"An output to a step.\"\"\"\n\n    class Config:\n        allow_mutation = True\n\n    step_id: str = Field(description=\"The step id.\")\n    pipeline_output: Union[str, None] = Field(\n        description=\"The connected pipeline output.\"\n    )\n    connected_inputs: List[StepValueAddress] = Field(\n        description=\"The step inputs that are connected to this step output\",\n        default_factory=list,\n    )\n\n    @property\n    def alias(self) -&gt; str:\n        return generate_step_alias(self.step_id, self.value_name)\n\n    @property\n    def address(self) -&gt; StepValueAddress:\n        return StepValueAddress(step_id=self.step_id, value_name=self.value_name)\n\n    def __str__(self):\n        name = camel_case_to_snake_case(self.__class__.__name__[0:-5], repl=\" \")\n        return f\"{name}: {self.step_id}.{self.value_name} ({self.value_schema.type})\"\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.step_id","title":"<code>step_id: str = Field(description='The step id.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.pipeline_output","title":"<code>pipeline_output: Union[str, None] = Field(description='The connected pipeline output.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.connected_inputs","title":"<code>connected_inputs: List[StepValueAddress] = Field(description='The step inputs that are connected to this step output', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.alias","title":"<code>alias: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.address","title":"<code>address: StepValueAddress</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef-classes","title":"Classes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class Config:\n    allow_mutation = True\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.StepOutputRef.Config-attributes","title":"Attributes","text":"<code>allow_mutation = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineInputRef","title":"<code>PipelineInputRef</code>","text":"<p>         Bases: <code>ValueRef</code></p> <p>An input to a pipeline.</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class PipelineInputRef(ValueRef):\n\"\"\"An input to a pipeline.\"\"\"\n\n    connected_inputs: List[StepValueAddress] = Field(\n        description=\"The step inputs that are connected to this pipeline input\",\n        default_factory=list,\n    )\n    is_constant: bool = Field(\n        description=\"Whether this input is a constant and can't be changed by the user.\"\n    )\n\n    @property\n    def alias(self) -&gt; str:\n        return generate_step_alias(PIPELINE_PARENT_MARKER, self.value_name)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineInputRef-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineInputRef.connected_inputs","title":"<code>connected_inputs: List[StepValueAddress] = Field(description='The step inputs that are connected to this pipeline input', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineInputRef.is_constant","title":"<code>is_constant: bool = Field(description=\"Whether this input is a constant and can't be changed by the user.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineInputRef.alias","title":"<code>alias: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineOutputRef","title":"<code>PipelineOutputRef</code>","text":"<p>         Bases: <code>ValueRef</code></p> <p>An output to a pipeline.</p> Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>class PipelineOutputRef(ValueRef):\n\"\"\"An output to a pipeline.\"\"\"\n\n    connected_output: StepValueAddress = Field(description=\"Connected step outputs.\")\n\n    @property\n    def alias(self) -&gt; str:\n        return generate_step_alias(PIPELINE_PARENT_MARKER, self.value_name)\n</code></pre>"},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineOutputRef-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineOutputRef.connected_output","title":"<code>connected_output: StepValueAddress = Field(description='Connected step outputs.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.PipelineOutputRef.alias","title":"<code>alias: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs-functions","title":"Functions","text":""},{"location":"reference/kiara/models/module/pipeline/value_refs/#kiara.models.module.pipeline.value_refs.generate_step_alias","title":"<code>generate_step_alias(step_id: str, value_name)</code>","text":"Source code in <code>kiara/models/module/pipeline/value_refs.py</code> <pre><code>def generate_step_alias(step_id: str, value_name):\n    return f\"{step_id}.{value_name}\"\n</code></pre>"},{"location":"reference/kiara/models/rendering/__init__/","title":"rendering","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.DataT","title":"<code>DataT = TypeVar('DataT')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering-classes","title":"Classes","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene","title":"<code>RenderScene</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/rendering/__init__.py</code> <pre><code>class RenderScene(KiaraModel):\n\n    _kiara_model_id = \"instance.render_scene\"\n\n    title: str = Field(description=\"The title of this scene.\")\n    disabled: bool = Field(\n        description=\"Whether this scene should be displayed as 'disabled' in a UI.\",\n        default=False,\n    )\n    description: str = Field(\n        description=\"Description of what this scene renders.\",\n        default=DEFAULT_NO_DESC_VALUE,\n    )\n    manifest_hash: str = Field(\n        description=\"The hash of the manifest of the referenced render scene.\"\n    )\n    render_config: Mapping[str, Any] = Field(\n        description=\"The inputs used with the referenced manifest.\",\n        default_factory=dict,\n    )\n    related_scenes: Mapping[str, Union[None, \"RenderScene\"]] = Field(\n        description=\"Other render scenes, related to this one.\", default_factory=dict\n    )\n\n    @validator(\"manifest_hash\", pre=True)\n    def validate_manifest_hash(cls, value):\n\n        if hasattr(value, \"manifest_hash\"):\n            return value.manifest_hash  # type: ignore\n        else:\n            return value\n</code></pre>"},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.title","title":"<code>title: str = Field(description='The title of this scene.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.disabled","title":"<code>disabled: bool = Field(description=\"Whether this scene should be displayed as 'disabled' in a UI.\", default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.description","title":"<code>description: str = Field(description='Description of what this scene renders.', default=DEFAULT_NO_DESC_VALUE)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.manifest_hash","title":"<code>manifest_hash: str = Field(description='The hash of the manifest of the referenced render scene.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.render_config","title":"<code>render_config: Mapping[str, Any] = Field(description='The inputs used with the referenced manifest.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.related_scenes","title":"<code>related_scenes: Mapping[str, Union[None, RenderScene]] = Field(description='Other render scenes, related to this one.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene-functions","title":"Functions","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderScene.validate_manifest_hash","title":"<code>validate_manifest_hash(value)</code>","text":"Source code in <code>kiara/models/rendering/__init__.py</code> <pre><code>@validator(\"manifest_hash\", pre=True)\ndef validate_manifest_hash(cls, value):\n\n    if hasattr(value, \"manifest_hash\"):\n        return value.manifest_hash  # type: ignore\n    else:\n        return value\n</code></pre>"},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult","title":"<code>RenderValueResult</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>Object containing all the result properties of a 'render_value' operation.</p> Source code in <code>kiara/models/rendering/__init__.py</code> <pre><code>class RenderValueResult(KiaraModel):\n\"\"\"Object containing all the result properties of a 'render_value' operation.\"\"\"\n\n    value_id: uuid.UUID = Field(description=\"The value that was rendered.\")\n    render_config: Mapping[str, Any] = Field(\n        description=\"The config that was used to render this.\", default_factory=dict\n    )\n    render_manifest: str = Field(\n        description=\"The id of the manifest that was used to render this.\"\n    )\n    related_scenes: Mapping[str, Union[None, RenderScene]] = Field(\n        description=\"Other render scenes, related to this one.\", default_factory=dict\n    )\n    manifest_lookup: Dict[str, Manifest] = Field(\n        description=\"The manifests referenced in this model, indexed by the hashes.\",\n        default_factory=dict,\n    )\n    rendered: Any = Field(description=\"The rendered object.\")\n\n    def _retrieve_data_to_hash(self) -&gt; Kind:\n        return {\n            \"value_id\": str(self.value_id),\n            \"render_config\": self.render_config,  # type: ignore\n            \"render_manifest\": self.render_manifest,\n        }\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        show_render_result = config.get(\"show_render_result\", True)\n        show_render_metadata = config.get(\"show_render_metadata\", False)\n        if show_render_metadata:\n\n            table: Table = Table(show_header=False)\n            table.add_column(\"key\")\n            table.add_column(\"value\")\n\n            table.add_row(\"value_id\", str(self.value_id))\n\n            rc_data = orjson_dumps(self.render_config, option=orjson.OPT_INDENT_2)\n            render_config = Syntax(rc_data, \"json\", background_color=\"default\")\n            table.add_row(\"applied render config\", render_config)\n\n            applied_module = self.manifest_lookup[self.render_manifest]\n            table.add_row(\"applied module\", applied_module.create_renderable(**config))  # type: ignore\n\n            related_scenes: Dict[str, Union[str, Dict[str, Any]]] = {}\n            for k, v in self.related_scenes.items():\n                if v is None:\n                    related_scenes[k] = \"-- disabled --\"\n                else:\n                    related_scenes[k] = v.dict()\n            rel_scenes_json = orjson_dumps(related_scenes, option=orjson.OPT_INDENT_2)\n            table.add_row(\n                \"related scenes\",\n                Syntax(rel_scenes_json, \"json\", background_color=\"default\"),\n            )\n            if show_render_result:\n                table.add_row(\n                    \"rendered\", extract_renderable(self.rendered, render_config=config)\n                )\n\n            result: RenderableType = table\n        else:\n            result = extract_renderable(self.rendered, render_config=config)\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.value_id","title":"<code>value_id: uuid.UUID = Field(description='The value that was rendered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.render_config","title":"<code>render_config: Mapping[str, Any] = Field(description='The config that was used to render this.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.render_manifest","title":"<code>render_manifest: str = Field(description='The id of the manifest that was used to render this.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.related_scenes","title":"<code>related_scenes: Mapping[str, Union[None, RenderScene]] = Field(description='Other render scenes, related to this one.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.manifest_lookup","title":"<code>manifest_lookup: Dict[str, Manifest] = Field(description='The manifests referenced in this model, indexed by the hashes.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.rendered","title":"<code>rendered: Any = Field(description='The rendered object.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult-functions","title":"Functions","text":""},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering.RenderValueResult.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/rendering/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    show_render_result = config.get(\"show_render_result\", True)\n    show_render_metadata = config.get(\"show_render_metadata\", False)\n    if show_render_metadata:\n\n        table: Table = Table(show_header=False)\n        table.add_column(\"key\")\n        table.add_column(\"value\")\n\n        table.add_row(\"value_id\", str(self.value_id))\n\n        rc_data = orjson_dumps(self.render_config, option=orjson.OPT_INDENT_2)\n        render_config = Syntax(rc_data, \"json\", background_color=\"default\")\n        table.add_row(\"applied render config\", render_config)\n\n        applied_module = self.manifest_lookup[self.render_manifest]\n        table.add_row(\"applied module\", applied_module.create_renderable(**config))  # type: ignore\n\n        related_scenes: Dict[str, Union[str, Dict[str, Any]]] = {}\n        for k, v in self.related_scenes.items():\n            if v is None:\n                related_scenes[k] = \"-- disabled --\"\n            else:\n                related_scenes[k] = v.dict()\n        rel_scenes_json = orjson_dumps(related_scenes, option=orjson.OPT_INDENT_2)\n        table.add_row(\n            \"related scenes\",\n            Syntax(rel_scenes_json, \"json\", background_color=\"default\"),\n        )\n        if show_render_result:\n            table.add_row(\n                \"rendered\", extract_renderable(self.rendered, render_config=config)\n            )\n\n        result: RenderableType = table\n    else:\n        result = extract_renderable(self.rendered, render_config=config)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/rendering/__init__/#kiara.models.rendering-functions","title":"Functions","text":""},{"location":"reference/kiara/models/rendering/values/","title":"values","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/","title":"runtime_environment","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.logger","title":"<code>logger = structlog.get_logger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment-classes","title":"Classes","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment","title":"<code>RuntimeEnvironment</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>class RuntimeEnvironment(KiaraModel):\n    class Config:\n        underscore_attrs_are_private = False\n        allow_mutation = False\n\n    @classmethod\n    def get_environment_type_name(cls) -&gt; str:\n\n        env_type = cls.__fields__[\"environment_type\"]\n        args = get_args(env_type.type_)\n        assert len(args) == 1\n\n        return args[0]\n\n    @classmethod\n    def create_environment_model(cls):\n\n        try:\n            type_name = cls.get_environment_type_name()\n            data = cls.retrieve_environment_data()\n            assert (\n                \"environment_type\" not in data.keys()\n                or data[\"environment_keys\"] == type_name\n            )\n            data[\"environment_type\"] = type_name\n\n        except Exception as e:\n            raise Exception(f\"Can't create environment model for '{cls.__name__}': {e}\")\n        return cls(**data)\n\n    def get_category_alias(self) -&gt; str:\n        return f\"{ENVIRONMENT_TYPE_CATEGORY_ID}.{self.environment_type}\"  # type: ignore\n\n    @classmethod\n    @abstractmethod\n    def retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n        pass\n\n    _env_hashes: Union[Mapping[str, str], None] = PrivateAttr(default=None)\n\n    def _create_renderable_for_field(\n        self, field_name: str, for_summary: bool = False\n    ) -&gt; Union[RenderableType, None]:\n\n        return extract_renderable(getattr(self, field_name))\n\n    def _retrieve_id(self) -&gt; str:\n        return self.__class__.get_environment_type_name()\n\n    @property\n    def env_hashes(self) -&gt; Mapping[str, str]:\n\n        if self._env_hashes is not None:\n            return self._env_hashes\n\n        result = {}\n        for k, v in self._retrieve_sub_profile_env_data().items():\n            _, cid = compute_cid(data=v)\n            result[k] = str(cid)\n\n        self._env_hashes = result\n        return self._env_hashes\n\n    def _retrieve_sub_profile_env_data(self) -&gt; Mapping[str, Any]:\n\"\"\"Return a dictionary with data that identifies one hash profile per key.\n\n        In most cases, this will only return a single-key dictionary containing all the data in that environment. But\n        in some cases one might want to have several sub-hash profiles, for example a list of Python packages with and\n        without version information, to have more fine-grained control about when to consider two environments functionally\n        equal.\n        \"\"\"\n\n        return {DEFAULT_ENV_HASH_KEY: self._retrieve_data_to_hash()}\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        summary = config.get(\"summary\", False)\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"field\")\n        table.add_column(\"summary\")\n\n        hashes_str = orjson_dumps(self.env_hashes, option=orjson.OPT_INDENT_2)\n        table.add_row(\n            \"environment hashes\", Syntax(hashes_str, \"json\", background_color=\"default\")\n        )\n\n        for field_name, field in self.__fields__.items():\n            summary_item = self._create_renderable_for_field(\n                field_name, for_summary=summary\n            )\n            if summary_item is not None:\n                table.add_row(field_name, summary_item)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.env_hashes","title":"<code>env_hashes: Mapping[str, str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment-classes","title":"Classes","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>class Config:\n    underscore_attrs_are_private = False\n    allow_mutation = False\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.Config-attributes","title":"Attributes","text":"<code>underscore_attrs_are_private = False</code> <code>class-attribute</code> \u00b6 <code>allow_mutation = False</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.get_environment_type_name","title":"<code>get_environment_type_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>@classmethod\ndef get_environment_type_name(cls) -&gt; str:\n\n    env_type = cls.__fields__[\"environment_type\"]\n    args = get_args(env_type.type_)\n    assert len(args) == 1\n\n    return args[0]\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.create_environment_model","title":"<code>create_environment_model()</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>@classmethod\ndef create_environment_model(cls):\n\n    try:\n        type_name = cls.get_environment_type_name()\n        data = cls.retrieve_environment_data()\n        assert (\n            \"environment_type\" not in data.keys()\n            or data[\"environment_keys\"] == type_name\n        )\n        data[\"environment_type\"] = type_name\n\n    except Exception as e:\n        raise Exception(f\"Can't create environment model for '{cls.__name__}': {e}\")\n    return cls(**data)\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.get_category_alias","title":"<code>get_category_alias() -&gt; str</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>def get_category_alias(self) -&gt; str:\n    return f\"{ENVIRONMENT_TYPE_CATEGORY_ID}.{self.environment_type}\"  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.retrieve_environment_data","title":"<code>retrieve_environment_data() -&gt; Dict[str, Any]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>@classmethod\n@abstractmethod\ndef retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment.RuntimeEnvironment.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/runtime_environment/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    summary = config.get(\"summary\", False)\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"field\")\n    table.add_column(\"summary\")\n\n    hashes_str = orjson_dumps(self.env_hashes, option=orjson.OPT_INDENT_2)\n    table.add_row(\n        \"environment hashes\", Syntax(hashes_str, \"json\", background_color=\"default\")\n    )\n\n    for field_name, field in self.__fields__.items():\n        summary_item = self._create_renderable_for_field(\n            field_name, for_summary=summary\n        )\n        if summary_item is not None:\n            table.add_row(field_name, summary_item)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/__init__/#kiara.models.runtime_environment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/","title":"kiara","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara-classes","title":"Classes","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment","title":"<code>KiaraTypesRuntimeEnvironment</code>","text":"<p>         Bases: <code>RuntimeEnvironment</code></p> Source code in <code>kiara/models/runtime_environment/kiara.py</code> <pre><code>class KiaraTypesRuntimeEnvironment(RuntimeEnvironment):\n\n    _kiara_model_id = \"info.runtime.kiara_types\"\n\n    environment_type: Literal[\"kiara_types\"]\n    archive_types: ArchiveTypeClassesInfo = Field(\n        description=\"The available implemented store types.\"\n    )\n    metadata_types: MetadataTypeClassesInfo = Field(\n        description=\"The available metadata types.\"\n    )\n\n    @classmethod\n    def retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n        result: Dict[str, Any] = {}\n        result[\"metadata_types\"] = find_metadata_models()\n        result[\"archive_types\"] = find_archive_types()\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment.environment_type","title":"<code>environment_type: Literal['kiara_types']</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment.archive_types","title":"<code>archive_types: ArchiveTypeClassesInfo = Field(description='The available implemented store types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment.metadata_types","title":"<code>metadata_types: MetadataTypeClassesInfo = Field(description='The available metadata types.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.KiaraTypesRuntimeEnvironment.retrieve_environment_data","title":"<code>retrieve_environment_data() -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/kiara.py</code> <pre><code>@classmethod\ndef retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n    result: Dict[str, Any] = {}\n    result[\"metadata_types\"] = find_metadata_models()\n    result[\"archive_types\"] = find_archive_types()\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/kiara/#kiara.models.runtime_environment.kiara.find_archive_types","title":"<code>find_archive_types(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; ArchiveTypeClassesInfo</code>","text":"Source code in <code>kiara/models/runtime_environment/kiara.py</code> <pre><code>def find_archive_types(\n    alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; ArchiveTypeClassesInfo:\n\n    archive_types = find_all_archive_types()\n\n    kiara: Kiara = None  # type: ignore\n    group: ArchiveTypeClassesInfo = ArchiveTypeClassesInfo.create_from_type_items(  # type: ignore\n        kiara=kiara, group_title=alias, **archive_types\n    )\n\n    if only_for_package:\n        temp: Dict[str, TypeInfo] = {}\n        for key, info in group.item_infos.items():\n            if info.context.labels.get(\"package\") == only_for_package:\n                temp[key] = info  # type: ignore\n\n        group = ArchiveTypeClassesInfo.construct(\n            group_id=group.group_id, group_alias=group.group_alias, item_infos=temp  # type: ignore\n        )\n\n    return group\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/operating_system/","title":"operating_system","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system-classes","title":"Classes","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment","title":"<code>OSRuntimeEnvironment</code>","text":"<p>         Bases: <code>RuntimeEnvironment</code></p> <p>Manages information about the OS this kiara instance is running in.</p>"},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment--todo-details-for-other-oss-mainly-bsds","title":"TODO: details for other OS's (mainly BSDs)","text":"Source code in <code>kiara/models/runtime_environment/operating_system.py</code> <pre><code>class OSRuntimeEnvironment(RuntimeEnvironment):\n\"\"\"Manages information about the OS this kiara instance is running in.\n\n    # TODO: details for other OS's (mainly BSDs)\n    \"\"\"\n\n    _kiara_model_id = \"info.runtime.os\"\n\n    environment_type: typing.Literal[\"operating_system\"]\n    operation_system: str = Field(description=\"The operation system name.\")\n    platform: str = Field(description=\"The platform name.\")\n    release: str = Field(description=\"The platform release name.\")\n    version: str = Field(description=\"The platform version name.\")\n    machine: str = Field(description=\"The architecture.\")\n    os_specific: typing.Dict[str, typing.Any] = Field(\n        description=\"OS specific platform metadata.\", default_factory=dict\n    )\n\n    @classmethod\n    def retrieve_environment_data(self) -&gt; typing.Dict[str, typing.Any]:\n\n        os_specific: typing.Dict[str, typing.Any] = {}\n        platform_system = platform.system()\n        if platform_system == \"Linux\":\n            import distro\n\n            os_specific[\"distribution\"] = {\n                \"name\": distro.name(),\n                \"version\": distro.version(),\n                \"codename\": distro.codename(),\n            }\n        elif platform_system == \"Darwin\":\n            mac_version = platform.mac_ver()\n            os_specific[\"mac_ver_release\"] = mac_version[0]\n            os_specific[\"mac_ver_machine\"] = mac_version[2]\n\n        result = {\n            \"operation_system\": os.name,\n            \"platform\": platform_system,\n            \"release\": platform.release(),\n            \"version\": platform.version(),\n            \"machine\": platform.machine(),\n            \"os_specific\": os_specific,\n        }\n\n        # if config.include_all_info:\n        #     result[\"uname\"] = platform.uname()._asdict()\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.environment_type","title":"<code>environment_type: typing.Literal['operating_system']</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.operation_system","title":"<code>operation_system: str = Field(description='The operation system name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.platform","title":"<code>platform: str = Field(description='The platform name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.release","title":"<code>release: str = Field(description='The platform release name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.version","title":"<code>version: str = Field(description='The platform version name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.machine","title":"<code>machine: str = Field(description='The architecture.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.os_specific","title":"<code>os_specific: typing.Dict[str, typing.Any] = Field(description='OS specific platform metadata.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/operating_system/#kiara.models.runtime_environment.operating_system.OSRuntimeEnvironment.retrieve_environment_data","title":"<code>retrieve_environment_data() -&gt; typing.Dict[str, typing.Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/operating_system.py</code> <pre><code>@classmethod\ndef retrieve_environment_data(self) -&gt; typing.Dict[str, typing.Any]:\n\n    os_specific: typing.Dict[str, typing.Any] = {}\n    platform_system = platform.system()\n    if platform_system == \"Linux\":\n        import distro\n\n        os_specific[\"distribution\"] = {\n            \"name\": distro.name(),\n            \"version\": distro.version(),\n            \"codename\": distro.codename(),\n        }\n    elif platform_system == \"Darwin\":\n        mac_version = platform.mac_ver()\n        os_specific[\"mac_ver_release\"] = mac_version[0]\n        os_specific[\"mac_ver_machine\"] = mac_version[2]\n\n    result = {\n        \"operation_system\": os.name,\n        \"platform\": platform_system,\n        \"release\": platform.release(),\n        \"version\": platform.version(),\n        \"machine\": platform.machine(),\n        \"os_specific\": os_specific,\n    }\n\n    # if config.include_all_info:\n    #     result[\"uname\"] = platform.uname()._asdict()\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/","title":"python","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python-classes","title":"Classes","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonPackage","title":"<code>PythonPackage</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>class PythonPackage(BaseModel):\n\n    name: str = Field(description=\"The name of the Python package.\")\n    version: str = Field(description=\"The version of the package.\")\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonPackage-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonPackage.name","title":"<code>name: str = Field(description='The name of the Python package.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonPackage.version","title":"<code>version: str = Field(description='The version of the package.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment","title":"<code>PythonRuntimeEnvironment</code>","text":"<p>         Bases: <code>RuntimeEnvironment</code></p> Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>class PythonRuntimeEnvironment(RuntimeEnvironment):\n\n    _kiara_model_id = \"info.runtime.python\"\n\n    environment_type: Literal[\"python\"]\n    python_version: str = Field(description=\"The version of Python.\")\n    packages: List[PythonPackage] = Field(\n        description=\"The packages installed in the Python (virtual) environment.\"\n    )\n    # python_config: typing.Dict[str, str] = Field(\n    #     description=\"Configuration details about the Python installation.\"\n    # )\n\n    def _create_renderable_for_field(\n        self, field_name: str, for_summary: bool = False\n    ) -&gt; Union[RenderableType, None]:\n\n        if field_name != \"packages\":\n            return extract_renderable(getattr(self, field_name))\n\n        if for_summary:\n            return \", \".join(p.name for p in self.packages)\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"package name\")\n        table.add_column(\"version\")\n\n        for package in self.packages:\n            table.add_row(package.name, package.version)\n\n        return table\n\n    def _retrieve_sub_profile_env_data(self) -&gt; Mapping[str, Any]:\n\n        only_packages = [p.name for p in self.packages]\n        full = {k.name: k.version for k in self.packages}\n\n        return {\n            \"package_names\": only_packages,\n            \"packages\": full,\n            \"package_names_incl_python_version\": {\n                \"python_version\": self.python_version,\n                \"packages\": only_packages,\n            },\n            \"packages_incl_python_version\": {\n                \"python_version\": self.python_version,\n                \"packages\": full,\n            },\n        }\n\n    @classmethod\n    def retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n        packages: Dict[str, str] = {}\n        all_packages = find_all_distributions()\n        for name, pkgs in all_packages.items():\n            for pkg in pkgs:\n                dist = distribution(pkg)\n                if pkg in packages.keys() and packages[pkg] != dist.version:\n                    raise Exception(\n                        f\"Multiple versions of package '{pkg}' available: {packages[pkg]} and {dist.version}.\"\n                    )\n                packages[pkg] = dist.version\n\n        result: Dict[str, Any] = {\n            \"python_version\": sys.version,\n            \"packages\": [\n                {\"name\": p, \"version\": packages[p]}\n                for p in sorted(packages.keys(), key=lambda x: x.lower())\n            ],\n        }\n\n        # if config.include_all_info:\n        #     import sysconfig\n        #     result[\"python_config\"] = sysconfig.get_config_vars()\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment.environment_type","title":"<code>environment_type: Literal['python']</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment.python_version","title":"<code>python_version: str = Field(description='The version of Python.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment.packages","title":"<code>packages: List[PythonPackage] = Field(description='The packages installed in the Python (virtual) environment.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.PythonRuntimeEnvironment.retrieve_environment_data","title":"<code>retrieve_environment_data() -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>@classmethod\ndef retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n    packages: Dict[str, str] = {}\n    all_packages = find_all_distributions()\n    for name, pkgs in all_packages.items():\n        for pkg in pkgs:\n            dist = distribution(pkg)\n            if pkg in packages.keys() and packages[pkg] != dist.version:\n                raise Exception(\n                    f\"Multiple versions of package '{pkg}' available: {packages[pkg]} and {dist.version}.\"\n                )\n            packages[pkg] = dist.version\n\n    result: Dict[str, Any] = {\n        \"python_version\": sys.version,\n        \"packages\": [\n            {\"name\": p, \"version\": packages[p]}\n            for p in sorted(packages.keys(), key=lambda x: x.lower())\n        ],\n    }\n\n    # if config.include_all_info:\n    #     import sysconfig\n    #     result[\"python_config\"] = sysconfig.get_config_vars()\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment","title":"<code>KiaraPluginsRuntimeEnvironment</code>","text":"<p>         Bases: <code>RuntimeEnvironment</code></p> Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>class KiaraPluginsRuntimeEnvironment(RuntimeEnvironment):\n\n    _kiara_model_id = \"info.runtime.kiara_plugins\"\n\n    environment_type: Literal[\"kiara_plugins\"]\n    kiara_plugins: List[PythonPackage] = Field(\n        description=\"The kiara plugin packages installed in the Python (virtual) environment.\"\n    )\n\n    def _create_renderable_for_field(\n        self, field_name: str, for_summary: bool = False\n    ) -&gt; Union[RenderableType, None]:\n\n        if field_name != \"packages\":\n            return extract_renderable(getattr(self, field_name))\n\n        if for_summary:\n            return \", \".join(p.name for p in self.kiara_plugins)\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"package name\")\n        table.add_column(\"version\")\n\n        for package in self.kiara_plugins:\n            table.add_row(package.name, package.version)\n\n        return table\n\n    def _retrieve_sub_profile_env_data(self) -&gt; Mapping[str, Any]:\n\n        only_packages = [p.name for p in self.kiara_plugins]\n        full = {k.name: k.version for k in self.kiara_plugins}\n\n        return {\"package_names\": only_packages, \"packages\": full}\n\n    @classmethod\n    def retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n        packages = []\n        all_packages = find_all_distributions()\n        for name, pkgs in all_packages.items():\n\n            for pkg in pkgs:\n                if not pkg.startswith(\"kiara_plugin.\") and not pkg.startswith(\n                    \"kiara-plugin.\"\n                ):\n                    continue\n                dist = distribution(pkg)\n                packages.append({\"name\": pkg, \"version\": dist.version})\n\n        result: Dict[str, Any] = {\n            \"kiara_plugins\": sorted(packages, key=lambda x: x[\"name\"]),\n        }\n\n        # if config.include_all_info:\n        #     import sysconfig\n        #     result[\"python_config\"] = sysconfig.get_config_vars()\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment.environment_type","title":"<code>environment_type: Literal['kiara_plugins']</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment.kiara_plugins","title":"<code>kiara_plugins: List[PythonPackage] = Field(description='The kiara plugin packages installed in the Python (virtual) environment.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.KiaraPluginsRuntimeEnvironment.retrieve_environment_data","title":"<code>retrieve_environment_data() -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>@classmethod\ndef retrieve_environment_data(cls) -&gt; Dict[str, Any]:\n\n    packages = []\n    all_packages = find_all_distributions()\n    for name, pkgs in all_packages.items():\n\n        for pkg in pkgs:\n            if not pkg.startswith(\"kiara_plugin.\") and not pkg.startswith(\n                \"kiara-plugin.\"\n            ):\n                continue\n            dist = distribution(pkg)\n            packages.append({\"name\": pkg, \"version\": dist.version})\n\n    result: Dict[str, Any] = {\n        \"kiara_plugins\": sorted(packages, key=lambda x: x[\"name\"]),\n    }\n\n    # if config.include_all_info:\n    #     import sysconfig\n    #     result[\"python_config\"] = sysconfig.get_config_vars()\n\n    return result\n</code></pre>"},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python-functions","title":"Functions","text":""},{"location":"reference/kiara/models/runtime_environment/python/#kiara.models.runtime_environment.python.find_all_distributions","title":"<code>find_all_distributions()</code>  <code>cached</code>","text":"Source code in <code>kiara/models/runtime_environment/python.py</code> <pre><code>@lru_cache()\ndef find_all_distributions():\n    all_packages = packages_distributions()\n    return all_packages\n</code></pre>"},{"location":"reference/kiara/models/values/__init__/","title":"values","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.DEFAULT_SCALAR_DATATYPE_CHARACTERISTICS","title":"<code>DEFAULT_SCALAR_DATATYPE_CHARACTERISTICS = DataTypeCharacteristics.construct(is_scalar=True, is_json_serializable=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus","title":"<code>ValueStatus</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/models/values/__init__.py</code> <pre><code>class ValueStatus(Enum):\n\n    UNKNONW = \"unknown\"\n    NOT_SET = \"not set\"\n    NONE = \"none\"\n    DEFAULT = \"default\"\n    SET = \"set\"\n</code></pre>"},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus.UNKNONW","title":"<code>UNKNONW = 'unknown'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus.NOT_SET","title":"<code>NOT_SET = 'not set'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus.NONE","title":"<code>NONE = 'none'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus.DEFAULT","title":"<code>DEFAULT = 'default'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.ValueStatus.SET","title":"<code>SET = 'set'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.DataTypeCharacteristics","title":"<code>DataTypeCharacteristics</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/models/values/__init__.py</code> <pre><code>class DataTypeCharacteristics(BaseModel):\n\n    is_scalar: bool = Field(\n        description=\"Whether the data desribed by this data type behaves like a skalar.\",\n        default=False,\n    )\n    is_json_serializable: bool = Field(\n        description=\"Whether the data can be serialized to json without information loss.\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.DataTypeCharacteristics-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.DataTypeCharacteristics.is_scalar","title":"<code>is_scalar: bool = Field(description='Whether the data desribed by this data type behaves like a skalar.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/__init__/#kiara.models.values.DataTypeCharacteristics.is_json_serializable","title":"<code>is_json_serializable: bool = Field(description='Whether the data can be serialized to json without information loss.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/data_type/","title":"data_type","text":""},{"location":"reference/kiara/models/values/lineage/","title":"lineage","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.COLOR_LIST","title":"<code>COLOR_LIST = ['green', 'blue', 'bright_magenta', 'dark_red', 'gold3', 'cyan', 'orange1', 'light_yellow3', 'light_slate_grey', 'deep_pink4']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage","title":"<code>ValueLineage</code>","text":"<p>         Bases: <code>JupyterMixin</code></p> Source code in <code>kiara/models/values/lineage.py</code> <pre><code>class ValueLineage(JupyterMixin):\n    def __init__(self, kiara: \"Kiara\", value: Value) -&gt; None:\n\n        self._value: Value = value\n        self._kiara: Kiara = kiara\n        self._full_graph: Union[None, DiGraph] = None\n        self._module_graph: Union[None, DiGraph] = None\n\n    @property\n    def value(self) -&gt; Value:\n        return self._value\n\n    @property\n    def full_graph(self) -&gt; DiGraph:\n\n        if self._full_graph is not None:\n            return self._full_graph\n\n        self._full_graph = create_lineage_graph(kiara=self._kiara, value=self._value)\n        return self._full_graph\n\n    @property\n    def module_graph(self) -&gt; DiGraph:\n\n        if self._module_graph is not None:\n            return self._module_graph\n\n        self._module_graph = create_lineage_graph_modules(\n            kiara=self._kiara, value=self._value\n        ).reverse()\n        return self._module_graph\n\n    def as_dict(\n        self,\n        include_preview: bool = False,\n        include_module_info: bool = False,\n        ensure_json_serializable: bool = False,\n    ) -&gt; Dict[str, Any]:\n\n        data = fill_dict_with_lineage(\n            kiara=self._kiara,\n            value=self._value,\n            include_preview=include_preview,\n            include_module_info=include_module_info,\n        )\n\n        if ensure_json_serializable:\n            data = orjson.loads(orjson.dumps(data))\n\n        return data\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_ids: bool = config.get(\"include_ids\", True)\n        tree = fill_renderable_lineage_tree(\n            kiara=self._kiara, pedigree=self._value.pedigree, include_ids=include_ids\n        )\n        return tree\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -&gt; RenderResult:\n\n        yield self.create_renderable()\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage.value","title":"<code>value: Value</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage.full_graph","title":"<code>full_graph: DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage.module_graph","title":"<code>module_graph: DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage.as_dict","title":"<code>as_dict(include_preview: bool = False, include_module_info: bool = False, ensure_json_serializable: bool = False) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def as_dict(\n    self,\n    include_preview: bool = False,\n    include_module_info: bool = False,\n    ensure_json_serializable: bool = False,\n) -&gt; Dict[str, Any]:\n\n    data = fill_dict_with_lineage(\n        kiara=self._kiara,\n        value=self._value,\n        include_preview=include_preview,\n        include_module_info=include_module_info,\n    )\n\n    if ensure_json_serializable:\n        data = orjson.loads(orjson.dumps(data))\n\n    return data\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.ValueLineage.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_ids: bool = config.get(\"include_ids\", True)\n    tree = fill_renderable_lineage_tree(\n        kiara=self._kiara, pedigree=self._value.pedigree, include_ids=include_ids\n    )\n    return tree\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.fill_renderable_lineage_tree","title":"<code>fill_renderable_lineage_tree(kiara: Kiara, pedigree: ValuePedigree, node: Union[Tree, None] = None, include_ids: bool = False, level: int = 0)</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def fill_renderable_lineage_tree(\n    kiara: \"Kiara\",\n    pedigree: ValuePedigree,\n    node: Union[Tree, None] = None,\n    include_ids: bool = False,\n    level: int = 0,\n):\n\n    color = COLOR_LIST[level % len(COLOR_LIST)]\n    title = f\"[b {color}]{pedigree.module_type}[/b {color}]\"\n    if node is None:\n        main = Tree(title)\n    else:\n        main = node.add(title)\n\n    for input_name in sorted(pedigree.inputs.keys()):\n\n        child_value_id = pedigree.inputs[input_name]\n\n        child_value = kiara.data_registry.get_value(child_value_id)\n\n        value_type = child_value.data_type_name\n        if include_ids:\n            v_id_str = f\" = {child_value.value_id}\"\n        else:\n            v_id_str = \"\"\n        input_node = main.add(\n            f\"input: [i {color}]{input_name} ({value_type})[/i {color}]{v_id_str}\"\n        )\n        if child_value.pedigree != ORPHAN:\n            fill_renderable_lineage_tree(\n                kiara=kiara,\n                pedigree=child_value.pedigree,\n                node=input_node,\n                level=level + 1,\n                include_ids=include_ids,\n            )\n\n    return main\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.fill_dict_with_lineage","title":"<code>fill_dict_with_lineage(kiara: Kiara, value: Value, node: Union[Dict[str, Any], None] = None, include_preview: bool = False, include_module_info: bool = False, level: int = 0) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def fill_dict_with_lineage(\n    kiara: \"Kiara\",\n    value: Value,\n    node: Union[Dict[str, Any], None] = None,\n    include_preview: bool = False,\n    include_module_info: bool = False,\n    level: int = 0,\n) -&gt; Dict[str, Any]:\n\n    pedigree = value.pedigree\n    title = pedigree.module_type\n    if node is None:\n        root: Dict[str, Any] = {\n            \"pedigree\": {\n                \"module\": {\"name\": title, \"module_config\": pedigree.module_config},\n                \"output_name\": value.pedigree_output_name,\n                \"inputs\": {},\n            },\n            \"type\": value.data_type_name,\n            \"id\": str(value.value_id),\n        }\n        if include_preview:\n            preview = kiara.render_registry.render(\n                source_type=\"value\",\n                item=value,\n                target_type=\"string\",\n                render_config={},\n            )\n            root[\"preview\"] = preview\n        main: Dict[str, Any] = root[\"pedigree\"]\n    else:\n        node[\"inputs\"] = {}\n        node[\"module\"] = {\"name\": title, \"module_config\": pedigree.module_config}\n        main = node\n\n    if include_module_info:\n        info = kiara.module_registry.get_module_type_metadata(title)\n        main[\"module\"][\"info\"] = info.dict()\n\n    for input_name in sorted(pedigree.inputs.keys()):\n\n        child_value_id = pedigree.inputs[input_name]\n        child_value = kiara.data_registry.get_value(child_value_id)\n\n        value_type = child_value.data_type_name\n        main[\"inputs\"][input_name] = {\n            \"type\": value_type,\n            \"id\": str(child_value.value_id),\n        }\n        if include_preview:\n            preview = kiara.render_registry.render(\n                source_type=\"value\",\n                item=child_value,\n                target_type=\"string\",\n                render_config={},\n            )\n            main[\"inputs\"][input_name][\"preview\"] = preview\n\n        if child_value.pedigree != ORPHAN:\n            main[\"inputs\"][input_name][\"pedigree\"] = {}\n            fill_dict_with_lineage(\n                kiara=kiara,\n                value=child_value,\n                node=main[\"inputs\"][input_name][\"pedigree\"],\n                level=level + 1,\n                include_preview=include_preview,\n                include_module_info=include_module_info,\n            )\n\n    if node is None:\n        return root  # type: ignore\n    else:\n        return node\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.create_lineage_graph","title":"<code>create_lineage_graph(kiara: Kiara, value: Value, graph: Union[DiGraph, None] = None, parent: Union[None, str] = None, level: int = 1) -&gt; DiGraph</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def create_lineage_graph(\n    kiara: \"Kiara\",\n    value: Value,\n    graph: Union[DiGraph, None] = None,\n    parent: Union[None, str] = None,\n    level: int = 1,\n) -&gt; DiGraph:\n\n    if graph is None:\n        graph = DiGraph()\n        graph.add_node(\n            f\"value:{value.value_id}\",\n            data_type=value.data_type_name,\n            label=\"root_value\",\n            node_type=\"value\",\n            data_type_config=value.data_type_config,\n            level=1,\n        )\n        parent = f\"value:{value.value_id}\"\n\n    module_id = f\"module:{value.pedigree.job_hash}\"\n    module_label = f\"module:{value.pedigree.module_type}\"\n    graph.add_node(\n        module_id,\n        module_type=value.pedigree.module_type,\n        module_config=value.pedigree.module_config,\n        label=module_label,\n        node_type=\"operation\",\n        level=(level * 2) + 1,\n    )\n    graph.add_edge(\n        parent,\n        module_id,\n        id=f\"{parent}:{module_id}\",\n        field_name=value.pedigree_output_name,\n        label=value.pedigree_output_name,\n    )\n\n    for input_name in sorted(value.pedigree.inputs.keys()):\n\n        child_value_id = value.pedigree.inputs[input_name]\n        child_value = kiara.data_registry.get_value(child_value_id)\n\n        input_id = f\"value:{child_value.value_id}\"\n        input_label = f\"{input_name}:{input_name}\"\n\n        graph.add_node(\n            input_id,\n            label=input_label,\n            node_type=\"value\",\n            data_type=child_value.data_type_name,\n            data_type_config=child_value.data_type_config,\n            level=(level * 2) + 2,\n        )\n        graph.add_edge(\n            module_id,\n            input_id,\n            id=f\"{module_id}:{input_id}\",\n            field_name=input_name,\n            label=input_name,\n        )\n\n        if child_value.pedigree != ORPHAN:\n            create_lineage_graph(\n                kiara=kiara,\n                value=child_value,\n                graph=graph,\n                parent=input_id,\n                level=level + 1,\n            )\n    return graph\n</code></pre>"},{"location":"reference/kiara/models/values/lineage/#kiara.models.values.lineage.create_lineage_graph_modules","title":"<code>create_lineage_graph_modules(kiara: Kiara, value: Value, graph: Union[DiGraph, None] = None, parent: Union[None, str] = None, input_field: Union[None, str] = None, level: int = 1) -&gt; DiGraph</code>","text":"Source code in <code>kiara/models/values/lineage.py</code> <pre><code>def create_lineage_graph_modules(\n    kiara: \"Kiara\",\n    value: Value,\n    graph: Union[DiGraph, None] = None,\n    parent: Union[None, str] = None,\n    input_field: Union[None, str] = None,\n    level: int = 1,\n) -&gt; DiGraph:\n\n    if graph is None:\n        graph = DiGraph()\n        graph.add_node(\n            f\"value:{value.value_id}\",\n            data_type=value.data_type_name,\n            label=\"[this value]\",\n            node_type=\"value\",\n            data_type_config=value.data_type_config,\n            level=1,\n        )\n\n    module_id = f\"module:{value.pedigree.job_hash}\"\n    module_label = value.pedigree.module_type\n    graph.add_node(\n        module_id,\n        module_type=value.pedigree.module_type,\n        module_config=value.pedigree.module_config,\n        label=module_label,\n        node_type=\"operation\",\n        level=(level * 2) + 1,\n    )\n\n    if parent is None:\n        parent = f\"value:{value.value_id}\"\n        graph.add_edge(\n            parent,\n            module_id,\n            id=f\"{parent}:{module_id}\",\n            field_name=value.pedigree_output_name,\n            label=f\"{value.pedigree_output_name} ({value.data_type_name})\",\n        )\n    else:\n        assert input_field is not None\n        graph.add_edge(\n            parent,\n            module_id,\n            id=f\"{parent}:{input_field}\",\n            field_name=input_field,\n            label=f\"{input_field} ({value.data_type_name})\",\n        )\n\n    for input_name in sorted(value.pedigree.inputs.keys()):\n\n        child_value_id = value.pedigree.inputs[input_name]\n        child_value = kiara.data_registry.get_value(child_value_id)\n\n        if child_value.pedigree != ORPHAN:\n            create_lineage_graph_modules(\n                kiara=kiara,\n                value=child_value,\n                graph=graph,\n                parent=module_id,\n                input_field=input_name,\n                level=level + 1,\n            )\n        else:\n            input_id = f\"value:{child_value.value_id}\"\n            input_label = f\"{input_name} ({child_value.data_type_name})\"\n\n            graph.add_node(\n                input_id,\n                label=input_label,\n                node_type=\"value\",\n                data_type=child_value.data_type_name,\n                data_type_config=child_value.data_type_config,\n                level=(level * 2) + 2,\n            )\n            graph.add_edge(\n                module_id,\n                input_id,\n                id=f\"{module_id}:{input_id}\",\n                field_name=input_name,\n                label=f\"{input_name} ({child_value.data_type_name})\",\n            )\n\n    return graph\n</code></pre>"},{"location":"reference/kiara/models/values/matchers/","title":"matchers","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher","title":"<code>ValueMatcher</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>An object describing requirements values should satisfy in order to be included in a query result.</p> Source code in <code>kiara/models/values/matchers.py</code> <pre><code>class ValueMatcher(KiaraModel):\n\"\"\"An object describing requirements values should satisfy in order to be included in a query result.\"\"\"\n\n    @classmethod\n    def create_matcher(self, **match_options: Any):\n\n        m = ValueMatcher(**match_options)\n        return m\n\n    data_types: List[str] = Field(description=\"The data type.\", default_factory=list)\n    allow_sub_types: bool = Field(description=\"Allow subtypes.\", default=True)\n    min_size: int = Field(description=\"The minimum size for the dataset.\", default=0)\n    max_size: Union[None, int] = Field(\n        description=\"The maximum size for the dataset.\", default=None\n    )\n    allow_internal: bool = Field(\n        description=\"Allow internal data types.\", default=False\n    )\n    has_alias: bool = Field(\n        description=\"Value must have at least one alias.\", default=True\n    )\n\n    def is_match(self, value: Value, kiara: \"Kiara\") -&gt; bool:\n        if self.data_types:\n            match = False\n            if not self.allow_sub_types:\n                for data_type in self.data_types:\n                    if data_type == value.data_type_name:\n                        match = True\n                        break\n            else:\n                if value.data_type_name not in kiara.type_registry.data_type_names:\n                    return False\n                lineage = kiara.type_registry.get_type_lineage(value.data_type_name)\n                for data_type in self.data_types:\n                    if data_type in lineage:\n                        match = True\n                        break\n            if not match:\n                return False\n\n        if self.min_size:\n            if value.value_size &lt; self.min_size:\n                return False\n        if self.max_size:\n            if value.value_size &gt; self.max_size:\n                return False\n\n        if not self.allow_internal:\n            if kiara.type_registry.is_internal_type(\n                data_type_name=value.data_type_name\n            ):\n                return False\n\n        if self.has_alias:\n            aliases = kiara.alias_registry.find_aliases_for_value_id(\n                value_id=value.value_id\n            )\n            if not aliases:\n                return False\n\n        return True\n</code></pre>"},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.data_types","title":"<code>data_types: List[str] = Field(description='The data type.', default_factory=list)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.allow_sub_types","title":"<code>allow_sub_types: bool = Field(description='Allow subtypes.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.min_size","title":"<code>min_size: int = Field(description='The minimum size for the dataset.', default=0)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.max_size","title":"<code>max_size: Union[None, int] = Field(description='The maximum size for the dataset.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.allow_internal","title":"<code>allow_internal: bool = Field(description='Allow internal data types.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.has_alias","title":"<code>has_alias: bool = Field(description='Value must have at least one alias.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.create_matcher","title":"<code>create_matcher(**match_options: Any)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/matchers.py</code> <pre><code>@classmethod\ndef create_matcher(self, **match_options: Any):\n\n    m = ValueMatcher(**match_options)\n    return m\n</code></pre>"},{"location":"reference/kiara/models/values/matchers/#kiara.models.values.matchers.ValueMatcher.is_match","title":"<code>is_match(value: Value, kiara: Kiara) -&gt; bool</code>","text":"Source code in <code>kiara/models/values/matchers.py</code> <pre><code>def is_match(self, value: Value, kiara: \"Kiara\") -&gt; bool:\n    if self.data_types:\n        match = False\n        if not self.allow_sub_types:\n            for data_type in self.data_types:\n                if data_type == value.data_type_name:\n                    match = True\n                    break\n        else:\n            if value.data_type_name not in kiara.type_registry.data_type_names:\n                return False\n            lineage = kiara.type_registry.get_type_lineage(value.data_type_name)\n            for data_type in self.data_types:\n                if data_type in lineage:\n                    match = True\n                    break\n        if not match:\n            return False\n\n    if self.min_size:\n        if value.value_size &lt; self.min_size:\n            return False\n    if self.max_size:\n        if value.value_size &gt; self.max_size:\n            return False\n\n    if not self.allow_internal:\n        if kiara.type_registry.is_internal_type(\n            data_type_name=value.data_type_name\n        ):\n            return False\n\n    if self.has_alias:\n        aliases = kiara.alias_registry.find_aliases_for_value_id(\n            value_id=value.value_id\n        )\n        if not aliases:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/kiara/models/values/value/","title":"value","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.log","title":"<code>log = logging.getLogger('kiara')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.yaml","title":"<code>yaml = StringYAML()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SERIALIZE_TYPES","title":"<code>SERIALIZE_TYPES = {'chunk': SerializedBytes, 'chunks': SerializedListOfBytes, 'file': SerializedFile, 'files': SerializedFiles, 'inline-json': SerializedInlineJson, 'chunk-ids': SerializedChunkIDs}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ORPHAN","title":"<code>ORPHAN = ValuePedigree(kiara_id=VOID_KIARA_ID, environments={}, module_type=NO_MODULE_TYPE, inputs={})</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks","title":"<code>SerializedChunks</code>","text":"<p>         Bases: <code>BaseModel</code>, <code>abc.ABC</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedChunks(BaseModel, abc.ABC):\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n        extra = Extra.forbid\n\n    _size_cache: Union[int, None] = PrivateAttr(default=None)\n    _hashes_cache: Dict[str, Sequence[CID]] = PrivateAttr(default_factory=dict)\n\n    @abc.abstractmethod\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n\"\"\"Retrieve the chunks belonging to this data instance.\n\n        If 'as_file' is False, return the data as bytes. If set to 'True' store it to an arbitrary location (or use\n        an existing one), and return the path to that file. If 'as_file' is a string, write the data (bytes) into\n        a new file using the string as path. If 'symlink_ok' is set to True, symlinking an existing file to the value of\n        'as_file' is also ok, otherwise copy the content.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_number_of_chunks(self) -&gt; int:\n        pass\n\n    @abc.abstractmethod\n    def _get_size(self) -&gt; int:\n        pass\n\n    @abc.abstractmethod\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        pass\n\n    def get_size(self) -&gt; int:\n\n        if self._size_cache is None:\n            self._size_cache = self._get_size()\n        return self._size_cache\n\n    def get_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n\n        if self._hashes_cache.get(hash_codec, None) is None:\n            self._hashes_cache[hash_codec] = self._create_cids(hash_codec=hash_codec)\n        return self._hashes_cache[hash_codec]\n\n    def _store_bytes_to_file(\n        self, chunks: Iterable[bytes], file: Union[str, None] = None\n    ) -&gt; str:\n        \"Utility method to store bytes to a file.\"\n\n        if file is None:\n            file_desc, file = tempfile.mkstemp()\n\n            def del_temp_file():\n                os.remove(file)\n\n            atexit.register(del_temp_file)\n\n        else:\n            if os.path.exists(file):\n                raise Exception(f\"Can't write to file, file exists: {file}\")\n            file_desc = os.open(file, 0o600)\n\n        with os.fdopen(file_desc, \"wb\") as tmp:\n            for chunk in chunks:\n                tmp.write(chunk)\n\n        return file\n\n    def _read_bytes_from_file(self, file: str) -&gt; bytes:\n\n        with open(file, \"rb\") as f:\n            content = f.read()\n\n        return content\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n    extra = Extra.forbid\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6 <code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>  <code>abstractmethod</code>","text":"<p>Retrieve the chunks belonging to this data instance.</p> <p>If 'as_file' is False, return the data as bytes. If set to 'True' store it to an arbitrary location (or use an existing one), and return the path to that file. If 'as_file' is a string, write the data (bytes) into a new file using the string as path. If 'symlink_ok' is set to True, symlinking an existing file to the value of 'as_file' is also ok, otherwise copy the content.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n\"\"\"Retrieve the chunks belonging to this data instance.\n\n    If 'as_file' is False, return the data as bytes. If set to 'True' store it to an arbitrary location (or use\n    an existing one), and return the path to that file. If 'as_file' is a string, write the data (bytes) into\n    a new file using the string as path. If 'symlink_ok' is set to True, symlinking an existing file to the value of\n    'as_file' is also ok, otherwise copy the content.\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_number_of_chunks(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.get_size","title":"<code>get_size() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_size(self) -&gt; int:\n\n    if self._size_cache is None:\n        self._size_cache = self._get_size()\n    return self._size_cache\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunks.get_cids","title":"<code>get_cids(hash_codec: str) -&gt; Sequence[CID]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n\n    if self._hashes_cache.get(hash_codec, None) is None:\n        self._hashes_cache[hash_codec] = self._create_cids(hash_codec=hash_codec)\n    return self._hashes_cache[hash_codec]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedPreStoreChunks","title":"<code>SerializedPreStoreChunks</code>","text":"<p>         Bases: <code>SerializedChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedPreStoreChunks(SerializedChunks):\n\n    codec: str = Field(\n        description=\"The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table.\"\n    )\n\n    def _create_cid_from_chunk(self, chunk: bytes, hash_codec: str) -&gt; CID:\n\n        multihash = Multihash(codec=hash_codec)\n        hash = multihash.digest(chunk)\n        return create_cid_digest(digest=hash, codec=self.codec)\n\n    def _create_cid_from_file(self, file: str, hash_codec: str) -&gt; CID:\n\n        assert hash_codec == \"sha2-256\"\n\n        hash_func = hashlib.sha256\n        file_hash = hash_func()\n\n        CHUNK_SIZE = 65536\n        with open(file, \"rb\") as f:\n            fb = f.read(CHUNK_SIZE)\n            while len(fb) &gt; 0:\n                file_hash.update(fb)\n                fb = f.read(CHUNK_SIZE)\n\n        wrapped = multihash.wrap(file_hash.digest(), \"sha2-256\")\n        return create_cid_digest(digest=wrapped, codec=self.codec)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedPreStoreChunks-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedPreStoreChunks.codec","title":"<code>codec: str = Field(description='The codec used to encode the chunks in this model. Using the [multicodecs](https://github.com/multiformats/multicodec) codec table.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes","title":"<code>SerializedBytes</code>","text":"<p>         Bases: <code>SerializedPreStoreChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedBytes(SerializedPreStoreChunks):\n\n    type: Literal[\"chunk\"] = \"chunk\"\n    chunk: bytes = Field(description=\"A byte-array\")\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n\n        if as_files is False:\n            return [self.chunk]\n        else:\n            if as_files is True:\n                file = None\n            elif isinstance(as_files, str):\n                file = as_files\n            else:\n                assert len(as_files) == 1\n                file = as_files[0]\n            path = self._store_bytes_to_file([self.chunk], file=file)\n            return path\n\n    def get_number_of_chunks(self) -&gt; int:\n        return 1\n\n    def _get_size(self) -&gt; int:\n        return len(self.chunk)\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        return [self._create_cid_from_chunk(self.chunk, hash_codec=hash_codec)]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes.type","title":"<code>type: Literal['chunk'] = 'chunk'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes.chunk","title":"<code>chunk: bytes = Field(description='A byte-array')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n\n    if as_files is False:\n        return [self.chunk]\n    else:\n        if as_files is True:\n            file = None\n        elif isinstance(as_files, str):\n            file = as_files\n        else:\n            assert len(as_files) == 1\n            file = as_files[0]\n        path = self._store_bytes_to_file([self.chunk], file=file)\n        return path\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedBytes.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return 1\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes","title":"<code>SerializedListOfBytes</code>","text":"<p>         Bases: <code>SerializedPreStoreChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedListOfBytes(SerializedPreStoreChunks):\n\n    type: Literal[\"chunks\"] = \"chunks\"\n    chunks: List[bytes] = Field(description=\"A list of byte arrays.\")\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n        if as_files is False:\n            return self.chunks\n        else:\n            if as_files is None or as_files is True or isinstance(as_files, str):\n                # means we write all the chunks into one file\n                file = None if as_files is True else as_files\n                path = self._store_bytes_to_file(self.chunks, file=file)\n                return [path]\n            else:\n                assert len(as_files) == self.get_number_of_chunks()\n                result = []\n                for idx, chunk in enumerate(self.chunks):\n                    _file = as_files[idx]\n                    path = self._store_bytes_to_file([chunk], file=_file)\n                    result.append(path)\n                return result\n\n    def get_number_of_chunks(self) -&gt; int:\n        return len(self.chunks)\n\n    def _get_size(self) -&gt; int:\n        size = 0\n        for chunk in self.chunks:\n            size = size + len(chunk)\n        return size\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        return [\n            self._create_cid_from_chunk(chunk, hash_codec=hash_codec)\n            for chunk in self.chunks\n        ]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes.type","title":"<code>type: Literal['chunks'] = 'chunks'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes.chunks","title":"<code>chunks: List[bytes] = Field(description='A list of byte arrays.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n    if as_files is False:\n        return self.chunks\n    else:\n        if as_files is None or as_files is True or isinstance(as_files, str):\n            # means we write all the chunks into one file\n            file = None if as_files is True else as_files\n            path = self._store_bytes_to_file(self.chunks, file=file)\n            return [path]\n        else:\n            assert len(as_files) == self.get_number_of_chunks()\n            result = []\n            for idx, chunk in enumerate(self.chunks):\n                _file = as_files[idx]\n                path = self._store_bytes_to_file([chunk], file=_file)\n                result.append(path)\n            return result\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedListOfBytes.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return len(self.chunks)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile","title":"<code>SerializedFile</code>","text":"<p>         Bases: <code>SerializedPreStoreChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedFile(SerializedPreStoreChunks):\n\n    type: Literal[\"file\"] = \"file\"\n    file: str = Field(description=\"A path to a file containing the serialized data.\")\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n\n        if as_files is False:\n            chunk = self._read_bytes_from_file(self.file)\n            return [chunk]\n        else:\n            if as_files is True:\n                return [self.file]\n            else:\n                if isinstance(as_files, str):\n                    file = as_files\n                else:\n                    assert len(as_files) == 1\n                    file = as_files[0]\n                if os.path.exists(file):\n                    raise Exception(f\"Can't write to file '{file}': file exists.\")\n                if symlink_ok:\n                    os.symlink(self.file, file)\n                    return [file]\n                else:\n                    raise NotImplementedError()\n\n    def get_number_of_chunks(self) -&gt; int:\n        return 1\n\n    def _get_size(self) -&gt; int:\n        return os.path.getsize(os.path.realpath(self.file))\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        return [self._create_cid_from_file(self.file, hash_codec=hash_codec)]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile.type","title":"<code>type: Literal['file'] = 'file'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile.file","title":"<code>file: str = Field(description='A path to a file containing the serialized data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n\n    if as_files is False:\n        chunk = self._read_bytes_from_file(self.file)\n        return [chunk]\n    else:\n        if as_files is True:\n            return [self.file]\n        else:\n            if isinstance(as_files, str):\n                file = as_files\n            else:\n                assert len(as_files) == 1\n                file = as_files[0]\n            if os.path.exists(file):\n                raise Exception(f\"Can't write to file '{file}': file exists.\")\n            if symlink_ok:\n                os.symlink(self.file, file)\n                return [file]\n            else:\n                raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFile.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return 1\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles","title":"<code>SerializedFiles</code>","text":"<p>         Bases: <code>SerializedPreStoreChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedFiles(SerializedPreStoreChunks):\n\n    type: Literal[\"files\"] = \"files\"\n    files: List[str] = Field(\n        description=\"A list of strings, pointing to files containing parts of the serialized data.\"\n    )\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n        raise NotImplementedError()\n\n    def get_number_of_chunks(self) -&gt; int:\n        return len(self.files)\n\n    def _get_size(self) -&gt; int:\n\n        size = 0\n        for file in self.files:\n            size = size + os.path.getsize(os.path.realpath(file))\n        return size\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        return [\n            self._create_cid_from_file(file, hash_codec=hash_codec)\n            for file in self.files\n        ]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles.type","title":"<code>type: Literal['files'] = 'files'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles.files","title":"<code>files: List[str] = Field(description='A list of strings, pointing to files containing parts of the serialized data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedFiles.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return len(self.files)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson","title":"<code>SerializedInlineJson</code>","text":"<p>         Bases: <code>SerializedPreStoreChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedInlineJson(SerializedPreStoreChunks):\n\n    type: Literal[\"inline-json\"] = \"inline-json\"\n    inline_data: Any = Field(\n        description=\"Data that will not be stored externally, but inline in the containing model. This should only contain data types that can be serialized reliably using json (scalars, etc.).\"\n    )\n    _json_cache: Union[bytes, None] = PrivateAttr(default=None)\n\n    def as_json(self) -&gt; bytes:\n        assert self.inline_data is not None\n        if self._json_cache is None:\n            self._json_cache = orjson.dumps(\n                self.inline_data,\n                option=orjson.OPT_NON_STR_KEYS,\n            )\n        return self._json_cache\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n\n        if as_files is False:\n            return [self.as_json()]\n        else:\n            raise NotImplementedError()\n\n    def get_number_of_chunks(self) -&gt; int:\n        return 1\n\n    def _get_size(self) -&gt; int:\n        return len(self.as_json())\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n        return [self._create_cid_from_chunk(self.as_json(), hash_codec=hash_codec)]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson.type","title":"<code>type: Literal['inline-json'] = 'inline-json'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson.inline_data","title":"<code>inline_data: Any = Field(description='Data that will not be stored externally, but inline in the containing model. This should only contain data types that can be serialized reliably using json (scalars, etc.).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson.as_json","title":"<code>as_json() -&gt; bytes</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def as_json(self) -&gt; bytes:\n    assert self.inline_data is not None\n    if self._json_cache is None:\n        self._json_cache = orjson.dumps(\n            self.inline_data,\n            option=orjson.OPT_NON_STR_KEYS,\n        )\n    return self._json_cache\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n\n    if as_files is False:\n        return [self.as_json()]\n    else:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedInlineJson.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return 1\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs","title":"<code>SerializedChunkIDs</code>","text":"<p>         Bases: <code>SerializedChunks</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedChunkIDs(SerializedChunks):\n\n    type: Literal[\"chunk-ids\"] = \"chunk-ids\"\n    chunk_id_list: List[str] = Field(\n        description=\"A list of chunk ids, which will be resolved via the attached data registry.\"\n    )\n    archive_id: Union[uuid.UUID, None] = Field(\n        description=\"The preferred data archive to get the chunks from.\"\n    )\n    size: int = Field(description=\"The size of all chunks combined.\")\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n\n    def get_chunks(\n        self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n    ) -&gt; Iterable[Union[str, BytesLike]]:\n\n        if isinstance(as_files, (bool, str)):\n            return (\n                self._data_registry.retrieve_chunk(\n                    chunk_id=chunk,\n                    archive_id=self.archive_id,\n                    as_file=as_files,\n                    symlink_ok=symlink_ok,\n                )\n                for chunk in self.chunk_id_list\n            )\n        else:\n            result = []\n            for idx, chunk_id in enumerate(self.chunk_id_list):\n                file = as_files[idx]\n                self._data_registry.retrieve_chunk(\n                    chunk_id=chunk_id,\n                    archive_id=self.archive_id,\n                    as_file=file,\n                    symlink_ok=symlink_ok,\n                )\n                result.append(file)\n            return result\n\n    def get_number_of_chunks(self) -&gt; int:\n        return len(self.chunk_id_list)\n\n    def _get_size(self) -&gt; int:\n        return self.size\n\n    def _create_cids(self, hash_codec: str) -&gt; Sequence[CID]:\n\n        result = []\n        for chunk_id in self.chunk_id_list:\n            cid = CID.decode(chunk_id)\n            result.append(cid)\n\n        return result\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.type","title":"<code>type: Literal['chunk-ids'] = 'chunk-ids'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.chunk_id_list","title":"<code>chunk_id_list: List[str] = Field(description='A list of chunk ids, which will be resolved via the attached data registry.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.archive_id","title":"<code>archive_id: Union[uuid.UUID, None] = Field(description='The preferred data archive to get the chunks from.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.size","title":"<code>size: int = Field(description='The size of all chunks combined.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.get_chunks","title":"<code>get_chunks(as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True) -&gt; Iterable[Union[str, BytesLike]]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_chunks(\n    self, as_files: Union[bool, str, Sequence[str]] = True, symlink_ok: bool = True\n) -&gt; Iterable[Union[str, BytesLike]]:\n\n    if isinstance(as_files, (bool, str)):\n        return (\n            self._data_registry.retrieve_chunk(\n                chunk_id=chunk,\n                archive_id=self.archive_id,\n                as_file=as_files,\n                symlink_ok=symlink_ok,\n            )\n            for chunk in self.chunk_id_list\n        )\n    else:\n        result = []\n        for idx, chunk_id in enumerate(self.chunk_id_list):\n            file = as_files[idx]\n            self._data_registry.retrieve_chunk(\n                chunk_id=chunk_id,\n                archive_id=self.archive_id,\n                as_file=file,\n                symlink_ok=symlink_ok,\n            )\n            result.append(file)\n        return result\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedChunkIDs.get_number_of_chunks","title":"<code>get_number_of_chunks() -&gt; int</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_number_of_chunks(self) -&gt; int:\n    return len(self.chunk_id_list)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationMetadata","title":"<code>SerializationMetadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializationMetadata(KiaraModel):\n\n    _kiara_model_id = \"metadata.serialized_data\"\n\n    environment: Mapping[str, int] = Field(\n        description=\"Hash(es) for the environments the value was created/serialized.\",\n        default_factory=dict,\n    )\n    deserialize: Mapping[str, Manifest] = Field(\n        description=\"Suggested manifest configs to use to de-serialize the data.\",\n        default_factory=dict,\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationMetadata.environment","title":"<code>environment: Mapping[str, int] = Field(description='Hash(es) for the environments the value was created/serialized.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationMetadata.deserialize","title":"<code>deserialize: Mapping[str, Manifest] = Field(description='Suggested manifest configs to use to de-serialize the data.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData","title":"<code>SerializedData</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializedData(KiaraModel):\n\n    data_type: str = Field(\n        description=\"The name of the data type for this serialized value.\"\n    )\n    data_type_config: Mapping[str, Any] = Field(\n        description=\"The (optional) config for the data type for this serialized value.\",\n        default_factory=dict,\n    )\n    serialization_profile: str = Field(\n        description=\"An identifying name for the serialization method used.\"\n    )\n    metadata: SerializationMetadata = Field(\n        description=\"Optional metadata describing aspects of the serialization used.\",\n        default_factory=SerializationMetadata,\n    )\n\n    hash_codec: str = Field(\n        description=\"The codec used to hash the value.\", default=\"sha2-256\"\n    )\n    _cids_cache: Dict[str, Sequence[CID]] = PrivateAttr(default_factory=dict)\n\n    _cached_data_size: Union[int, None] = PrivateAttr(default=None)\n    _cached_dag: Union[Dict[str, Sequence[CID]], None] = PrivateAttr(default=None)\n    # _cached_cid: Optional[CID] = PrivateAttr(default=None)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n\n        return self.dag\n\n    @property\n    def data_size(self) -&gt; int:\n        if self._cached_data_size is not None:\n            return self._cached_data_size\n\n        size = 0\n        for k in self.get_keys():\n            model = self.get_serialized_data(k)\n            size = size + model.get_size()\n        self._cached_data_size = size\n        return self._cached_data_size\n\n    @abc.abstractmethod\n    def get_keys(self) -&gt; Iterable[str]:\n        pass\n\n    @abc.abstractmethod\n    def get_serialized_data(self, key: str) -&gt; SerializedChunks:\n        pass\n\n    def get_cids_for_key(self, key) -&gt; Sequence[CID]:\n\n        if key in self._cids_cache.keys():\n            return self._cids_cache[key]\n\n        model = self.get_serialized_data(key)\n        self._cids_cache[key] = model.get_cids(hash_codec=self.hash_codec)\n        return self._cids_cache[key]\n\n    @property\n    def dag(self) -&gt; Mapping[str, Sequence[CID]]:\n\n        if self._cached_dag is not None:\n            return self._cached_dag\n\n        dag: Dict[str, Sequence[CID]] = {}\n        for key in self.get_keys():\n            dag[key] = self.get_cids_for_key(key)\n\n        self._cached_dag = dag\n        return self._cached_dag\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.data_type","title":"<code>data_type: str = Field(description='The name of the data type for this serialized value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.data_type_config","title":"<code>data_type_config: Mapping[str, Any] = Field(description='The (optional) config for the data type for this serialized value.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.serialization_profile","title":"<code>serialization_profile: str = Field(description='An identifying name for the serialization method used.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.metadata","title":"<code>metadata: SerializationMetadata = Field(description='Optional metadata describing aspects of the serialization used.', default_factory=SerializationMetadata)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.hash_codec","title":"<code>hash_codec: str = Field(description='The codec used to hash the value.', default='sha2-256')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.data_size","title":"<code>data_size: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.dag","title":"<code>dag: Mapping[str, Sequence[CID]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.get_keys","title":"<code>get_keys() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_keys(self) -&gt; Iterable[str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.get_serialized_data","title":"<code>get_serialized_data(key: str) -&gt; SerializedChunks</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_serialized_data(self, key: str) -&gt; SerializedChunks:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializedData.get_cids_for_key","title":"<code>get_cids_for_key(key) -&gt; Sequence[CID]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_cids_for_key(self, key) -&gt; Sequence[CID]:\n\n    if key in self._cids_cache.keys():\n        return self._cids_cache[key]\n\n    model = self.get_serialized_data(key)\n    self._cids_cache[key] = model.get_cids(hash_codec=self.hash_codec)\n    return self._cids_cache[key]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult","title":"<code>SerializationResult</code>","text":"<p>         Bases: <code>SerializedData</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class SerializationResult(SerializedData):\n\n    _kiara_model_id = \"instance.serialization_result\"\n\n    data: Dict[\n        str,\n        Union[\n            SerializedBytes,\n            SerializedListOfBytes,\n            SerializedFile,\n            SerializedFiles,\n            SerializedInlineJson,\n        ],\n    ] = Field(\n        description=\"One or several byte arrays representing the serialized state of the value.\"\n    )\n\n    def get_keys(self) -&gt; Iterable[str]:\n        return self.data.keys()\n\n    def get_serialized_data(self, key: str) -&gt; SerializedChunks:\n        return self.data[key]\n\n    @root_validator(pre=True)\n    def validate_data(cls, values):\n\n        codec = values.get(\"codec\", None)\n        if codec is None:\n            codec = \"sha2-256\"\n            values[\"hash_codec\"] = codec\n\n        v = values.get(\"data\")\n        assert isinstance(v, Mapping)\n\n        result = {}\n        for field_name, data in v.items():\n            if isinstance(data, SerializedChunks):\n                result[field_name] = data\n            elif isinstance(data, Mapping):\n                s_type = data.get(\"type\", None)\n                if not s_type:\n                    raise ValueError(\n                        f\"Invalid serialized data config, missing 'type' key: {data}\"\n                    )\n\n                if s_type not in SERIALIZE_TYPES.keys():\n                    raise ValueError(\n                        f\"Invalid serialized data type '{s_type}'. Allowed types: {', '.join(SERIALIZE_TYPES.keys())}\"\n                    )\n\n                assert s_type != \"chunk-ids\"\n                cls = SERIALIZE_TYPES[s_type]\n                result[field_name] = cls(**data)\n\n        values[\"data\"] = result\n        return values\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"key\")\n        table.add_column(\"value\")\n        table.add_row(\"data_type\", self.data_type)\n        _config = Syntax(\n            orjson_dumps(self.data_type_config), \"json\", background_color=\"default\"\n        )\n        table.add_row(\"data_type_config\", _config)\n\n        data_fields = {}\n        for field, model in self.data.items():\n            data_fields[field] = {\"type\": model.type}\n        data_json = Syntax(\n            orjson_dumps(data_fields), \"json\", background_color=\"default\"\n        )\n        table.add_row(\"data\", data_json)\n        table.add_row(\"size\", str(self.data_size))\n        table.add_row(\"hash\", self.instance_id)\n\n        return table\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(type={self.data_type} size={self.data_size})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult.data","title":"<code>data: Dict[str, Union[SerializedBytes, SerializedListOfBytes, SerializedFile, SerializedFiles, SerializedInlineJson]] = Field(description='One or several byte arrays representing the serialized state of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult.get_keys","title":"<code>get_keys() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_keys(self) -&gt; Iterable[str]:\n    return self.data.keys()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult.get_serialized_data","title":"<code>get_serialized_data(key: str) -&gt; SerializedChunks</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_serialized_data(self, key: str) -&gt; SerializedChunks:\n    return self.data[key]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult.validate_data","title":"<code>validate_data(values)</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@root_validator(pre=True)\ndef validate_data(cls, values):\n\n    codec = values.get(\"codec\", None)\n    if codec is None:\n        codec = \"sha2-256\"\n        values[\"hash_codec\"] = codec\n\n    v = values.get(\"data\")\n    assert isinstance(v, Mapping)\n\n    result = {}\n    for field_name, data in v.items():\n        if isinstance(data, SerializedChunks):\n            result[field_name] = data\n        elif isinstance(data, Mapping):\n            s_type = data.get(\"type\", None)\n            if not s_type:\n                raise ValueError(\n                    f\"Invalid serialized data config, missing 'type' key: {data}\"\n                )\n\n            if s_type not in SERIALIZE_TYPES.keys():\n                raise ValueError(\n                    f\"Invalid serialized data type '{s_type}'. Allowed types: {', '.join(SERIALIZE_TYPES.keys())}\"\n                )\n\n            assert s_type != \"chunk-ids\"\n            cls = SERIALIZE_TYPES[s_type]\n            result[field_name] = cls(**data)\n\n    values[\"data\"] = result\n    return values\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.SerializationResult.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\")\n    table.add_column(\"value\")\n    table.add_row(\"data_type\", self.data_type)\n    _config = Syntax(\n        orjson_dumps(self.data_type_config), \"json\", background_color=\"default\"\n    )\n    table.add_row(\"data_type_config\", _config)\n\n    data_fields = {}\n    for field, model in self.data.items():\n        data_fields[field] = {\"type\": model.type}\n    data_json = Syntax(\n        orjson_dumps(data_fields), \"json\", background_color=\"default\"\n    )\n    table.add_row(\"data\", data_json)\n    table.add_row(\"size\", str(self.data_size))\n    table.add_row(\"hash\", self.instance_id)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData","title":"<code>PersistedData</code>","text":"<p>         Bases: <code>SerializedData</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class PersistedData(SerializedData):\n\n    _kiara_model_id = \"instance.persisted_data\"\n\n    archive_id: uuid.UUID = Field(\n        description=\"The id of the store that persisted the data.\"\n    )\n    chunk_id_map: Mapping[str, SerializedChunkIDs] = Field(\n        description=\"Reference-ids that resolve to the values' serialized chunks.\"\n    )\n\n    def get_keys(self) -&gt; Iterable[str]:\n        return self.chunk_id_map.keys()\n\n    def get_serialized_data(self, key: str) -&gt; SerializedChunks:\n        return self.chunk_id_map[key]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData.archive_id","title":"<code>archive_id: uuid.UUID = Field(description='The id of the store that persisted the data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData.chunk_id_map","title":"<code>chunk_id_map: Mapping[str, SerializedChunkIDs] = Field(description=\"Reference-ids that resolve to the values' serialized chunks.\")</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData.get_keys","title":"<code>get_keys() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_keys(self) -&gt; Iterable[str]:\n    return self.chunk_id_map.keys()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.PersistedData.get_serialized_data","title":"<code>get_serialized_data(key: str) -&gt; SerializedChunks</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_serialized_data(self, key: str) -&gt; SerializedChunks:\n    return self.chunk_id_map[key]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValuePedigree","title":"<code>ValuePedigree</code>","text":"<p>         Bases: <code>InputsManifest</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValuePedigree(InputsManifest):\n\n    _kiara_model_id = \"instance.value_pedigree\"\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The id of the kiara context a value was created in.\"\n    )\n    environments: Dict[str, str] = Field(\n        description=\"References to the runtime environment details a value was created in.\"\n    )\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            \"manifest\": self.manifest_cid,\n            \"inputs\": self.inputs_cid,\n            \"environments\": self.environments,\n        }\n\n    def __repr__(self):\n        return f\"ValuePedigree(module_type={self.module_type}, inputs=[{', '.join(self.inputs.keys())}], instance_id={self.instance_id})\"\n\n    def __str__(self):\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValuePedigree-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValuePedigree.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context a value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValuePedigree.environments","title":"<code>environments: Dict[str, str] = Field(description='References to the runtime environment details a value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo","title":"<code>DataTypeInfo</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class DataTypeInfo(KiaraModel):\n\n    _kiara_model_id = \"info.data_type_instance\"\n\n    data_type_name: str = Field(description=\"The registered name of this data type.\")\n    data_type_config: Mapping[str, Any] = Field(\n        description=\"The (optional) configuration for this data type.\",\n        default_factory=dict,\n    )\n    characteristics: DataTypeCharacteristics = Field(\n        description=\"Characteristics of this data type.\"\n    )\n    data_type_class: PythonClass = Field(\n        description=\"The python class that is associated with this model.\"\n    )\n    _data_type_instance: \"DataType\" = PrivateAttr(default=None)\n\n    @property\n    def data_type_instance(self) -&gt; \"DataType\":\n\n        if self._data_type_instance is not None:\n            return self._data_type_instance\n\n        self._data_type_instance = self.data_type_class.get_class()(\n            **self.data_type_config\n        )\n        return self._data_type_instance\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo.data_type_name","title":"<code>data_type_name: str = Field(description='The registered name of this data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo.data_type_config","title":"<code>data_type_config: Mapping[str, Any] = Field(description='The (optional) configuration for this data type.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo.characteristics","title":"<code>characteristics: DataTypeCharacteristics = Field(description='Characteristics of this data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo.data_type_class","title":"<code>data_type_class: PythonClass = Field(description='The python class that is associated with this model.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.DataTypeInfo.data_type_instance","title":"<code>data_type_instance: DataType</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails","title":"<code>ValueDetails</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A wrapper class that manages and retieves value data and its details.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValueDetails(KiaraModel):\n\"\"\"A wrapper class that manages and retieves value data and its details.\"\"\"\n\n    _kiara_model_id = \"instance.value_details\"\n\n    value_id: uuid.UUID = Field(description=\"The id of the value.\")\n\n    kiara_id: uuid.UUID = Field(\n        description=\"The id of the kiara context this value belongs to.\"\n    )\n\n    value_schema: ValueSchema = Field(\n        description=\"The schema that was used for this Value.\"\n    )\n\n    value_status: ValueStatus = Field(description=\"The set/unset status of this value.\")\n    value_size: int = Field(description=\"The size of this value, in bytes.\")\n    value_hash: str = Field(description=\"The hash of this value.\")\n    pedigree: ValuePedigree = Field(\n        description=\"Information about the module and inputs that went into creating this value.\"\n    )\n    pedigree_output_name: str = Field(\n        description=\"The output name that produced this value (using the manifest inside the pedigree).\"\n    )\n    data_type_info: DataTypeInfo = Field(\n        description=\"Information about the data type this value is made of.\"\n    )\n\n    def _retrieve_id(self) -&gt; str:\n        return str(self.value_id)\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            \"value_type\": self.value_schema.type,\n            \"value_hash\": self.value_hash,\n            \"value_size\": self.value_size,\n        }\n\n    @property\n    def data_type_name(self) -&gt; str:\n        return self.data_type_info.data_type_name\n\n    @property\n    def data_type_config(self) -&gt; Mapping[str, Any]:\n        return self.data_type_info.data_type_config\n\n    @property\n    def is_optional(self) -&gt; bool:\n        return self.value_schema.optional\n\n    @property\n    def is_valid(self) -&gt; bool:\n\"\"\"Check whether the current value is valid\"\"\"\n\n        if self.is_optional:\n            return True\n        else:\n            return self.value_status == ValueStatus.SET\n\n    @property\n    def is_set(self) -&gt; bool:\n        return self.value_status in [ValueStatus.SET, ValueStatus.DEFAULT]\n\n    @property\n    def value_status_string(self) -&gt; str:\n\"\"\"Print a human readable short description of this values status.\"\"\"\n\n        if self.value_status == ValueStatus.DEFAULT:\n            return \"set (default)\"\n        elif self.value_status == ValueStatus.SET:\n            return \"set\"\n        elif self.value_status == ValueStatus.NONE:\n            result = \"no value\"\n        elif self.value_status == ValueStatus.NOT_SET:\n            result = \"not set\"\n        else:\n            raise Exception(\n                f\"Invalid internal status of value '{self.value_id}'. This is most likely a bug.\"\n            )\n\n        if self.is_optional:\n            result = f\"{result} (not required)\"\n        return result\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(id={self.value_id}, type={self.data_type_name}, status={self.value_status.value})\"\n\n    def __str__(self):\n\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_id","title":"<code>value_id: uuid.UUID = Field(description='The id of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.kiara_id","title":"<code>kiara_id: uuid.UUID = Field(description='The id of the kiara context this value belongs to.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_schema","title":"<code>value_schema: ValueSchema = Field(description='The schema that was used for this Value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_status","title":"<code>value_status: ValueStatus = Field(description='The set/unset status of this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_size","title":"<code>value_size: int = Field(description='The size of this value, in bytes.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_hash","title":"<code>value_hash: str = Field(description='The hash of this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.pedigree","title":"<code>pedigree: ValuePedigree = Field(description='Information about the module and inputs that went into creating this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.pedigree_output_name","title":"<code>pedigree_output_name: str = Field(description='The output name that produced this value (using the manifest inside the pedigree).')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.data_type_info","title":"<code>data_type_info: DataTypeInfo = Field(description='Information about the data type this value is made of.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.data_type_name","title":"<code>data_type_name: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.data_type_config","title":"<code>data_type_config: Mapping[str, Any]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.is_optional","title":"<code>is_optional: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.is_valid","title":"<code>is_valid: bool</code>  <code>property</code>","text":"<p>Check whether the current value is valid</p>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.is_set","title":"<code>is_set: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueDetails.value_status_string","title":"<code>value_status_string: str</code>  <code>property</code>","text":"<p>Print a human readable short description of this values status.</p>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value","title":"<code>Value</code>","text":"<p>         Bases: <code>ValueDetails</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class Value(ValueDetails):\n\n    _kiara_model_id = \"instance.value\"\n\n    _value_data: Any = PrivateAttr(default=SpecialValue.NOT_SET)\n    _serialized_data: Union[None, str, SerializedData] = PrivateAttr(default=None)\n    _data_retrieved: bool = PrivateAttr(default=False)\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n    # _data_type: \"DataType\" = PrivateAttr(default=None)\n    _is_stored: bool = PrivateAttr(default=False)\n    _cached_properties: Union[\"ValueMap\", None] = PrivateAttr(default=None)\n    _lineage: Union[\"ValueLineage\", None] = PrivateAttr(default=None)\n\n    environment_hashes: Mapping[str, Mapping[str, str]] = Field(\n        description=\"Hashes for the environments this value was created in.\"\n    )\n    enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(\n        description=\"Information about the environments this value was created in.\",\n        default=None,\n    )\n    property_links: Mapping[str, uuid.UUID] = Field(\n        description=\"Links to values that are properties of this value.\",\n        default_factory=dict,\n    )\n    destiny_backlinks: Mapping[uuid.UUID, str] = Field(\n        description=\"Backlinks to values that this value acts as destiny/or property for.\",\n        default_factory=dict,\n    )\n\n    def add_property(\n        self,\n        value_id: Union[uuid.UUID, \"Value\"],\n        property_path: str,\n        add_origin_to_property_value: bool = True,\n    ):\n\n        value = None\n        try:\n            value_temp = value\n            value_id = value_id.value_id  # type: ignore\n            value = value_temp\n        except Exception:\n            # in case a Value object was provided\n            pass\n        finally:\n            del value_temp\n\n        if add_origin_to_property_value:\n            if value is None:\n                value = self._data_registry.get_value(value=value_id)  # type: ignore\n\n            if value._is_stored:\n                raise Exception(\n                    f\"Can't add property to value '{self.value_id}': referenced value '{value.value_id}' already locked, so it's not possible to add the property backlink (as requested).\"\n                )\n\n        assert value is not None\n\n        if self._is_stored:\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': value already locked.\"\n            )\n\n        if property_path in self.property_links.keys():\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': property '{property_path}' already set.\"\n            )\n\n        self.property_links[property_path] = value_id  # type: ignore\n\n        if add_origin_to_property_value:\n            value.add_destiny_details(\n                value_id=self.value_id, destiny_alias=property_path\n            )\n\n        self._cached_properties = None\n\n    def add_destiny_details(self, value_id: uuid.UUID, destiny_alias: str):\n\n        if self._is_stored:\n            raise Exception(\n                f\"Can't set destiny_refs to value '{self.value_id}': value already locked.\"\n            )\n\n        self.destiny_backlinks[value_id] = destiny_alias  # type: ignore\n\n    @property\n    def is_serializable(self) -&gt; bool:\n\n        try:\n            if self._serialized_data == NO_SERIALIZATION_MARKER:\n                return False\n            self.serialized_data\n            return True\n        except Exception:\n            pass\n\n        return False\n\n    # @property\n    # def data_type_class(self) -&gt; \"PythonClass\":\n    #     \"\"\"Return the (Python) type of the underlying 'DataType' subclass.\"\"\"\n    #     return self.data_type_info.data_type_class\n\n    @property\n    def serialized_data(self) -&gt; SerializedData:\n\n        # if not self.is_set:\n        #     raise Exception(f\"Can't retrieve serialized data: value not set.\")\n\n        if self._serialized_data is not None:\n            if isinstance(self._serialized_data, str):\n                raise Exception(\n                    f\"Data type '{self.data_type_name}' does not support serializing: {self._serialized_data}\"\n                )\n\n            return self._serialized_data\n\n        self._serialized_data = self._data_registry.retrieve_persisted_value_details(\n            self.value_id\n        )\n        return self._serialized_data\n\n    @property\n    def data(self) -&gt; Any:\n        if not self.is_initialized:\n            raise Exception(\n                f\"Can't retrieve data for value '{self.value_id}': value not initialized yet. This is most likely a bug.\"\n            )\n        try:\n            return self._retrieve_data()\n        except DataTypeUnknownException as dtue:\n            dtue._value = self\n            raise dtue\n\n    def _retrieve_data(self) -&gt; Any:\n\n        if self._value_data is not SpecialValue.NOT_SET:\n            return self._value_data\n\n        if self.value_status in [ValueStatus.NOT_SET, ValueStatus.NONE]:\n            self._value_data = None\n            return self._value_data\n        elif self.value_status not in [ValueStatus.SET, ValueStatus.DEFAULT]:\n            raise Exception(f\"Invalid internal state of value '{self.value_id}'.\")\n\n        retrieved = self._data_registry.retrieve_value_data(value=self)\n\n        if retrieved is None or isinstance(retrieved, SpecialValue):\n            raise Exception(\n                f\"Can't set value data, invalid data type: {type(retrieved)}\"\n            )\n\n        self._value_data = retrieved\n        self._data_retrieved = True\n        return self._value_data\n\n    # def retrieve_load_config(self) -&gt; Optional[LoadConfig]:\n    #     return self._data_registry.retrieve_persisted_value_details(\n    #         value_id=self.value_id\n    #     )\n\n    def __repr__(self):\n\n        return f\"{self.__class__.__name__}(id={self.value_id}, type={self.data_type_name}, status={self.value_status.value}, initialized={self.is_initialized} optional={self.value_schema.optional})\"\n\n    def _set_registry(self, data_registry: \"DataRegistry\") -&gt; None:\n        self._data_registry = data_registry\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        result = not self.is_set or self._data_registry is not None\n        return result\n\n    @property\n    def is_stored(self) -&gt; bool:\n        return self._is_stored\n\n    @property\n    def data_type(self) -&gt; \"DataType\":\n\n        return self.data_type_info.data_type_instance\n\n    @property\n    def lineage(self) -&gt; \"ValueLineage\":\n        if self._lineage is not None:\n            return self._lineage\n\n        from kiara.models.values.lineage import ValueLineage\n\n        self._lineage = ValueLineage(kiara=self._data_registry._kiara, value=self)\n        return self._lineage\n\n    @property\n    def property_values(self) -&gt; \"ValueMap\":\n\n        if self._cached_properties is not None:\n            return self._cached_properties\n\n        self._cached_properties = self._data_registry.load_values(self.property_links)\n        return self._cached_properties\n\n    @property\n    def property_names(self) -&gt; Iterable[str]:\n        return self.property_links.keys()\n\n    def get_property_value(self, property_key) -&gt; \"Value\":\n\n        if property_key not in self.property_links.keys():\n            raise Exception(\n                f\"Value '{self.value_id}' has no property with key '{property_key}.\"\n            )\n\n        return self._data_registry.get_value(self.property_links[property_key])\n\n    def get_property_data(self, property_key: str) -&gt; Any:\n\n        try:\n            return self.get_property_value(property_key=property_key).data\n        except Exception as e:\n            log_exception(e)\n            return None\n\n    def get_all_property_data(self) -&gt; Mapping[str, Any]:\n\n        return {k: self.get_property_data(k) for k in self.property_names}\n\n    def lookup_self_aliases(self) -&gt; Set[str]:\n\n        if not self._data_registry:\n            raise Exception(\n                f\"Can't lookup aliases for value '{self.value_id}': data registry not set (yet).\"\n            )\n\n        return self._data_registry.lookup_aliases(self)\n\n    def create_info(self) -&gt; \"ValueInfo\":\n\n        if not self._data_registry:\n            raise Exception(\n                f\"Can't create info object for value '{self.value_id}': data registry not set (yet).\"\n            )\n\n        return self._data_registry.create_value_info(value=self.value_id)\n\n    def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n        show_pedigree = config.get(\"show_pedigree\", False)\n        show_lineage = config.get(\"show_lineage\", False)\n        show_properties = config.get(\"show_properties\", False)\n        # show_destinies = config.get(\"show_destinies\", False)\n        # show_destiny_backlinks = config.get(\"show_destiny_backlinks\", False)\n        # show_data = config.get(\"show_data_preview\", False)\n        show_serialized = config.get(\"show_serialized\", False)\n        show_env_data_hashes = config.get(\"show_environment_hashes\", False)\n        show_env_data = config.get(\"show_environment_data\", False)\n\n        ignore_fields = config.get(\"ignore_fields\", [])\n\n        table: Dict[str, Any] = {}\n\n        if \"value_id\" not in ignore_fields:\n            table[\"value_id\"] = self.value_id\n        if \"aliases\" not in ignore_fields:\n            if hasattr(self, \"aliases\"):\n                table[\"aliases\"] = self.aliases  # type: ignore\n\n        if \"kiara_id\" not in ignore_fields:\n            table[\"kiara_id\"] = self.kiara_id\n\n        for k in sorted(self.__fields__.keys()):\n\n            if (\n                k\n                in [\n                    \"serialized\",\n                    \"value_id\",\n                    \"aliases\",\n                    \"kiara_id\",\n                    \"environments\",\n                    \"lineage\",\n                    \"environment_hashes\",\n                ]\n                or k in ignore_fields\n            ):\n                continue\n\n            attr = getattr(self, k)\n            if k in [\"pedigree_output_name\", \"pedigree\"]:\n                continue\n            else:\n                v = attr\n\n            table[k] = v\n\n        if show_pedigree:\n            pedigree = getattr(self, \"pedigree\")\n\n            table[\"pedigree\"] = pedigree\n            if pedigree == ORPHAN:\n                pedigree_output_name: Union[Any, None] = None\n            else:\n                pedigree_output_name = getattr(self, \"pedigree_output_name\")\n\n            table[\"pedigree_output_name\"] = pedigree_output_name\n\n        if show_lineage:\n            table[\"lineage\"] = self.lineage\n\n        if show_serialized:\n            serialized = self._data_registry.retrieve_persisted_value_details(\n                self.value_id\n            )\n            table[\"serialized\"] = serialized\n\n        if show_env_data_hashes:\n            env_hashes = Syntax(\n                orjson_dumps(self.environment_hashes, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            table[\"environment_hashes\"] = env_hashes\n\n        if show_env_data:\n            raise NotImplementedError()\n\n        if show_properties:\n            if not self.property_links:\n                table[\"properties\"] = {}\n            else:\n                properties = self._data_registry.load_values(self.property_links)\n                table[\"properties\"] = properties\n\n        # if hasattr(self, \"destiny_links\") and show_destinies:\n        #     if not self.destiny_links:  # type: ignore\n        #         table[\"destinies\"] = {}\n        #     else:\n        #         destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n        #         table[\"destinies\"] = destinies\n        #\n        # if show_destiny_backlinks:\n        #     if not self.destiny_backlinks:\n        #         table[\"destiny backlinks\"] = {}\n        #     else:\n        #         destiny_items: List[Any] = []\n        #         for v_id, alias in self.destiny_backlinks.items():\n        #             destiny_items.append(\n        #                 f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n        #             )\n        #             rendered = self._data_registry.pretty_print_data(\n        #                 value_id=v_id, **config\n        #             )\n        #             destiny_items.append(rendered)\n        #         table[\"destiny backlinks\"] = destiny_items\n        #\n        # if show_data:\n        #     rendered = self._data_registry.pretty_print_data(\n        #         self.value_id, target_type=\"terminal_renderable\"\n        #     )\n        #     table[\"data preview\"] = rendered\n\n        return table\n\n    def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n        from kiara.utils.output import extract_renderable\n\n        show_pedigree = render_config.get(\"show_pedigree\", False)\n        show_lineage = render_config.get(\"show_lineage\", False)\n        show_properties = render_config.get(\"show_properties\", False)\n        show_destinies = render_config.get(\"show_destinies\", False)\n        show_destiny_backlinks = render_config.get(\"show_destiny_backlinks\", False)\n        show_data = render_config.get(\"show_data_preview\", False)\n        show_serialized = render_config.get(\"show_serialized\", False)\n        show_env_data_hashes = render_config.get(\"show_environment_hashes\", False)\n        show_env_data = render_config.get(\"show_environment_data\", False)\n\n        ignore_fields = render_config.get(\"ignore_fields\", [])\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n\n        info_data = self.create_info_data(**render_config)\n\n        if \"value_id\" not in ignore_fields:\n            table.add_row(\"value_id\", str(info_data[\"value_id\"]))\n        if \"aliases\" not in ignore_fields:\n            if info_data.get(\"aliases\", None):\n                aliases_str = \", \".join(info_data[\"aliases\"])  # type: ignore\n                table.add_row(\"aliases\", aliases_str)\n            # else:\n            #     aliases_str = \"-- n/a --\"\n            #     table.add_row(\"aliases\", aliases_str)\n\n        if \"kiara_id\" not in ignore_fields:\n            table.add_row(\"kiara_id\", str(info_data[\"kiara_id\"]))\n\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        for k in sorted(info_data.keys()):\n\n            if (\n                k\n                in [\n                    \"serialized\",\n                    \"value_id\",\n                    \"aliases\",\n                    \"kiara_id\",\n                    \"lineage\",\n                    \"environments\",\n                    \"environment_hashes\",\n                ]\n                or k in ignore_fields\n            ):\n                continue\n\n            attr = info_data[k]\n            if k in [\"pedigree_output_name\", \"pedigree\"]:\n                continue\n\n            elif k == \"value_status\":\n                v: RenderableType = f\"[i]-- {attr.value} --[/i]\"\n            elif k == \"value_size\":\n                v = format_size(attr)\n            else:\n                v = extract_renderable(attr)\n\n            table.add_row(k, v)\n\n        if (\n            show_pedigree\n            or show_lineage\n            or show_serialized\n            or show_properties\n            or show_destinies\n            or show_destiny_backlinks\n            or show_env_data_hashes\n            or show_env_data\n        ):\n            table.add_row(\"\", \"\")\n            table.add_row(\"\", Rule())\n            table.add_row(\"\", \"\")\n\n        if show_pedigree:\n            pedigree = info_data[\"pedigree\"]\n\n            if pedigree == ORPHAN:\n                v = \"[i]-- external data --[/i]\"\n                pedigree_output_name: Union[Any, None] = None\n            else:\n                v = extract_renderable(pedigree)\n                pedigree_output_name = info_data[\"pedigree_output_name\"]\n\n            row = [\"pedigree\", v]\n            table.add_row(*row)\n            if pedigree_output_name:\n                row = [\"pedigree_output_name\", pedigree_output_name]\n                table.add_row(*row)\n\n        if show_lineage:\n            table.add_row(\n                \"lineage\", info_data[\"lineage\"].create_renderable(include_ids=True)\n            )\n\n        if show_serialized:\n            serialized = info_data[\"serialized\"]\n            table.add_row(\"serialized\", serialized.create_renderable())\n\n        if show_env_data_hashes:\n            env_hashes = Syntax(\n                orjson_dumps(\n                    info_data[\"environment_hashes\"], option=orjson.OPT_INDENT_2\n                ),\n                \"json\",\n                background_color=\"default\",\n            )\n            table.add_row(\"environment_hashes\", env_hashes)\n\n        if show_env_data:\n            raise NotImplementedError()\n\n        if show_properties:\n            if not info_data[\"properties\"]:\n                table.add_row(\"properties\", \"{}\")\n            else:\n                properties = info_data[\"properties\"]\n                pr = properties.create_renderable(show_header=False)\n                table.add_row(\"properties\", pr)\n\n        if hasattr(self, \"destiny_links\") and show_destinies:\n            if not self.destiny_links:  # type: ignore\n                table.add_row(\"destinies\", \"{}\")\n            else:\n                destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n                dr = destinies.create_renderable(show_header=False)\n                table.add_row(\"destinies\", dr)\n\n        if show_destiny_backlinks:\n            if not self.destiny_backlinks:\n                table.add_row(\"destiny backlinks\", \"{}\")\n            else:\n                destiny_items: List[Any] = []\n                for v_id, alias in self.destiny_backlinks.items():\n                    destiny_items.append(Rule())\n                    destiny_items.append(\n                        f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n                    )\n                    rendered = self._data_registry.pretty_print_data(\n                        value_id=v_id, **render_config\n                    )\n                    destiny_items.append(rendered)\n                table.add_row(\"destiny backlinks\", Group(*destiny_items))\n\n        if show_data:\n            rendered = self._data_registry.pretty_print_data(\n                self.value_id, target_type=\"terminal_renderable\"\n            )\n            table.add_row(\"\", \"\")\n            table.add_row(\"\", Rule())\n            table.add_row(\"data preview\", rendered)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.environment_hashes","title":"<code>environment_hashes: Mapping[str, Mapping[str, str]] = Field(description='Hashes for the environments this value was created in.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.enviroments","title":"<code>enviroments: Union[Mapping[str, Mapping[str, Any]], None] = Field(description='Information about the environments this value was created in.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.property_links","title":"<code>property_links: Mapping[str, uuid.UUID] = Field(description='Links to values that are properties of this value.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.destiny_backlinks","title":"<code>destiny_backlinks: Mapping[uuid.UUID, str] = Field(description='Backlinks to values that this value acts as destiny/or property for.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.is_serializable","title":"<code>is_serializable: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.serialized_data","title":"<code>serialized_data: SerializedData</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.data","title":"<code>data: Any</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.is_initialized","title":"<code>is_initialized: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.is_stored","title":"<code>is_stored: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.data_type","title":"<code>data_type: DataType</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.lineage","title":"<code>lineage: ValueLineage</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.property_values","title":"<code>property_values: ValueMap</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.property_names","title":"<code>property_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.add_property","title":"<code>add_property(value_id: Union[uuid.UUID, Value], property_path: str, add_origin_to_property_value: bool = True)</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def add_property(\n    self,\n    value_id: Union[uuid.UUID, \"Value\"],\n    property_path: str,\n    add_origin_to_property_value: bool = True,\n):\n\n    value = None\n    try:\n        value_temp = value\n        value_id = value_id.value_id  # type: ignore\n        value = value_temp\n    except Exception:\n        # in case a Value object was provided\n        pass\n    finally:\n        del value_temp\n\n    if add_origin_to_property_value:\n        if value is None:\n            value = self._data_registry.get_value(value=value_id)  # type: ignore\n\n        if value._is_stored:\n            raise Exception(\n                f\"Can't add property to value '{self.value_id}': referenced value '{value.value_id}' already locked, so it's not possible to add the property backlink (as requested).\"\n            )\n\n    assert value is not None\n\n    if self._is_stored:\n        raise Exception(\n            f\"Can't add property to value '{self.value_id}': value already locked.\"\n        )\n\n    if property_path in self.property_links.keys():\n        raise Exception(\n            f\"Can't add property to value '{self.value_id}': property '{property_path}' already set.\"\n        )\n\n    self.property_links[property_path] = value_id  # type: ignore\n\n    if add_origin_to_property_value:\n        value.add_destiny_details(\n            value_id=self.value_id, destiny_alias=property_path\n        )\n\n    self._cached_properties = None\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.add_destiny_details","title":"<code>add_destiny_details(value_id: uuid.UUID, destiny_alias: str)</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def add_destiny_details(self, value_id: uuid.UUID, destiny_alias: str):\n\n    if self._is_stored:\n        raise Exception(\n            f\"Can't set destiny_refs to value '{self.value_id}': value already locked.\"\n        )\n\n    self.destiny_backlinks[value_id] = destiny_alias  # type: ignore\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.get_property_value","title":"<code>get_property_value(property_key) -&gt; Value</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_property_value(self, property_key) -&gt; \"Value\":\n\n    if property_key not in self.property_links.keys():\n        raise Exception(\n            f\"Value '{self.value_id}' has no property with key '{property_key}.\"\n        )\n\n    return self._data_registry.get_value(self.property_links[property_key])\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.get_property_data","title":"<code>get_property_data(property_key: str) -&gt; Any</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_property_data(self, property_key: str) -&gt; Any:\n\n    try:\n        return self.get_property_value(property_key=property_key).data\n    except Exception as e:\n        log_exception(e)\n        return None\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.get_all_property_data","title":"<code>get_all_property_data() -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_property_data(self) -&gt; Mapping[str, Any]:\n\n    return {k: self.get_property_data(k) for k in self.property_names}\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.lookup_self_aliases","title":"<code>lookup_self_aliases() -&gt; Set[str]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def lookup_self_aliases(self) -&gt; Set[str]:\n\n    if not self._data_registry:\n        raise Exception(\n            f\"Can't lookup aliases for value '{self.value_id}': data registry not set (yet).\"\n        )\n\n    return self._data_registry.lookup_aliases(self)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.create_info","title":"<code>create_info() -&gt; ValueInfo</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_info(self) -&gt; \"ValueInfo\":\n\n    if not self._data_registry:\n        raise Exception(\n            f\"Can't create info object for value '{self.value_id}': data registry not set (yet).\"\n        )\n\n    return self._data_registry.create_value_info(value=self.value_id)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.create_info_data","title":"<code>create_info_data(**config: Any) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_info_data(self, **config: Any) -&gt; Mapping[str, Any]:\n\n    show_pedigree = config.get(\"show_pedigree\", False)\n    show_lineage = config.get(\"show_lineage\", False)\n    show_properties = config.get(\"show_properties\", False)\n    # show_destinies = config.get(\"show_destinies\", False)\n    # show_destiny_backlinks = config.get(\"show_destiny_backlinks\", False)\n    # show_data = config.get(\"show_data_preview\", False)\n    show_serialized = config.get(\"show_serialized\", False)\n    show_env_data_hashes = config.get(\"show_environment_hashes\", False)\n    show_env_data = config.get(\"show_environment_data\", False)\n\n    ignore_fields = config.get(\"ignore_fields\", [])\n\n    table: Dict[str, Any] = {}\n\n    if \"value_id\" not in ignore_fields:\n        table[\"value_id\"] = self.value_id\n    if \"aliases\" not in ignore_fields:\n        if hasattr(self, \"aliases\"):\n            table[\"aliases\"] = self.aliases  # type: ignore\n\n    if \"kiara_id\" not in ignore_fields:\n        table[\"kiara_id\"] = self.kiara_id\n\n    for k in sorted(self.__fields__.keys()):\n\n        if (\n            k\n            in [\n                \"serialized\",\n                \"value_id\",\n                \"aliases\",\n                \"kiara_id\",\n                \"environments\",\n                \"lineage\",\n                \"environment_hashes\",\n            ]\n            or k in ignore_fields\n        ):\n            continue\n\n        attr = getattr(self, k)\n        if k in [\"pedigree_output_name\", \"pedigree\"]:\n            continue\n        else:\n            v = attr\n\n        table[k] = v\n\n    if show_pedigree:\n        pedigree = getattr(self, \"pedigree\")\n\n        table[\"pedigree\"] = pedigree\n        if pedigree == ORPHAN:\n            pedigree_output_name: Union[Any, None] = None\n        else:\n            pedigree_output_name = getattr(self, \"pedigree_output_name\")\n\n        table[\"pedigree_output_name\"] = pedigree_output_name\n\n    if show_lineage:\n        table[\"lineage\"] = self.lineage\n\n    if show_serialized:\n        serialized = self._data_registry.retrieve_persisted_value_details(\n            self.value_id\n        )\n        table[\"serialized\"] = serialized\n\n    if show_env_data_hashes:\n        env_hashes = Syntax(\n            orjson_dumps(self.environment_hashes, option=orjson.OPT_INDENT_2),\n            \"json\",\n            background_color=\"default\",\n        )\n        table[\"environment_hashes\"] = env_hashes\n\n    if show_env_data:\n        raise NotImplementedError()\n\n    if show_properties:\n        if not self.property_links:\n            table[\"properties\"] = {}\n        else:\n            properties = self._data_registry.load_values(self.property_links)\n            table[\"properties\"] = properties\n\n    # if hasattr(self, \"destiny_links\") and show_destinies:\n    #     if not self.destiny_links:  # type: ignore\n    #         table[\"destinies\"] = {}\n    #     else:\n    #         destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n    #         table[\"destinies\"] = destinies\n    #\n    # if show_destiny_backlinks:\n    #     if not self.destiny_backlinks:\n    #         table[\"destiny backlinks\"] = {}\n    #     else:\n    #         destiny_items: List[Any] = []\n    #         for v_id, alias in self.destiny_backlinks.items():\n    #             destiny_items.append(\n    #                 f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n    #             )\n    #             rendered = self._data_registry.pretty_print_data(\n    #                 value_id=v_id, **config\n    #             )\n    #             destiny_items.append(rendered)\n    #         table[\"destiny backlinks\"] = destiny_items\n    #\n    # if show_data:\n    #     rendered = self._data_registry.pretty_print_data(\n    #         self.value_id, target_type=\"terminal_renderable\"\n    #     )\n    #     table[\"data preview\"] = rendered\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.Value.create_renderable","title":"<code>create_renderable(**render_config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_renderable(self, **render_config: Any) -&gt; RenderableType:\n\n    from kiara.utils.output import extract_renderable\n\n    show_pedigree = render_config.get(\"show_pedigree\", False)\n    show_lineage = render_config.get(\"show_lineage\", False)\n    show_properties = render_config.get(\"show_properties\", False)\n    show_destinies = render_config.get(\"show_destinies\", False)\n    show_destiny_backlinks = render_config.get(\"show_destiny_backlinks\", False)\n    show_data = render_config.get(\"show_data_preview\", False)\n    show_serialized = render_config.get(\"show_serialized\", False)\n    show_env_data_hashes = render_config.get(\"show_environment_hashes\", False)\n    show_env_data = render_config.get(\"show_environment_data\", False)\n\n    ignore_fields = render_config.get(\"ignore_fields\", [])\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"Key\", style=\"i\")\n    table.add_column(\"Value\")\n\n    info_data = self.create_info_data(**render_config)\n\n    if \"value_id\" not in ignore_fields:\n        table.add_row(\"value_id\", str(info_data[\"value_id\"]))\n    if \"aliases\" not in ignore_fields:\n        if info_data.get(\"aliases\", None):\n            aliases_str = \", \".join(info_data[\"aliases\"])  # type: ignore\n            table.add_row(\"aliases\", aliases_str)\n        # else:\n        #     aliases_str = \"-- n/a --\"\n        #     table.add_row(\"aliases\", aliases_str)\n\n    if \"kiara_id\" not in ignore_fields:\n        table.add_row(\"kiara_id\", str(info_data[\"kiara_id\"]))\n\n    table.add_row(\"\", \"\")\n    table.add_row(\"\", Rule())\n    for k in sorted(info_data.keys()):\n\n        if (\n            k\n            in [\n                \"serialized\",\n                \"value_id\",\n                \"aliases\",\n                \"kiara_id\",\n                \"lineage\",\n                \"environments\",\n                \"environment_hashes\",\n            ]\n            or k in ignore_fields\n        ):\n            continue\n\n        attr = info_data[k]\n        if k in [\"pedigree_output_name\", \"pedigree\"]:\n            continue\n\n        elif k == \"value_status\":\n            v: RenderableType = f\"[i]-- {attr.value} --[/i]\"\n        elif k == \"value_size\":\n            v = format_size(attr)\n        else:\n            v = extract_renderable(attr)\n\n        table.add_row(k, v)\n\n    if (\n        show_pedigree\n        or show_lineage\n        or show_serialized\n        or show_properties\n        or show_destinies\n        or show_destiny_backlinks\n        or show_env_data_hashes\n        or show_env_data\n    ):\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        table.add_row(\"\", \"\")\n\n    if show_pedigree:\n        pedigree = info_data[\"pedigree\"]\n\n        if pedigree == ORPHAN:\n            v = \"[i]-- external data --[/i]\"\n            pedigree_output_name: Union[Any, None] = None\n        else:\n            v = extract_renderable(pedigree)\n            pedigree_output_name = info_data[\"pedigree_output_name\"]\n\n        row = [\"pedigree\", v]\n        table.add_row(*row)\n        if pedigree_output_name:\n            row = [\"pedigree_output_name\", pedigree_output_name]\n            table.add_row(*row)\n\n    if show_lineage:\n        table.add_row(\n            \"lineage\", info_data[\"lineage\"].create_renderable(include_ids=True)\n        )\n\n    if show_serialized:\n        serialized = info_data[\"serialized\"]\n        table.add_row(\"serialized\", serialized.create_renderable())\n\n    if show_env_data_hashes:\n        env_hashes = Syntax(\n            orjson_dumps(\n                info_data[\"environment_hashes\"], option=orjson.OPT_INDENT_2\n            ),\n            \"json\",\n            background_color=\"default\",\n        )\n        table.add_row(\"environment_hashes\", env_hashes)\n\n    if show_env_data:\n        raise NotImplementedError()\n\n    if show_properties:\n        if not info_data[\"properties\"]:\n            table.add_row(\"properties\", \"{}\")\n        else:\n            properties = info_data[\"properties\"]\n            pr = properties.create_renderable(show_header=False)\n            table.add_row(\"properties\", pr)\n\n    if hasattr(self, \"destiny_links\") and show_destinies:\n        if not self.destiny_links:  # type: ignore\n            table.add_row(\"destinies\", \"{}\")\n        else:\n            destinies = self._data_registry.load_values(self.destiny_links)  # type: ignore\n            dr = destinies.create_renderable(show_header=False)\n            table.add_row(\"destinies\", dr)\n\n    if show_destiny_backlinks:\n        if not self.destiny_backlinks:\n            table.add_row(\"destiny backlinks\", \"{}\")\n        else:\n            destiny_items: List[Any] = []\n            for v_id, alias in self.destiny_backlinks.items():\n                destiny_items.append(Rule())\n                destiny_items.append(\n                    f\"[b]Value: [i]{v_id}[/i] (destiny alias: {alias})[/b]\"\n                )\n                rendered = self._data_registry.pretty_print_data(\n                    value_id=v_id, **render_config\n                )\n                destiny_items.append(rendered)\n            table.add_row(\"destiny backlinks\", Group(*destiny_items))\n\n    if show_data:\n        rendered = self._data_registry.pretty_print_data(\n            self.value_id, target_type=\"terminal_renderable\"\n        )\n        table.add_row(\"\", \"\")\n        table.add_row(\"\", Rule())\n        table.add_row(\"data preview\", rendered)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.UnloadableData","title":"<code>UnloadableData</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>A special 'marker' model, indicating that the data of value can't be loaded.</p> <p>In most cases, the reason this happens is because the current kiara context is missing some value types and/or modules.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class UnloadableData(KiaraModel):\n\"\"\"A special 'marker' model, indicating that the data of value can't be loaded.\n\n    In most cases, the reason this happens is because the current kiara context is missing some value types and/or modules.\"\"\"\n\n    _kiara_model_id = \"instance.unloadable_data\"\n\n    value: Value = Field(description=\"A reference to the value.\")\n\n    def _retrieve_id(self) -&gt; str:\n        return self.value.instance_id\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return self.value.value_id.bytes\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.UnloadableData-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.UnloadableData.value","title":"<code>value: Value = Field(description='A reference to the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap","title":"<code>ValueMap</code>","text":"<p>         Bases: <code>KiaraModel</code>, <code>MutableMapping[str, Value]</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValueMap(KiaraModel, MutableMapping[str, Value]):  # type: ignore\n\n    values_schema: Dict[str, ValueSchema] = Field(\n        description=\"The schemas for all the values in this set.\"\n    )\n\n    @property\n    def field_names(self) -&gt; Iterable[str]:\n        return sorted(self.values_schema.keys())\n\n    @abc.abstractmethod\n    def get_value_obj(self, field_name: str) -&gt; Value:\n        pass\n\n    @property\n    def all_items_valid(self) -&gt; bool:\n        for field_name in self.values_schema.keys():\n            item = self.get_value_obj(field_name)\n            if not item.is_valid:\n                return False\n        return True\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\n            k: self.get_value_obj(k).instance_cid for k in self.values_schema.keys()\n        }\n\n    def check_invalid(self) -&gt; Dict[str, str]:\n\"\"\"Check whether the value set is invalid, if it is, return a description of what's wrong.\"\"\"\n\n        invalid: Dict[str, str] = {}\n        for field_name in self.values_schema.keys():\n\n            item = self.get_value_obj(field_name)\n            field_schema = self.values_schema[field_name]\n            if not field_schema.optional:\n                msg: Union[str, None] = None\n                if not item.value_status == ValueStatus.SET:\n\n                    item_schema = self.values_schema[field_name]\n                    if item_schema.is_required():\n\n                        if not item.is_set:\n                            msg = \"not set\"\n                        elif item.value_status == ValueStatus.NONE:\n                            msg = \"no value\"\n                if msg:\n                    invalid[field_name] = msg\n\n        return invalid\n\n    def get_value_data_for_fields(\n        self, *field_names: str, raise_exception_when_unset: bool = False\n    ) -&gt; Dict[str, Any]:\n\"\"\"Return the data for a one or several fields of this ValueMap.\n\n        If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True',\n        in which case an Exception will be raised (obviously).\n        \"\"\"\n\n        if raise_exception_when_unset:\n            unset: List[str] = []\n            for k in field_names:\n                v = self.get_value_obj(k)\n                if not v.is_set:\n                    if raise_exception_when_unset:\n                        unset.append(k)\n            if unset:\n                raise Exception(\n                    f\"Can't get data for fields, one or several of the requested fields are not set yet: {', '.join(unset)}.\"\n                )\n\n        result: Dict[str, Any] = {}\n        for k in field_names:\n            v = self.get_value_obj(k)\n            if not v.is_set:\n                result[k] = None\n            else:\n                result[k] = v.data\n        return result\n\n    def get_value_data(\n        self, field_name: str, raise_exception_when_unset: bool = False\n    ) -&gt; Any:\n        return self.get_value_data_for_fields(\n            field_name, raise_exception_when_unset=raise_exception_when_unset\n        )[field_name]\n\n    def get_all_value_ids(self) -&gt; Dict[str, uuid.UUID]:\n        return {k: self.get_value_obj(k).value_id for k in self.field_names}\n\n    def get_all_value_data(\n        self, raise_exception_when_unset: bool = False\n    ) -&gt; Dict[str, Any]:\n        return self.get_value_data_for_fields(\n            *self.field_names,\n            raise_exception_when_unset=raise_exception_when_unset,\n        )\n\n    def set_values(self, **values) -&gt; None:\n\n        for k, v in values.items():\n            self.set_value(k, v)\n\n    def set_value(self, field_name: str, data: Any) -&gt; None:\n        raise Exception(\n            f\"The value set implementation '{self.__class__.__name__}' is read-only, and does not support the setting or changing of values.\"\n        )\n\n    def __getitem__(self, item: str) -&gt; Value:\n\n        return self.get_value_obj(item)\n\n    def __setitem__(self, key: str, value):\n\n        raise NotImplementedError()\n        # self.set_value(key, value)\n\n    def __delitem__(self, key: str):\n\n        raise Exception(f\"Removing items not supported: {key}\")\n\n    def __iter__(self):\n        return iter(self.field_names)\n\n    def __len__(self):\n        return len(list(self.values_schema))\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(field_names={self.field_names})\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def create_invalid_renderable(self, **config) -&gt; Union[RenderableType, None]:\n\n        inv = self.check_invalid()\n        if not inv:\n            return None\n\n        table = Table(show_header=False, box=box.SIMPLE)\n        table.add_column(\"field name\", style=\"i\")\n        table.add_column(\"details\", style=\"b red\")\n\n        for field, err in inv.items():\n            table.add_row(field, err)\n\n        return table\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        in_panel = config.get(\"in_panel\", None)\n        if in_panel is None:\n            if is_jupyter():\n                in_panel = True\n            else:\n                in_panel = False\n\n        render_value_data = config.get(\"render_value_data\", True)\n        field_title = config.get(\"field_title\", \"field\")\n        value_title = config.get(\"value_title\", \"value\")\n        show_header = config.get(\"show_header\", True)\n        show_type = config.get(\"show_data_type\", False)\n\n        table = Table(show_lines=False, show_header=show_header, box=box.SIMPLE)\n        table.add_column(field_title, style=\"b\")\n        if show_type:\n            table.add_column(\"data_type\")\n        table.add_column(value_title, style=\"i\")\n\n        for field_name in self.field_names:\n\n            value = self.get_value_obj(field_name=field_name)\n            if render_value_data:\n                rendered = value._data_registry.pretty_print_data(\n                    value_id=value.value_id, target_type=\"terminal_renderable\", **config\n                )\n            else:\n                rendered = value.create_renderable(**config)\n\n            if show_type:\n                table.add_row(field_name, value.value_schema.type, rendered)\n            else:\n                table.add_row(field_name, rendered)\n\n        if in_panel:\n            return Panel(table)\n        else:\n            return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.values_schema","title":"<code>values_schema: Dict[str, ValueSchema] = Field(description='The schemas for all the values in this set.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.field_names","title":"<code>field_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.all_items_valid","title":"<code>all_items_valid: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.get_value_obj","title":"<code>get_value_obj(field_name: str) -&gt; Value</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@abc.abstractmethod\ndef get_value_obj(self, field_name: str) -&gt; Value:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.check_invalid","title":"<code>check_invalid() -&gt; Dict[str, str]</code>","text":"<p>Check whether the value set is invalid, if it is, return a description of what's wrong.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def check_invalid(self) -&gt; Dict[str, str]:\n\"\"\"Check whether the value set is invalid, if it is, return a description of what's wrong.\"\"\"\n\n    invalid: Dict[str, str] = {}\n    for field_name in self.values_schema.keys():\n\n        item = self.get_value_obj(field_name)\n        field_schema = self.values_schema[field_name]\n        if not field_schema.optional:\n            msg: Union[str, None] = None\n            if not item.value_status == ValueStatus.SET:\n\n                item_schema = self.values_schema[field_name]\n                if item_schema.is_required():\n\n                    if not item.is_set:\n                        msg = \"not set\"\n                    elif item.value_status == ValueStatus.NONE:\n                        msg = \"no value\"\n            if msg:\n                invalid[field_name] = msg\n\n    return invalid\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.get_value_data_for_fields","title":"<code>get_value_data_for_fields(*field_names: str, raise_exception_when_unset: bool = False) -&gt; Dict[str, Any]</code>","text":"<p>Return the data for a one or several fields of this ValueMap.</p> <p>If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True', in which case an Exception will be raised (obviously).</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_data_for_fields(\n    self, *field_names: str, raise_exception_when_unset: bool = False\n) -&gt; Dict[str, Any]:\n\"\"\"Return the data for a one or several fields of this ValueMap.\n\n    If a value is unset, by default 'None' is returned for it. Unless 'raise_exception_when_unset' is set to 'True',\n    in which case an Exception will be raised (obviously).\n    \"\"\"\n\n    if raise_exception_when_unset:\n        unset: List[str] = []\n        for k in field_names:\n            v = self.get_value_obj(k)\n            if not v.is_set:\n                if raise_exception_when_unset:\n                    unset.append(k)\n        if unset:\n            raise Exception(\n                f\"Can't get data for fields, one or several of the requested fields are not set yet: {', '.join(unset)}.\"\n            )\n\n    result: Dict[str, Any] = {}\n    for k in field_names:\n        v = self.get_value_obj(k)\n        if not v.is_set:\n            result[k] = None\n        else:\n            result[k] = v.data\n    return result\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.get_value_data","title":"<code>get_value_data(field_name: str, raise_exception_when_unset: bool = False) -&gt; Any</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_data(\n    self, field_name: str, raise_exception_when_unset: bool = False\n) -&gt; Any:\n    return self.get_value_data_for_fields(\n        field_name, raise_exception_when_unset=raise_exception_when_unset\n    )[field_name]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.get_all_value_ids","title":"<code>get_all_value_ids() -&gt; Dict[str, uuid.UUID]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_value_ids(self) -&gt; Dict[str, uuid.UUID]:\n    return {k: self.get_value_obj(k).value_id for k in self.field_names}\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.get_all_value_data","title":"<code>get_all_value_data(raise_exception_when_unset: bool = False) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_all_value_data(\n    self, raise_exception_when_unset: bool = False\n) -&gt; Dict[str, Any]:\n    return self.get_value_data_for_fields(\n        *self.field_names,\n        raise_exception_when_unset=raise_exception_when_unset,\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.set_values","title":"<code>set_values(**values) -&gt; None</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def set_values(self, **values) -&gt; None:\n\n    for k, v in values.items():\n        self.set_value(k, v)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.set_value","title":"<code>set_value(field_name: str, data: Any) -&gt; None</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def set_value(self, field_name: str, data: Any) -&gt; None:\n    raise Exception(\n        f\"The value set implementation '{self.__class__.__name__}' is read-only, and does not support the setting or changing of values.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.create_invalid_renderable","title":"<code>create_invalid_renderable(**config) -&gt; Union[RenderableType, None]</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_invalid_renderable(self, **config) -&gt; Union[RenderableType, None]:\n\n    inv = self.check_invalid()\n    if not inv:\n        return None\n\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"field name\", style=\"i\")\n    table.add_column(\"details\", style=\"b red\")\n\n    for field, err in inv.items():\n        table.add_row(field, err)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMap.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    in_panel = config.get(\"in_panel\", None)\n    if in_panel is None:\n        if is_jupyter():\n            in_panel = True\n        else:\n            in_panel = False\n\n    render_value_data = config.get(\"render_value_data\", True)\n    field_title = config.get(\"field_title\", \"field\")\n    value_title = config.get(\"value_title\", \"value\")\n    show_header = config.get(\"show_header\", True)\n    show_type = config.get(\"show_data_type\", False)\n\n    table = Table(show_lines=False, show_header=show_header, box=box.SIMPLE)\n    table.add_column(field_title, style=\"b\")\n    if show_type:\n        table.add_column(\"data_type\")\n    table.add_column(value_title, style=\"i\")\n\n    for field_name in self.field_names:\n\n        value = self.get_value_obj(field_name=field_name)\n        if render_value_data:\n            rendered = value._data_registry.pretty_print_data(\n                value_id=value.value_id, target_type=\"terminal_renderable\", **config\n            )\n        else:\n            rendered = value.create_renderable(**config)\n\n        if show_type:\n            table.add_row(field_name, value.value_schema.type, rendered)\n        else:\n            table.add_row(field_name, rendered)\n\n    if in_panel:\n        return Panel(table)\n    else:\n        return table\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly","title":"<code>ValueMapReadOnly</code>","text":"<p>         Bases: <code>ValueMap</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValueMapReadOnly(ValueMap):  # type: ignore\n\n    _kiara_model_id = \"instance.value_map.readonly\"\n\n    @classmethod\n    def create_from_ids(cls, data_registry: \"DataRegistry\", **value_ids: uuid.UUID):\n\n        values = {k: data_registry.get_value(v) for k, v in value_ids.items()}\n        values_schema = {k: v.value_schema for k, v in values.items()}\n        return ValueMapReadOnly.construct(\n            value_items=values, values_schema=values_schema\n        )\n\n    value_items: Dict[str, Value] = Field(\n        description=\"The values contained in this set.\"\n    )\n\n    def get_value_obj(self, field_name: str) -&gt; Value:\n\n        if field_name not in self.value_items.keys():\n            raise KeyError(\n                f\"Field '{field_name}' not available in value set. Available fields: {', '.join(self.field_names)}\"\n            )\n        return self.value_items[field_name]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly.value_items","title":"<code>value_items: Dict[str, Value] = Field(description='The values contained in this set.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly.create_from_ids","title":"<code>create_from_ids(data_registry: DataRegistry, **value_ids: uuid.UUID)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@classmethod\ndef create_from_ids(cls, data_registry: \"DataRegistry\", **value_ids: uuid.UUID):\n\n    values = {k: data_registry.get_value(v) for k, v in value_ids.items()}\n    values_schema = {k: v.value_schema for k, v in values.items()}\n    return ValueMapReadOnly.construct(\n        value_items=values, values_schema=values_schema\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapReadOnly.get_value_obj","title":"<code>get_value_obj(field_name: str) -&gt; Value</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_obj(self, field_name: str) -&gt; Value:\n\n    if field_name not in self.value_items.keys():\n        raise KeyError(\n            f\"Field '{field_name}' not available in value set. Available fields: {', '.join(self.field_names)}\"\n        )\n    return self.value_items[field_name]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable","title":"<code>ValueMapWritable</code>","text":"<p>         Bases: <code>ValueMap</code></p> Source code in <code>kiara/models/values/value.py</code> <pre><code>class ValueMapWritable(ValueMap):  # type: ignore\n\n    _kiara_model_id = \"instance.value_map.writeable\"\n\n    @classmethod\n    def create_from_schema(\n        cls,\n        kiara: \"Kiara\",\n        schema: Mapping[str, ValueSchema],\n        pedigree: ValuePedigree,\n        unique_value_ids: bool = False,\n    ) -&gt; \"ValueMapWritable\":\n\n        v = ValueMapWritable(\n            values_schema=dict(schema),\n            pedigree=pedigree,\n            unique_value_ids=unique_value_ids,\n        )\n        v._kiara = kiara\n        v._data_registry = kiara.data_registry\n        return v\n\n    value_items: Dict[str, Value] = Field(\n        description=\"The values contained in this set.\", default_factory=dict\n    )\n    pedigree: ValuePedigree = Field(\n        description=\"The pedigree to add to all of the result values.\"\n    )\n    unique_value_ids: bool = Field(\n        description=\"Whether this value map always creates new value(id)s, even when a dataset with matching hash is found.\",\n        default=True,\n    )\n\n    _values_uncommitted: Dict[str, Any] = PrivateAttr(default_factory=dict)\n    _kiara: \"Kiara\" = PrivateAttr(default=None)\n    _data_registry: \"DataRegistry\" = PrivateAttr(default=None)\n    _auto_commit: bool = PrivateAttr(default=True)\n\n    def get_value_obj(self, field_name: str) -&gt; Value:\n\"\"\"Retrieve the value object for the specified field.\n\n        This class only creates the actual value object the first time it is requested, because there is a potential\n        cost to assembling it, and it might not be needed ever.\n        \"\"\"\n\n        if field_name not in self.values_schema.keys():\n            raise Exception(\n                f\"Can't set data for field '{field_name}': field not valid, valid field names: {', '.join(self.field_names)}.\"\n            )\n\n        if field_name in self.value_items.keys():\n            return self.value_items[field_name]\n        elif field_name not in self._values_uncommitted.keys():\n            raise Exception(\n                f\"Can't retrieve value for field '{field_name}': value not set (yet).\"\n            )\n\n        schema = self.values_schema[field_name]\n        value_data = self._values_uncommitted[field_name]\n        if isinstance(value_data, Value):\n            value = value_data\n        elif isinstance(value_data, uuid.UUID):\n            value = self._data_registry.get_value(value_data)\n        else:\n            value = self._data_registry.register_data(\n                data=value_data,\n                schema=schema,\n                pedigree=self.pedigree,\n                pedigree_output_name=field_name,\n                reuse_existing=not self.unique_value_ids,\n            )\n\n        self._values_uncommitted.pop(field_name)\n        self.value_items[field_name] = value\n        return self.value_items[field_name]\n\n    def sync_values(self):\n\n        for field_name in self.field_names:\n            self.get_value_obj(field_name)\n\n        invalid = self.check_invalid()\n        if invalid:\n            e = InvalidValuesException(invalid_values=invalid)\n            try:\n                raise e\n            except Exception:\n                # this is silly, I know\n                log_exception(e)\n                raise e\n\n    def set_value(self, field_name: str, data: Any) -&gt; None:\n\"\"\"Set the value for the specified field.\"\"\"\n\n        if field_name not in self.field_names:\n            raise Exception(\n                f\"Can't set data for field '{field_name}': field not valid, valid field names: {', '.join(self.field_names)}.\"\n            )\n        if self.value_items.get(field_name, False):\n            raise Exception(\n                f\"Can't set data for field '{field_name}': field already committed.\"\n            )\n        if self._values_uncommitted.get(field_name, None) is not None:\n            raise Exception(\n                f\"Can't set data for field '{field_name}': field already set.\"\n            )\n\n        self._values_uncommitted[field_name] = data\n        if self._auto_commit:\n            self.get_value_obj(field_name=field_name)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.value_items","title":"<code>value_items: Dict[str, Value] = Field(description='The values contained in this set.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.pedigree","title":"<code>pedigree: ValuePedigree = Field(description='The pedigree to add to all of the result values.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.unique_value_ids","title":"<code>unique_value_ids: bool = Field(description='Whether this value map always creates new value(id)s, even when a dataset with matching hash is found.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.create_from_schema","title":"<code>create_from_schema(kiara: Kiara, schema: Mapping[str, ValueSchema], pedigree: ValuePedigree, unique_value_ids: bool = False) -&gt; ValueMapWritable</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>@classmethod\ndef create_from_schema(\n    cls,\n    kiara: \"Kiara\",\n    schema: Mapping[str, ValueSchema],\n    pedigree: ValuePedigree,\n    unique_value_ids: bool = False,\n) -&gt; \"ValueMapWritable\":\n\n    v = ValueMapWritable(\n        values_schema=dict(schema),\n        pedigree=pedigree,\n        unique_value_ids=unique_value_ids,\n    )\n    v._kiara = kiara\n    v._data_registry = kiara.data_registry\n    return v\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.get_value_obj","title":"<code>get_value_obj(field_name: str) -&gt; Value</code>","text":"<p>Retrieve the value object for the specified field.</p> <p>This class only creates the actual value object the first time it is requested, because there is a potential cost to assembling it, and it might not be needed ever.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def get_value_obj(self, field_name: str) -&gt; Value:\n\"\"\"Retrieve the value object for the specified field.\n\n    This class only creates the actual value object the first time it is requested, because there is a potential\n    cost to assembling it, and it might not be needed ever.\n    \"\"\"\n\n    if field_name not in self.values_schema.keys():\n        raise Exception(\n            f\"Can't set data for field '{field_name}': field not valid, valid field names: {', '.join(self.field_names)}.\"\n        )\n\n    if field_name in self.value_items.keys():\n        return self.value_items[field_name]\n    elif field_name not in self._values_uncommitted.keys():\n        raise Exception(\n            f\"Can't retrieve value for field '{field_name}': value not set (yet).\"\n        )\n\n    schema = self.values_schema[field_name]\n    value_data = self._values_uncommitted[field_name]\n    if isinstance(value_data, Value):\n        value = value_data\n    elif isinstance(value_data, uuid.UUID):\n        value = self._data_registry.get_value(value_data)\n    else:\n        value = self._data_registry.register_data(\n            data=value_data,\n            schema=schema,\n            pedigree=self.pedigree,\n            pedigree_output_name=field_name,\n            reuse_existing=not self.unique_value_ids,\n        )\n\n    self._values_uncommitted.pop(field_name)\n    self.value_items[field_name] = value\n    return self.value_items[field_name]\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.sync_values","title":"<code>sync_values()</code>","text":"Source code in <code>kiara/models/values/value.py</code> <pre><code>def sync_values(self):\n\n    for field_name in self.field_names:\n        self.get_value_obj(field_name)\n\n    invalid = self.check_invalid()\n    if invalid:\n        e = InvalidValuesException(invalid_values=invalid)\n        try:\n            raise e\n        except Exception:\n            # this is silly, I know\n            log_exception(e)\n            raise e\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value.ValueMapWritable.set_value","title":"<code>set_value(field_name: str, data: Any) -&gt; None</code>","text":"<p>Set the value for the specified field.</p> Source code in <code>kiara/models/values/value.py</code> <pre><code>def set_value(self, field_name: str, data: Any) -&gt; None:\n\"\"\"Set the value for the specified field.\"\"\"\n\n    if field_name not in self.field_names:\n        raise Exception(\n            f\"Can't set data for field '{field_name}': field not valid, valid field names: {', '.join(self.field_names)}.\"\n        )\n    if self.value_items.get(field_name, False):\n        raise Exception(\n            f\"Can't set data for field '{field_name}': field already committed.\"\n        )\n    if self._values_uncommitted.get(field_name, None) is not None:\n        raise Exception(\n            f\"Can't set data for field '{field_name}': field already set.\"\n        )\n\n    self._values_uncommitted[field_name] = data\n    if self._auto_commit:\n        self.get_value_obj(field_name=field_name)\n</code></pre>"},{"location":"reference/kiara/models/values/value/#kiara.models.values.value-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_schema/","title":"value_schema","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema","title":"<code>ValueSchema</code>","text":"<p>         Bases: <code>KiaraModel</code></p> <p>The schema of a value.</p> <p>The schema contains the ValueTypeOrm of a value, as well as an optional default that will be used if no user input was given (yet) for a value.</p> <p>For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the <code>type_config</code> field.</p> Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>class ValueSchema(KiaraModel):\n\"\"\"The schema of a value.\n\n    The schema contains the [ValueTypeOrm][kiara.data.values.ValueTypeOrm] of a value, as well as an optional default that\n    will be used if no user input was given (yet) for a value.\n\n    For more complex container data_types like array, tables, unions etc, data_types can also be configured with values from the ``type_config`` field.\n    \"\"\"\n\n    _kiara_model_id = \"instance.value_schema\"\n\n    class Config:\n        use_enum_values = True\n        # extra = Extra.forbid\n\n    type: str = Field(description=\"The type of the value.\")\n    type_config: typing.Dict[str, typing.Any] = Field(\n        description=\"Configuration for the type, in case it's complex.\",\n        default_factory=dict,\n    )\n    default: typing.Any = Field(\n        description=\"A default value.\", default=SpecialValue.NOT_SET\n    )\n\n    optional: bool = Field(\n        description=\"Whether this value is required (True), or whether 'None' value is allowed (False).\",\n        default=False,\n    )\n    is_constant: bool = Field(\n        description=\"Whether the value is a constant.\", default=False\n    )\n\n    doc: DocumentationMetadataModel = Field(\n        default_factory=DocumentationMetadataModel,\n        description=\"A description for the value of this input field.\",\n    )\n\n    @validator(\"doc\", pre=True)\n    def validate_doc(cls, value):\n        doc = DocumentationMetadataModel.create(value)\n        return doc\n\n    def _retrieve_data_to_hash(self) -&gt; typing.Any:\n\n        return {\"type\": self.type, \"type_config\": self.type_config}\n\n    def is_required(self):\n\n        if self.optional:\n            return False\n        else:\n            if self.default in [None, SpecialValue.NOT_SET, SpecialValue.NO_VALUE]:\n                return True\n            else:\n                return False\n\n    # def validate_types(self, kiara: \"Kiara\"):\n    #\n    #     if self.type not in kiara.value_type_names:\n    #         raise ValueError(\n    #             f\"Invalid value type '{self.type}', available data_types: {kiara.value_type_names}\"\n    #         )\n\n    def __eq__(self, other):\n\n        if not isinstance(other, ValueSchema):\n            return False\n\n        return (self.type, self.default) == (other.type, other.default)\n\n    def __hash__(self):\n\n        return hash((self.type, self.default))\n\n    def __repr__(self):\n\n        return f\"ValueSchema(type={self.type}, default={self.default}, optional={self.optional})\"\n\n    def __str__(self):\n\n        return self.__repr__()\n</code></pre>"},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.type","title":"<code>type: str = Field(description='The type of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.type_config","title":"<code>type_config: typing.Dict[str, typing.Any] = Field(description=\"Configuration for the type, in case it's complex.\", default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.default","title":"<code>default: typing.Any = Field(description='A default value.', default=SpecialValue.NOT_SET)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.optional","title":"<code>optional: bool = Field(description=\"Whether this value is required (True), or whether 'None' value is allowed (False).\", default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.is_constant","title":"<code>is_constant: bool = Field(description='Whether the value is a constant.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.doc","title":"<code>doc: DocumentationMetadataModel = Field(default_factory=DocumentationMetadataModel, description='A description for the value of this input field.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>class Config:\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.Config-attributes","title":"Attributes","text":"<code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.validate_doc","title":"<code>validate_doc(value)</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>@validator(\"doc\", pre=True)\ndef validate_doc(cls, value):\n    doc = DocumentationMetadataModel.create(value)\n    return doc\n</code></pre>"},{"location":"reference/kiara/models/values/value_schema/#kiara.models.values.value_schema.ValueSchema.is_required","title":"<code>is_required()</code>","text":"Source code in <code>kiara/models/values/value_schema.py</code> <pre><code>def is_required(self):\n\n    if self.optional:\n        return False\n    else:\n        if self.default in [None, SpecialValue.NOT_SET, SpecialValue.NO_VALUE]:\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/","title":"value_metadata","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.ValueMetadata","title":"<code>ValueMetadata</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>class ValueMetadata(KiaraModel):\n    @classmethod\n    @abc.abstractmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        pass\n\n    @classmethod\n    @abc.abstractmethod\n    def create_value_metadata(\n        cls, value: \"Value\"\n    ) -&gt; Union[\"ValueMetadata\", Dict[str, Any]]:\n        pass\n\n    # @property\n    # def metadata_key(self) -&gt; str:\n    #     return self._metadata_key  # type: ignore  # this is added by the kiara class loading functionality\n\n    def _retrieve_id(self) -&gt; str:\n        return self._metadata_key  # type: ignore\n\n    def _retrieve_data_to_hash(self) -&gt; Any:\n        return {\"metadata\": self.dict(), \"schema\": self.schema_json()}\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.ValueMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.ValueMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.ValueMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; Union[ValueMetadata, Dict[str, Any]]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef create_value_metadata(\n    cls, value: \"Value\"\n) -&gt; Union[\"ValueMetadata\", Dict[str, Any]]:\n    pass\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo","title":"<code>MetadataTypeInfo</code>","text":"<p>         Bases: <code>TypeInfo</code></p> Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>class MetadataTypeInfo(TypeInfo):\n\n    _kiara_model_id = \"info.metadata_type\"\n\n    @classmethod\n    def create_from_type_class(\n        self, type_cls: Type[ValueMetadata], kiara: \"Kiara\"\n    ) -&gt; \"MetadataTypeInfo\":\n\n        authors_md = AuthorsMetadataModel.from_class(type_cls)\n        doc = DocumentationMetadataModel.from_class_doc(type_cls)\n        python_class = PythonClass.from_class(type_cls)\n        properties_md = ContextMetadataModel.from_class(type_cls)\n        type_name = type_cls._metadata_key  # type: ignore\n        schema = type_cls.schema()\n\n        return MetadataTypeInfo.construct(\n            type_name=type_name,\n            documentation=doc,\n            authors=authors_md,\n            context=properties_md,\n            python_class=python_class,\n            metadata_schema=schema,\n        )\n\n    @classmethod\n    def base_class(self) -&gt; Type[ValueMetadata]:\n        return ValueMetadata\n\n    @classmethod\n    def category_name(cls) -&gt; str:\n        return \"value_metadata\"\n\n    metadata_schema: Dict[str, Any] = Field(\n        description=\"The (json) schema for this metadata value.\"\n    )\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n        include_doc = config.get(\"include_doc\", True)\n        include_schema = config.get(\"include_schema\", True)\n\n        table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n        table.add_column(\"property\", style=\"i\")\n        table.add_column(\"value\")\n\n        if include_doc:\n            table.add_row(\n                \"Documentation\",\n                Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n            )\n        table.add_row(\"Author(s)\", self.authors.create_renderable())\n        table.add_row(\"Context\", self.context.create_renderable())\n\n        if hasattr(self, \"python_class\"):\n            table.add_row(\"Python class\", self.python_class.create_renderable())\n\n        if include_schema:\n            schema = Syntax(\n                orjson_dumps(self.metadata_schema, option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            table.add_row(\"metadata_schema\", schema)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo.metadata_schema","title":"<code>metadata_schema: Dict[str, Any] = Field(description='The (json) schema for this metadata value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo.create_from_type_class","title":"<code>create_from_type_class(type_cls: Type[ValueMetadata], kiara: Kiara) -&gt; MetadataTypeInfo</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\ndef create_from_type_class(\n    self, type_cls: Type[ValueMetadata], kiara: \"Kiara\"\n) -&gt; \"MetadataTypeInfo\":\n\n    authors_md = AuthorsMetadataModel.from_class(type_cls)\n    doc = DocumentationMetadataModel.from_class_doc(type_cls)\n    python_class = PythonClass.from_class(type_cls)\n    properties_md = ContextMetadataModel.from_class(type_cls)\n    type_name = type_cls._metadata_key  # type: ignore\n    schema = type_cls.schema()\n\n    return MetadataTypeInfo.construct(\n        type_name=type_name,\n        documentation=doc,\n        authors=authors_md,\n        context=properties_md,\n        python_class=python_class,\n        metadata_schema=schema,\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo.base_class","title":"<code>base_class() -&gt; Type[ValueMetadata]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\ndef base_class(self) -&gt; Type[ValueMetadata]:\n    return ValueMetadata\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo.category_name","title":"<code>category_name() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\ndef category_name(cls) -&gt; str:\n    return \"value_metadata\"\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeInfo.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\n    include_doc = config.get(\"include_doc\", True)\n    include_schema = config.get(\"include_schema\", True)\n\n    table = Table(box=box.SIMPLE, show_header=False, padding=(0, 0, 0, 0))\n    table.add_column(\"property\", style=\"i\")\n    table.add_column(\"value\")\n\n    if include_doc:\n        table.add_row(\n            \"Documentation\",\n            Panel(self.documentation.create_renderable(), box=box.SIMPLE),\n        )\n    table.add_row(\"Author(s)\", self.authors.create_renderable())\n    table.add_row(\"Context\", self.context.create_renderable())\n\n    if hasattr(self, \"python_class\"):\n        table.add_row(\"Python class\", self.python_class.create_renderable())\n\n    if include_schema:\n        schema = Syntax(\n            orjson_dumps(self.metadata_schema, option=orjson.OPT_INDENT_2),\n            \"json\",\n            background_color=\"default\",\n        )\n        table.add_row(\"metadata_schema\", schema)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo","title":"<code>MetadataTypeClassesInfo</code>","text":"<p>         Bases: <code>TypeInfoItemGroup</code></p> Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>class MetadataTypeClassesInfo(TypeInfoItemGroup):\n\n    _kiara_model_id = \"info.metadata_types\"\n\n    @classmethod\n    def base_info_class(cls) -&gt; Type[TypeInfo]:\n        return MetadataTypeInfo\n\n    type_name: Literal[\"value_metadata\"] = \"value_metadata\"\n    item_infos: Mapping[str, MetadataTypeInfo] = Field(  # type: ignore\n        description=\"The value metadata info instances for each type.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo.type_name","title":"<code>type_name: Literal['value_metadata'] = 'value_metadata'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo.item_infos","title":"<code>item_infos: Mapping[str, MetadataTypeInfo] = Field(description='The value metadata info instances for each type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata.MetadataTypeClassesInfo.base_info_class","title":"<code>base_info_class() -&gt; Type[TypeInfo]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/__init__.py</code> <pre><code>@classmethod\ndef base_info_class(cls) -&gt; Type[TypeInfo]:\n    return MetadataTypeInfo\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/__init__/#kiara.models.values.value_metadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/","title":"included_metadata_types","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types-classes","title":"Classes","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata","title":"<code>PythonClassMetadata</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>Python class and module information.</p> Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>class PythonClassMetadata(ValueMetadata):\n\"\"\"Python class and module information.\"\"\"\n\n    _metadata_key = \"python_class\"\n    _kiara_model_id = \"metadata.python_class\"\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"any\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: \"Value\") -&gt; \"PythonClassMetadata\":\n\n        return PythonClassMetadata.construct(\n            python_class=PythonClass.from_class(value.data.__class__)\n        )\n\n    # metadata_key: Literal[\"python_class\"]\n    python_class: PythonClass = Field(\n        description=\"Details about the Python class that backs this value.\"\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata.python_class","title":"<code>python_class: PythonClass = Field(description='Details about the Python class that backs this value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"any\"]\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.PythonClassMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; PythonClassMetadata</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: \"Value\") -&gt; \"PythonClassMetadata\":\n\n    return PythonClassMetadata.construct(\n        python_class=PythonClass.from_class(value.data.__class__)\n    )\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata","title":"<code>FileMetadata</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>File stats.</p> Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>class FileMetadata(ValueMetadata):\n\"\"\"File stats.\"\"\"\n\n    _metadata_key = \"file\"\n    _kiara_model_id = \"metadata.file\"\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"file\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: \"Value\") -&gt; \"FileMetadata\":\n\n        return FileMetadata.construct(file=value.data)\n\n    file: FileModel = Field(description=\"The file-specific metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata.file","title":"<code>file: FileModel = Field(description='The file-specific metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"file\"]\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; FileMetadata</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: \"Value\") -&gt; \"FileMetadata\":\n\n    return FileMetadata.construct(file=value.data)\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata","title":"<code>FileBundleMetadata</code>","text":"<p>         Bases: <code>ValueMetadata</code></p> <p>File bundle stats.</p> Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>class FileBundleMetadata(ValueMetadata):\n\"\"\"File bundle stats.\"\"\"\n\n    _metadata_key = \"file_bundle\"\n    _kiara_model_id = \"metadata.file_bundle\"\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"file_bundle\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: \"Value\") -&gt; \"FileBundleMetadata\":\n\n        return FileBundleMetadata.construct(file_bundle=value.data)\n\n    file_bundle: FileBundle = Field(description=\"The file-specific metadata.\")\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata.file_bundle","title":"<code>file_bundle: FileBundle = Field(description='The file-specific metadata.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"file_bundle\"]\n</code></pre>"},{"location":"reference/kiara/models/values/value_metadata/included_metadata_types/__init__/#kiara.models.values.value_metadata.included_metadata_types.FileBundleMetadata.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; FileBundleMetadata</code>  <code>classmethod</code>","text":"Source code in <code>kiara/models/values/value_metadata/included_metadata_types/__init__.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: \"Value\") -&gt; \"FileBundleMetadata\":\n\n    return FileBundleMetadata.construct(file_bundle=value.data)\n</code></pre>"},{"location":"reference/kiara/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.yaml","title":"<code>yaml = StringYAML()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KIARA_CONFIG","title":"<code>KIARA_CONFIG = TypeVar('KIARA_CONFIG', bound=KiaraModuleConfig)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ValueMapSchema","title":"<code>ValueMapSchema = Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ValueSetSchema","title":"<code>ValueSetSchema = Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.log","title":"<code>log = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.DEFAULT_IDEMPOTENT_MODULE_CHARACTERISTICS","title":"<code>DEFAULT_IDEMPOTENT_MODULE_CHARACTERISTICS = ModuleCharacteristics()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.DEFAULT_NO_IDEMPOTENT_MODULE_CHARACTERISTICS","title":"<code>DEFAULT_NO_IDEMPOTENT_MODULE_CHARACTERISTICS = ModuleCharacteristics(is_idempotent=False)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS","title":"<code>DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS = ModuleCharacteristics(is_internal=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject","title":"<code>InputOutputObject</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract base class for classes that define inputs and outputs schemas.</p> <p>Both the 'create_inputs_schema<code>and</code>creawte_outputs_schema` methods implemented by child classes return a description of the input schema of this module.</p> <p>If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional):</p> <p><code>{       \"[input_field_name]: {           \"type\": \"[type]\",           \"doc*\": \"[a description of this input]\",           \"optional*': [boolean whether this input is optional or required (defaults to 'False')]       \"[other_input_field_name]: {           \"type: ...           ...       }</code></p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>class InputOutputObject(abc.ABC):\n\"\"\"Abstract base class for classes that define inputs and outputs schemas.\n\n    Both the 'create_inputs_schema` and `creawte_outputs_schema` methods implemented by child classes return a description of the input schema of this module.\n\n    If returning a dictionary of dictionaries, the format of the return value is as follows (items with '*' are optional):\n\n    ```\n        {\n          \"[input_field_name]: {\n              \"type\": \"[type]\",\n              \"doc*\": \"[a description of this input]\",\n              \"optional*': [boolean whether this input is optional or required (defaults to 'False')]\n          \"[other_input_field_name]: {\n              \"type: ...\n              ...\n          }\n              ```\n    \"\"\"\n\n    def __init__(\n        self,\n        alias: str,\n        config: Union[KiaraModuleConfig, None] = None,\n        allow_empty_inputs_schema: bool = False,\n        allow_empty_outputs_schema: bool = False,\n    ):\n\n        self._alias: str = alias\n        self._inputs_schema: Mapping[str, ValueSchema] = None  # type: ignore\n        self._full_inputs_schema: Mapping[str, ValueSchema] = None  # type: ignore\n        self._outputs_schema: Mapping[str, ValueSchema] = None  # type: ignore\n        self._constants: Mapping[str, ValueSchema] = None  # type: ignore\n\n        if config is None:\n            config = KiaraModuleConfig()\n        self._config: KiaraModuleConfig = config\n\n        self._allow_empty_inputs: bool = allow_empty_inputs_schema\n        self._allow_empty_outputs: bool = allow_empty_outputs_schema\n\n    @property\n    def alias(self) -&gt; str:\n        return self._alias\n\n    def input_required(self, input_name: str):\n\n        if input_name not in self._inputs_schema.keys():\n            raise Exception(\n                f\"No input '{input_name}', available inputs: {', '.join(self._inputs_schema)}\"\n            )\n\n        if not self._inputs_schema[input_name].is_required():\n            return False\n\n        if input_name in self.constants.keys():\n            return False\n        else:\n            return True\n\n    @abstractmethod\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\"\"\"Return the schema for this types' inputs.\"\"\"\n\n    @abstractmethod\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\"\"\"Return the schema for this types' outputs.\"\"\"\n\n    @property\n    def inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\"\"\"The input schema for this module.\"\"\"\n\n        if self._inputs_schema is None:\n            self._create_inputs_schema()\n\n        return self._inputs_schema  # type: ignore\n\n    @property\n    def full_inputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\n        if self._full_inputs_schema is not None:\n            return self._full_inputs_schema\n\n        self._full_inputs_schema = dict(self.inputs_schema)\n        self._full_inputs_schema.update(self._constants)\n        return self._full_inputs_schema\n\n    @property\n    def constants(self) -&gt; Mapping[str, ValueSchema]:\n\n        if self._constants is None:\n            self._create_inputs_schema()\n        return self._constants  # type: ignore\n\n    def _create_inputs_schema(self) -&gt; None:\n\"\"\"Assemble the inputs schema and assign it to the approriate instance attributes.\n\n        DEV NOTE: if anything in this method is changed, also change the method of the AutoInputsKiaraModule\n        in the kiara_pluginc.core_types package, since it's a carbon copy if this, except for a small change.\n        \"\"\"\n        try:\n            _input_schemas_data = self.create_inputs_schema()\n\n            if _input_schemas_data is None:\n                raise Exception(\n                    f\"Invalid inputs implementation for '{self.alias}': no inputs schema\"\n                )\n\n            if not _input_schemas_data and not self._allow_empty_inputs:\n                raise Exception(\n                    f\"Invalid inputs implementation for '{self.alias}': empty inputs schema\"\n                )\n            try:\n                _input_schemas = create_schema_dict(schema_config=_input_schemas_data)\n            except Exception as e:\n                raise Exception(f\"Can't create input schemas for '{self.alias}': {e}\")\n\n            defaults = self._config.defaults\n            constants = self._config.constants\n\n            for k, v in defaults.items():\n                if k not in _input_schemas.keys():\n                    raise Exception(\n                        f\"Can't create inputs for '{self.alias}', invalid default field name '{k}'. Available field names: '{', '.join(_input_schemas.keys())}'\"  # type: ignore\n                    )\n\n            for k, v in constants.items():\n                if k not in _input_schemas.keys():\n                    raise Exception(\n                        f\"Can't create inputs for '{self.alias}', invalid constant field name '{k}'. Available field names: '{', '.join(_input_schemas.keys())}'\"  # type: ignore\n                    )\n\n            self._inputs_schema, self._constants = overlay_constants_and_defaults(\n                _input_schemas, defaults=defaults, constants=constants\n            )\n\n        except Exception as e:\n            raise KiaraException(f\"Can't create input schemas for instance of '{self.alias}'.\", parent=e)  # type: ignore\n\n    @property\n    def outputs_schema(self) -&gt; Mapping[str, ValueSchema]:\n\"\"\"The output schema for this module.\"\"\"\n\n        if self._outputs_schema is not None:\n            return self._outputs_schema\n\n        try:\n            _output_schema = self.create_outputs_schema()\n\n            if _output_schema is None:\n                raise Exception(\n                    f\"Invalid outputs implementation for '{self.alias}': no outputs schema\"\n                )\n\n            if not _output_schema and not self._allow_empty_outputs:\n                raise Exception(\n                    f\"Invalid outputs implementation for '{self.alias}': empty outputs schema\"\n                )\n\n            try:\n                self._outputs_schema = create_schema_dict(schema_config=_output_schema)\n            except Exception as e:\n                raise Exception(\n                    f\"Can't create output schemas for module {self.alias}: {e}\"\n                )\n\n            return self._outputs_schema\n        except Exception as e:\n            if is_debug():\n                import traceback\n\n                traceback.print_exc()\n            raise KiaraException(\n                f\"Can't create output schemas for instance of module '{self.alias}': {e}\",\n                parent=e,\n            )\n\n    @property\n    def input_names(self) -&gt; Iterable[str]:\n\"\"\"A list of input field names for this module.\"\"\"\n        return self.inputs_schema.keys()\n\n    @property\n    def output_names(self) -&gt; Iterable[str]:\n\"\"\"A list of output field names for this module.\"\"\"\n        return self.outputs_schema.keys()\n\n    def augment_module_inputs(self, inputs: Mapping[str, Any]) -&gt; Dict[str, Any]:\n\n        augmented = augment_values(\n            values=inputs, schemas=self.inputs_schema, constants=self.constants\n        )\n\n        return augmented\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.alias","title":"<code>alias: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.inputs_schema","title":"<code>inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":"<p>The input schema for this module.</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.full_inputs_schema","title":"<code>full_inputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.constants","title":"<code>constants: Mapping[str, ValueSchema]</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.outputs_schema","title":"<code>outputs_schema: Mapping[str, ValueSchema]</code>  <code>property</code>","text":"<p>The output schema for this module.</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.input_names","title":"<code>input_names: Iterable[str]</code>  <code>property</code>","text":"<p>A list of input field names for this module.</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.output_names","title":"<code>output_names: Iterable[str]</code>  <code>property</code>","text":"<p>A list of output field names for this module.</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.input_required","title":"<code>input_required(input_name: str)</code>","text":"Source code in <code>kiara/modules/__init__.py</code> <pre><code>def input_required(self, input_name: str):\n\n    if input_name not in self._inputs_schema.keys():\n        raise Exception(\n            f\"No input '{input_name}', available inputs: {', '.join(self._inputs_schema)}\"\n        )\n\n    if not self._inputs_schema[input_name].is_required():\n        return False\n\n    if input_name in self.constants.keys():\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>  <code>abstractmethod</code>","text":"<p>Return the schema for this types' inputs.</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>@abstractmethod\ndef create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\"\"\"Return the schema for this types' inputs.\"\"\"\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>  <code>abstractmethod</code>","text":"<p>Return the schema for this types' outputs.</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>@abstractmethod\ndef create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\"\"\"Return the schema for this types' outputs.\"\"\"\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.InputOutputObject.augment_module_inputs","title":"<code>augment_module_inputs(inputs: Mapping[str, Any]) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/modules/__init__.py</code> <pre><code>def augment_module_inputs(self, inputs: Mapping[str, Any]) -&gt; Dict[str, Any]:\n\n    augmented = augment_values(\n        values=inputs, schemas=self.inputs_schema, constants=self.constants\n    )\n\n    return augmented\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics","title":"<code>ModuleCharacteristics</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>class ModuleCharacteristics(BaseModel):\n    class Config:\n        allow_mutation = False\n\n    is_idempotent: bool = Field(\n        description=\"Whether this module is idempotent (aka always produces the same output with the same inputs.\",\n        default=True,\n    )\n    is_internal: bool = Field(\n        description=\"Hint for frontends whether this module is used predominantly internally, and users won't need to know of its existence.\",\n        default=False,\n    )\n    unique_result_values: bool = Field(\n        description=\"Don't re-use existing values for outputs that have matching hashes in the data store.\",\n        default=True,\n    )\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics.is_idempotent","title":"<code>is_idempotent: bool = Field(description='Whether this module is idempotent (aka always produces the same output with the same inputs.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics.is_internal","title":"<code>is_internal: bool = Field(description=\"Hint for frontends whether this module is used predominantly internally, and users won't need to know of its existence.\", default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics.unique_result_values","title":"<code>unique_result_values: bool = Field(description=\"Don't re-use existing values for outputs that have matching hashes in the data store.\", default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/modules/__init__.py</code> <pre><code>class Config:\n    allow_mutation = False\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.ModuleCharacteristics.Config-attributes","title":"Attributes","text":"<code>allow_mutation = False</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule","title":"<code>KiaraModule</code>","text":"<p>         Bases: <code>InputOutputObject</code>, <code>Generic[KIARA_CONFIG]</code></p> <p>The base class that every custom module in Kiara needs to inherit from.</p> <p>The core of every <code>KiaraModule</code> is a <code>process</code> method, which should be a 'pure',  idempotent function that creates one or several output values from the given input(s), and its purpose is to transfor  a set of inputs into a set of outputs.</p> <p>Every module can be configured. The module configuration schema can differ, but every one such configuration needs to  subclass the KiaraModuleConfig class and set as the value to the  <code>_config_cls</code> attribute of the module class. This is useful, because it allows for some modules to serve a much  larger variety of use-cases than non-configurable modules would be, which would mean more code duplication because  of very simlilar, but slightly different module data_types.</p> <p>Each module class (type) has a unique -- within a kiara context -- module type id which can be accessed via the  <code>_module_type_name</code> class attribute.</p> <p>Examples:</p> <p>A simple example would be an 'addition' module, with <code>a</code> and <code>b</code> configured as inputs, and <code>z</code> as the output field name.</p> <p>An implementing class would look something like this:</p> <p>TODO</p> <p>Parameters:</p> Name Type Description Default <code>module_config</code> <code>Union[None, KIARA_CONFIG, Mapping[str, Any]]</code> <p>the configuation for this module</p> <code>None</code> Source code in <code>kiara/modules/__init__.py</code> <pre><code>class KiaraModule(InputOutputObject, Generic[KIARA_CONFIG]):\n\"\"\"The base class that every custom module in *Kiara* needs to inherit from.\n\n    The core of every ``KiaraModule`` is a ``process`` method, which should be a 'pure',\n     idempotent function that creates one or several output values from the given input(s), and its purpose is to transfor\n     a set of inputs into a set of outputs.\n\n     Every module can be configured. The module configuration schema can differ, but every one such configuration needs to\n     subclass the [KiaraModuleConfig][kiara.module_config.KiaraModuleConfig] class and set as the value to the\n     ``_config_cls`` attribute of the module class. This is useful, because it allows for some modules to serve a much\n     larger variety of use-cases than non-configurable modules would be, which would mean more code duplication because\n     of very simlilar, but slightly different module data_types.\n\n     Each module class (type) has a unique -- within a *kiara* context -- module type id which can be accessed via the\n     ``_module_type_name`` class attribute.\n\n    Examples:\n\n        A simple example would be an 'addition' module, with ``a`` and ``b`` configured as inputs, and ``z`` as the output field name.\n\n        An implementing class would look something like this:\n\n        TODO\n\n    Arguments:\n        module_config: the configuation for this module\n    \"\"\"\n\n    # TODO: not quite sure about this generic type here, mypy doesn't seem to like it\n    _config_cls: Type[KIARA_CONFIG] = KiaraModuleConfig  # type: ignore\n\n    @classmethod\n    def is_pipeline(cls) -&gt; bool:\n\"\"\"Check whether this module type is a pipeline, or not.\"\"\"\n        return False\n\n    @classmethod\n    def _calculate_module_cid(\n        cls, module_type_config: Union[Mapping[str, Any], KIARA_CONFIG]\n    ) -&gt; CID:\n\n        if isinstance(module_type_config, Mapping):\n            module_type_config = cls._resolve_module_config(**module_type_config)\n\n        obj = {\n            \"module_type\": cls._module_type_name,  # type: ignore\n            \"module_type_config\": module_type_config.dict(),\n        }\n        _, cid = compute_cid(data=obj)\n        return cid\n\n    @classmethod\n    def _resolve_module_config(cls, **config: Any) -&gt; KIARA_CONFIG:\n\n        _config = cls._config_cls(**config)  # type: ignore\n\n        return _config\n\n    def __init__(\n        self,\n        module_config: Union[None, KIARA_CONFIG, Mapping[str, Any]] = None,\n    ):\n        self._id: uuid.UUID = uuid.uuid4()\n\n        if isinstance(module_config, KiaraModuleConfig):\n            self._config: KIARA_CONFIG = module_config  # type: ignore\n        elif module_config is None:\n            self._config = self.__class__._config_cls()\n        elif isinstance(module_config, Mapping):\n            try:\n                self._config = self.__class__._config_cls(**module_config)\n            except ValidationError as ve:\n                raise KiaraModuleConfigException(\n                    f\"Error creating module '{id}'. {ve}\",\n                    self.__class__,\n                    module_config,\n                    ve,\n                )\n        else:\n            raise TypeError(f\"Invalid type for module config: {type(module_config)}\")\n\n        self._module_cid: Union[CID, None] = None\n        self._characteristics: Union[ModuleCharacteristics, None] = None\n\n        self._doc: Union[None, DocumentationMetadataModel] = None\n        super().__init__(alias=self.__class__._module_type_name, config=self._config)  # type: ignore\n\n        self._operation: Union[Operation, None] = None\n        # self._merged_input_schemas: typing.Mapping[str, ValueSchema] = None  # type: ignore\n        self._manifest_cache: Union[None, Manifest] = None\n\n    @property\n    def manifest(self) -&gt; \"Manifest\":\n        if self._manifest_cache is None:\n            self._manifest_cache = Manifest(\n                module_type=self.module_type_name,\n                module_config=self.config.dict(),\n                is_resolved=True,\n            )\n        return self._manifest_cache\n\n    @property\n    def doc(self) -&gt; \"DocumentationMetadataModel\":\n        if self._doc is None:\n\n            self._doc = DocumentationMetadataModel.from_class_doc(self.__class__)\n        return self._doc\n\n    @property\n    def module_id(self) -&gt; uuid.UUID:\n\"\"\"The id of this module.\"\"\"\n        return self._id\n\n    @property\n    def module_type_name(self) -&gt; str:\n        if not self._module_type_name:  # type: ignore\n            raise Exception(\n                f\"Module class '{self.__class__.__name__}' does not have a '_module_type_name' attribute. This is a bug.\"\n            )\n        return self._module_type_name  # type: ignore\n\n    @property\n    def config(self) -&gt; KIARA_CONFIG:\n\"\"\"Retrieve the configuration object for this module.\n\n        Returns:\n            the module-class-specific config object\n        \"\"\"\n        return self._config\n\n    @property\n    def module_instance_cid(self) -&gt; CID:\n\n        if self._module_cid is None:\n            self._module_cid = self.__class__._calculate_module_cid(self._config)\n        return self._module_cid\n\n    @property\n    def characteristics(self) -&gt; ModuleCharacteristics:\n        if self._characteristics is not None:\n            return self._characteristics\n\n        self._characteristics = self._retrieve_module_characteristics()\n        return self._characteristics\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n\n        return DEFAULT_IDEMPOTENT_MODULE_CHARACTERISTICS\n\n    def get_config_value(self, key: str) -&gt; Any:\n\"\"\"Retrieve the value for a specific configuration option.\n\n        Arguments:\n            key: the config key\n\n        Returns:\n            the value for the provided key\n        \"\"\"\n\n        try:\n            return self.config.get(key)\n        except Exception:\n            raise Exception(\n                f\"Error accessing config value '{key}' in module {self.__class__._module_type_name}.\"  # type: ignore\n            )\n\n    def run(self, kiara: \"Kiara\", **inputs: Any) -&gt; \"ValueMap\":\n\"\"\"Run the module ad-hoc.\n\n        This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.\n\n        Arguments:\n            kiara: the kiara context\n            inputs: the inputs for this module\n\n        Returns:\n            the outputs of this module run as a ValueMap instance\n        \"\"\"\n\n        from kiara.models.values.value import ValueMap, ValueMapWritable, ValuePedigree\n\n        _inputs: ValueMap = kiara.data_registry.create_valuemap(\n            data=inputs, schema=self.inputs_schema\n        )\n\n        if _inputs.check_invalid():\n            raise InvalidValuesException(\n                msg=f\"Invalid inputs for module '{self.module_type_name}'.\",\n                invalid_values=_inputs.check_invalid(),\n            )\n        environments = {\n            env_name: env.instance_id\n            for env_name, env in kiara.current_environments.items()\n        }\n\n        result_pedigree = ValuePedigree(\n            kiara_id=kiara.id,\n            module_type=self.module_type_name,\n            module_config=self.config.dict(),\n            inputs={k: v.value_id for k, v in _inputs.items()},\n            environments=environments,\n        )\n\n        unique_result_values = self.characteristics.unique_result_values\n\n        outputs = ValueMapWritable.create_from_schema(\n            kiara=kiara,\n            schema=self.outputs_schema,\n            pedigree=result_pedigree,\n            unique_value_ids=unique_result_values,\n        )\n        job_log = JobLog()\n        self.process_step(inputs=_inputs, outputs=outputs, job_log=job_log)\n\n        return outputs\n\n    def process_step(\n        self, inputs: \"ValueMap\", outputs: \"ValueMap\", job_log: JobLog\n    ) -&gt; None:\n\"\"\"Kick off processing for a specific set of input/outputs.\n\n        This method calls the implemented [process][kiara.module.KiaraModule.process] method of the inheriting class,\n        as well as wrapping input/output-data related functionality.\n\n        Arguments:\n            inputs: the input value set\n            outputs: the output value set\n        \"\"\"\n\n        signature = inspect.signature(self.process)  # type: ignore\n\n        process_inputs: Dict[str, Any] = {\n            \"inputs\": inputs,\n            \"outputs\": outputs,\n        }\n\n        if \"job_log\" in signature.parameters.keys():\n            process_inputs[\"job_log\"] = job_log\n\n        try:\n            self.process(**process_inputs)  # type: ignore\n        except KiaraProcessingException as kpe:\n            log_exception(kpe)\n            raise kpe\n        except Exception as e:\n            log_exception(e)\n            raise KiaraProcessingException(e, module=self, inputs=inputs)\n\n    def __eq__(self, other):\n        if self.__class__ != other.__class__:\n            return False\n        return self.module_instance_cid == other.module_instance_cid\n\n    def __hash__(self):\n        return int.from_bytes(self.module_instance_cid.digest, \"big\")\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(id={self.module_id} module_type={self.module_type_name} input_names={list(self.input_names)} output_names={list(self.output_names)})\"\n\n    @property\n    def operation(self) -&gt; \"Operation\":\n\n        if self._operation is not None:\n            return self._operation\n\n        from kiara.models.module.operation import Operation\n\n        self._operation = Operation.create_from_module(self)\n        return self._operation\n\n    def create_renderable(self, **config) -&gt; RenderableType:\n\n        return self.operation.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule._config_cls","title":"<code>_config_cls: Type[KIARA_CONFIG] = KiaraModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.manifest","title":"<code>manifest: Manifest</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.doc","title":"<code>doc: DocumentationMetadataModel</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.module_id","title":"<code>module_id: uuid.UUID</code>  <code>property</code>","text":"<p>The id of this module.</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.module_type_name","title":"<code>module_type_name: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.config","title":"<code>config: KIARA_CONFIG</code>  <code>property</code>","text":"<p>Retrieve the configuration object for this module.</p> <p>Returns:</p> Type Description <code>KIARA_CONFIG</code> <p>the module-class-specific config object</p>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.module_instance_cid","title":"<code>module_instance_cid: CID</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.characteristics","title":"<code>characteristics: ModuleCharacteristics</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.operation","title":"<code>operation: Operation</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.is_pipeline","title":"<code>is_pipeline() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check whether this module type is a pipeline, or not.</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>@classmethod\ndef is_pipeline(cls) -&gt; bool:\n\"\"\"Check whether this module type is a pipeline, or not.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.get_config_value","title":"<code>get_config_value(key: str) -&gt; Any</code>","text":"<p>Retrieve the value for a specific configuration option.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the config key</p> required <p>Returns:</p> Type Description <code>Any</code> <p>the value for the provided key</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>def get_config_value(self, key: str) -&gt; Any:\n\"\"\"Retrieve the value for a specific configuration option.\n\n    Arguments:\n        key: the config key\n\n    Returns:\n        the value for the provided key\n    \"\"\"\n\n    try:\n        return self.config.get(key)\n    except Exception:\n        raise Exception(\n            f\"Error accessing config value '{key}' in module {self.__class__._module_type_name}.\"  # type: ignore\n        )\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.run","title":"<code>run(kiara: Kiara, **inputs: Any) -&gt; ValueMap</code>","text":"<p>Run the module ad-hoc.</p> <p>This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.</p> <p>Parameters:</p> Name Type Description Default <code>kiara</code> <code>Kiara</code> <p>the kiara context</p> required <code>inputs</code> <code>Any</code> <p>the inputs for this module</p> <code>{}</code> <p>Returns:</p> Type Description <code>ValueMap</code> <p>the outputs of this module run as a ValueMap instance</p> Source code in <code>kiara/modules/__init__.py</code> <pre><code>def run(self, kiara: \"Kiara\", **inputs: Any) -&gt; \"ValueMap\":\n\"\"\"Run the module ad-hoc.\n\n    This is mostly used in unit tests, you typically want to run a module via the KiaraAPI instance.\n\n    Arguments:\n        kiara: the kiara context\n        inputs: the inputs for this module\n\n    Returns:\n        the outputs of this module run as a ValueMap instance\n    \"\"\"\n\n    from kiara.models.values.value import ValueMap, ValueMapWritable, ValuePedigree\n\n    _inputs: ValueMap = kiara.data_registry.create_valuemap(\n        data=inputs, schema=self.inputs_schema\n    )\n\n    if _inputs.check_invalid():\n        raise InvalidValuesException(\n            msg=f\"Invalid inputs for module '{self.module_type_name}'.\",\n            invalid_values=_inputs.check_invalid(),\n        )\n    environments = {\n        env_name: env.instance_id\n        for env_name, env in kiara.current_environments.items()\n    }\n\n    result_pedigree = ValuePedigree(\n        kiara_id=kiara.id,\n        module_type=self.module_type_name,\n        module_config=self.config.dict(),\n        inputs={k: v.value_id for k, v in _inputs.items()},\n        environments=environments,\n    )\n\n    unique_result_values = self.characteristics.unique_result_values\n\n    outputs = ValueMapWritable.create_from_schema(\n        kiara=kiara,\n        schema=self.outputs_schema,\n        pedigree=result_pedigree,\n        unique_value_ids=unique_result_values,\n    )\n    job_log = JobLog()\n    self.process_step(inputs=_inputs, outputs=outputs, job_log=job_log)\n\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.process_step","title":"<code>process_step(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"<p>Kick off processing for a specific set of input/outputs.</p> <p>This method calls the implemented process method of the inheriting class, as well as wrapping input/output-data related functionality.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>ValueMap</code> <p>the input value set</p> required <code>outputs</code> <code>ValueMap</code> <p>the output value set</p> required Source code in <code>kiara/modules/__init__.py</code> <pre><code>def process_step(\n    self, inputs: \"ValueMap\", outputs: \"ValueMap\", job_log: JobLog\n) -&gt; None:\n\"\"\"Kick off processing for a specific set of input/outputs.\n\n    This method calls the implemented [process][kiara.module.KiaraModule.process] method of the inheriting class,\n    as well as wrapping input/output-data related functionality.\n\n    Arguments:\n        inputs: the input value set\n        outputs: the output value set\n    \"\"\"\n\n    signature = inspect.signature(self.process)  # type: ignore\n\n    process_inputs: Dict[str, Any] = {\n        \"inputs\": inputs,\n        \"outputs\": outputs,\n    }\n\n    if \"job_log\" in signature.parameters.keys():\n        process_inputs[\"job_log\"] = job_log\n\n    try:\n        self.process(**process_inputs)  # type: ignore\n    except KiaraProcessingException as kpe:\n        log_exception(kpe)\n        raise kpe\n    except Exception as e:\n        log_exception(e)\n        raise KiaraProcessingException(e, module=self, inputs=inputs)\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules.KiaraModule.create_renderable","title":"<code>create_renderable(**config) -&gt; RenderableType</code>","text":"Source code in <code>kiara/modules/__init__.py</code> <pre><code>def create_renderable(self, **config) -&gt; RenderableType:\n\n    return self.operation.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/modules/__init__/#kiara.modules-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/__init__/","title":"included_core_modules","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/","title":"create_from","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModuleConfig","title":"<code>CreateFromModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>class CreateFromModuleConfig(KiaraModuleConfig):\n\n    source_type: str = Field(description=\"The value type of the source value.\")\n    target_type: str = Field(description=\"The value type of the target.\")\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModuleConfig.source_type","title":"<code>source_type: str = Field(description='The value type of the source value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModuleConfig.target_type","title":"<code>target_type: str = Field(description='The value type of the target.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule","title":"<code>CreateFromModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>class CreateFromModule(KiaraModule):\n\n    _module_type_name: str = None  # type: ignore\n    _config_cls = CreateFromModuleConfig\n\n    @classmethod\n    def retrieve_supported_create_combinations(cls) -&gt; Iterable[Mapping[str, str]]:\n\n        result = []\n        for attr in dir(cls):\n            if (\n                len(attr) &lt;= 16\n                or not attr.startswith(\"create__\")\n                or \"__from__\" not in attr\n            ):\n                continue\n\n            tokens = attr.split(\"__\")\n            if len(tokens) != 4:\n                continue\n\n            source_type = tokens[3]\n            target_type = tokens[1]\n\n            data = {\n                \"source_type\": source_type,\n                \"target_type\": target_type,\n                \"func\": attr,\n            }\n            result.append(data)\n        return result\n\n    def create_optional_inputs(\n        self, source_type: str, target_type\n    ) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n        return None\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        source_type = self.get_config_value(\"source_type\")\n        assert source_type not in [\"target\", \"base_name\"]\n\n        target_type = self.get_config_value(\"target_type\")\n        optional = self.create_optional_inputs(\n            source_type=source_type, target_type=target_type\n        )\n\n        schema = {\n            source_type: {\n                \"type\": source_type,\n                \"doc\": f\"The source value (of type '{source_type}').\",\n            },\n        }\n        if optional:\n            for field, field_schema in optional.items():\n                field_schema = dict(field_schema)\n                if field in schema.keys():\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                    )\n                if field == source_type:\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': invalid field name '{field}'.\"\n                    )\n\n                optional = field_schema.get(\"optional\", True)\n                if not optional:\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                    )\n                field_schema[\"optional\"] = True\n                schema[field] = field_schema\n        return schema\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        return {\n            self.get_config_value(\"target_type\"): {\n                \"type\": self.get_config_value(\"target_type\"),\n                \"doc\": f\"The result value (of type '{self.get_config_value('target_type')}').\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n        source_type = self.get_config_value(\"source_type\")\n        target_type = self.get_config_value(\"target_type\")\n\n        func_name = f\"create__{target_type}__from__{source_type}\"\n        func = getattr(self, func_name)\n\n        source_value = inputs.get_value_obj(source_type)\n\n        signature = inspect.signature(func)\n        args: Dict[str, Any] = {\"source_value\": source_value}\n\n        if \"optional\" in signature.parameters:\n            optional: Dict[str, Value] = {}\n            op_schemas = {}\n            for field, schema in self.inputs_schema.items():\n                if field == source_type:\n                    continue\n                optional[field] = inputs.get_value_obj(field)\n                op_schemas[field] = schema\n            args[\"optional\"] = ValueMapReadOnly(\n                value_items=optional, values_schema=op_schemas\n            )\n\n        if \"job_log\" in signature.parameters:\n            args[\"job_log\"] = job_log\n\n        result = func(**args)\n        outputs.set_value(target_type, result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule._config_cls","title":"<code>_config_cls = CreateFromModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule.retrieve_supported_create_combinations","title":"<code>retrieve_supported_create_combinations() -&gt; Iterable[Mapping[str, str]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>@classmethod\ndef retrieve_supported_create_combinations(cls) -&gt; Iterable[Mapping[str, str]]:\n\n    result = []\n    for attr in dir(cls):\n        if (\n            len(attr) &lt;= 16\n            or not attr.startswith(\"create__\")\n            or \"__from__\" not in attr\n        ):\n            continue\n\n        tokens = attr.split(\"__\")\n        if len(tokens) != 4:\n            continue\n\n        source_type = tokens[3]\n        target_type = tokens[1]\n\n        data = {\n            \"source_type\": source_type,\n            \"target_type\": target_type,\n            \"func\": attr,\n        }\n        result.append(data)\n    return result\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule.create_optional_inputs","title":"<code>create_optional_inputs(source_type: str, target_type) -&gt; Union[Mapping[str, Mapping[str, Any]], None]</code>","text":"Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>def create_optional_inputs(\n    self, source_type: str, target_type\n) -&gt; Union[Mapping[str, Mapping[str, Any]], None]:\n    return None\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    source_type = self.get_config_value(\"source_type\")\n    assert source_type not in [\"target\", \"base_name\"]\n\n    target_type = self.get_config_value(\"target_type\")\n    optional = self.create_optional_inputs(\n        source_type=source_type, target_type=target_type\n    )\n\n    schema = {\n        source_type: {\n            \"type\": source_type,\n            \"doc\": f\"The source value (of type '{source_type}').\",\n        },\n    }\n    if optional:\n        for field, field_schema in optional.items():\n            field_schema = dict(field_schema)\n            if field in schema.keys():\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                )\n            if field == source_type:\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': invalid field name '{field}'.\"\n                )\n\n            optional = field_schema.get(\"optional\", True)\n            if not optional:\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                )\n            field_schema[\"optional\"] = True\n            schema[field] = field_schema\n    return schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    return {\n        self.get_config_value(\"target_type\"): {\n            \"type\": self.get_config_value(\"target_type\"),\n            \"doc\": f\"The result value (of type '{self.get_config_value('target_type')}').\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/create_from/#kiara.modules.included_core_modules.create_from.CreateFromModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/create_from.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n\n    source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    func_name = f\"create__{target_type}__from__{source_type}\"\n    func = getattr(self, func_name)\n\n    source_value = inputs.get_value_obj(source_type)\n\n    signature = inspect.signature(func)\n    args: Dict[str, Any] = {\"source_value\": source_value}\n\n    if \"optional\" in signature.parameters:\n        optional: Dict[str, Value] = {}\n        op_schemas = {}\n        for field, schema in self.inputs_schema.items():\n            if field == source_type:\n                continue\n            optional[field] = inputs.get_value_obj(field)\n            op_schemas[field] = schema\n        args[\"optional\"] = ValueMapReadOnly(\n            value_items=optional, values_schema=op_schemas\n        )\n\n    if \"job_log\" in signature.parameters:\n        args[\"job_log\"] = job_log\n\n    result = func(**args)\n    outputs.set_value(target_type, result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/","title":"export_as","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportResult","title":"<code>DataExportResult</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>class DataExportResult(BaseModel):\n\n    files: List[str] = Field(description=\"A list of exported files.\")\n\n    @validator(\"files\", pre=True)\n    def validate_files(cls, value):\n\n        if isinstance(value, str):\n            value = [value]\n\n        # TODO: make sure file exists\n\n        return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportResult-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportResult.files","title":"<code>files: List[str] = Field(description='A list of exported files.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportResult-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportResult.validate_files","title":"<code>validate_files(value)</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>@validator(\"files\", pre=True)\ndef validate_files(cls, value):\n\n    if isinstance(value, str):\n        value = [value]\n\n    # TODO: make sure file exists\n\n    return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModuleConfig","title":"<code>DataExportModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>class DataExportModuleConfig(KiaraModuleConfig):\n\n    target_profile: str = Field(\n        description=\"The name of the target profile. Used to distinguish different target formats for the same data type.\"\n    )\n    source_type: str = Field(\n        description=\"The type of the source data that is going to be exported.\"\n    )\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModuleConfig.target_profile","title":"<code>target_profile: str = Field(description='The name of the target profile. Used to distinguish different target formats for the same data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModuleConfig.source_type","title":"<code>source_type: str = Field(description='The type of the source data that is going to be exported.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule","title":"<code>DataExportModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>class DataExportModule(KiaraModule):\n\n    _config_cls = DataExportModuleConfig\n    _module_type_name: Union[str, None] = None\n\n    @classmethod\n    def retrieve_supported_export_combinations(cls) -&gt; Iterable[Mapping[str, str]]:\n\n        result = []\n        for attr in dir(cls):\n            if (\n                len(attr) &lt;= 16\n                or not attr.startswith(\"export__\")\n                or \"__as__\" not in attr\n            ):\n                continue\n\n            tokens = attr.split(\"__\", maxsplit=4)\n            if len(tokens) != 4:\n                continue\n\n            source_type = tokens[1]\n            target_profile = tokens[3]\n\n            data = {\n                \"source_type\": source_type,\n                \"target_profile\": target_profile,\n                \"func\": attr,\n            }\n            result.append(data)\n        return result\n\n    def create_optional_inputs(\n        self, source_type: str, target_profile: str\n    ) -&gt; Union[None, Mapping[str, Mapping[str, Any]]]:\n        return None\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        source_type = self.get_config_value(\"source_type\")\n        target_profile = self.get_config_value(\"target_profile\")\n\n        inputs: Dict[str, Any] = {\n            source_type: {\n                \"type\": source_type,\n                \"doc\": f\"A value of type '{source_type}'.\",\n            },\n            \"base_path\": {\n                \"type\": \"string\",\n                \"doc\": \"The directory to export the file(s) to.\",\n                \"optional\": True,\n            },\n            \"name\": {\n                \"type\": \"string\",\n                \"doc\": \"The (base) name of the exported file(s).\",\n                \"optional\": True,\n            },\n            \"export_metadata\": {\n                \"type\": \"boolean\",\n                \"doc\": \"Whether to also export the value metadata.\",\n                \"default\": False,\n            },\n        }\n\n        optional = self.create_optional_inputs(\n            source_type=source_type, target_profile=target_profile\n        )\n        if optional:\n            for field, field_schema in optional.items():\n                field_schema = dict(field_schema)\n                if field in inputs.keys():\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                    )\n                if field == source_type:\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': invalid field name '{field}'.\"\n                    )\n\n                optional = field_schema.get(\"optional\", True)\n                if not optional:\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                    )\n                field_schema[\"optional\"] = True\n                inputs[field] = field_schema\n\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        outputs = {\n            \"export_details\": {\n                \"type\": \"dict\",\n                \"doc\": \"Details about the exported files/folders.\",\n            }\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        target_profile: str = self.get_config_value(\"target_profile\")\n        source_type: str = self.get_config_value(\"source_type\")\n\n        export_metadata = inputs.get_value_data(\"export_metadata\")\n\n        source_obj = inputs.get_value_obj(source_type)\n        source = source_obj.data\n\n        func_name = f\"export__{source_type}__as__{target_profile}\"\n        if not hasattr(self, func_name):\n            raise Exception(\n                f\"Can't export '{source_type}' value: missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which source types and profiles are supported.\"\n            )\n\n        base_path = inputs.get_value_data(\"base_path\")\n        if base_path is None:\n            base_path = os.getcwd()\n        name = inputs.get_value_data(\"name\")\n        if not name:\n            name = str(source_obj.value_id)\n\n        func = getattr(self, func_name)\n        # TODO: check signature?\n\n        base_path = os.path.abspath(base_path)\n        os.makedirs(base_path, exist_ok=True)\n        result = func(value=source, base_path=base_path, name=name)\n\n        if isinstance(result, Mapping):\n            result = DataExportResult(**result)\n        elif isinstance(result, str):\n            result = DataExportResult(files=[result])\n\n        if not isinstance(result, DataExportResult):\n            raise KiaraProcessingException(\n                f\"Can't export value: invalid result type '{type(result)}' from internal method. This is most likely a bug in the '{self.module_type_name}' module code.\"\n            )\n\n        if export_metadata:\n            metadata_file = Path(os.path.join(base_path, f\"{name}.metadata\"))\n            value_info = source_obj.create_info()\n            value_json = value_info.json()\n            metadata_file.write_text(value_json)\n\n            result.files.append(metadata_file.as_posix())\n\n        # schema = ValueSchema(type=self.get_target_value_type(), doc=\"Imported dataset.\")\n\n        # value_lineage = ValueLineage.from_module_and_inputs(\n        #     module=self, output_name=output_key, inputs=inputs\n        # )\n        # value: Value = self._kiara.data_registry.register_data(\n        #     value_data=result, value_schema=schema, lineage=None\n        # )\n\n        outputs.set_value(\"export_details\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule._config_cls","title":"<code>_config_cls = DataExportModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule.retrieve_supported_export_combinations","title":"<code>retrieve_supported_export_combinations() -&gt; Iterable[Mapping[str, str]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>@classmethod\ndef retrieve_supported_export_combinations(cls) -&gt; Iterable[Mapping[str, str]]:\n\n    result = []\n    for attr in dir(cls):\n        if (\n            len(attr) &lt;= 16\n            or not attr.startswith(\"export__\")\n            or \"__as__\" not in attr\n        ):\n            continue\n\n        tokens = attr.split(\"__\", maxsplit=4)\n        if len(tokens) != 4:\n            continue\n\n        source_type = tokens[1]\n        target_profile = tokens[3]\n\n        data = {\n            \"source_type\": source_type,\n            \"target_profile\": target_profile,\n            \"func\": attr,\n        }\n        result.append(data)\n    return result\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule.create_optional_inputs","title":"<code>create_optional_inputs(source_type: str, target_profile: str) -&gt; Union[None, Mapping[str, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>def create_optional_inputs(\n    self, source_type: str, target_profile: str\n) -&gt; Union[None, Mapping[str, Mapping[str, Any]]]:\n    return None\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    source_type = self.get_config_value(\"source_type\")\n    target_profile = self.get_config_value(\"target_profile\")\n\n    inputs: Dict[str, Any] = {\n        source_type: {\n            \"type\": source_type,\n            \"doc\": f\"A value of type '{source_type}'.\",\n        },\n        \"base_path\": {\n            \"type\": \"string\",\n            \"doc\": \"The directory to export the file(s) to.\",\n            \"optional\": True,\n        },\n        \"name\": {\n            \"type\": \"string\",\n            \"doc\": \"The (base) name of the exported file(s).\",\n            \"optional\": True,\n        },\n        \"export_metadata\": {\n            \"type\": \"boolean\",\n            \"doc\": \"Whether to also export the value metadata.\",\n            \"default\": False,\n        },\n    }\n\n    optional = self.create_optional_inputs(\n        source_type=source_type, target_profile=target_profile\n    )\n    if optional:\n        for field, field_schema in optional.items():\n            field_schema = dict(field_schema)\n            if field in inputs.keys():\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                )\n            if field == source_type:\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': invalid field name '{field}'.\"\n                )\n\n            optional = field_schema.get(\"optional\", True)\n            if not optional:\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                )\n            field_schema[\"optional\"] = True\n            inputs[field] = field_schema\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    outputs = {\n        \"export_details\": {\n            \"type\": \"dict\",\n            \"doc\": \"Details about the exported files/folders.\",\n        }\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/export_as/#kiara.modules.included_core_modules.export_as.DataExportModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/export_as.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    target_profile: str = self.get_config_value(\"target_profile\")\n    source_type: str = self.get_config_value(\"source_type\")\n\n    export_metadata = inputs.get_value_data(\"export_metadata\")\n\n    source_obj = inputs.get_value_obj(source_type)\n    source = source_obj.data\n\n    func_name = f\"export__{source_type}__as__{target_profile}\"\n    if not hasattr(self, func_name):\n        raise Exception(\n            f\"Can't export '{source_type}' value: missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which source types and profiles are supported.\"\n        )\n\n    base_path = inputs.get_value_data(\"base_path\")\n    if base_path is None:\n        base_path = os.getcwd()\n    name = inputs.get_value_data(\"name\")\n    if not name:\n        name = str(source_obj.value_id)\n\n    func = getattr(self, func_name)\n    # TODO: check signature?\n\n    base_path = os.path.abspath(base_path)\n    os.makedirs(base_path, exist_ok=True)\n    result = func(value=source, base_path=base_path, name=name)\n\n    if isinstance(result, Mapping):\n        result = DataExportResult(**result)\n    elif isinstance(result, str):\n        result = DataExportResult(files=[result])\n\n    if not isinstance(result, DataExportResult):\n        raise KiaraProcessingException(\n            f\"Can't export value: invalid result type '{type(result)}' from internal method. This is most likely a bug in the '{self.module_type_name}' module code.\"\n        )\n\n    if export_metadata:\n        metadata_file = Path(os.path.join(base_path, f\"{name}.metadata\"))\n        value_info = source_obj.create_info()\n        value_json = value_info.json()\n        metadata_file.write_text(value_json)\n\n        result.files.append(metadata_file.as_posix())\n\n    # schema = ValueSchema(type=self.get_target_value_type(), doc=\"Imported dataset.\")\n\n    # value_lineage = ValueLineage.from_module_and_inputs(\n    #     module=self, output_name=output_key, inputs=inputs\n    # )\n    # value: Value = self._kiara.data_registry.register_data(\n    #     value_data=result, value_schema=schema, lineage=None\n    # )\n\n    outputs.set_value(\"export_details\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/","title":"filesystem","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileModule","title":"<code>ImportLocalFileModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Import a file from the local filesystem.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class ImportLocalFileModule(KiaraModule):\n\"\"\"Import a file from the local filesystem.\"\"\"\n\n    _module_type_name = \"import.local.file\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\"path\": {\"type\": \"string\", \"doc\": \"The local path to the file.\"}}\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\"file\": {\"type\": \"file\", \"doc\": \"The loaded files.\"}}\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return ModuleCharacteristics(is_idempotent=False)\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        path = inputs.get_value_data(\"path\")\n\n        file = FileModel.load_file(source=path)\n        outputs.set_value(\"file\", file)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\"path\": {\"type\": \"string\", \"doc\": \"The local path to the file.\"}}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\"file\": {\"type\": \"file\", \"doc\": \"The loaded files.\"}}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    path = inputs.get_value_data(\"path\")\n\n    file = FileModel.load_file(source=path)\n    outputs.set_value(\"file\", file)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule","title":"<code>DeserializeFileModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> <p>Deserialize data to a 'file' value instance.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class DeserializeFileModule(DeserializeValueModule):\n\"\"\"Deserialize data to a 'file' value instance.\"\"\"\n\n    _module_type_name = \"deserialize.file\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": FileModel}\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"file\"\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"copy\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        keys = list(data.get_keys())\n        keys.remove(\"__file_metadata__\")\n        assert len(keys) == 1\n\n        file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")\n        assert file_metadata_chunks.get_number_of_chunks() == 1\n        file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))\n        assert len(file_metadata_json) == 1\n        file_metadata = orjson.loads(file_metadata_json[0])\n\n        chunks = data.get_serialized_data(keys[0])\n        assert chunks.get_number_of_chunks() == 1\n\n        files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n        assert len(files) == 1\n\n        file: str = files[0]  # type: ignore\n\n        fm = FileModel.load_file(\n            source=file,\n            file_name=file_metadata[\"file_name\"],\n        )\n        return fm\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": FileModel}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"file\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"copy\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    keys = list(data.get_keys())\n    keys.remove(\"__file_metadata__\")\n    assert len(keys) == 1\n\n    file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")\n    assert file_metadata_chunks.get_number_of_chunks() == 1\n    file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))\n    assert len(file_metadata_json) == 1\n    file_metadata = orjson.loads(file_metadata_json[0])\n\n    chunks = data.get_serialized_data(keys[0])\n    assert chunks.get_number_of_chunks() == 1\n\n    files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n    assert len(files) == 1\n\n    file: str = files[0]  # type: ignore\n\n    fm = FileModel.load_file(\n        source=file,\n        file_name=file_metadata[\"file_name\"],\n    )\n    return fm\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportFileBundleConfig","title":"<code>ImportFileBundleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class ImportFileBundleConfig(KiaraModuleConfig):\n\n    include_file_types: Union[None, List[str]] = Field(\n        description=\"File types to include.\", default=None\n    )\n    exclude_file_types: Union[None, List[str]] = Field(\n        description=\"File types to include.\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportFileBundleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportFileBundleConfig.include_file_types","title":"<code>include_file_types: Union[None, List[str]] = Field(description='File types to include.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportFileBundleConfig.exclude_file_types","title":"<code>exclude_file_types: Union[None, List[str]] = Field(description='File types to include.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule","title":"<code>ImportLocalFileBundleModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Import a folder (file_bundle) from the local filesystem.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class ImportLocalFileBundleModule(KiaraModule):\n\"\"\"Import a folder (file_bundle) from the local filesystem.\"\"\"\n\n    _module_type_name = \"import.local.file_bundle\"\n    _config_cls = ImportFileBundleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"path\": {\"type\": \"string\", \"doc\": \"The local path of the folder to import.\"}\n        }\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The imported file bundle.\"}\n        }\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_NO_IDEMPOTENT_MODULE_CHARACTERISTICS\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        path = inputs.get_value_data(\"path\")\n\n        include = self.get_config_value(\"include_file_types\")\n        exclude = self.get_config_value(\"exclude_file_types\")\n\n        config = FolderImportConfig(include_files=include, exclude_files=exclude)\n\n        file_bundle = FileBundle.import_folder(source=path, import_config=config)\n        outputs.set_value(\"file_bundle\", file_bundle)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule._config_cls","title":"<code>_config_cls = ImportFileBundleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"path\": {\"type\": \"string\", \"doc\": \"The local path of the folder to import.\"}\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The imported file bundle.\"}\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ImportLocalFileBundleModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    path = inputs.get_value_data(\"path\")\n\n    include = self.get_config_value(\"include_file_types\")\n    exclude = self.get_config_value(\"exclude_file_types\")\n\n    config = FolderImportConfig(include_files=include, exclude_files=exclude)\n\n    file_bundle = FileBundle.import_folder(source=path, import_config=config)\n    outputs.set_value(\"file_bundle\", file_bundle)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule","title":"<code>DeserializeFileBundleModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> <p>Deserialize data to a 'file' value instance.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class DeserializeFileBundleModule(DeserializeValueModule):\n\"\"\"Deserialize data to a 'file' value instance.\"\"\"\n\n    _module_type_name = \"deserialize.file_bundle\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": FileBundle}\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"file_bundle\"\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"copy\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        keys = list(data.get_keys())\n        keys.remove(\"__file_metadata__\")\n\n        file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")\n        assert file_metadata_chunks.get_number_of_chunks() == 1\n        file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))\n        assert len(file_metadata_json) == 1\n        metadata = orjson.loads(file_metadata_json[0])\n        file_metadata = metadata[\"included_files\"]\n        bundle_name = metadata[\"bundle_name\"]\n        # bundle_import_time = metadata[\"import_time\"]\n        sum_size = metadata[\"size\"]\n        number_of_files = metadata[\"number_of_files\"]\n\n        included_files = {}\n        for rel_path in keys:\n\n            chunks = data.get_serialized_data(rel_path)\n            assert chunks.get_number_of_chunks() == 1\n\n            files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n            assert len(files) == 1\n\n            file: str = files[0]  # type: ignore\n            file_name = file_metadata[rel_path][\"file_name\"]\n            # import_time = file_metadata[rel_path][\"import_time\"]\n            fm = FileModel.load_file(source=file, file_name=file_name)\n            included_files[rel_path] = fm\n\n        fb = FileBundle(\n            included_files=included_files,\n            bundle_name=bundle_name,\n            # import_time=bundle_import_time,\n            number_of_files=number_of_files,\n            size=sum_size,\n        )\n        return fb\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": FileBundle}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"file_bundle\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"copy\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.DeserializeFileBundleModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    keys = list(data.get_keys())\n    keys.remove(\"__file_metadata__\")\n\n    file_metadata_chunks = data.get_serialized_data(\"__file_metadata__\")\n    assert file_metadata_chunks.get_number_of_chunks() == 1\n    file_metadata_json = list(file_metadata_chunks.get_chunks(as_files=False))\n    assert len(file_metadata_json) == 1\n    metadata = orjson.loads(file_metadata_json[0])\n    file_metadata = metadata[\"included_files\"]\n    bundle_name = metadata[\"bundle_name\"]\n    # bundle_import_time = metadata[\"import_time\"]\n    sum_size = metadata[\"size\"]\n    number_of_files = metadata[\"number_of_files\"]\n\n    included_files = {}\n    for rel_path in keys:\n\n        chunks = data.get_serialized_data(rel_path)\n        assert chunks.get_number_of_chunks() == 1\n\n        files = list(chunks.get_chunks(as_files=True, symlink_ok=True))\n        assert len(files) == 1\n\n        file: str = files[0]  # type: ignore\n        file_name = file_metadata[rel_path][\"file_name\"]\n        # import_time = file_metadata[rel_path][\"import_time\"]\n        fm = FileModel.load_file(source=file, file_name=file_name)\n        included_files[rel_path] = fm\n\n    fb = FileBundle(\n        included_files=included_files,\n        bundle_name=bundle_name,\n        # import_time=bundle_import_time,\n        number_of_files=number_of_files,\n        size=sum_size,\n    )\n    return fb\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ExportFileModule","title":"<code>ExportFileModule</code>","text":"<p>         Bases: <code>DataExportModule</code></p> <p>Export files.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class ExportFileModule(DataExportModule):\n\"\"\"Export files.\"\"\"\n\n    _module_type_name = \"export.file\"\n\n    def export__file__as__file(self, value: FileModel, base_path: str, name: str):\n\n        target_path = os.path.join(base_path, value.file_name)\n\n        shutil.copy2(value.path, target_path)\n\n        return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ExportFileModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.ExportFileModule.export__file__as__file","title":"<code>export__file__as__file(value: FileModel, base_path: str, name: str)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def export__file__as__file(self, value: FileModel, base_path: str, name: str):\n\n    target_path = os.path.join(base_path, value.file_name)\n\n    shutil.copy2(value.path, target_path)\n\n    return {\"files\": target_path}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule","title":"<code>PickFileFromFileBundleModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Pick a single file from a file_bundle value.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class PickFileFromFileBundleModule(KiaraModule):\n\"\"\"Pick a single file from a file_bundle value.\"\"\"\n\n    _module_type_name = \"file_bundle.pick.file\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},\n            \"path\": {\"type\": \"string\", \"doc\": \"The relative path of the file to pick.\"},\n        }\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\"file\": {\"type\": \"file\", \"doc\": \"The file.\"}}\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")\n        path: str = inputs.get_value_data(\"path\")\n\n        if path not in file_bundle.included_files.keys():\n            raise KiaraProcessingException(\n                f\"Can't pick file '{path}' from file bundle: file not available.\"\n            )\n\n        file: FileModel = file_bundle.included_files[path]\n\n        outputs.set_value(\"file\", file)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},\n        \"path\": {\"type\": \"string\", \"doc\": \"The relative path of the file to pick.\"},\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\"file\": {\"type\": \"file\", \"doc\": \"The file.\"}}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickFileFromFileBundleModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")\n    path: str = inputs.get_value_data(\"path\")\n\n    if path not in file_bundle.included_files.keys():\n        raise KiaraProcessingException(\n            f\"Can't pick file '{path}' from file bundle: file not available.\"\n        )\n\n    file: FileModel = file_bundle.included_files[path]\n\n    outputs.set_value(\"file\", file)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickSubBundle","title":"<code>PickSubBundle</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Pick a sub-folder from a file_bundle, resulting in a new file_bundle.</p> Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>class PickSubBundle(KiaraModule):\n\"\"\"Pick a sub-folder from a file_bundle, resulting in a new file_bundle.\"\"\"\n\n    _module_type_name = \"file_bundle.pick.sub_folder\"\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},\n            \"sub_path\": {\n                \"type\": \"string\",\n                \"doc\": \"The relative path of the sub-folder to pick.\",\n            },\n        }\n\n    def create_outputs_schema(self) -&gt; ValueMapSchema:\n        return {\n            \"file_bundle\": {\n                \"type\": \"file_bundle\",\n                \"doc\": \"The picked (sub-)file_bundle.\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")\n        sub_path: str = inputs.get_value_data(\"sub_path\")\n\n        result = {}\n        for path, file in file_bundle.included_files.items():\n            if path.startswith(sub_path):\n                result[path] = file\n\n        if not result:\n            raise KiaraProcessingException(\n                f\"Can't pick sub-folder '{sub_path}' from file bundle: no matches.\"\n            )\n\n        new_file_bundle: FileBundle = FileBundle.create_from_file_models(\n            result, bundle_name=f\"{file_bundle.bundle_name}_{sub_path}\"\n        )\n\n        outputs.set_value(\"file_bundle\", new_file_bundle)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickSubBundle-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickSubBundle.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"file_bundle\": {\"type\": \"file_bundle\", \"doc\": \"The file bundle.\"},\n        \"sub_path\": {\n            \"type\": \"string\",\n            \"doc\": \"The relative path of the sub-folder to pick.\",\n        },\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickSubBundle.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def create_outputs_schema(self) -&gt; ValueMapSchema:\n    return {\n        \"file_bundle\": {\n            \"type\": \"file_bundle\",\n            \"doc\": \"The picked (sub-)file_bundle.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filesystem/#kiara.modules.included_core_modules.filesystem.PickSubBundle.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/filesystem.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    file_bundle: FileBundle = inputs.get_value_data(\"file_bundle\")\n    sub_path: str = inputs.get_value_data(\"sub_path\")\n\n    result = {}\n    for path, file in file_bundle.included_files.items():\n        if path.startswith(sub_path):\n            result[path] = file\n\n    if not result:\n        raise KiaraProcessingException(\n            f\"Can't pick sub-folder '{sub_path}' from file bundle: no matches.\"\n        )\n\n    new_file_bundle: FileBundle = FileBundle.create_from_file_models(\n        result, bundle_name=f\"{file_bundle.bundle_name}_{sub_path}\"\n    )\n\n    outputs.set_value(\"file_bundle\", new_file_bundle)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/","title":"filter","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModuleConfig","title":"<code>FilterModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>class FilterModuleConfig(KiaraModuleConfig):\n\n    filter_name: str = Field(description=\"The name of the filter.\")\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModuleConfig.filter_name","title":"<code>filter_name: str = Field(description='The name of the filter.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule","title":"<code>FilterModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>class FilterModule(KiaraModule):\n\n    _module_type_name: Union[str, None] = None\n\n    @classmethod\n    def get_supported_filters(cls) -&gt; List[str]:\n\n        result = []\n        for attr in dir(cls):\n            if len(attr) &lt;= 8 or not attr.startswith(\"filter__\"):\n                continue\n\n            filter_name = attr[8:]\n            result.append(filter_name)\n\n        if not result and is_develop():\n            from rich.table import Table\n\n            from kiara.models.python_class import PythonClass\n\n            pcls = PythonClass.from_class(cls)\n            tbl = Table.grid()\n            tbl.add_column(\"key\", style=\"i\")\n            tbl.add_column(\"value\")\n            tbl.add_row(\n                \"details\",\n                \"Module class inherits from the 'FilterModule' class, but doesn't implement any methods that start with 'filter__.\",\n            )\n            tbl.add_row(\"reference\", \"TODO\")\n            tbl.add_row(\"python class\", pcls)\n            log_dev_message(tbl)\n        return result\n\n    @classmethod\n    @abstractmethod\n    def retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n        pass\n\n    @classmethod\n    def get_supported_type(cls) -&gt; Dict[str, Any]:\n\n        data = cls.retrieve_supported_type()\n        if isinstance(data, str):\n            data = {\"type\": data, \"type_config\": {}}\n        else:\n            # TODO: more validation?\n            assert \"type\" in data.keys()\n            if \"type_config\" not in data.keys():\n                data[\"type_config\"] = {}\n\n        return data\n\n    _config_cls = FilterModuleConfig\n\n    def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n        return None\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        filter_name = self.get_config_value(\"filter_name\")\n\n        data_type_data = self.get_supported_type()\n        data_type = data_type_data[\"type\"]\n        data_type_config = data_type_data[\"type_config\"]\n\n        inputs: Dict[str, Any] = {\n            \"value\": {\n                \"type\": data_type,\n                \"type_config\": data_type_config,\n                \"doc\": f\"A value of type '{data_type}'.\",\n            },\n        }\n\n        filter_inputs = self.create_filter_inputs(filter_name=filter_name)\n\n        if filter_inputs:\n            for field, field_schema in filter_inputs.items():\n                field_schema = dict(field_schema)\n                if field in inputs.keys():\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                    )\n\n                filter_inputs_optional = field_schema.get(\"optional\", False)\n                filter_inputs_default = field_schema.get(\"default\", None)\n                if not filter_inputs_optional and filter_inputs_default is None:\n                    raise Exception(\n                        f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                    )\n                field_schema[\"optional\"] = True\n                inputs[field] = field_schema\n\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        data_type_data = self.get_supported_type()\n        data_type = data_type_data[\"type\"]\n        data_type_config = data_type_data[\"type_config\"]\n\n        outputs = {\n            \"value\": {\n                \"type\": data_type,\n                \"type_config\": data_type_config,\n                \"doc\": \"The filtered value.\",\n            }\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        filter_name: str = self.get_config_value(\"filter_name\")\n        data_type_data = self.__class__.get_supported_type()\n        data_type = data_type_data[\"type\"]\n        # data_type_config = data_type_data[\"type_config\"]\n        # TODO: ensure value is of the right type?\n\n        source_obj = inputs.get_value_obj(\"value\")\n\n        func_name = f\"filter__{filter_name}\"\n        if not hasattr(self, func_name):\n            raise Exception(\n                f\"Can't apply filter '{filter_name}': missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which filters are supported.\"\n            )\n\n        func = getattr(self, func_name)\n        # TODO: check signature?\n\n        filter_inputs = {}\n        for k, v in inputs.items():\n            if k == data_type:\n                continue\n            filter_inputs[k] = v.data\n\n        result = func(value=source_obj, filter_inputs=filter_inputs)\n\n        if result is None:\n            outputs.set_value(\"value\", source_obj)\n        else:\n            outputs.set_value(\"value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule._config_cls","title":"<code>_config_cls = FilterModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.get_supported_filters","title":"<code>get_supported_filters() -&gt; List[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>@classmethod\ndef get_supported_filters(cls) -&gt; List[str]:\n\n    result = []\n    for attr in dir(cls):\n        if len(attr) &lt;= 8 or not attr.startswith(\"filter__\"):\n            continue\n\n        filter_name = attr[8:]\n        result.append(filter_name)\n\n    if not result and is_develop():\n        from rich.table import Table\n\n        from kiara.models.python_class import PythonClass\n\n        pcls = PythonClass.from_class(cls)\n        tbl = Table.grid()\n        tbl.add_column(\"key\", style=\"i\")\n        tbl.add_column(\"value\")\n        tbl.add_row(\n            \"details\",\n            \"Module class inherits from the 'FilterModule' class, but doesn't implement any methods that start with 'filter__.\",\n        )\n        tbl.add_row(\"reference\", \"TODO\")\n        tbl.add_row(\"python class\", pcls)\n        log_dev_message(tbl)\n    return result\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.retrieve_supported_type","title":"<code>retrieve_supported_type() -&gt; Union[Dict[str, Any], str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>@classmethod\n@abstractmethod\ndef retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.get_supported_type","title":"<code>get_supported_type() -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>@classmethod\ndef get_supported_type(cls) -&gt; Dict[str, Any]:\n\n    data = cls.retrieve_supported_type()\n    if isinstance(data, str):\n        data = {\"type\": data, \"type_config\": {}}\n    else:\n        # TODO: more validation?\n        assert \"type\" in data.keys()\n        if \"type_config\" not in data.keys():\n            data[\"type_config\"] = {}\n\n    return data\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.create_filter_inputs","title":"<code>create_filter_inputs(filter_name: str) -&gt; Union[None, ValueMapSchema]</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n    return None\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    filter_name = self.get_config_value(\"filter_name\")\n\n    data_type_data = self.get_supported_type()\n    data_type = data_type_data[\"type\"]\n    data_type_config = data_type_data[\"type_config\"]\n\n    inputs: Dict[str, Any] = {\n        \"value\": {\n            \"type\": data_type,\n            \"type_config\": data_type_config,\n            \"doc\": f\"A value of type '{data_type}'.\",\n        },\n    }\n\n    filter_inputs = self.create_filter_inputs(filter_name=filter_name)\n\n    if filter_inputs:\n        for field, field_schema in filter_inputs.items():\n            field_schema = dict(field_schema)\n            if field in inputs.keys():\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': duplicate field '{field}'.\"\n                )\n\n            filter_inputs_optional = field_schema.get(\"optional\", False)\n            filter_inputs_default = field_schema.get(\"default\", None)\n            if not filter_inputs_optional and filter_inputs_default is None:\n                raise Exception(\n                    f\"Can't create inputs schema for '{self.module_type_name}': non-optional field '{field}' specified.\"\n                )\n            field_schema[\"optional\"] = True\n            inputs[field] = field_schema\n\n    return inputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    data_type_data = self.get_supported_type()\n    data_type = data_type_data[\"type\"]\n    data_type_config = data_type_data[\"type_config\"]\n\n    outputs = {\n        \"value\": {\n            \"type\": data_type,\n            \"type_config\": data_type_config,\n            \"doc\": \"The filtered value.\",\n        }\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter.FilterModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/filter.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    filter_name: str = self.get_config_value(\"filter_name\")\n    data_type_data = self.__class__.get_supported_type()\n    data_type = data_type_data[\"type\"]\n    # data_type_config = data_type_data[\"type_config\"]\n    # TODO: ensure value is of the right type?\n\n    source_obj = inputs.get_value_obj(\"value\")\n\n    func_name = f\"filter__{filter_name}\"\n    if not hasattr(self, func_name):\n        raise Exception(\n            f\"Can't apply filter '{filter_name}': missing function '{func_name}' in class '{self.__class__.__name__}'. Please check this modules documentation or source code to determine which filters are supported.\"\n        )\n\n    func = getattr(self, func_name)\n    # TODO: check signature?\n\n    filter_inputs = {}\n    for k, v in inputs.items():\n        if k == data_type:\n            continue\n        filter_inputs[k] = v.data\n\n    result = func(value=source_obj, filter_inputs=filter_inputs)\n\n    if result is None:\n        outputs.set_value(\"value\", source_obj)\n    else:\n        outputs.set_value(\"value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/filter/#kiara.modules.included_core_modules.filter-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/","title":"metadata","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.MetadataModuleConfig","title":"<code>MetadataModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/metadata.py</code> <pre><code>class MetadataModuleConfig(KiaraModuleConfig):\n\n    data_type: str = Field(description=\"The data type this module will be used for.\")\n    kiara_model_id: str = Field(description=\"The id of the kiara (metadata) model.\")\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.MetadataModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.MetadataModuleConfig.data_type","title":"<code>data_type: str = Field(description='The data type this module will be used for.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.MetadataModuleConfig.kiara_model_id","title":"<code>kiara_model_id: str = Field(description='The id of the kiara (metadata) model.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule","title":"<code>ExtractMetadataModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>Base class to use when writing a module to extract metadata from a file.</p> <p>It's possible to use any arbitrary kiara module for this purpose, but sub-classing this makes it easier.</p> Source code in <code>kiara/modules/included_core_modules/metadata.py</code> <pre><code>class ExtractMetadataModule(KiaraModule):\n\"\"\"Base class to use when writing a module to extract metadata from a file.\n\n    It's possible to use any arbitrary *kiara* module for this purpose, but sub-classing this makes it easier.\n    \"\"\"\n\n    _config_cls = MetadataModuleConfig\n    _module_type_name: str = \"value.extract_metadata\"\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n\n        return ModuleCharacteristics(\n            is_idempotent=True, is_internal=True, unique_result_values=True\n        )\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        data_type_name = self.get_config_value(\"data_type\")\n        inputs = {\n            \"value\": {\n                \"type\": data_type_name,\n                \"doc\": f\"A value of type '{data_type_name}'\",\n                \"optional\": False,\n            }\n        }\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        kiara_model_id: str = self.get_config_value(\"kiara_model_id\")\n\n        # TODO: check it's subclassing the right class\n\n        outputs = {\n            \"value_metadata\": {\n                \"type\": \"internal_model\",\n                \"type_config\": {\"kiara_model_id\": kiara_model_id},\n                \"doc\": \"The metadata for the provided value.\",\n            }\n        }\n\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        value = inputs.get_value_obj(\"value\")\n\n        kiara_model_id: str = self.get_config_value(\"kiara_model_id\")\n\n        model_registry = ModelRegistry.instance()\n        metadata_model_cls: Type[ValueMetadata] = model_registry.get_model_cls(kiara_model_id=kiara_model_id, required_subclass=ValueMetadata)  # type: ignore\n\n        metadata = metadata_model_cls.create_value_metadata(value=value)\n\n        if not isinstance(metadata, metadata_model_cls):\n            raise KiaraProcessingException(\n                f\"Invalid metadata model result, should be class '{metadata_model_cls.__name__}', but is: {metadata.__class__.__name__}. This is most likely a bug.\"\n            )\n\n        outputs.set_value(\"value_metadata\", metadata)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule._config_cls","title":"<code>_config_cls = MetadataModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/metadata.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    data_type_name = self.get_config_value(\"data_type\")\n    inputs = {\n        \"value\": {\n            \"type\": data_type_name,\n            \"doc\": f\"A value of type '{data_type_name}'\",\n            \"optional\": False,\n        }\n    }\n    return inputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/metadata.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    kiara_model_id: str = self.get_config_value(\"kiara_model_id\")\n\n    # TODO: check it's subclassing the right class\n\n    outputs = {\n        \"value_metadata\": {\n            \"type\": \"internal_model\",\n            \"type_config\": {\"kiara_model_id\": kiara_model_id},\n            \"doc\": \"The metadata for the provided value.\",\n        }\n    }\n\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/metadata/#kiara.modules.included_core_modules.metadata.ExtractMetadataModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/metadata.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    value = inputs.get_value_obj(\"value\")\n\n    kiara_model_id: str = self.get_config_value(\"kiara_model_id\")\n\n    model_registry = ModelRegistry.instance()\n    metadata_model_cls: Type[ValueMetadata] = model_registry.get_model_cls(kiara_model_id=kiara_model_id, required_subclass=ValueMetadata)  # type: ignore\n\n    metadata = metadata_model_cls.create_value_metadata(value=value)\n\n    if not isinstance(metadata, metadata_model_cls):\n        raise KiaraProcessingException(\n            f\"Invalid metadata model result, should be class '{metadata_model_cls.__name__}', but is: {metadata.__class__.__name__}. This is most likely a bug.\"\n        )\n\n    outputs.set_value(\"value_metadata\", metadata)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pipeline/","title":"pipeline","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule","title":"<code>PipelineModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>A utility module to run multiple connected inner-modules and present it as its own entity.</p> Source code in <code>kiara/modules/included_core_modules/pipeline.py</code> <pre><code>class PipelineModule(KiaraModule):\n\"\"\"A utility module to run multiple connected inner-modules and present it as its own entity.\"\"\"\n\n    _config_cls = PipelineConfig\n    _module_type_name = \"pipeline\"\n\n    def __init__(\n        self,\n        module_config: Union[None, KIARA_CONFIG, Mapping[str, Any]] = None,\n    ):\n        self._job_registry: Union[JobRegistry, None] = None\n        super().__init__(module_config=module_config)\n\n    @classmethod\n    def is_pipeline(cls) -&gt; bool:\n        return True\n\n    def _set_job_registry(self, job_registry: \"JobRegistry\"):\n        self._job_registry = job_registry\n\n    @property\n    def operation(self) -&gt; \"Operation\":\n\n        if self._operation is not None:\n            return self._operation\n\n        from kiara.models.module.operation import Operation\n\n        self._operation = Operation.create_from_module(self, doc=self.config.doc)\n        return self._operation\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        pipeline_structure: PipelineStructure = self.config.structure\n        inputs_schema = pipeline_structure.pipeline_inputs_schema\n        return inputs_schema\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        pipeline_structure: PipelineStructure = self.config.structure\n        return pipeline_structure.pipeline_outputs_schema\n\n    def process(self, inputs: ValueMap, outputs: ValueMapWritable, job_log: JobLog):\n\n        pipeline_structure: PipelineStructure = self.config.structure\n\n        pipeline = Pipeline(structure=pipeline_structure, kiara=outputs._kiara)\n\n        assert self._job_registry is not None\n        controller = SinglePipelineBatchController(\n            pipeline=pipeline, job_registry=self._job_registry\n        )\n\n        pipeline.set_pipeline_inputs(inputs=inputs)\n        step_details = controller.process_pipeline()\n\n        errors: Dict[str, Union[Exception, uuid.UUID]] = {}\n        for step_id, details in step_details.items():\n            if isinstance(details, Exception):\n                errors[step_id] = details\n            else:\n                job = self._job_registry.get_job(details)\n                if job.error:\n                    if job._exception:\n                        errors[step_id] = job._exception\n                    else:\n                        errors[step_id] = Exception(job.error)\n\n        if errors:\n            msg = \"Error processing pipeline:\"\n            for f, e in errors.items():\n                msg = f\"{msg}\\n  - {f}: {e}\"\n\n            raise KiaraProcessingException(f\"Errors while processing pipeline: {msg}\")\n\n        # TODO: resolve values first?\n        outputs.set_values(**pipeline.get_current_pipeline_outputs())\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule._config_cls","title":"<code>_config_cls = PipelineConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule.operation","title":"<code>operation: Operation</code>  <code>property</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule.is_pipeline","title":"<code>is_pipeline() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/pipeline.py</code> <pre><code>@classmethod\ndef is_pipeline(cls) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/pipeline.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    pipeline_structure: PipelineStructure = self.config.structure\n    inputs_schema = pipeline_structure.pipeline_inputs_schema\n    return inputs_schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/pipeline.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    pipeline_structure: PipelineStructure = self.config.structure\n    return pipeline_structure.pipeline_outputs_schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pipeline/#kiara.modules.included_core_modules.pipeline.PipelineModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMapWritable, job_log: JobLog)</code>","text":"Source code in <code>kiara/modules/included_core_modules/pipeline.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMapWritable, job_log: JobLog):\n\n    pipeline_structure: PipelineStructure = self.config.structure\n\n    pipeline = Pipeline(structure=pipeline_structure, kiara=outputs._kiara)\n\n    assert self._job_registry is not None\n    controller = SinglePipelineBatchController(\n        pipeline=pipeline, job_registry=self._job_registry\n    )\n\n    pipeline.set_pipeline_inputs(inputs=inputs)\n    step_details = controller.process_pipeline()\n\n    errors: Dict[str, Union[Exception, uuid.UUID]] = {}\n    for step_id, details in step_details.items():\n        if isinstance(details, Exception):\n            errors[step_id] = details\n        else:\n            job = self._job_registry.get_job(details)\n            if job.error:\n                if job._exception:\n                    errors[step_id] = job._exception\n                else:\n                    errors[step_id] = Exception(job.error)\n\n    if errors:\n        msg = \"Error processing pipeline:\"\n        for f, e in errors.items():\n            msg = f\"{msg}\\n  - {f}: {e}\"\n\n        raise KiaraProcessingException(f\"Errors while processing pipeline: {msg}\")\n\n    # TODO: resolve values first?\n    outputs.set_values(**pipeline.get_current_pipeline_outputs())\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/","title":"pretty_print","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig","title":"<code>PrettyPrintConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>class PrettyPrintConfig(KiaraModuleConfig):\n\n    source_type: str = Field(description=\"The value type of the source value.\")\n    target_type: str = Field(description=\"The value type of the rendered value.\")\n\n    @validator(\"source_type\")\n    def validate_source_type(cls, value):\n        if value == \"render_config\":\n            raise ValueError(f\"Invalid source type: {value}.\")\n        return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig.source_type","title":"<code>source_type: str = Field(description='The value type of the source value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig.target_type","title":"<code>target_type: str = Field(description='The value type of the rendered value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintConfig.validate_source_type","title":"<code>validate_source_type(value)</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>@validator(\"source_type\")\ndef validate_source_type(cls, value):\n    if value == \"render_config\":\n        raise ValueError(f\"Invalid source type: {value}.\")\n    return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule","title":"<code>PrettyPrintModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>class PrettyPrintModule(KiaraModule):\n\n    _module_type_name: str = None  # type: ignore\n    _config_cls = PrettyPrintConfig\n\n    @classmethod\n    def retrieve_supported_render_combinations(cls) -&gt; Iterable[Tuple[str, str]]:\n\n        result = []\n        for attr in dir(cls):\n            if (\n                len(attr) &lt;= 19\n                or not attr.startswith(\"pretty_print__\")\n                or \"__as__\" not in attr\n            ):\n                continue\n\n            attr = attr[14:]\n            end_start_type = attr.find(\"__as__\")\n            source_type = attr[0:end_start_type]\n            target_type = attr[end_start_type + 6 :]\n            result.append((source_type, target_type))\n        return result\n\n    # def create_persistence_config_schema(self) -&gt; Optional[Mapping[str, Mapping[str, Any]]]:\n    #     return None\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        source_type = self.get_config_value(\"source_type\")\n        assert source_type not in [\"target\", \"base_name\"]\n\n        schema = {\n            \"value\": {\"type\": source_type, \"doc\": \"The value to render.\"},\n            \"render_config\": {\n                \"type\": \"any\",\n                \"doc\": \"Value type dependent render configuration.\",\n                \"optional\": True,\n            },\n        }\n\n        return schema\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        return {\n            \"rendered_value\": {\n                \"type\": self.get_config_value(\"target_type\"),\n                \"doc\": \"The rendered value.\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        source_type = self.get_config_value(\"source_type\")\n        target_type = self.get_config_value(\"target_type\")\n\n        value = inputs.get_value_obj(\"value\")\n        render_config = inputs.get_value_data(\"render_config\")\n\n        func_name = f\"pretty_print__{source_type}__as__{target_type}\"\n\n        func = getattr(self, func_name)\n        # TODO: check function signature is valid\n\n        if render_config is None:\n            render_config = {}\n\n        result = func(value=value, render_config=render_config)\n\n        outputs.set_value(\"rendered_value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule._config_cls","title":"<code>_config_cls = PrettyPrintConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule.retrieve_supported_render_combinations","title":"<code>retrieve_supported_render_combinations() -&gt; Iterable[Tuple[str, str]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>@classmethod\ndef retrieve_supported_render_combinations(cls) -&gt; Iterable[Tuple[str, str]]:\n\n    result = []\n    for attr in dir(cls):\n        if (\n            len(attr) &lt;= 19\n            or not attr.startswith(\"pretty_print__\")\n            or \"__as__\" not in attr\n        ):\n            continue\n\n        attr = attr[14:]\n        end_start_type = attr.find(\"__as__\")\n        source_type = attr[0:end_start_type]\n        target_type = attr[end_start_type + 6 :]\n        result.append((source_type, target_type))\n    return result\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    source_type = self.get_config_value(\"source_type\")\n    assert source_type not in [\"target\", \"base_name\"]\n\n    schema = {\n        \"value\": {\"type\": source_type, \"doc\": \"The value to render.\"},\n        \"render_config\": {\n            \"type\": \"any\",\n            \"doc\": \"Value type dependent render configuration.\",\n            \"optional\": True,\n        },\n    }\n\n    return schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    return {\n        \"rendered_value\": {\n            \"type\": self.get_config_value(\"target_type\"),\n            \"doc\": \"The rendered value.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    value = inputs.get_value_obj(\"value\")\n    render_config = inputs.get_value_data(\"render_config\")\n\n    func_name = f\"pretty_print__{source_type}__as__{target_type}\"\n\n    func = getattr(self, func_name)\n    # TODO: check function signature is valid\n\n    if render_config is None:\n        render_config = {}\n\n    result = func(value=value, render_config=render_config)\n\n    outputs.set_value(\"rendered_value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule","title":"<code>ValueTypePrettyPrintModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>class ValueTypePrettyPrintModule(KiaraModule):\n\n    _module_type_name = \"pretty_print.value\"\n    _config_cls = PrettyPrintConfig\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        source_type = self.get_config_value(\"source_type\")\n        assert source_type not in [\"target\", \"base_name\"]\n\n        schema = {\n            \"value\": {\n                \"type\": source_type,\n                \"doc\": \"The value to render.\",\n                \"optional\": True,\n            },\n            \"render_config\": {\n                \"type\": \"any\",\n                \"doc\": \"Value type dependent render configuration.\",\n                \"optional\": True,\n            },\n        }\n\n        return schema\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        return {\n            \"rendered_value\": {\n                \"type\": self.get_config_value(\"target_type\"),\n                \"doc\": \"The rendered value.\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        # source_type = self.get_config_value(\"source_type\")\n        target_type = self.get_config_value(\"target_type\")\n\n        source_value = inputs.get_value_obj(\"value\")\n        render_config = inputs.get_value_obj(\"render_config\")\n\n        if not source_value.is_set:\n            outputs.set_value(\"rendered_value\", \"-- none/not set --\")\n            return\n\n        try:\n            data_type_cls = source_value.data_type_info.data_type_class.get_class()\n            data_type = data_type_cls(**source_value.value_schema.type_config)\n        except Exception as e:\n            source_data_type = source_value.data_type_name\n            log_message(\"data_type.unknown\", data_type=source_data_type, error=e)\n\n            from kiara.data_types.included_core_types import AnyType\n\n            data_type = AnyType()\n\n        func_name = f\"pretty_print_as__{target_type}\"\n        func = getattr(data_type, func_name)\n\n        render_config_dict = render_config.data\n        if render_config_dict is None:\n            render_config_dict = {}\n\n        result = func(value=source_value, render_config=render_config_dict)\n        # TODO: check we have the correct type?\n        outputs.set_value(\"rendered_value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule._config_cls","title":"<code>_config_cls = PrettyPrintConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    source_type = self.get_config_value(\"source_type\")\n    assert source_type not in [\"target\", \"base_name\"]\n\n    schema = {\n        \"value\": {\n            \"type\": source_type,\n            \"doc\": \"The value to render.\",\n            \"optional\": True,\n        },\n        \"render_config\": {\n            \"type\": \"any\",\n            \"doc\": \"Value type dependent render configuration.\",\n            \"optional\": True,\n        },\n    }\n\n    return schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    return {\n        \"rendered_value\": {\n            \"type\": self.get_config_value(\"target_type\"),\n            \"doc\": \"The rendered value.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.ValueTypePrettyPrintModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    # source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    source_value = inputs.get_value_obj(\"value\")\n    render_config = inputs.get_value_obj(\"render_config\")\n\n    if not source_value.is_set:\n        outputs.set_value(\"rendered_value\", \"-- none/not set --\")\n        return\n\n    try:\n        data_type_cls = source_value.data_type_info.data_type_class.get_class()\n        data_type = data_type_cls(**source_value.value_schema.type_config)\n    except Exception as e:\n        source_data_type = source_value.data_type_name\n        log_message(\"data_type.unknown\", data_type=source_data_type, error=e)\n\n        from kiara.data_types.included_core_types import AnyType\n\n        data_type = AnyType()\n\n    func_name = f\"pretty_print_as__{target_type}\"\n    func = getattr(data_type, func_name)\n\n    render_config_dict = render_config.data\n    if render_config_dict is None:\n        render_config_dict = {}\n\n    result = func(value=source_value, render_config=render_config_dict)\n    # TODO: check we have the correct type?\n    outputs.set_value(\"rendered_value\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print.PrettyPrintAnyValueModule","title":"<code>PrettyPrintAnyValueModule</code>","text":"<p>         Bases: <code>PrettyPrintModule</code></p> Source code in <code>kiara/modules/included_core_modules/pretty_print.py</code> <pre><code>class PrettyPrintAnyValueModule(PrettyPrintModule):\n\n    _module_type_name = \"pretty_print.any.value\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/pretty_print/#kiara.modules.included_core_modules.pretty_print-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/","title":"render_value","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModuleConfig","title":"<code>RenderValueModuleConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>class RenderValueModuleConfig(KiaraModuleConfig):\n\n    # render_scene_type: str = Field(\n    #     description=\"The id of the model that describes (and handles) the actual rendering.\"\n    # )\n    source_type: str = Field(description=\"The (kiara) data type to be rendered.\")\n    target_type: str = Field(\n        description=\"The (kiara) data type of210 the rendered result.\"\n    )\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModuleConfig.source_type","title":"<code>source_type: str = Field(description='The (kiara) data type to be rendered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModuleConfig.target_type","title":"<code>target_type: str = Field(description='The (kiara) data type of210 the rendered result.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule","title":"<code>RenderValueModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>class RenderValueModule(KiaraModule):\n    @classmethod\n    def retrieve_supported_render_combinations(cls) -&gt; Iterable[Tuple[str, str]]:\n\n        result = []\n        for attr in dir(cls):\n            if (\n                len(attr) &lt;= 16\n                or not attr.startswith(\"render__\")\n                or \"__as__\" not in attr\n            ):\n                continue\n\n            attr = attr[8:]\n            end_start_type = attr.find(\"__as__\")\n            source_type = attr[0:end_start_type]\n            target_type = attr[end_start_type + 6 :]\n            result.append((source_type, target_type))\n        return result\n\n    _config_cls = RenderValueModuleConfig\n    _module_type_name: str = None  # type: ignore\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        # instruction = self.get_config_value(\"render_scene_type\")\n        # model_registry = ModelRegistry.instance()\n        # instr_model_cls: Type[RenderScene] = model_registry.get_model_cls(instruction, required_subclass=RenderScene)  # type: ignore\n\n        # data_type_name = instr_model_cls.retrieve_source_type()\n        # assert data_type_name\n\n        source_type = self.get_config_value(\"source_type\")\n        optional = source_type == \"none\"\n        inputs = {\n            \"value\": {\n                \"type\": source_type,\n                \"doc\": f\"A value of type '{source_type}'\",\n                \"optional\": optional,\n            },\n            \"render_config\": {\n                \"type\": \"dict\",\n                \"doc\": \"Instructions/config on how (or what) to render the provided value.\",\n                \"default\": {},\n            },\n        }\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        outputs = {\n            \"render_value_result\": {\n                \"type\": \"render_value_result\",\n                \"doc\": \"The rendered value, incl. some metadata.\",\n            },\n        }\n\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        source_type = self.get_config_value(\"source_type\")\n        target_type = self.get_config_value(\"target_type\")\n\n        value: Value = inputs.get_value_obj(\"value\")\n\n        render_scene: DictModel = inputs.get_value_data(\"render_config\")\n        if render_scene:\n            rc = render_scene.dict_data\n        else:\n            rc = {}\n\n        func_name = f\"render__{source_type}__as__{target_type}\"\n\n        func = getattr(self, func_name)\n        result = func(value=value, render_config=rc)\n        if isinstance(result, RenderValueResult):\n            render_scene_result: RenderValueResult = result\n        else:\n            render_scene_result = RenderValueResult(\n                value_id=value.value_id,\n                render_config=rc,\n                render_manifest=self.manifest.manifest_hash,\n                rendered=result,\n                related_scenes={},\n            )\n        render_scene_result.manifest_lookup[self.manifest.manifest_hash] = self.manifest\n\n        outputs.set_value(\"render_value_result\", render_scene_result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule._config_cls","title":"<code>_config_cls = RenderValueModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule.retrieve_supported_render_combinations","title":"<code>retrieve_supported_render_combinations() -&gt; Iterable[Tuple[str, str]]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>@classmethod\ndef retrieve_supported_render_combinations(cls) -&gt; Iterable[Tuple[str, str]]:\n\n    result = []\n    for attr in dir(cls):\n        if (\n            len(attr) &lt;= 16\n            or not attr.startswith(\"render__\")\n            or \"__as__\" not in attr\n        ):\n            continue\n\n        attr = attr[8:]\n        end_start_type = attr.find(\"__as__\")\n        source_type = attr[0:end_start_type]\n        target_type = attr[end_start_type + 6 :]\n        result.append((source_type, target_type))\n    return result\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    # instruction = self.get_config_value(\"render_scene_type\")\n    # model_registry = ModelRegistry.instance()\n    # instr_model_cls: Type[RenderScene] = model_registry.get_model_cls(instruction, required_subclass=RenderScene)  # type: ignore\n\n    # data_type_name = instr_model_cls.retrieve_source_type()\n    # assert data_type_name\n\n    source_type = self.get_config_value(\"source_type\")\n    optional = source_type == \"none\"\n    inputs = {\n        \"value\": {\n            \"type\": source_type,\n            \"doc\": f\"A value of type '{source_type}'\",\n            \"optional\": optional,\n        },\n        \"render_config\": {\n            \"type\": \"dict\",\n            \"doc\": \"Instructions/config on how (or what) to render the provided value.\",\n            \"default\": {},\n        },\n    }\n    return inputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    outputs = {\n        \"render_value_result\": {\n            \"type\": \"render_value_result\",\n            \"doc\": \"The rendered value, incl. some metadata.\",\n        },\n    }\n\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.RenderValueModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    value: Value = inputs.get_value_obj(\"value\")\n\n    render_scene: DictModel = inputs.get_value_data(\"render_config\")\n    if render_scene:\n        rc = render_scene.dict_data\n    else:\n        rc = {}\n\n    func_name = f\"render__{source_type}__as__{target_type}\"\n\n    func = getattr(self, func_name)\n    result = func(value=value, render_config=rc)\n    if isinstance(result, RenderValueResult):\n        render_scene_result: RenderValueResult = result\n    else:\n        render_scene_result = RenderValueResult(\n            value_id=value.value_id,\n            render_config=rc,\n            render_manifest=self.manifest.manifest_hash,\n            rendered=result,\n            related_scenes={},\n        )\n    render_scene_result.manifest_lookup[self.manifest.manifest_hash] = self.manifest\n\n    outputs.set_value(\"render_value_result\", render_scene_result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule","title":"<code>ValueTypeRenderModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> <p>A module that uses render methods attached to DataType classes.</p> Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>class ValueTypeRenderModule(KiaraModule):\n\"\"\"A module that uses render methods attached to DataType classes.\"\"\"\n\n    _module_type_name = \"render.value\"\n    _config_cls = RenderValueModuleConfig\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        source_type = self.get_config_value(\"source_type\")\n        assert source_type not in [\"target\", \"base_name\"]\n\n        schema = {\n            \"value\": {\n                \"type\": source_type,\n                \"doc\": \"The value to render.\",\n                \"optional\": False,\n            },\n            \"render_config\": {\n                \"type\": \"dict\",\n                \"doc\": \"Instructions/config on how (or what) to render the provided value.\",\n                \"default\": {},\n            },\n        }\n\n        return schema\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        outputs = {\n            \"render_value_result\": {\n                \"type\": \"render_value_result\",\n                \"doc\": \"The rendered value, incl. some metadata.\",\n            },\n        }\n\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        source_value = inputs.get_value_obj(\"value\")\n        if not source_value.is_set:\n            raise KiaraProcessingException(\n                f\"Can't render value '{source_value.value_id}': value not set.\"\n            )\n\n        # source_type = self.get_config_value(\"source_type\")\n        target_type = self.get_config_value(\"target_type\")\n\n        render_scene: DictModel = inputs.get_value_data(\"render_config\")\n\n        try:\n            data_type_cls = source_value.data_type_info.data_type_class.get_class()\n            data_type = data_type_cls(**source_value.value_schema.type_config)\n\n        except Exception as e:\n            source_data_type = source_value.data_type_name\n            log_message(\"data_type.unknown\", data_type=source_data_type, error=e)\n\n            from kiara.data_types.included_core_types import AnyType\n\n            data_type = AnyType()\n\n        func_name = f\"render_as__{target_type}\"\n        func = getattr(data_type, func_name)\n\n        if render_scene:\n            rc = render_scene.dict_data\n        else:\n            rc = {}\n\n        result = func(\n            value=source_value,\n            render_config=rc,\n            manifest=self.manifest,\n        )\n\n        if isinstance(result, RenderValueResult):\n            render_scene_result = result\n        else:\n            render_scene_result = RenderValueResult(\n                value_id=source_value.value_id,\n                render_config=rc,\n                render_manifest=self.manifest.manifest_hash,\n                rendered=result,\n                related_scenes={},\n                manifest_lookup={self.manifest.manifest_hash: self.manifest},\n            )\n\n        outputs.set_value(\"render_value_result\", render_scene_result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule._config_cls","title":"<code>_config_cls = RenderValueModuleConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    source_type = self.get_config_value(\"source_type\")\n    assert source_type not in [\"target\", \"base_name\"]\n\n    schema = {\n        \"value\": {\n            \"type\": source_type,\n            \"doc\": \"The value to render.\",\n            \"optional\": False,\n        },\n        \"render_config\": {\n            \"type\": \"dict\",\n            \"doc\": \"Instructions/config on how (or what) to render the provided value.\",\n            \"default\": {},\n        },\n    }\n\n    return schema\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    outputs = {\n        \"render_value_result\": {\n            \"type\": \"render_value_result\",\n            \"doc\": \"The rendered value, incl. some metadata.\",\n        },\n    }\n\n    return outputs\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value.ValueTypeRenderModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/render_value.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    source_value = inputs.get_value_obj(\"value\")\n    if not source_value.is_set:\n        raise KiaraProcessingException(\n            f\"Can't render value '{source_value.value_id}': value not set.\"\n        )\n\n    # source_type = self.get_config_value(\"source_type\")\n    target_type = self.get_config_value(\"target_type\")\n\n    render_scene: DictModel = inputs.get_value_data(\"render_config\")\n\n    try:\n        data_type_cls = source_value.data_type_info.data_type_class.get_class()\n        data_type = data_type_cls(**source_value.value_schema.type_config)\n\n    except Exception as e:\n        source_data_type = source_value.data_type_name\n        log_message(\"data_type.unknown\", data_type=source_data_type, error=e)\n\n        from kiara.data_types.included_core_types import AnyType\n\n        data_type = AnyType()\n\n    func_name = f\"render_as__{target_type}\"\n    func = getattr(data_type, func_name)\n\n    if render_scene:\n        rc = render_scene.dict_data\n    else:\n        rc = {}\n\n    result = func(\n        value=source_value,\n        render_config=rc,\n        manifest=self.manifest,\n    )\n\n    if isinstance(result, RenderValueResult):\n        render_scene_result = result\n    else:\n        render_scene_result = RenderValueResult(\n            value_id=source_value.value_id,\n            render_config=rc,\n            render_manifest=self.manifest.manifest_hash,\n            rendered=result,\n            related_scenes={},\n            manifest_lookup={self.manifest.manifest_hash: self.manifest},\n        )\n\n    outputs.set_value(\"render_value_result\", render_scene_result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/render_value/#kiara.modules.included_core_modules.render_value-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/","title":"serialization","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization-classes","title":"Classes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig","title":"<code>SerializeConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class SerializeConfig(KiaraModuleConfig):\n\n    value_type: str = Field(\n        description=\"The value type of the actual (unserialized) value.\"\n    )\n    target_profile: str = Field(\n        description=\"The profile name of the de-serialization result data.\"\n    )\n    serialization_profile: str = Field(\n        description=\"The name of the serialization profile used to serialize the source value.\"\n    )\n\n    @validator(\"value_type\")\n    def validate_source_type(cls, value):\n        if value == \"serialization_config\":\n            raise ValueError(f\"Invalid source type: {value}.\")\n        return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig.value_type","title":"<code>value_type: str = Field(description='The value type of the actual (unserialized) value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig.target_profile","title":"<code>target_profile: str = Field(description='The profile name of the de-serialization result data.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig.serialization_profile","title":"<code>serialization_profile: str = Field(description='The name of the serialization profile used to serialize the source value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.SerializeConfig.validate_source_type","title":"<code>validate_source_type(value)</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@validator(\"value_type\")\ndef validate_source_type(cls, value):\n    if value == \"serialization_config\":\n        raise ValueError(f\"Invalid source type: {value}.\")\n    return value\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule","title":"<code>DeserializeValueModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class DeserializeValueModule(KiaraModule):\n\n    _config_cls = SerializeConfig\n\n    @classmethod\n    @abc.abstractmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        raise NotImplementedError()\n\n    @classmethod\n    @abc.abstractmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        raise NotImplementedError()\n\n    @classmethod\n    @abc.abstractmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        raise NotImplementedError()\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        value_type = self.get_config_value(\"value_type\")\n        return {\n            value_type: {\n                \"type\": value_type,\n                \"doc\": \"The value object.\",\n            },\n            \"deserialization_config\": {\n                \"type\": \"any\",\n                \"doc\": \"Serialization-format specific configuration.\",\n                \"optional\": True,\n            },\n        }\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n        return {\n            \"python_object\": {\n                \"type\": \"python_object\",\n                \"doc\": \"The deserialized python object instance.\",\n            },\n        }\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS\n\n    def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n        value_type = self.get_config_value(\"value_type\")\n        serialized_value = inputs.get_value_obj(value_type)\n        config = inputs.get_value_obj(\"deserialization_config\")\n\n        target_profile = self.get_config_value(\"target_profile\")\n        func_name = f\"to__{target_profile}\"\n        func = getattr(self, func_name)\n\n        if config.is_set:\n            _config = config.data\n        else:\n            _config = {}\n\n        result: Any = func(data=serialized_value.serialized_data, **_config)\n        outputs.set_value(\"python_object\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule._config_cls","title":"<code>_config_cls = SerializeConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    value_type = self.get_config_value(\"value_type\")\n    return {\n        value_type: {\n            \"type\": value_type,\n            \"doc\": \"The value object.\",\n        },\n        \"deserialization_config\": {\n            \"type\": \"any\",\n            \"doc\": \"Serialization-format specific configuration.\",\n            \"optional\": True,\n        },\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; Mapping[str, Union[ValueSchema, Mapping[str, Any]]]:\n\n    return {\n        \"python_object\": {\n            \"type\": \"python_object\",\n            \"doc\": \"The deserialized python object instance.\",\n        },\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeValueModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap) -&gt; None</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap) -&gt; None:\n\n    value_type = self.get_config_value(\"value_type\")\n    serialized_value = inputs.get_value_obj(value_type)\n    config = inputs.get_value_obj(\"deserialization_config\")\n\n    target_profile = self.get_config_value(\"target_profile\")\n    func_name = f\"to__{target_profile}\"\n    func = getattr(self, func_name)\n\n    if config.is_set:\n        _config = config.data\n    else:\n        _config = {}\n\n    result: Any = func(data=serialized_value.serialized_data, **_config)\n    outputs.set_value(\"python_object\", result)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule","title":"<code>UnpickleModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class UnpickleModule(DeserializeValueModule):\n\n    _module_type_name = \"unpickle.value\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n\n        return {\"python_object\": object}\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"pickle\"\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n\n        return \"any\"\n\n    def to__python_object(self, data: SerializedData, **config: Any):\n\n        try:\n            import pickle5 as pickle\n        except Exception:\n            import pickle  # type: ignore\n\n        assert \"python_object\" in data.get_keys()\n        python_object_data = data.get_serialized_data(\"python_object\")\n        assert python_object_data.get_number_of_chunks() == 1\n\n        _bytes = list(python_object_data.get_chunks(as_files=False))[0]\n        data = pickle.loads(_bytes)\n\n        return data\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n\n    return {\"python_object\": object}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"pickle\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n\n    return \"any\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.UnpickleModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any)</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any):\n\n    try:\n        import pickle5 as pickle\n    except Exception:\n        import pickle  # type: ignore\n\n    assert \"python_object\" in data.get_keys()\n    python_object_data = data.get_serialized_data(\"python_object\")\n    assert python_object_data.get_number_of_chunks() == 1\n\n    _bytes = list(python_object_data.get_chunks(as_files=False))[0]\n    data = pickle.loads(_bytes)\n\n    return data\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule","title":"<code>LoadBytesModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class LoadBytesModule(DeserializeValueModule):\n\n    _module_type_name = \"load.bytes\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": bytes}\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"raw\"\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"bytes\"\n\n    def to__python_object(self, data: SerializedData, **config: Any) -&gt; bytes:\n\n        chunks = data.get_serialized_data(\"bytes\")\n        assert chunks.get_number_of_chunks() == 1\n        _chunks = list(chunks.get_chunks(as_files=False))\n        assert len(_chunks) == 1\n        _chunk: bytes = _chunks[0]  # type: ignore\n        return _chunk\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": bytes}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"raw\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"bytes\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadBytesModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any) -&gt; bytes</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any) -&gt; bytes:\n\n    chunks = data.get_serialized_data(\"bytes\")\n    assert chunks.get_number_of_chunks() == 1\n    _chunks = list(chunks.get_chunks(as_files=False))\n    assert len(_chunks) == 1\n    _chunk: bytes = _chunks[0]  # type: ignore\n    return _chunk\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule","title":"<code>LoadStringModule</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class LoadStringModule(DeserializeValueModule):\n\n    _module_type_name = \"load.string\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": str}\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"raw\"\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"string\"\n\n    def to__python_object(self, data: SerializedData, **config: Any) -&gt; str:\n\n        chunks = data.get_serialized_data(\"string\")\n        assert chunks.get_number_of_chunks() == 1\n        _chunks = list(chunks.get_chunks(as_files=False))\n        assert len(_chunks) == 1\n\n        bytes_string: bytes = _chunks[0]  # type: ignore\n        return bytes_string.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": str}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"raw\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"string\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadStringModule.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any) -&gt; str</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any) -&gt; str:\n\n    chunks = data.get_serialized_data(\"string\")\n    assert chunks.get_number_of_chunks() == 1\n    _chunks = list(chunks.get_chunks(as_files=False))\n    assert len(_chunks) == 1\n\n    bytes_string: bytes = _chunks[0]  # type: ignore\n    return bytes_string.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel","title":"<code>LoadInternalModel</code>","text":"<p>         Bases: <code>DeserializeValueModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class LoadInternalModel(DeserializeValueModule):\n\n    _module_type_name = \"load.internal_model\"\n\n    @classmethod\n    def retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n        return {\"python_object\": KiaraModel}\n\n    @classmethod\n    def retrieve_supported_serialization_profile(cls) -&gt; str:\n        return \"json\"\n\n    @classmethod\n    def retrieve_serialized_value_type(cls) -&gt; str:\n        return \"internal_model\"\n\n    def to__python_object(self, data: SerializedData, **config: Any) -&gt; KiaraModel:\n\n        chunks = data.get_serialized_data(\"data\")\n        assert chunks.get_number_of_chunks() == 1\n        _chunks = list(chunks.get_chunks(as_files=False))\n        assert len(_chunks) == 1\n\n        bytes_string: bytes = _chunks[0]  # type: ignore\n        model_data = orjson.loads(bytes_string)\n\n        model_id: str = data.data_type_config[\"kiara_model_id\"]\n        model_registry = ModelRegistry.instance()\n        m_cls = model_registry.get_model_cls(kiara_model_id=model_id)\n        obj = m_cls(**model_data)\n        return obj\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel.retrieve_supported_target_profiles","title":"<code>retrieve_supported_target_profiles() -&gt; Mapping[str, Type]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_target_profiles(cls) -&gt; Mapping[str, Type]:\n    return {\"python_object\": KiaraModel}\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel.retrieve_supported_serialization_profile","title":"<code>retrieve_supported_serialization_profile() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_supported_serialization_profile(cls) -&gt; str:\n    return \"json\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel.retrieve_serialized_value_type","title":"<code>retrieve_serialized_value_type() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>@classmethod\ndef retrieve_serialized_value_type(cls) -&gt; str:\n    return \"internal_model\"\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.LoadInternalModel.to__python_object","title":"<code>to__python_object(data: SerializedData, **config: Any) -&gt; KiaraModel</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def to__python_object(self, data: SerializedData, **config: Any) -&gt; KiaraModel:\n\n    chunks = data.get_serialized_data(\"data\")\n    assert chunks.get_number_of_chunks() == 1\n    _chunks = list(chunks.get_chunks(as_files=False))\n    assert len(_chunks) == 1\n\n    bytes_string: bytes = _chunks[0]  # type: ignore\n    model_data = orjson.loads(bytes_string)\n\n    model_id: str = data.data_type_config[\"kiara_model_id\"]\n    model_registry = ModelRegistry.instance()\n    m_cls = model_registry.get_model_cls(kiara_model_id=model_id)\n    obj = m_cls(**model_data)\n    return obj\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeJsonConfig","title":"<code>DeserializeJsonConfig</code>","text":"<p>         Bases: <code>KiaraModuleConfig</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class DeserializeJsonConfig(KiaraModuleConfig):\n\n    result_path: Union[str, None] = Field(\n        description=\"The path of the result dictionary to return.\", default=\"data\"\n    )\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeJsonConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeJsonConfig.result_path","title":"<code>result_path: Union[str, None] = Field(description='The path of the result dictionary to return.', default='data')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule","title":"<code>DeserializeFromJsonModule</code>","text":"<p>         Bases: <code>KiaraModule</code></p> Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>class DeserializeFromJsonModule(KiaraModule):\n\n    _module_type_name: str = \"deserialize.from_json\"\n    _config_cls = DeserializeJsonConfig\n\n    def _retrieve_module_characteristics(self) -&gt; ModuleCharacteristics:\n        return DEFAULT_IDEMPOTENT_INTERNAL_MODULE_CHARACTERISTICS\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"value\": {\n                \"type\": \"any\",\n                \"doc\": \"The value object to deserialize the data for.\",\n            }\n        }\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n\n        return {\n            \"python_object\": {\n                \"type\": \"python_object\",\n                \"doc\": \"The deserialized python object.\",\n            }\n        }\n\n    def process(self, inputs: ValueMap, outputs: ValueMap):\n\n        value: Value = inputs.get_value_obj(\"value\")\n        serialized: SerializedData = value.serialized_data\n\n        chunks = serialized.get_serialized_data(self.get_config_value(\"result_path\"))\n        assert chunks.get_number_of_chunks() == 1\n        _data = list(chunks.get_chunks(as_files=False))\n        assert len(_data) == 1\n        _chunk: bytes = _data[0]  # type: ignore\n\n        deserialized = orjson.loads(_chunk)\n\n        outputs.set_value(\"python_object\", deserialized)\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule._config_cls","title":"<code>_config_cls = DeserializeJsonConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule-functions","title":"Functions","text":""},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"value\": {\n            \"type\": \"any\",\n            \"doc\": \"The value object to deserialize the data for.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n\n    return {\n        \"python_object\": {\n            \"type\": \"python_object\",\n            \"doc\": \"The deserialized python object.\",\n        }\n    }\n</code></pre>"},{"location":"reference/kiara/modules/included_core_modules/serialization/#kiara.modules.included_core_modules.serialization.DeserializeFromJsonModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap)</code>","text":"Source code in <code>kiara/modules/included_core_modules/serialization.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap):\n\n    value: Value = inputs.get_value_obj(\"value\")\n    serialized: SerializedData = value.serialized_data\n\n    chunks = serialized.get_serialized_data(self.get_config_value(\"result_path\"))\n    assert chunks.get_number_of_chunks() == 1\n    _data = list(chunks.get_chunks(as_files=False))\n    assert len(_data) == 1\n    _chunk: bytes = _data[0]  # type: ignore\n\n    deserialized = orjson.loads(_chunk)\n\n    outputs.set_value(\"python_object\", deserialized)\n</code></pre>"},{"location":"reference/kiara/operations/__init__/","title":"operations","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations.OPERATION_TYPE_DETAILS","title":"<code>OPERATION_TYPE_DETAILS = TypeVar('OPERATION_TYPE_DETAILS', bound=OperationDetails)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType","title":"<code>OperationType</code>","text":"<p>         Bases: <code>abc.ABC</code>, <code>Generic[OPERATION_TYPE_DETAILS]</code></p> Source code in <code>kiara/operations/__init__.py</code> <pre><code>class OperationType(abc.ABC, Generic[OPERATION_TYPE_DETAILS]):\n    def __init__(self, kiara: \"Kiara\", op_type_name: str):\n        self._kiara: Kiara = kiara\n        self._op_type_name: str = op_type_name\n\n    @property\n    def operations(self) -&gt; Mapping[str, Operation]:\n        return {\n            op_id: self._kiara.operation_registry.get_operation(op_id)\n            for op_id in self._kiara.operation_registry.operations_by_type[\n                self._op_type_name\n            ]\n        }\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n        return []\n\n    @abc.abstractmethod\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[OPERATION_TYPE_DETAILS, None]:\n\"\"\"Check whether the provided module is a valid operation for this type.\"\"\"\n\n    def retrieve_operation_details(\n        self, operation: Union[Operation, str]\n    ) -&gt; OPERATION_TYPE_DETAILS:\n\"\"\"Retrieve operation details for provided operation.\n\n        This is really just a utility method, to make the type checker happy.\n        \"\"\"\n\n        if isinstance(operation, str):\n            operation = self.operations[operation]\n\n        return operation.operation_details  # type: ignore\n\n    def create_renderable(self, **config):\n\n        info = OperationTypeInfo.create_from_type_class(\n            kiara=None, type_cls=self.__class__\n        )\n        return info.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType.operations","title":"<code>operations: Mapping[str, Operation]</code>  <code>property</code>","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/__init__.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n    return []\n</code></pre>"},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[OPERATION_TYPE_DETAILS, None]</code>  <code>abstractmethod</code>","text":"<p>Check whether the provided module is a valid operation for this type.</p> Source code in <code>kiara/operations/__init__.py</code> <pre><code>@abc.abstractmethod\ndef check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[OPERATION_TYPE_DETAILS, None]:\n\"\"\"Check whether the provided module is a valid operation for this type.\"\"\"\n</code></pre>"},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType.retrieve_operation_details","title":"<code>retrieve_operation_details(operation: Union[Operation, str]) -&gt; OPERATION_TYPE_DETAILS</code>","text":"<p>Retrieve operation details for provided operation.</p> <p>This is really just a utility method, to make the type checker happy.</p> Source code in <code>kiara/operations/__init__.py</code> <pre><code>def retrieve_operation_details(\n    self, operation: Union[Operation, str]\n) -&gt; OPERATION_TYPE_DETAILS:\n\"\"\"Retrieve operation details for provided operation.\n\n    This is really just a utility method, to make the type checker happy.\n    \"\"\"\n\n    if isinstance(operation, str):\n        operation = self.operations[operation]\n\n    return operation.operation_details  # type: ignore\n</code></pre>"},{"location":"reference/kiara/operations/__init__/#kiara.operations.OperationType.create_renderable","title":"<code>create_renderable(**config)</code>","text":"Source code in <code>kiara/operations/__init__.py</code> <pre><code>def create_renderable(self, **config):\n\n    info = OperationTypeInfo.create_from_type_class(\n        kiara=None, type_cls=self.__class__\n    )\n    return info.create_renderable(**config)\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/","title":"included_core_operations","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails","title":"<code>CustomModuleOperationDetails</code>","text":"<p>         Bases: <code>OperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>class CustomModuleOperationDetails(OperationDetails):\n    @classmethod\n    def create_from_module(cls, module: KiaraModule):\n\n        return CustomModuleOperationDetails(\n            operation_id=module.module_type_name,\n            module_inputs_schema=module.inputs_schema,\n            module_outputs_schema=module.outputs_schema,\n        )\n\n    module_inputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The input schemas of the module.\"\n    )\n    module_outputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The output schemas of the module.\"\n    )\n    _op_schema: OperationSchema = PrivateAttr(default=None)\n\n    def get_operation_schema(self) -&gt; OperationSchema:\n\n        if self._op_schema is not None:\n            return self._op_schema\n\n        self._op_schema = OperationSchema(\n            alias=self.operation_id,\n            inputs_schema=self.module_inputs_schema,\n            outputs_schema=self.module_outputs_schema,\n        )\n        return self._op_schema\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails.module_inputs_schema","title":"<code>module_inputs_schema: Mapping[str, ValueSchema] = Field(description='The input schemas of the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails.module_outputs_schema","title":"<code>module_outputs_schema: Mapping[str, ValueSchema] = Field(description='The output schemas of the module.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails.create_from_module","title":"<code>create_from_module(module: KiaraModule)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>@classmethod\ndef create_from_module(cls, module: KiaraModule):\n\n    return CustomModuleOperationDetails(\n        operation_id=module.module_type_name,\n        module_inputs_schema=module.inputs_schema,\n        module_outputs_schema=module.outputs_schema,\n    )\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationDetails.get_operation_schema","title":"<code>get_operation_schema() -&gt; OperationSchema</code>","text":"Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>def get_operation_schema(self) -&gt; OperationSchema:\n\n    if self._op_schema is not None:\n        return self._op_schema\n\n    self._op_schema = OperationSchema(\n        alias=self.operation_id,\n        inputs_schema=self.module_inputs_schema,\n        outputs_schema=self.module_outputs_schema,\n    )\n    return self._op_schema\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationType","title":"<code>CustomModuleOperationType</code>","text":"<p>         Bases: <code>OperationType[CustomModuleOperationDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>class CustomModuleOperationType(OperationType[CustomModuleOperationDetails]):\n\n    _operation_type_name = \"custom_module\"\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = []\n        for name, module_cls in self._kiara.module_type_classes.items():\n            mod_conf = module_cls._config_cls\n            if mod_conf.requires_config():\n                logger.debug(\n                    \"ignore.custom_operation\",\n                    module_type=name,\n                    reason=\"config required\",\n                )\n                continue\n            doc = DocumentationMetadataModel.from_class_doc(module_cls)\n            oc = ManifestOperationConfig(module_type=name, doc=doc)\n            result.append(oc)\n        return result\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[CustomModuleOperationDetails, None]:\n        mod_conf = module.__class__._config_cls\n\n        if not mod_conf.requires_config():\n            is_internal = module.characteristics.is_internal\n            # inputs_map = {k: k for k in module.inputs_schema.keys()}\n            # outputs_map = {k: k for k in module.outputs_schema.keys()}\n            op_details = CustomModuleOperationDetails.create_operation_details(\n                operation_id=module.module_type_name,\n                module_inputs_schema=module.inputs_schema,\n                module_outputs_schema=module.outputs_schema,\n                is_internal_operation=is_internal,\n            )\n            return op_details\n        else:\n            return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = []\n    for name, module_cls in self._kiara.module_type_classes.items():\n        mod_conf = module_cls._config_cls\n        if mod_conf.requires_config():\n            logger.debug(\n                \"ignore.custom_operation\",\n                module_type=name,\n                reason=\"config required\",\n            )\n            continue\n        doc = DocumentationMetadataModel.from_class_doc(module_cls)\n        oc = ManifestOperationConfig(module_type=name, doc=doc)\n        result.append(oc)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/__init__/#kiara.operations.included_core_operations.CustomModuleOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[CustomModuleOperationDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/__init__.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[CustomModuleOperationDetails, None]:\n    mod_conf = module.__class__._config_cls\n\n    if not mod_conf.requires_config():\n        is_internal = module.characteristics.is_internal\n        # inputs_map = {k: k for k in module.inputs_schema.keys()}\n        # outputs_map = {k: k for k in module.outputs_schema.keys()}\n        op_details = CustomModuleOperationDetails.create_operation_details(\n            operation_id=module.module_type_name,\n            module_inputs_schema=module.inputs_schema,\n            module_outputs_schema=module.outputs_schema,\n            is_internal_operation=is_internal,\n        )\n        return op_details\n    else:\n        return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/create_from/","title":"create_from","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateValueFromDetails","title":"<code>CreateValueFromDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/create_from.py</code> <pre><code>class CreateValueFromDetails(BaseOperationDetails):\n\n    source_type: str = Field(description=\"The type of the value to be created.\")\n    target_type: str = Field(description=\"The result type.\")\n    optional_args: Mapping[str, ValueSchema] = Field(description=\"Optional arguments.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateValueFromDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateValueFromDetails.source_type","title":"<code>source_type: str = Field(description='The type of the value to be created.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateValueFromDetails.target_type","title":"<code>target_type: str = Field(description='The result type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateValueFromDetails.optional_args","title":"<code>optional_args: Mapping[str, ValueSchema] = Field(description='Optional arguments.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateFromOperationType","title":"<code>CreateFromOperationType</code>","text":"<p>         Bases: <code>OperationType[CreateValueFromDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/create_from.py</code> <pre><code>class CreateFromOperationType(OperationType[CreateValueFromDetails]):\n\n    _operation_type_name = \"create_from\"\n\n    def _calculate_op_id(self, source_type: str, target_type: str):\n\n        if source_type == \"any\":\n            operation_id = f\"create.{target_type}\"\n        else:\n            operation_id = f\"create.{target_type}.from.{source_type}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = {}\n        for name, module_cls in self._kiara.module_type_classes.items():\n            if not hasattr(module_cls, \"retrieve_supported_create_combinations\"):\n                continue\n\n            try:\n                supported_combinations = module_cls.retrieve_supported_create_combinations()  # type: ignore\n                for sup_comb in supported_combinations:\n                    source_type = sup_comb[\"source_type\"]\n                    target_type = sup_comb[\"target_type\"]\n                    func = sup_comb[\"func\"]\n\n                    if source_type not in self._kiara.data_type_names:\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Source type '{source_type}' not registered.\",\n                        )\n                        continue\n                    if target_type not in self._kiara.data_type_names:\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Target type '{target_type}' not registered.\",\n                        )\n                        continue\n                    if not hasattr(module_cls, func):\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Specified create function '{func}' not available.\",\n                        )\n                        continue\n\n                    mc = {\"source_type\": source_type, \"target_type\": target_type}\n                    # TODO: check whether module config actually supports those, for now, only 'CreateFromModule' subtypes are supported\n                    _func = getattr(module_cls, func)\n                    doc = DocumentationMetadataModel.from_function(_func)\n\n                    oc = ManifestOperationConfig(\n                        module_type=name, module_config=mc, doc=doc\n                    )\n                    op_id = self._calculate_op_id(\n                        source_type=source_type, target_type=target_type\n                    )\n                    result[op_id] = oc\n            except Exception as e:\n                log_exception(e)\n                logger.debug(\n                    \"ignore.create_operation_instance\", module_type=name, reason=e\n                )\n                continue\n\n        return result.values()\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[CreateValueFromDetails, None]:\n\n        if not isinstance(module, CreateFromModule):\n            return None\n\n        source_type = None\n        for field_name, schema in module.inputs_schema.items():\n            if field_name == schema.type:\n                if source_type is not None:\n                    logger.debug(\n                        \"ignore.operation\",\n                        operation_type=\"create_from\",\n                        reason=f\"more than one possible target type field: {field_name}\",\n                    )\n                    return None\n                source_type = field_name\n\n        if source_type is None:\n            return None\n\n        target_type = None\n        for field_name, schema in module.outputs_schema.items():\n            if field_name == schema.type:\n                if target_type is not None:\n                    logger.debug(\n                        \"ignore.operation\",\n                        operation_type=\"create_from\",\n                        reason=f\"more than one possible target type field: {field_name}\",\n                    )\n                    return None\n                target_type = field_name\n\n        if target_type is None:\n            return None\n\n        op_id = self._calculate_op_id(source_type=source_type, target_type=target_type)\n\n        if (\n            \"any\" in self._kiara.type_registry.get_type_lineage(target_type)\n            and target_type != \"any\"\n        ):\n            is_internal = False\n        else:\n            is_internal = True\n\n        optional = {}\n        for field, schema in module.inputs_schema.items():\n            if field == source_type:\n                continue\n            optional[field] = schema\n\n        details = {\n            \"module_inputs_schema\": module.inputs_schema,\n            \"module_outputs_schema\": module.outputs_schema,\n            \"operation_id\": op_id,\n            \"source_type\": source_type,\n            \"target_type\": target_type,\n            \"optional_args\": optional,\n            \"is_internal_operation\": is_internal,\n        }\n\n        result = CreateValueFromDetails.create_operation_details(**details)\n        return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateFromOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateFromOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/create_from.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = {}\n    for name, module_cls in self._kiara.module_type_classes.items():\n        if not hasattr(module_cls, \"retrieve_supported_create_combinations\"):\n            continue\n\n        try:\n            supported_combinations = module_cls.retrieve_supported_create_combinations()  # type: ignore\n            for sup_comb in supported_combinations:\n                source_type = sup_comb[\"source_type\"]\n                target_type = sup_comb[\"target_type\"]\n                func = sup_comb[\"func\"]\n\n                if source_type not in self._kiara.data_type_names:\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Source type '{source_type}' not registered.\",\n                    )\n                    continue\n                if target_type not in self._kiara.data_type_names:\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Target type '{target_type}' not registered.\",\n                    )\n                    continue\n                if not hasattr(module_cls, func):\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Specified create function '{func}' not available.\",\n                    )\n                    continue\n\n                mc = {\"source_type\": source_type, \"target_type\": target_type}\n                # TODO: check whether module config actually supports those, for now, only 'CreateFromModule' subtypes are supported\n                _func = getattr(module_cls, func)\n                doc = DocumentationMetadataModel.from_function(_func)\n\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                op_id = self._calculate_op_id(\n                    source_type=source_type, target_type=target_type\n                )\n                result[op_id] = oc\n        except Exception as e:\n            log_exception(e)\n            logger.debug(\n                \"ignore.create_operation_instance\", module_type=name, reason=e\n            )\n            continue\n\n    return result.values()\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from.CreateFromOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[CreateValueFromDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/create_from.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[CreateValueFromDetails, None]:\n\n    if not isinstance(module, CreateFromModule):\n        return None\n\n    source_type = None\n    for field_name, schema in module.inputs_schema.items():\n        if field_name == schema.type:\n            if source_type is not None:\n                logger.debug(\n                    \"ignore.operation\",\n                    operation_type=\"create_from\",\n                    reason=f\"more than one possible target type field: {field_name}\",\n                )\n                return None\n            source_type = field_name\n\n    if source_type is None:\n        return None\n\n    target_type = None\n    for field_name, schema in module.outputs_schema.items():\n        if field_name == schema.type:\n            if target_type is not None:\n                logger.debug(\n                    \"ignore.operation\",\n                    operation_type=\"create_from\",\n                    reason=f\"more than one possible target type field: {field_name}\",\n                )\n                return None\n            target_type = field_name\n\n    if target_type is None:\n        return None\n\n    op_id = self._calculate_op_id(source_type=source_type, target_type=target_type)\n\n    if (\n        \"any\" in self._kiara.type_registry.get_type_lineage(target_type)\n        and target_type != \"any\"\n    ):\n        is_internal = False\n    else:\n        is_internal = True\n\n    optional = {}\n    for field, schema in module.inputs_schema.items():\n        if field == source_type:\n            continue\n        optional[field] = schema\n\n    details = {\n        \"module_inputs_schema\": module.inputs_schema,\n        \"module_outputs_schema\": module.outputs_schema,\n        \"operation_id\": op_id,\n        \"source_type\": source_type,\n        \"target_type\": target_type,\n        \"optional_args\": optional,\n        \"is_internal_operation\": is_internal,\n    }\n\n    result = CreateValueFromDetails.create_operation_details(**details)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/create_from/#kiara.operations.included_core_operations.create_from-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/","title":"export_as","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationDetails","title":"<code>ExportAsOperationDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/export_as.py</code> <pre><code>class ExportAsOperationDetails(BaseOperationDetails):\n\n    source_type: str = Field(description=\"The type of the value to be created.\")\n    target_profile: str = Field(description=\"The result profile type.\")\n    optional_args: Mapping[str, ValueSchema] = Field(description=\"Optional arguments.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationDetails.source_type","title":"<code>source_type: str = Field(description='The type of the value to be created.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationDetails.target_profile","title":"<code>target_profile: str = Field(description='The result profile type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationDetails.optional_args","title":"<code>optional_args: Mapping[str, ValueSchema] = Field(description='Optional arguments.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationType","title":"<code>ExportAsOperationType</code>","text":"<p>         Bases: <code>OperationType[ExportAsOperationDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/export_as.py</code> <pre><code>class ExportAsOperationType(OperationType[ExportAsOperationDetails]):\n\n    _operation_type_name = \"export_as\"\n\n    def _calculate_op_id(self, source_type: str, target_profile: str):\n\n        if source_type == \"any\":\n            operation_id = f\"export.as.{target_profile}\"\n        else:\n            operation_id = f\"export.{source_type}.as.{target_profile}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = []\n        for name, module_cls in self._kiara.module_type_classes.items():\n            if not hasattr(module_cls, \"retrieve_supported_export_combinations\"):\n                continue\n\n            try:\n                supported_combinations = module_cls.retrieve_supported_export_combinations()  # type: ignore\n                for sup_comb in supported_combinations:\n                    source_type = sup_comb[\"source_type\"]\n                    target_profile = sup_comb[\"target_profile\"]\n                    func = sup_comb[\"func\"]\n\n                    if source_type not in self._kiara.data_type_names:\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Source type '{source_type}' not registered.\",\n                        )\n                        continue\n\n                    if not hasattr(module_cls, func):\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Specified create function '{func}' not available.\",\n                        )\n                        continue\n\n                    mc = {\"source_type\": source_type, \"target_profile\": target_profile}\n                    # TODO: check whether module config actually supports those, for now, only 'DataExportModule' subtypes are supported\n                    _func = getattr(module_cls, func)\n                    doc = DocumentationMetadataModel.from_function(_func)\n\n                    oc = ManifestOperationConfig(\n                        module_type=name, module_config=mc, doc=doc\n                    )\n                    result.append(oc)\n            except Exception as e:\n                log_exception(e)\n                logger.debug(\n                    \"ignore.create_operation_instance\", module_type=name, reason=e\n                )\n                continue\n\n        return result\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[ExportAsOperationDetails, None]:\n\n        if not isinstance(module, DataExportModule):\n            return None\n\n        source_type = None\n        for field_name, schema in module.inputs_schema.items():\n            if field_name == schema.type:\n                if source_type is not None:\n                    logger.debug(\n                        \"ignore.operation\",\n                        operation_type=\"create_from\",\n                        reason=f\"more than one possible target type field: {field_name}\",\n                    )\n                    return None\n                source_type = field_name\n\n        if source_type is None:\n            return None\n\n        target_profile = module.config.target_profile\n\n        op_id = self._calculate_op_id(\n            source_type=source_type, target_profile=target_profile\n        )\n\n        optional = {}\n        for field, schema in module.inputs_schema.items():\n            if field in [source_type]:\n                continue\n            optional[field] = schema\n\n        details = {\n            \"module_inputs_schema\": module.inputs_schema,\n            \"module_outputs_schema\": module.outputs_schema,\n            \"operation_id\": op_id,\n            \"source_type\": source_type,\n            \"target_profile\": target_profile,\n            \"optional_args\": optional,\n            \"is_internal_operation\": False,\n        }\n\n        result = ExportAsOperationDetails.create_operation_details(**details)\n        return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/export_as.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = []\n    for name, module_cls in self._kiara.module_type_classes.items():\n        if not hasattr(module_cls, \"retrieve_supported_export_combinations\"):\n            continue\n\n        try:\n            supported_combinations = module_cls.retrieve_supported_export_combinations()  # type: ignore\n            for sup_comb in supported_combinations:\n                source_type = sup_comb[\"source_type\"]\n                target_profile = sup_comb[\"target_profile\"]\n                func = sup_comb[\"func\"]\n\n                if source_type not in self._kiara.data_type_names:\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Source type '{source_type}' not registered.\",\n                    )\n                    continue\n\n                if not hasattr(module_cls, func):\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Specified create function '{func}' not available.\",\n                    )\n                    continue\n\n                mc = {\"source_type\": source_type, \"target_profile\": target_profile}\n                # TODO: check whether module config actually supports those, for now, only 'DataExportModule' subtypes are supported\n                _func = getattr(module_cls, func)\n                doc = DocumentationMetadataModel.from_function(_func)\n\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                result.append(oc)\n        except Exception as e:\n            log_exception(e)\n            logger.debug(\n                \"ignore.create_operation_instance\", module_type=name, reason=e\n            )\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as.ExportAsOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[ExportAsOperationDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/export_as.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[ExportAsOperationDetails, None]:\n\n    if not isinstance(module, DataExportModule):\n        return None\n\n    source_type = None\n    for field_name, schema in module.inputs_schema.items():\n        if field_name == schema.type:\n            if source_type is not None:\n                logger.debug(\n                    \"ignore.operation\",\n                    operation_type=\"create_from\",\n                    reason=f\"more than one possible target type field: {field_name}\",\n                )\n                return None\n            source_type = field_name\n\n    if source_type is None:\n        return None\n\n    target_profile = module.config.target_profile\n\n    op_id = self._calculate_op_id(\n        source_type=source_type, target_profile=target_profile\n    )\n\n    optional = {}\n    for field, schema in module.inputs_schema.items():\n        if field in [source_type]:\n            continue\n        optional[field] = schema\n\n    details = {\n        \"module_inputs_schema\": module.inputs_schema,\n        \"module_outputs_schema\": module.outputs_schema,\n        \"operation_id\": op_id,\n        \"source_type\": source_type,\n        \"target_profile\": target_profile,\n        \"optional_args\": optional,\n        \"is_internal_operation\": False,\n    }\n\n    result = ExportAsOperationDetails.create_operation_details(**details)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/export_as/#kiara.operations.included_core_operations.export_as-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/","title":"filter","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails","title":"<code>FilterOperationDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>class FilterOperationDetails(BaseOperationDetails):\n\n    data_type: str = Field(description=\"The data type of the value to be filtered.\")\n    data_type_config: Mapping[str, Any] = Field(\n        description=\"The configuration of the data type to be filtered.\",\n        default_factory=dict,\n    )\n    filter_name: str = Field(description=\"The filter operation name.\")\n    optional_args: Mapping[str, ValueSchema] = Field(description=\"Optional arguments.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails.data_type","title":"<code>data_type: str = Field(description='The data type of the value to be filtered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails.data_type_config","title":"<code>data_type_config: Mapping[str, Any] = Field(description='The configuration of the data type to be filtered.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails.filter_name","title":"<code>filter_name: str = Field(description='The filter operation name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationDetails.optional_args","title":"<code>optional_args: Mapping[str, ValueSchema] = Field(description='Optional arguments.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType","title":"<code>FilterOperationType</code>","text":"<p>         Bases: <code>OperationType[FilterOperationDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>class FilterOperationType(OperationType[FilterOperationDetails]):\n\n    _operation_type_name = \"filter\"\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = []\n\n        for name, module_cls in self._kiara.module_type_classes.items():\n\n            if not issubclass(module_cls, FilterModule):\n                continue\n\n            try:\n                data_type_data = module_cls.get_supported_type()\n                data_type: str = data_type_data[\"type\"]  # type: ignore\n                # data_type_config: Mapping[str, Any] = data_type[\"type_config\"]  # type: ignore\n\n                # TODO; try to create data type obj?\n                if data_type not in self._kiara.data_type_names:\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Data type '{data_type}' not registered.\",\n                    )\n                    continue\n\n                supported_filters = module_cls.get_supported_filters()\n                for filter in supported_filters:\n\n                    func_name = f\"filter__{filter}\"\n\n                    if not hasattr(module_cls, func_name):\n                        logger.debug(\n                            \"ignore.operation_config\",\n                            module_type=name,\n                            reason=f\"Specified filter function '{func_name}' not available.\",\n                        )\n                        continue\n\n                    mc = {\"filter_name\": filter}\n                    # TODO: check whether module config actually supports those, for now, only 'DataExportModule' subtypes are supported\n                    _func = getattr(module_cls, func_name)\n                    doc = DocumentationMetadataModel.from_function(_func)\n                    oc = ManifestOperationConfig(\n                        module_type=name, module_config=mc, doc=doc\n                    )\n                    result.append(oc)\n            except Exception as e:\n                log_exception(e)\n                logger.debug(\n                    \"ignore.create_operation_instance\", module_type=name, reason=e\n                )\n                continue\n\n        return result\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[FilterOperationDetails, None]:\n\n        if not isinstance(module, FilterModule):\n            return None\n\n        data_type_data = module.__class__.get_supported_type()\n        data_type: str = data_type_data[\"type\"]  # type: ignore\n        data_type_config: Mapping[str, Any] = data_type_data[\"type_config\"]  # type: ignore\n\n        filter_name = module.get_config_value(\"filter_name\")\n\n        op_id = f\"{data_type}_filter.{filter_name}\"\n\n        optional = {}\n        for field, schema in module.inputs_schema.items():\n            if field in [data_type]:\n                continue\n            optional[field] = schema\n\n        details = {\n            \"module_inputs_schema\": module.inputs_schema,\n            \"module_outputs_schema\": module.outputs_schema,\n            \"operation_id\": op_id,\n            \"data_type\": data_type,\n            \"data_type_config\": data_type_config,\n            \"filter_name\": filter_name,\n            \"optional_args\": optional,\n            \"is_internal_operation\": False,\n        }\n\n        result = FilterOperationDetails.create_operation_details(**details)\n        return result\n\n    def find_filter_operations_for_data_type(\n        self, data_type: str\n    ) -&gt; Dict[str, Operation]:\n\n        result = {}\n        for op in self.operations.values():\n            details: FilterOperationDetails = op.operation_details  # type: ignore\n            if details.data_type == data_type:\n                result[details.filter_name] = op\n\n        return result\n\n    def get_filter(self, data_type: str, filter_name: str) -&gt; Filter:\n\n        try:\n            op = self._kiara.operation_registry.get_operation(operation_id=filter_name)\n        except Exception:\n            op_id = f\"{data_type}_filter.{filter_name}\"\n            op = self.operations.get(op_id, None)  # type: ignore\n            if op is None:\n                raise Exception(\n                    f\"No filter operation '{filter_name}' available for type '{data_type}'.\"\n                )\n\n        inp_match = []\n        for input_name, schema in op.inputs_schema.items():\n            # TODO: check lineage/profiles\n            if schema.type == data_type:\n                inp_match.append(input_name)\n\n        if not inp_match:\n            raise Exception(\n                f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}': input fields for operation '{op.operation_id}' don't match.\"\n            )\n        if len(inp_match) &gt; 1:\n            if \"value\" in inp_match:\n                inp_match = [\"value\"]\n            elif data_type in inp_match:\n                inp_match = [data_type]\n            else:\n                raise Exception(\n                    f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}', operation '{op.operation_id}' has multiple potential input fields: {', '.join(inp_match)}.\"\n                )\n\n        input_field = inp_match[0]\n\n        outp_match = []\n        for output_name, schema in op.outputs_schema.items():\n            # TODO: check lineage/profiles\n            if schema.type == data_type:\n                outp_match.append(output_name)\n\n        if not outp_match:\n            raise Exception(\n                f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}': output fields for operation '{op.operation_id}' don't match.\"\n            )\n        if len(outp_match) &gt; 1:\n            if \"value\" in outp_match:\n                outp_match = [\"value\"]\n            elif data_type in outp_match:\n                outp_match = [data_type]\n            else:\n                raise Exception(\n                    f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}', operation '{op.operation_id}' has multiple potential output fields: {', '.join(outp_match)}.\"\n                )\n\n        output_field = outp_match[0]\n        filter = Filter.construct(\n            operation=op,\n            input_name=input_field,\n            output_name=output_field,\n            data_type=data_type,\n        )\n        return filter\n\n    def assemble_filter_pipeline_config(\n        self,\n        data_type: str,\n        filters: Union[str, Iterable[str], Mapping[str, str]],\n        endpoint: Union[None, Manifest, str] = None,\n        endpoint_input_field: Union[str, None] = None,\n        endpoint_step_id: Union[str, None] = None,\n        extra_input_aliases: Union[None, Mapping[str, str]] = None,\n        extra_output_aliases: Union[None, Mapping[str, str]] = None,\n    ) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n        Optionally, a module that uses the filtered dataset as input can be specified.\n\n        # TODO: document filter names\n        For the 'filters' argument, the accepted inputs are:\n        - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n        - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n        - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n        Arguments:\n            data_type: the type of the data to filter\n            filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n            endpoint: optional module to put as last step in the created pipeline\n            endpoing_input_field: field name of the input that will receive the filtered value\n            endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n            extra_output_aliases: extra output aliases to add to the pipeline config\n\n        Returns:\n            the (pipeline) module configuration of the filter pipeline\n        \"\"\"\n\n        steps: List[Mapping[str, Any]] = []\n        last_filter_id: Union[str, None] = None\n        last_filter_output_name: Union[str, None] = None\n        input_aliases: Dict[str, str] = {}\n        output_aliases: Dict[str, str] = {}\n\n        if isinstance(filters, str):\n            filters = {filters: filters}\n\n        if not isinstance(filters, Mapping):\n            _filters = {}\n            _step_ids: List[str] = []\n            for filter_name in filters:\n                step_id = find_free_id(stem=filter_name, current_ids=_step_ids)\n                _filters[step_id] = filter_name\n            filters = _filters\n\n        for filter_name, step_id in filters.items():\n            if not input_aliases:\n                input_aliases[f\"{filter_name}.value\"] = \"value\"\n            filter = self.get_filter(data_type=data_type, filter_name=filter_name)\n            step_data = {\n                \"module_type\": filter.operation.operation_id,\n                \"step_id\": step_id,\n            }\n            if last_filter_id:\n                step_data[\"input_links\"] = {\n                    filter.input_name: f\"{last_filter_id}.{last_filter_output_name}\"\n                }\n            last_filter_id = step_id\n            last_filter_output_name = filter.output_name\n            steps.append(step_data)\n            output_aliases[f\"{step_id}.value\"] = f\"{step_id}__filtered\"\n\n        output_aliases[f\"{last_filter_id}.{last_filter_output_name}\"] = \"filtered_value\"\n\n        doc = f\"Auto generated filter operation ({'-&gt;'.join(filters.keys())}) for type '{data_type}'\"\n\n        if endpoint:\n            endpoint_module = self._kiara.module_registry.create_module(\n                manifest=endpoint\n            )\n            if endpoint_input_field is None:\n                matches = []\n                for field_name, schema in endpoint_module.inputs_schema.items():\n                    # TODO: check profiles/lineage\n                    if schema.type == data_type:\n                        matches.append(field_name)\n                if not matches:\n                    raise Exception(\n                        f\"Can't assemble filter operation: no potential input field of type {data_type} for endpoint module found.\"\n                    )\n                elif len(matches) &gt; 1:\n                    raise Exception(\n                        f\"Can't assemble filter operation: multiple potential input fields of type {data_type} for endpoint module found: {', '.join(matches)}\"\n                    )\n                endpoint_input_field = matches[0]\n\n            if not endpoint_step_id:\n                endpoint_step_id = find_free_id(\n                    stem=endpoint_module.module_type_name, current_ids=filters.values()\n                )\n            step_data = {\n                \"module_type\": endpoint_module.module_type_name,\n                \"module_config\": endpoint_module.config.dict(),\n                \"step_id\": endpoint_step_id,\n            }\n            step_data[\"input_links\"] = {\n                endpoint_input_field: {f\"{last_filter_id}.{last_filter_output_name}\"}\n            }\n            # for field_name in endpoint_module.output_names:\n            #     output_aliases[f\"{endpoint_step_id}.{field_name}\"] = f\"endpoint__{field_name}\"\n            doc = f\"{doc}, feeding into endpoing module '{endpoint_module.module_type_name}'.\"\n            steps.append(step_data)\n        else:\n            doc = f\"{doc}.\"\n\n        if extra_output_aliases:\n            for k, v in extra_output_aliases.items():\n                output_aliases[k] = v\n\n        if extra_input_aliases:\n            input_aliases.update(extra_input_aliases)\n            # raise NotImplementedError(\"Extra input aliases not supported yet.\")\n\n        pipeline_config = PipelineConfig.from_config(\n            pipeline_name=\"_filter_pipeline\",\n            data={\n                \"steps\": steps,\n                \"input_aliases\": input_aliases,\n                \"output_aliases\": output_aliases,\n                \"doc\": doc,\n            },\n        )\n\n        return pipeline_config\n\n    def create_filter_operation(\n        self,\n        data_type: str,\n        filters: Union[Iterable[str], Mapping[str, str]],\n        endpoint: Union[None, Manifest, str] = None,\n        endpoint_input_field: Union[str, None] = None,\n        endpoint_step_id: Union[str, None] = None,\n    ) -&gt; Operation:\n\n        pipeline_config = self.assemble_filter_pipeline_config(\n            data_type=data_type,\n            filters=filters,\n            endpoint=endpoint,\n            endpoint_input_field=endpoint_input_field,\n            endpoint_step_id=endpoint_step_id,\n        )\n\n        manifest = Manifest(\n            module_type=\"pipeline\", module_config=pipeline_config.dict()\n        )\n        module = self._kiara.module_registry.create_module(manifest=manifest)\n\n        op_details = PipelineOperationDetails.create_operation_details(\n            operation_id=module.config.pipeline_name,\n            pipeline_inputs_schema=module.inputs_schema,\n            pipeline_outputs_schema=module.outputs_schema,\n            pipeline_config=module.config,\n        )\n        operation = Operation(\n            module_type=manifest.module_type,\n            module_config=manifest.module_config,\n            operation_id=op_details.operation_id,\n            operation_details=op_details,\n            module_details=KiaraModuleInstance.from_module(module),\n            metadata={},\n            doc=pipeline_config.doc,\n        )\n        return operation\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = []\n\n    for name, module_cls in self._kiara.module_type_classes.items():\n\n        if not issubclass(module_cls, FilterModule):\n            continue\n\n        try:\n            data_type_data = module_cls.get_supported_type()\n            data_type: str = data_type_data[\"type\"]  # type: ignore\n            # data_type_config: Mapping[str, Any] = data_type[\"type_config\"]  # type: ignore\n\n            # TODO; try to create data type obj?\n            if data_type not in self._kiara.data_type_names:\n                logger.debug(\n                    \"ignore.operation_config\",\n                    module_type=name,\n                    reason=f\"Data type '{data_type}' not registered.\",\n                )\n                continue\n\n            supported_filters = module_cls.get_supported_filters()\n            for filter in supported_filters:\n\n                func_name = f\"filter__{filter}\"\n\n                if not hasattr(module_cls, func_name):\n                    logger.debug(\n                        \"ignore.operation_config\",\n                        module_type=name,\n                        reason=f\"Specified filter function '{func_name}' not available.\",\n                    )\n                    continue\n\n                mc = {\"filter_name\": filter}\n                # TODO: check whether module config actually supports those, for now, only 'DataExportModule' subtypes are supported\n                _func = getattr(module_cls, func_name)\n                doc = DocumentationMetadataModel.from_function(_func)\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                result.append(oc)\n        except Exception as e:\n            log_exception(e)\n            logger.debug(\n                \"ignore.create_operation_instance\", module_type=name, reason=e\n            )\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[FilterOperationDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[FilterOperationDetails, None]:\n\n    if not isinstance(module, FilterModule):\n        return None\n\n    data_type_data = module.__class__.get_supported_type()\n    data_type: str = data_type_data[\"type\"]  # type: ignore\n    data_type_config: Mapping[str, Any] = data_type_data[\"type_config\"]  # type: ignore\n\n    filter_name = module.get_config_value(\"filter_name\")\n\n    op_id = f\"{data_type}_filter.{filter_name}\"\n\n    optional = {}\n    for field, schema in module.inputs_schema.items():\n        if field in [data_type]:\n            continue\n        optional[field] = schema\n\n    details = {\n        \"module_inputs_schema\": module.inputs_schema,\n        \"module_outputs_schema\": module.outputs_schema,\n        \"operation_id\": op_id,\n        \"data_type\": data_type,\n        \"data_type_config\": data_type_config,\n        \"filter_name\": filter_name,\n        \"optional_args\": optional,\n        \"is_internal_operation\": False,\n    }\n\n    result = FilterOperationDetails.create_operation_details(**details)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.find_filter_operations_for_data_type","title":"<code>find_filter_operations_for_data_type(data_type: str) -&gt; Dict[str, Operation]</code>","text":"Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def find_filter_operations_for_data_type(\n    self, data_type: str\n) -&gt; Dict[str, Operation]:\n\n    result = {}\n    for op in self.operations.values():\n        details: FilterOperationDetails = op.operation_details  # type: ignore\n        if details.data_type == data_type:\n            result[details.filter_name] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.get_filter","title":"<code>get_filter(data_type: str, filter_name: str) -&gt; Filter</code>","text":"Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def get_filter(self, data_type: str, filter_name: str) -&gt; Filter:\n\n    try:\n        op = self._kiara.operation_registry.get_operation(operation_id=filter_name)\n    except Exception:\n        op_id = f\"{data_type}_filter.{filter_name}\"\n        op = self.operations.get(op_id, None)  # type: ignore\n        if op is None:\n            raise Exception(\n                f\"No filter operation '{filter_name}' available for type '{data_type}'.\"\n            )\n\n    inp_match = []\n    for input_name, schema in op.inputs_schema.items():\n        # TODO: check lineage/profiles\n        if schema.type == data_type:\n            inp_match.append(input_name)\n\n    if not inp_match:\n        raise Exception(\n            f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}': input fields for operation '{op.operation_id}' don't match.\"\n        )\n    if len(inp_match) &gt; 1:\n        if \"value\" in inp_match:\n            inp_match = [\"value\"]\n        elif data_type in inp_match:\n            inp_match = [data_type]\n        else:\n            raise Exception(\n                f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}', operation '{op.operation_id}' has multiple potential input fields: {', '.join(inp_match)}.\"\n            )\n\n    input_field = inp_match[0]\n\n    outp_match = []\n    for output_name, schema in op.outputs_schema.items():\n        # TODO: check lineage/profiles\n        if schema.type == data_type:\n            outp_match.append(output_name)\n\n    if not outp_match:\n        raise Exception(\n            f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}': output fields for operation '{op.operation_id}' don't match.\"\n        )\n    if len(outp_match) &gt; 1:\n        if \"value\" in outp_match:\n            outp_match = [\"value\"]\n        elif data_type in outp_match:\n            outp_match = [data_type]\n        else:\n            raise Exception(\n                f\"Can't retrieve filter with name '{filter_name}' for data type: '{data_type}', operation '{op.operation_id}' has multiple potential output fields: {', '.join(outp_match)}.\"\n            )\n\n    output_field = outp_match[0]\n    filter = Filter.construct(\n        operation=op,\n        input_name=input_field,\n        output_name=output_field,\n        data_type=data_type,\n    )\n    return filter\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.assemble_filter_pipeline_config","title":"<code>assemble_filter_pipeline_config(data_type: str, filters: Union[str, Iterable[str], Mapping[str, str]], endpoint: Union[None, Manifest, str] = None, endpoint_input_field: Union[str, None] = None, endpoint_step_id: Union[str, None] = None, extra_input_aliases: Union[None, Mapping[str, str]] = None, extra_output_aliases: Union[None, Mapping[str, str]] = None) -&gt; PipelineConfig</code>","text":"<p>Assemble a (pipeline) module config to filter values of a specific data type.</p> <p>Optionally, a module that uses the filtered dataset as input can be specified.</p>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.assemble_filter_pipeline_config--todo-document-filter-names","title":"TODO: document filter names","text":"<p>For the 'filters' argument, the accepted inputs are: - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically - a map of string pairs: the keys are step ids, the values operation ids or filter names</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>the type of the data to filter</p> required <code>filters</code> <code>Union[str, Iterable[str], Mapping[str, str]]</code> <p>a list of operation ids or filter names (and potentiall step_ids if type is a mapping)</p> required <code>endpoint</code> <code>Union[None, Manifest, str]</code> <p>optional module to put as last step in the created pipeline</p> <code>None</code> <code>endpoing_input_field</code> <p>field name of the input that will receive the filtered value</p> required <code>endpoint_step_id</code> <code>Union[str, None]</code> <p>id to use for the endpoint step (module type name will be used if not provided)</p> <code>None</code> <code>extra_output_aliases</code> <code>Union[None, Mapping[str, str]]</code> <p>extra output aliases to add to the pipeline config</p> <code>None</code> <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>the (pipeline) module configuration of the filter pipeline</p> Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def assemble_filter_pipeline_config(\n    self,\n    data_type: str,\n    filters: Union[str, Iterable[str], Mapping[str, str]],\n    endpoint: Union[None, Manifest, str] = None,\n    endpoint_input_field: Union[str, None] = None,\n    endpoint_step_id: Union[str, None] = None,\n    extra_input_aliases: Union[None, Mapping[str, str]] = None,\n    extra_output_aliases: Union[None, Mapping[str, str]] = None,\n) -&gt; PipelineConfig:\n\"\"\"Assemble a (pipeline) module config to filter values of a specific data type.\n\n    Optionally, a module that uses the filtered dataset as input can be specified.\n\n    # TODO: document filter names\n    For the 'filters' argument, the accepted inputs are:\n    - a string, in which case a single-step pipeline will be created, with the string referencing the operation id or filter\n    - a list of strings: in which case a multi-step pipeline will be created, the step_ids will be calculated automatically\n    - a map of string pairs: the keys are step ids, the values operation ids or filter names\n\n    Arguments:\n        data_type: the type of the data to filter\n        filters: a list of operation ids or filter names (and potentiall step_ids if type is a mapping)\n        endpoint: optional module to put as last step in the created pipeline\n        endpoing_input_field: field name of the input that will receive the filtered value\n        endpoint_step_id: id to use for the endpoint step (module type name will be used if not provided)\n        extra_output_aliases: extra output aliases to add to the pipeline config\n\n    Returns:\n        the (pipeline) module configuration of the filter pipeline\n    \"\"\"\n\n    steps: List[Mapping[str, Any]] = []\n    last_filter_id: Union[str, None] = None\n    last_filter_output_name: Union[str, None] = None\n    input_aliases: Dict[str, str] = {}\n    output_aliases: Dict[str, str] = {}\n\n    if isinstance(filters, str):\n        filters = {filters: filters}\n\n    if not isinstance(filters, Mapping):\n        _filters = {}\n        _step_ids: List[str] = []\n        for filter_name in filters:\n            step_id = find_free_id(stem=filter_name, current_ids=_step_ids)\n            _filters[step_id] = filter_name\n        filters = _filters\n\n    for filter_name, step_id in filters.items():\n        if not input_aliases:\n            input_aliases[f\"{filter_name}.value\"] = \"value\"\n        filter = self.get_filter(data_type=data_type, filter_name=filter_name)\n        step_data = {\n            \"module_type\": filter.operation.operation_id,\n            \"step_id\": step_id,\n        }\n        if last_filter_id:\n            step_data[\"input_links\"] = {\n                filter.input_name: f\"{last_filter_id}.{last_filter_output_name}\"\n            }\n        last_filter_id = step_id\n        last_filter_output_name = filter.output_name\n        steps.append(step_data)\n        output_aliases[f\"{step_id}.value\"] = f\"{step_id}__filtered\"\n\n    output_aliases[f\"{last_filter_id}.{last_filter_output_name}\"] = \"filtered_value\"\n\n    doc = f\"Auto generated filter operation ({'-&gt;'.join(filters.keys())}) for type '{data_type}'\"\n\n    if endpoint:\n        endpoint_module = self._kiara.module_registry.create_module(\n            manifest=endpoint\n        )\n        if endpoint_input_field is None:\n            matches = []\n            for field_name, schema in endpoint_module.inputs_schema.items():\n                # TODO: check profiles/lineage\n                if schema.type == data_type:\n                    matches.append(field_name)\n            if not matches:\n                raise Exception(\n                    f\"Can't assemble filter operation: no potential input field of type {data_type} for endpoint module found.\"\n                )\n            elif len(matches) &gt; 1:\n                raise Exception(\n                    f\"Can't assemble filter operation: multiple potential input fields of type {data_type} for endpoint module found: {', '.join(matches)}\"\n                )\n            endpoint_input_field = matches[0]\n\n        if not endpoint_step_id:\n            endpoint_step_id = find_free_id(\n                stem=endpoint_module.module_type_name, current_ids=filters.values()\n            )\n        step_data = {\n            \"module_type\": endpoint_module.module_type_name,\n            \"module_config\": endpoint_module.config.dict(),\n            \"step_id\": endpoint_step_id,\n        }\n        step_data[\"input_links\"] = {\n            endpoint_input_field: {f\"{last_filter_id}.{last_filter_output_name}\"}\n        }\n        # for field_name in endpoint_module.output_names:\n        #     output_aliases[f\"{endpoint_step_id}.{field_name}\"] = f\"endpoint__{field_name}\"\n        doc = f\"{doc}, feeding into endpoing module '{endpoint_module.module_type_name}'.\"\n        steps.append(step_data)\n    else:\n        doc = f\"{doc}.\"\n\n    if extra_output_aliases:\n        for k, v in extra_output_aliases.items():\n            output_aliases[k] = v\n\n    if extra_input_aliases:\n        input_aliases.update(extra_input_aliases)\n        # raise NotImplementedError(\"Extra input aliases not supported yet.\")\n\n    pipeline_config = PipelineConfig.from_config(\n        pipeline_name=\"_filter_pipeline\",\n        data={\n            \"steps\": steps,\n            \"input_aliases\": input_aliases,\n            \"output_aliases\": output_aliases,\n            \"doc\": doc,\n        },\n    )\n\n    return pipeline_config\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter.FilterOperationType.create_filter_operation","title":"<code>create_filter_operation(data_type: str, filters: Union[Iterable[str], Mapping[str, str]], endpoint: Union[None, Manifest, str] = None, endpoint_input_field: Union[str, None] = None, endpoint_step_id: Union[str, None] = None) -&gt; Operation</code>","text":"Source code in <code>kiara/operations/included_core_operations/filter.py</code> <pre><code>def create_filter_operation(\n    self,\n    data_type: str,\n    filters: Union[Iterable[str], Mapping[str, str]],\n    endpoint: Union[None, Manifest, str] = None,\n    endpoint_input_field: Union[str, None] = None,\n    endpoint_step_id: Union[str, None] = None,\n) -&gt; Operation:\n\n    pipeline_config = self.assemble_filter_pipeline_config(\n        data_type=data_type,\n        filters=filters,\n        endpoint=endpoint,\n        endpoint_input_field=endpoint_input_field,\n        endpoint_step_id=endpoint_step_id,\n    )\n\n    manifest = Manifest(\n        module_type=\"pipeline\", module_config=pipeline_config.dict()\n    )\n    module = self._kiara.module_registry.create_module(manifest=manifest)\n\n    op_details = PipelineOperationDetails.create_operation_details(\n        operation_id=module.config.pipeline_name,\n        pipeline_inputs_schema=module.inputs_schema,\n        pipeline_outputs_schema=module.outputs_schema,\n        pipeline_config=module.config,\n    )\n    operation = Operation(\n        module_type=manifest.module_type,\n        module_config=manifest.module_config,\n        operation_id=op_details.operation_id,\n        operation_details=op_details,\n        module_details=KiaraModuleInstance.from_module(module),\n        metadata={},\n        doc=pipeline_config.doc,\n    )\n    return operation\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/filter/#kiara.operations.included_core_operations.filter-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/","title":"import_data","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOpDetails","title":"<code>ImportDataOpDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/import_data.py</code> <pre><code>class ImportDataOpDetails(BaseOperationDetails):\n\n    source_type: str = Field(description=\"The type of the value to be created.\")\n    target_type: str = Field(description=\"The result type.\")\n    optional_args: Mapping[str, ValueSchema] = Field(description=\"Optional arguments.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOpDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOpDetails.source_type","title":"<code>source_type: str = Field(description='The type of the value to be created.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOpDetails.target_type","title":"<code>target_type: str = Field(description='The result type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOpDetails.optional_args","title":"<code>optional_args: Mapping[str, ValueSchema] = Field(description='Optional arguments.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOperationType","title":"<code>ImportDataOperationType</code>","text":"<p>         Bases: <code>OperationType[ImportDataOpDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/import_data.py</code> <pre><code>class ImportDataOperationType(OperationType[ImportDataOpDetails]):\n\n    _operation_type_name = \"import_data\"\n\n    def _calculate_op_id(self, source_type: str, target_type: str):\n\n        if source_type == \"any\":\n            operation_id = f\"import.{target_type}\"\n        else:\n            operation_id = f\"create.{target_type}.from.{source_type}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result: Iterable[Union[Mapping, OperationConfig]] = []\n        return result\n        # for name, module_cls in self._kiara.module_type_classes.items():\n        #     if not hasattr(module_cls, \"retrieve_supported_create_combinations\"):\n        #         continue\n        #\n        #     try:\n        #         supported_combinations = module_cls.retrieve_supported_create_combinations()  # type: ignore\n        #         for sup_comb in supported_combinations:\n        #             source_type = sup_comb[\"source_type\"]\n        #             target_type = sup_comb[\"target_type\"]\n        #             func = sup_comb[\"func\"]\n        #\n        #             if source_type not in self._kiara.data_type_names:\n        #                 logger.debug(\n        #                     \"ignore.operation_config\",\n        #                     module_type=name,\n        #                     reason=f\"Source type '{source_type}' not registered.\",\n        #                 )\n        #                 continue\n        #             if target_type not in self._kiara.data_type_names:\n        #                 logger.debug(\n        #                     \"ignore.operation_config\",\n        #                     module_type=name,\n        #                     reason=f\"Target type '{target_type}' not registered.\",\n        #                 )\n        #                 continue\n        #             if not hasattr(module_cls, func):\n        #                 logger.debug(\n        #                     \"ignore.operation_config\",\n        #                     module_type=name,\n        #                     reason=f\"Specified create function '{func}' not available.\",\n        #                 )\n        #                 continue\n        #\n        #             mc = {\"source_type\": source_type, \"target_type\": target_type}\n        #             # TODO: check whether module config actually supports those, for now, only 'CreateFromModule' subtypes are supported\n        #             _func = getattr(module_cls, func)\n        #             doc = DocumentationMetadataModel.from_function(_func)\n        #\n        #             oc = ManifestOperationConfig(\n        #                 module_type=name, module_config=mc, doc=doc\n        #             )\n        #             op_id = self._calculate_op_id(\n        #                 source_type=source_type, target_type=target_type\n        #             )\n        #             result[op_id] = oc\n        #     except Exception as e:\n        #         log_exception(e)\n        #         logger.debug(\n        #             \"ignore.create_operation_instance\", module_type=name, reason=e\n        #         )\n        #         continue\n        #\n        # return result.values()\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[ImportDataOpDetails, None]:\n\n        return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/import_data.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result: Iterable[Union[Mapping, OperationConfig]] = []\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/import_data/#kiara.operations.included_core_operations.import_data.ImportDataOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[ImportDataOpDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/import_data.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[ImportDataOpDetails, None]:\n\n    return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/metadata/","title":"metadata","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails","title":"<code>ExtractMetadataDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> <p>A model that contains information needed to describe an 'extract_metadata' operation.</p> Source code in <code>kiara/operations/included_core_operations/metadata.py</code> <pre><code>class ExtractMetadataDetails(BaseOperationDetails):\n\"\"\"A model that contains information needed to describe an 'extract_metadata' operation.\"\"\"\n\n    data_type: str = Field(\n        description=\"The data type this metadata operation can be used with.\"\n    )\n    metadata_key: str = Field(description=\"The metadata key.\")\n    input_field_name: str = Field(description=\"The input field name.\")\n    result_field_name: str = Field(description=\"The result field name.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails.data_type","title":"<code>data_type: str = Field(description='The data type this metadata operation can be used with.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails.metadata_key","title":"<code>metadata_key: str = Field(description='The metadata key.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails.input_field_name","title":"<code>input_field_name: str = Field(description='The input field name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataDetails.result_field_name","title":"<code>result_field_name: str = Field(description='The result field name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType","title":"<code>ExtractMetadataOperationType</code>","text":"<p>         Bases: <code>OperationType[ExtractMetadataDetails]</code></p> <p>An operation that extracts metadata of a specific type from value data.</p> <p>For a module profile to be picked up by this operation type, it needs to have: - exactly one input field - that input field must have the same name as its value type, or be 'value' - exactly one output field, whose field name is called 'value_metadata', and where the value has the type 'internal_model'</p> Source code in <code>kiara/operations/included_core_operations/metadata.py</code> <pre><code>class ExtractMetadataOperationType(OperationType[ExtractMetadataDetails]):\n\"\"\"An operation that extracts metadata of a specific type from value data.\n\n    For a module profile to be picked up by this operation type, it needs to have:\n    - exactly one input field\n    - that input field must have the same name as its value type, or be 'value'\n    - exactly one output field, whose field name is called 'value_metadata', and where the value has the type 'internal_model'\n    \"\"\"\n\n    _operation_type_name = \"extract_metadata\"\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        model_registry = ModelRegistry.instance()\n        all_models = model_registry.get_models_of_type(ValueMetadata)\n\n        result = []\n        for model_id, model_cls_info in all_models.item_infos.items():\n            model_cls: Type[ValueMetadata] = model_cls_info.python_class.get_class()  # type: ignore\n            metadata_key = model_cls._metadata_key  # type: ignore\n            data_types = model_cls.retrieve_supported_data_types()\n            if isinstance(data_types, str):\n                data_types = [data_types]\n            for data_type in data_types:\n\n                config = {\n                    \"module_type\": \"value.extract_metadata\",\n                    \"module_config\": {\n                        \"data_type\": data_type,\n                        \"kiara_model_id\": model_cls._kiara_model_id,  # type: ignore\n                    },\n                    \"doc\": f\"Extract '{metadata_key}' metadata for value type '{data_type}'.\",\n                }\n                result.append(config)\n\n        return result\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[ExtractMetadataDetails, None]:\n\n        if len(module.outputs_schema) != 1:\n            return None\n        if (\n            \"value_metadata\" not in module.outputs_schema\n            or module.outputs_schema[\"value_metadata\"].type != \"internal_model\"\n        ):\n            return None\n        if len(module.inputs_schema) != 1:\n            return None\n\n        input_field_name = next(iter(module.inputs_schema.keys()))\n        input_schema = module.inputs_schema.get(input_field_name)\n        assert input_schema is not None\n        if input_field_name != input_schema.type and input_field_name != \"value\":\n            return None\n\n        data_type_name = module.inputs_schema[\"value\"].type\n        model_id: str = module.get_config_value(\"kiara_model_id\")\n\n        registry = ModelRegistry.instance()\n        metadata_model_cls = registry.get_model_cls(\n            kiara_model_id=model_id, required_subclass=ValueMetadata\n        )\n\n        metadata_key = metadata_model_cls._metadata_key  # type: ignore\n\n        if data_type_name == \"any\":\n            op_id = f\"extract.{metadata_key}.metadata\"\n        else:\n            op_id = f\"extract.{metadata_key}.metadata.from.{data_type_name}\"\n\n        details = ExtractMetadataDetails.create_operation_details(\n            module_inputs_schema=module.inputs_schema,\n            module_outputs_schema=module.outputs_schema,\n            operation_id=op_id,\n            data_type=data_type_name,\n            metadata_key=metadata_key,\n            input_field_name=input_field_name,\n            result_field_name=\"value_metadata\",\n            is_internal_operation=True,\n        )\n\n        return details\n\n    def get_operations_for_data_type(self, data_type: str) -&gt; Mapping[str, Operation]:\n\"\"\"Return all available metadata extract operations for the provided type (and it's parent types).\n\n        Arguments:\n            data_type: the value type\n\n        Returns:\n            a mapping with the metadata type as key, and the operation as value\n        \"\"\"\n\n        lineage = set(\n            self._kiara.type_registry.get_type_lineage(data_type_name=data_type)\n        )\n\n        result = {}\n\n        for op_id, op in self.operations.items():\n            op_details = self.retrieve_operation_details(op)\n            included = op_details.data_type in lineage\n            if not included:\n                continue\n            metadata_key = op_details.metadata_key\n            if metadata_key in result:\n                raise Exception(\n                    f\"Duplicate metadata operations for type '{metadata_key}'.\"\n                )\n\n            result[metadata_key] = op\n\n        return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/metadata.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    model_registry = ModelRegistry.instance()\n    all_models = model_registry.get_models_of_type(ValueMetadata)\n\n    result = []\n    for model_id, model_cls_info in all_models.item_infos.items():\n        model_cls: Type[ValueMetadata] = model_cls_info.python_class.get_class()  # type: ignore\n        metadata_key = model_cls._metadata_key  # type: ignore\n        data_types = model_cls.retrieve_supported_data_types()\n        if isinstance(data_types, str):\n            data_types = [data_types]\n        for data_type in data_types:\n\n            config = {\n                \"module_type\": \"value.extract_metadata\",\n                \"module_config\": {\n                    \"data_type\": data_type,\n                    \"kiara_model_id\": model_cls._kiara_model_id,  # type: ignore\n                },\n                \"doc\": f\"Extract '{metadata_key}' metadata for value type '{data_type}'.\",\n            }\n            result.append(config)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[ExtractMetadataDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/metadata.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[ExtractMetadataDetails, None]:\n\n    if len(module.outputs_schema) != 1:\n        return None\n    if (\n        \"value_metadata\" not in module.outputs_schema\n        or module.outputs_schema[\"value_metadata\"].type != \"internal_model\"\n    ):\n        return None\n    if len(module.inputs_schema) != 1:\n        return None\n\n    input_field_name = next(iter(module.inputs_schema.keys()))\n    input_schema = module.inputs_schema.get(input_field_name)\n    assert input_schema is not None\n    if input_field_name != input_schema.type and input_field_name != \"value\":\n        return None\n\n    data_type_name = module.inputs_schema[\"value\"].type\n    model_id: str = module.get_config_value(\"kiara_model_id\")\n\n    registry = ModelRegistry.instance()\n    metadata_model_cls = registry.get_model_cls(\n        kiara_model_id=model_id, required_subclass=ValueMetadata\n    )\n\n    metadata_key = metadata_model_cls._metadata_key  # type: ignore\n\n    if data_type_name == \"any\":\n        op_id = f\"extract.{metadata_key}.metadata\"\n    else:\n        op_id = f\"extract.{metadata_key}.metadata.from.{data_type_name}\"\n\n    details = ExtractMetadataDetails.create_operation_details(\n        module_inputs_schema=module.inputs_schema,\n        module_outputs_schema=module.outputs_schema,\n        operation_id=op_id,\n        data_type=data_type_name,\n        metadata_key=metadata_key,\n        input_field_name=input_field_name,\n        result_field_name=\"value_metadata\",\n        is_internal_operation=True,\n    )\n\n    return details\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/metadata/#kiara.operations.included_core_operations.metadata.ExtractMetadataOperationType.get_operations_for_data_type","title":"<code>get_operations_for_data_type(data_type: str) -&gt; Mapping[str, Operation]</code>","text":"<p>Return all available metadata extract operations for the provided type (and it's parent types).</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>the value type</p> required <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a mapping with the metadata type as key, and the operation as value</p> Source code in <code>kiara/operations/included_core_operations/metadata.py</code> <pre><code>def get_operations_for_data_type(self, data_type: str) -&gt; Mapping[str, Operation]:\n\"\"\"Return all available metadata extract operations for the provided type (and it's parent types).\n\n    Arguments:\n        data_type: the value type\n\n    Returns:\n        a mapping with the metadata type as key, and the operation as value\n    \"\"\"\n\n    lineage = set(\n        self._kiara.type_registry.get_type_lineage(data_type_name=data_type)\n    )\n\n    result = {}\n\n    for op_id, op in self.operations.items():\n        op_details = self.retrieve_operation_details(op)\n        included = op_details.data_type in lineage\n        if not included:\n            continue\n        metadata_key = op_details.metadata_key\n        if metadata_key in result:\n            raise Exception(\n                f\"Duplicate metadata operations for type '{metadata_key}'.\"\n            )\n\n        result[metadata_key] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/","title":"pipeline","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails","title":"<code>PipelineOperationDetails</code>","text":"<p>         Bases: <code>OperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/pipeline.py</code> <pre><code>class PipelineOperationDetails(OperationDetails):\n\n    pipeline_inputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The input schema for the pipeline.\"\n    )\n    pipeline_outputs_schema: Mapping[str, ValueSchema] = Field(\n        description=\"The output schema for the pipeline.\"\n    )\n    pipeline_config: PipelineConfig = Field(description=\"The pipeline config.\")\n    _op_schema: OperationSchema = PrivateAttr(default=None)\n\n    def get_operation_schema(self) -&gt; OperationSchema:\n\n        if self._op_schema is not None:\n            return self._op_schema\n\n        self._op_schema = OperationSchema(\n            alias=self.operation_id,\n            inputs_schema=self.pipeline_inputs_schema,\n            outputs_schema=self.pipeline_outputs_schema,\n        )\n        return self._op_schema\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails.pipeline_inputs_schema","title":"<code>pipeline_inputs_schema: Mapping[str, ValueSchema] = Field(description='The input schema for the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails.pipeline_outputs_schema","title":"<code>pipeline_outputs_schema: Mapping[str, ValueSchema] = Field(description='The output schema for the pipeline.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails.pipeline_config","title":"<code>pipeline_config: PipelineConfig = Field(description='The pipeline config.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationDetails.get_operation_schema","title":"<code>get_operation_schema() -&gt; OperationSchema</code>","text":"Source code in <code>kiara/operations/included_core_operations/pipeline.py</code> <pre><code>def get_operation_schema(self) -&gt; OperationSchema:\n\n    if self._op_schema is not None:\n        return self._op_schema\n\n    self._op_schema = OperationSchema(\n        alias=self.operation_id,\n        inputs_schema=self.pipeline_inputs_schema,\n        outputs_schema=self.pipeline_outputs_schema,\n    )\n    return self._op_schema\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType","title":"<code>PipelineOperationType</code>","text":"<p>         Bases: <code>OperationType[PipelineOperationDetails]</code></p> Source code in <code>kiara/operations/included_core_operations/pipeline.py</code> <pre><code>class PipelineOperationType(OperationType[PipelineOperationDetails]):\n\n    _operation_type_name = \"pipeline\"\n\n    def __init__(self, kiara: \"Kiara\", op_type_name: str) -&gt; None:\n\n        super().__init__(kiara=kiara, op_type_name=op_type_name)\n        self._pipelines: Union[None, Mapping[str, Mapping[str, Any]]] = None\n\n    @property\n    def pipeline_data(self) -&gt; Mapping[str, Mapping[str, Any]]:\n\n        if self._pipelines is not None:\n            return self._pipelines\n\n        ignore_errors = False\n        pipeline_paths: Dict[\n            str, Union[Dict[str, Any], None]\n        ] = find_all_kiara_pipeline_paths(skip_errors=ignore_errors)\n\n        for ep in self._kiara.context_config.extra_pipelines:\n            ep = os.path.realpath(ep)\n            if ep not in pipeline_paths.keys():\n                pipeline_paths[ep] = None\n\n        return find_pipeline_data_in_paths(pipeline_paths)\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        op_configs = []\n        for pipeline_name, pipeline_data in self.pipeline_data.items():\n            pipeline_config: Dict[str, Any] = dict(pipeline_data[\"data\"])\n            pipeline_id = pipeline_config.pop(\"pipeline_name\", None)\n            doc = pipeline_config.get(\"doc\", None)\n            pipeline_metadata = pipeline_data[\"metadata\"]\n\n            op_details = PipelineOperationConfig(\n                pipeline_name=pipeline_id,\n                pipeline_config=pipeline_config,\n                doc=doc,\n                metadata=pipeline_metadata,\n            )\n            op_configs.append(op_details)\n        return op_configs\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[PipelineOperationDetails, None]:\n\n        if isinstance(module, PipelineModule):\n\n            op_details = PipelineOperationDetails.create_operation_details(\n                operation_id=module.config.pipeline_name,\n                pipeline_inputs_schema=module.inputs_schema,\n                pipeline_outputs_schema=module.outputs_schema,\n                pipeline_config=module.config,\n            )\n            return op_details\n        else:\n            return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType.pipeline_data","title":"<code>pipeline_data: Mapping[str, Mapping[str, Any]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pipeline.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    op_configs = []\n    for pipeline_name, pipeline_data in self.pipeline_data.items():\n        pipeline_config: Dict[str, Any] = dict(pipeline_data[\"data\"])\n        pipeline_id = pipeline_config.pop(\"pipeline_name\", None)\n        doc = pipeline_config.get(\"doc\", None)\n        pipeline_metadata = pipeline_data[\"metadata\"]\n\n        op_details = PipelineOperationConfig(\n            pipeline_name=pipeline_id,\n            pipeline_config=pipeline_config,\n            doc=doc,\n            metadata=pipeline_metadata,\n        )\n        op_configs.append(op_details)\n    return op_configs\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline.PipelineOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[PipelineOperationDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pipeline.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[PipelineOperationDetails, None]:\n\n    if isinstance(module, PipelineModule):\n\n        op_details = PipelineOperationDetails.create_operation_details(\n            operation_id=module.config.pipeline_name,\n            pipeline_inputs_schema=module.inputs_schema,\n            pipeline_outputs_schema=module.outputs_schema,\n            pipeline_config=module.config,\n        )\n        return op_details\n    else:\n        return None\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pipeline/#kiara.operations.included_core_operations.pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/","title":"pretty_print","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintDetails","title":"<code>PrettyPrintDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>class PrettyPrintDetails(BaseOperationDetails):\n\n    source_type: str = Field(description=\"The type of the value to be rendered.\")\n    target_type: str = Field(description=\"The type of the render result.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintDetails.source_type","title":"<code>source_type: str = Field(description='The type of the value to be rendered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintDetails.target_type","title":"<code>target_type: str = Field(description='The type of the render result.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType","title":"<code>PrettyPrintOperationType</code>","text":"<p>         Bases: <code>OperationType[PrettyPrintDetails]</code></p> <p>An operation that takes a value, and renders into a format that can be printed for output..</p> <p>For a module profile to be picked up by this operation type, it needs to have: - exactly one output field named \"rendered_value\" - exactly two input fields, one of them named after the type it supports, and the other called 'render_config', of type 'dict'</p> Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>class PrettyPrintOperationType(OperationType[PrettyPrintDetails]):\n\"\"\"An operation that takes a value, and renders into a format that can be printed for output..\n\n    For a module profile to be picked up by this operation type, it needs to have:\n    - exactly one output field named \"rendered_value\"\n    - exactly two input fields, one of them named after the type it supports, and the other called 'render_config', of type 'dict'\n    \"\"\"\n\n    _operation_type_name = \"pretty_print\"\n\n    def _calculate_op_id(self, source_type: str, target_type: str):\n\n        if source_type == \"any\":\n            operation_id = f\"pretty_print.as.{target_type}\"\n        else:\n            operation_id = f\"pretty_print.{source_type}.as.{target_type}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = {}\n        for name, module_cls in self._kiara.module_type_classes.items():\n\n            if not issubclass(module_cls, PrettyPrintModule):\n                continue\n\n            for (\n                source_type,\n                target_type,\n            ) in module_cls.retrieve_supported_render_combinations():\n                if source_type not in self._kiara.data_type_names:\n                    log_message(\"ignore.operation_config\", operation_type=\"pretty_print\", module_type=module_cls._module_type_name, source_type=source_type, target_type=target_type, reason=f\"Source type '{source_type}' not registered.\")  # type: ignore\n                    continue\n                if target_type not in self._kiara.data_type_names:\n                    log_message(\n                        \"ignore.operation_config\",\n                        operation_type=\"pretty_print\",\n                        module_type=module_cls._module_type_name,\n                        source_type=source_type,  # type: ignore\n                        target_type=target_type,\n                        reason=f\"Target type '{target_type}' not registered.\",\n                    )\n                    continue\n                func_name = f\"pretty_print__{source_type}__as__{target_type}\"\n                attr = getattr(module_cls, func_name)\n                doc = DocumentationMetadataModel.from_function(attr)\n                mc = {\"source_type\": source_type, \"target_type\": target_type}\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                op_id = self._calculate_op_id(\n                    source_type=source_type, target_type=target_type\n                )\n                result[op_id] = oc\n\n        for data_type_name, data_type_class in self._kiara.data_type_classes.items():\n            for attr in data_type_class.__dict__.keys():\n                if not attr.startswith(\"pretty_print_as__\"):\n                    continue\n\n                target_type = attr[17:]\n                if target_type not in self._kiara.data_type_names:\n                    log_message(\n                        \"operation_config.ignore\",\n                        operation_type=\"pretty_print\",\n                        source_type=data_type_name,\n                        target_type=target_type,\n                        reason=f\"Target type '{target_type}' not registered.\",\n                    )  # type: ignore\n\n                # TODO: inspect signature?\n                doc = DocumentationMetadataModel.from_string(\n                    f\"Pretty print a {data_type_name} value as a {target_type}.\"\n                )\n                mc = {\n                    \"source_type\": data_type_name,\n                    \"target_type\": target_type,\n                }\n                oc = ManifestOperationConfig(\n                    module_type=\"pretty_print.value\", module_config=mc, doc=doc\n                )\n                result[f\"_type_{data_type_name}__{target_type}\"] = oc\n        return result.values()\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[PrettyPrintDetails, None]:\n\n        details = self.extract_details(module)\n\n        if details is None:\n            return None\n        else:\n            return details\n\n    def extract_details(self, module: \"KiaraModule\") -&gt; Union[PrettyPrintDetails, None]:\n\n        if len(module.inputs_schema) != 2 or len(module.outputs_schema) != 1:\n            return None\n\n        if \"rendered_value\" not in module.outputs_schema.keys():\n            return None\n        target_type = module.outputs_schema[\"rendered_value\"].type\n\n        if \"value\" not in module.inputs_schema.keys():\n            return None\n        if \"render_config\" not in module.inputs_schema.keys():\n            return None\n\n        input_field_match = \"value\"\n\n        input_field_type = module.inputs_schema[input_field_match].type\n\n        operation_id = self._calculate_op_id(\n            source_type=input_field_type, target_type=target_type\n        )\n\n        details = {\n            \"module_inputs_schema\": module.inputs_schema,\n            \"module_outputs_schema\": module.outputs_schema,\n            \"operation_id\": operation_id,\n            \"source_type\": input_field_type,\n            \"target_type\": target_type,\n            \"is_internal_operation\": True,\n        }\n\n        result = PrettyPrintDetails.create_operation_details(**details)\n        return result\n\n    def get_target_types_for(self, source_type: str) -&gt; Mapping[str, Operation]:\n\n        # TODO: support for sub-types\n        result: Dict[str, Operation] = {}\n        for operation in self.operations.values():\n            details = self.retrieve_operation_details(operation)\n\n            if details.source_type == source_type:\n                target_type = details.target_type\n                if target_type in result.keys():\n                    raise Exception(\n                        f\"More than one operation for pretty_print combination '{source_type}'/'{target_type}', this is not supported (for now).\"\n                    )\n                result[target_type] = operation\n\n        return result\n\n    def get_operation_for_render_combination(\n        self, source_type: str, target_type: str\n    ) -&gt; Operation:\n\n        type_lineage = self._kiara.type_registry.get_type_lineage(\n            data_type_name=source_type\n        )\n\n        for st in type_lineage:\n            target_types = self.get_target_types_for(source_type=st)\n            if not target_types:\n                continue\n            if target_type not in target_types.keys():\n                raise Exception(\n                    f\"No operation that produces '{target_type}' for source type: {st}.\"\n                )\n            result = target_types[target_type]\n            return result\n\n        raise Exception(f\"No pretty_print opration(s) for source type: {source_type}.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = {}\n    for name, module_cls in self._kiara.module_type_classes.items():\n\n        if not issubclass(module_cls, PrettyPrintModule):\n            continue\n\n        for (\n            source_type,\n            target_type,\n        ) in module_cls.retrieve_supported_render_combinations():\n            if source_type not in self._kiara.data_type_names:\n                log_message(\"ignore.operation_config\", operation_type=\"pretty_print\", module_type=module_cls._module_type_name, source_type=source_type, target_type=target_type, reason=f\"Source type '{source_type}' not registered.\")  # type: ignore\n                continue\n            if target_type not in self._kiara.data_type_names:\n                log_message(\n                    \"ignore.operation_config\",\n                    operation_type=\"pretty_print\",\n                    module_type=module_cls._module_type_name,\n                    source_type=source_type,  # type: ignore\n                    target_type=target_type,\n                    reason=f\"Target type '{target_type}' not registered.\",\n                )\n                continue\n            func_name = f\"pretty_print__{source_type}__as__{target_type}\"\n            attr = getattr(module_cls, func_name)\n            doc = DocumentationMetadataModel.from_function(attr)\n            mc = {\"source_type\": source_type, \"target_type\": target_type}\n            oc = ManifestOperationConfig(\n                module_type=name, module_config=mc, doc=doc\n            )\n            op_id = self._calculate_op_id(\n                source_type=source_type, target_type=target_type\n            )\n            result[op_id] = oc\n\n    for data_type_name, data_type_class in self._kiara.data_type_classes.items():\n        for attr in data_type_class.__dict__.keys():\n            if not attr.startswith(\"pretty_print_as__\"):\n                continue\n\n            target_type = attr[17:]\n            if target_type not in self._kiara.data_type_names:\n                log_message(\n                    \"operation_config.ignore\",\n                    operation_type=\"pretty_print\",\n                    source_type=data_type_name,\n                    target_type=target_type,\n                    reason=f\"Target type '{target_type}' not registered.\",\n                )  # type: ignore\n\n            # TODO: inspect signature?\n            doc = DocumentationMetadataModel.from_string(\n                f\"Pretty print a {data_type_name} value as a {target_type}.\"\n            )\n            mc = {\n                \"source_type\": data_type_name,\n                \"target_type\": target_type,\n            }\n            oc = ManifestOperationConfig(\n                module_type=\"pretty_print.value\", module_config=mc, doc=doc\n            )\n            result[f\"_type_{data_type_name}__{target_type}\"] = oc\n    return result.values()\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[PrettyPrintDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[PrettyPrintDetails, None]:\n\n    details = self.extract_details(module)\n\n    if details is None:\n        return None\n    else:\n        return details\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType.extract_details","title":"<code>extract_details(module: KiaraModule) -&gt; Union[PrettyPrintDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>def extract_details(self, module: \"KiaraModule\") -&gt; Union[PrettyPrintDetails, None]:\n\n    if len(module.inputs_schema) != 2 or len(module.outputs_schema) != 1:\n        return None\n\n    if \"rendered_value\" not in module.outputs_schema.keys():\n        return None\n    target_type = module.outputs_schema[\"rendered_value\"].type\n\n    if \"value\" not in module.inputs_schema.keys():\n        return None\n    if \"render_config\" not in module.inputs_schema.keys():\n        return None\n\n    input_field_match = \"value\"\n\n    input_field_type = module.inputs_schema[input_field_match].type\n\n    operation_id = self._calculate_op_id(\n        source_type=input_field_type, target_type=target_type\n    )\n\n    details = {\n        \"module_inputs_schema\": module.inputs_schema,\n        \"module_outputs_schema\": module.outputs_schema,\n        \"operation_id\": operation_id,\n        \"source_type\": input_field_type,\n        \"target_type\": target_type,\n        \"is_internal_operation\": True,\n    }\n\n    result = PrettyPrintDetails.create_operation_details(**details)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType.get_target_types_for","title":"<code>get_target_types_for(source_type: str) -&gt; Mapping[str, Operation]</code>","text":"Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>def get_target_types_for(self, source_type: str) -&gt; Mapping[str, Operation]:\n\n    # TODO: support for sub-types\n    result: Dict[str, Operation] = {}\n    for operation in self.operations.values():\n        details = self.retrieve_operation_details(operation)\n\n        if details.source_type == source_type:\n            target_type = details.target_type\n            if target_type in result.keys():\n                raise Exception(\n                    f\"More than one operation for pretty_print combination '{source_type}'/'{target_type}', this is not supported (for now).\"\n                )\n            result[target_type] = operation\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print.PrettyPrintOperationType.get_operation_for_render_combination","title":"<code>get_operation_for_render_combination(source_type: str, target_type: str) -&gt; Operation</code>","text":"Source code in <code>kiara/operations/included_core_operations/pretty_print.py</code> <pre><code>def get_operation_for_render_combination(\n    self, source_type: str, target_type: str\n) -&gt; Operation:\n\n    type_lineage = self._kiara.type_registry.get_type_lineage(\n        data_type_name=source_type\n    )\n\n    for st in type_lineage:\n        target_types = self.get_target_types_for(source_type=st)\n        if not target_types:\n            continue\n        if target_type not in target_types.keys():\n            raise Exception(\n                f\"No operation that produces '{target_type}' for source type: {st}.\"\n            )\n        result = target_types[target_type]\n        return result\n\n    raise Exception(f\"No pretty_print opration(s) for source type: {source_type}.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/pretty_print/#kiara.operations.included_core_operations.pretty_print-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/","title":"render_data","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataDetails","title":"<code>RenderDataDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> <p>A model that contains information needed to describe an 'extract_metadata' operation.</p> Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>class RenderDataDetails(BaseOperationDetails):\n\"\"\"A model that contains information needed to describe an 'extract_metadata' operation.\"\"\"\n\n    source_data_type: str = Field(description=\"The data type that will be rendered.\")\n    target_data_type: str = Field(description=\"The rendered data type.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataDetails.source_data_type","title":"<code>source_data_type: str = Field(description='The data type that will be rendered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataDetails.target_data_type","title":"<code>target_data_type: str = Field(description='The rendered data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType","title":"<code>RenderDataOperationType</code>","text":"<p>         Bases: <code>OperationType[RenderDataDetails]</code></p> <p>An operation that renders data (and metadata) associated with a value.</p> Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>class RenderDataOperationType(OperationType[RenderDataDetails]):\n\"\"\"An operation that renders data (and metadata) associated with a value.\"\"\"\n\n    _operation_type_name = \"render_data\"\n\n    def _calculate_op_id(cls, source_type: str, target_type: str):\n\n        if source_type == \"any\":\n            operation_id = f\"render.as.{target_type}\"\n        else:\n            operation_id = f\"render.{source_type}.as.{target_type}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        # result = {}\n        return []\n        # for name, module_cls in self._kiara.module_type_classes.items():\n        #\n        #     if not issubclass(module_cls, RenderValueModule):\n        #         continue\n        #\n        #     for (\n        #         source_type,\n        #         target_type,\n        #     ) in module_cls.retrieve_supported_render_combinations():\n        #         if source_type not in self._kiara.data_type_names:\n        #             log_message(\"ignore.operation_config\", operation_type=\"render_value\", module_type=module_cls._module_type_name, source_type=source_type, target_type=target_type, reason=f\"Source type '{source_type}' not registered.\")  # type: ignore\n        #             continue\n        #         if target_type not in self._kiara.data_type_names:\n        #             log_message(\n        #                 \"ignore.operation_config\",\n        #                 operation_type=\"render_value\",\n        #                 module_type=module_cls._module_type_name,\n        #                 source_type=source_type,  # type: ignore\n        #                 target_type=target_type,\n        #                 reason=f\"Target type '{target_type}' not registered.\",\n        #             )\n        #             continue\n        #         func_name = f\"render__{source_type}__as__{target_type}\"\n        #         attr = getattr(module_cls, func_name)\n        #         doc = DocumentationMetadataModel.from_function(attr)\n        #         mc = {\"source_type\": source_type, \"target_type\": target_type}\n        #         oc = ManifestOperationConfig(\n        #             module_type=name, module_config=mc, doc=doc\n        #         )\n        #         op_id = self._calculate_op_id(\n        #             source_type=source_type, target_type=target_type\n        #         )\n        #         result[op_id] = oc\n        #\n        # for data_type_name, data_type_class in self._kiara.data_type_classes.items():\n        #     for attr in data_type_class.__dict__.keys():\n        #         if not attr.startswith(\"render_as__\"):\n        #             continue\n        #\n        #         target_type = attr[11:]\n        #         if target_type not in self._kiara.data_type_names:\n        #             log_message(\n        #                 \"operation_config.ignore\",\n        #                 operation_type=\"render_value\",\n        #                 source_type=data_type_name,\n        #                 target_type=target_type,\n        #                 reason=f\"Target type '{target_type}' not registered.\",\n        #             )  # type: ignore\n        #\n        #         # TODO: inspect signature?\n        #         doc = DocumentationMetadataModel.from_string(\n        #             f\"Render a '{data_type_name}' value as a {target_type}.\"\n        #         )\n        #         mc = {\n        #             \"source_type\": data_type_name,\n        #             \"target_type\": target_type,\n        #         }\n        #         oc = ManifestOperationConfig(\n        #             module_type=\"render.value\", module_config=mc, doc=doc\n        #         )\n        #\n        #         result[f\"_type_{data_type_name}_{target_type}\"] = oc\n        #\n        # return result.values()\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[RenderDataDetails, None]:\n\n        if len(module.inputs_schema) != 2:\n            return None\n\n        if len(module.outputs_schema) != 1:\n            return None\n\n        if \"value\" not in module.inputs_schema.keys():\n            return None\n\n        if (\n            \"render_config\" not in module.inputs_schema.keys()\n            or module.inputs_schema[\"render_config\"].type != \"dict\"\n        ):\n            return None\n\n        if (\n            \"render_value_result\" not in module.outputs_schema.keys()\n            or module.outputs_schema[\"render_value_result\"].type\n            != \"render_value_result\"\n        ):\n            return None\n\n        source_type = module.inputs_schema[\"value\"].type\n        target_type = module.get_config_value(\"target_type\")\n\n        if source_type == \"any\":\n            op_id = f\"render.as.{target_type}\"\n        else:\n            op_id = f\"render.{source_type}.as.{target_type}\"\n\n        details = RenderDataDetails.create_operation_details(\n            module_inputs_schema=module.inputs_schema,\n            module_outputs_schema=module.outputs_schema,\n            operation_id=op_id,\n            source_data_type=source_type,\n            target_data_type=target_type,\n            is_internal_operation=True,\n        )\n\n        return details\n\n    def get_render_operations_for_source_type(\n        self, source_type: str\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations for the specified data type.\n\n        Arguments:\n            source_type: the data type to render\n\n        Returns:\n            a mapping with the target type as key, and the operation as value\n        \"\"\"\n\n        if source_type not in self._kiara.data_type_names:\n            source_type = \"any\"\n\n        lineage = self._kiara.type_registry.get_type_lineage(data_type_name=source_type)\n\n        result: Dict[str, Operation] = {}\n\n        for data_type in lineage:\n\n            for op_id, op in self.operations.items():\n                op_details = self.retrieve_operation_details(op)\n                match = op_details.source_data_type == data_type\n                if not match:\n                    continue\n                target_type = op_details.target_data_type\n                if target_type in result.keys():\n                    continue\n                result[target_type] = op\n\n        return result\n\n    def get_render_operations_for_target_type(\n        self, target_type: str\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations that renders to the specified data type.\n\n        Arguments:\n            target_type: the result data type\n\n        Returns:\n            a mapping with the source type as key, and the operation as value\n        \"\"\"\n\n        # TODO: consider type lineages\n\n        if target_type not in self._kiara.data_type_names:\n            raise Exception(f\"Invalid target data type: {target_type}\")\n\n        result: Dict[str, Operation] = {}\n\n        for op_id, op in self.operations.items():\n            op_details = self.retrieve_operation_details(op)\n            match = op_details.target_data_type == target_type\n            if not match:\n                continue\n            source_type = op_details.source_data_type\n            if source_type in result.keys():\n                continue\n\n            result[source_type] = op\n\n        return result\n\n    def get_render_operation(\n        self, source_type: str, target_type: str\n    ) -&gt; Union[Operation, None]:\n\n        all_ops = self.get_render_operations_for_source_type(source_type=source_type)\n        return all_ops.get(target_type, None)\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    # result = {}\n    return []\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[RenderDataDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[RenderDataDetails, None]:\n\n    if len(module.inputs_schema) != 2:\n        return None\n\n    if len(module.outputs_schema) != 1:\n        return None\n\n    if \"value\" not in module.inputs_schema.keys():\n        return None\n\n    if (\n        \"render_config\" not in module.inputs_schema.keys()\n        or module.inputs_schema[\"render_config\"].type != \"dict\"\n    ):\n        return None\n\n    if (\n        \"render_value_result\" not in module.outputs_schema.keys()\n        or module.outputs_schema[\"render_value_result\"].type\n        != \"render_value_result\"\n    ):\n        return None\n\n    source_type = module.inputs_schema[\"value\"].type\n    target_type = module.get_config_value(\"target_type\")\n\n    if source_type == \"any\":\n        op_id = f\"render.as.{target_type}\"\n    else:\n        op_id = f\"render.{source_type}.as.{target_type}\"\n\n    details = RenderDataDetails.create_operation_details(\n        module_inputs_schema=module.inputs_schema,\n        module_outputs_schema=module.outputs_schema,\n        operation_id=op_id,\n        source_data_type=source_type,\n        target_data_type=target_type,\n        is_internal_operation=True,\n    )\n\n    return details\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType.get_render_operations_for_source_type","title":"<code>get_render_operations_for_source_type(source_type: str) -&gt; Mapping[str, Operation]</code>","text":"<p>Return all render operations for the specified data type.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>the data type to render</p> required <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a mapping with the target type as key, and the operation as value</p> Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>def get_render_operations_for_source_type(\n    self, source_type: str\n) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations for the specified data type.\n\n    Arguments:\n        source_type: the data type to render\n\n    Returns:\n        a mapping with the target type as key, and the operation as value\n    \"\"\"\n\n    if source_type not in self._kiara.data_type_names:\n        source_type = \"any\"\n\n    lineage = self._kiara.type_registry.get_type_lineage(data_type_name=source_type)\n\n    result: Dict[str, Operation] = {}\n\n    for data_type in lineage:\n\n        for op_id, op in self.operations.items():\n            op_details = self.retrieve_operation_details(op)\n            match = op_details.source_data_type == data_type\n            if not match:\n                continue\n            target_type = op_details.target_data_type\n            if target_type in result.keys():\n                continue\n            result[target_type] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType.get_render_operations_for_target_type","title":"<code>get_render_operations_for_target_type(target_type: str) -&gt; Mapping[str, Operation]</code>","text":"<p>Return all render operations that renders to the specified data type.</p> <p>Parameters:</p> Name Type Description Default <code>target_type</code> <code>str</code> <p>the result data type</p> required <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a mapping with the source type as key, and the operation as value</p> Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>def get_render_operations_for_target_type(\n    self, target_type: str\n) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations that renders to the specified data type.\n\n    Arguments:\n        target_type: the result data type\n\n    Returns:\n        a mapping with the source type as key, and the operation as value\n    \"\"\"\n\n    # TODO: consider type lineages\n\n    if target_type not in self._kiara.data_type_names:\n        raise Exception(f\"Invalid target data type: {target_type}\")\n\n    result: Dict[str, Operation] = {}\n\n    for op_id, op in self.operations.items():\n        op_details = self.retrieve_operation_details(op)\n        match = op_details.target_data_type == target_type\n        if not match:\n            continue\n        source_type = op_details.source_data_type\n        if source_type in result.keys():\n            continue\n\n        result[source_type] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_data/#kiara.operations.included_core_operations.render_data.RenderDataOperationType.get_render_operation","title":"<code>get_render_operation(source_type: str, target_type: str) -&gt; Union[Operation, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_data.py</code> <pre><code>def get_render_operation(\n    self, source_type: str, target_type: str\n) -&gt; Union[Operation, None]:\n\n    all_ops = self.get_render_operations_for_source_type(source_type=source_type)\n    return all_ops.get(target_type, None)\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/","title":"render_value","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueDetails","title":"<code>RenderValueDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> <p>A model that contains information needed to describe an 'extract_metadata' operation.</p> Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>class RenderValueDetails(BaseOperationDetails):\n\"\"\"A model that contains information needed to describe an 'extract_metadata' operation.\"\"\"\n\n    source_data_type: str = Field(description=\"The data type that will be rendered.\")\n    target_data_type: str = Field(description=\"The rendered data type.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueDetails.source_data_type","title":"<code>source_data_type: str = Field(description='The data type that will be rendered.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueDetails.target_data_type","title":"<code>target_data_type: str = Field(description='The rendered data type.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType","title":"<code>RenderValueOperationType</code>","text":"<p>         Bases: <code>OperationType[RenderValueDetails]</code></p> <p>An operation that renders a value.</p> <p>A 'render_value' operation typically is named follwing the pattern:</p> <pre><code> 'render.&lt;source_type&gt;.as.&lt;target_type&gt;'\n</code></pre> It has 2 inputs <ul> <li>'value': the value to render</li> <li>'reneer_config' a target type-specific configuration dict</li> </ul> And one output <ul> <li><code>render_value_result</code>: using internal type RenderValueResultDataType</li> </ul> Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>class RenderValueOperationType(OperationType[RenderValueDetails]):\n\"\"\"An operation that renders a value.\n\n    A 'render_value' operation typically is named follwing the pattern:\n\n    ```\n     'render.&lt;source_type&gt;.as.&lt;target_type&gt;'\n    ```\n\n    It has 2 inputs:\n      - 'value': the value to render\n      - 'reneer_config' a target type-specific configuration dict\n\n    And one output:\n      - `render_value_result`: using internal type [RenderValueResultDataType][kiara.data_types.included_core_types.internal.render_value.RenderValueResultDataType]\n\n    \"\"\"\n\n    _operation_type_name = \"render_value\"\n\n    def _calculate_op_id(cls, source_type: str, target_type: str):\n\n        if source_type == \"any\":\n            operation_id = f\"render.as.{target_type}\"\n        else:\n            operation_id = f\"render.{source_type}.as.{target_type}\"\n\n        return operation_id\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n        result = {}\n        for name, module_cls in self._kiara.module_type_classes.items():\n\n            if not issubclass(module_cls, RenderValueModule):\n                continue\n\n            for (\n                source_type,\n                target_type,\n            ) in module_cls.retrieve_supported_render_combinations():\n                if source_type not in self._kiara.data_type_names:\n                    log_message(\"ignore.operation_config\", operation_type=\"render_value\", module_type=module_cls._module_type_name, source_type=source_type, target_type=target_type, reason=f\"Source type '{source_type}' not registered.\")  # type: ignore\n                    continue\n                if target_type not in self._kiara.data_type_names:\n                    log_message(\n                        \"ignore.operation_config\",\n                        operation_type=\"render_value\",\n                        module_type=module_cls._module_type_name,\n                        source_type=source_type,  # type: ignore\n                        target_type=target_type,\n                        reason=f\"Target type '{target_type}' not registered.\",\n                    )\n                    continue\n                func_name = f\"render__{source_type}__as__{target_type}\"\n                attr = getattr(module_cls, func_name)\n                doc = DocumentationMetadataModel.from_function(attr)\n                mc = {\"source_type\": source_type, \"target_type\": target_type}\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                op_id = self._calculate_op_id(\n                    source_type=source_type, target_type=target_type\n                )\n                result[op_id] = oc\n\n        for data_type_name, data_type_class in self._kiara.data_type_classes.items():\n            for attr in data_type_class.__dict__.keys():\n                if not attr.startswith(\"render_as__\"):\n                    continue\n\n                target_type = attr[11:]\n                if target_type not in self._kiara.data_type_names:\n                    log_message(\n                        \"operation_config.ignore\",\n                        operation_type=\"render_value\",\n                        source_type=data_type_name,\n                        target_type=target_type,\n                        reason=f\"Target type '{target_type}' not registered.\",\n                    )  # type: ignore\n\n                # TODO: inspect signature?\n                doc = DocumentationMetadataModel.from_string(\n                    f\"Render a '{data_type_name}' value as a {target_type}.\"\n                )\n                mc = {\n                    \"source_type\": data_type_name,\n                    \"target_type\": target_type,\n                }\n                oc = ManifestOperationConfig(\n                    module_type=\"render.value\", module_config=mc, doc=doc\n                )\n\n                result[f\"_type_{data_type_name}_{target_type}\"] = oc\n\n        return result.values()\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[RenderValueDetails, None]:\n\n        if len(module.inputs_schema) != 2:\n            return None\n\n        if len(module.outputs_schema) != 1:\n            return None\n\n        if \"value\" not in module.inputs_schema.keys():\n            return None\n\n        if (\n            \"render_config\" not in module.inputs_schema.keys()\n            or module.inputs_schema[\"render_config\"].type != \"dict\"\n        ):\n            return None\n\n        if (\n            \"render_value_result\" not in module.outputs_schema.keys()\n            or module.outputs_schema[\"render_value_result\"].type\n            != \"render_value_result\"\n        ):\n            return None\n\n        source_type = module.inputs_schema[\"value\"].type\n        target_type = module.get_config_value(\"target_type\")\n\n        if source_type == \"any\":\n            op_id = f\"render.as.{target_type}\"\n        else:\n            op_id = f\"render.{source_type}.as.{target_type}\"\n\n        details = RenderValueDetails.create_operation_details(\n            module_inputs_schema=module.inputs_schema,\n            module_outputs_schema=module.outputs_schema,\n            operation_id=op_id,\n            source_data_type=source_type,\n            target_data_type=target_type,\n            is_internal_operation=True,\n        )\n\n        return details\n\n    def get_render_operations_for_source_type(\n        self, source_type: str\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations for the specified data type.\n\n        Arguments:\n            source_type: the data type to render\n\n        Returns:\n            a mapping with the target type as key, and the operation as value\n        \"\"\"\n\n        if source_type not in self._kiara.data_type_names:\n            source_type = \"any\"\n\n        lineage = self._kiara.type_registry.get_type_lineage(data_type_name=source_type)\n\n        result: Dict[str, Operation] = {}\n\n        for data_type in lineage:\n\n            for op_id, op in self.operations.items():\n                op_details = self.retrieve_operation_details(op)\n                match = op_details.source_data_type == data_type\n                if not match:\n                    continue\n                target_type = op_details.target_data_type\n                if target_type in result.keys():\n                    continue\n                result[target_type] = op\n\n        return result\n\n    def get_render_operations_for_target_type(\n        self, target_type: str\n    ) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations that renders to the specified data type.\n\n        Arguments:\n            target_type: the result data type\n\n        Returns:\n            a mapping with the source type as key, and the operation as value\n        \"\"\"\n\n        # TODO: consider type lineages\n\n        if target_type not in self._kiara.data_type_names:\n            raise Exception(f\"Invalid target data type: {target_type}\")\n\n        result: Dict[str, Operation] = {}\n\n        for op_id, op in self.operations.items():\n            op_details = self.retrieve_operation_details(op)\n            match = op_details.target_data_type == target_type\n            if not match:\n                continue\n            source_type = op_details.source_data_type\n            if source_type in result.keys():\n                continue\n\n            result[source_type] = op\n\n        return result\n\n    def get_render_operation(\n        self, source_type: str, target_type: str\n    ) -&gt; Union[Operation, None]:\n\n        all_ops = self.get_render_operations_for_source_type(source_type=source_type)\n        return all_ops.get(target_type, None)\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n\n    result = {}\n    for name, module_cls in self._kiara.module_type_classes.items():\n\n        if not issubclass(module_cls, RenderValueModule):\n            continue\n\n        for (\n            source_type,\n            target_type,\n        ) in module_cls.retrieve_supported_render_combinations():\n            if source_type not in self._kiara.data_type_names:\n                log_message(\"ignore.operation_config\", operation_type=\"render_value\", module_type=module_cls._module_type_name, source_type=source_type, target_type=target_type, reason=f\"Source type '{source_type}' not registered.\")  # type: ignore\n                continue\n            if target_type not in self._kiara.data_type_names:\n                log_message(\n                    \"ignore.operation_config\",\n                    operation_type=\"render_value\",\n                    module_type=module_cls._module_type_name,\n                    source_type=source_type,  # type: ignore\n                    target_type=target_type,\n                    reason=f\"Target type '{target_type}' not registered.\",\n                )\n                continue\n            func_name = f\"render__{source_type}__as__{target_type}\"\n            attr = getattr(module_cls, func_name)\n            doc = DocumentationMetadataModel.from_function(attr)\n            mc = {\"source_type\": source_type, \"target_type\": target_type}\n            oc = ManifestOperationConfig(\n                module_type=name, module_config=mc, doc=doc\n            )\n            op_id = self._calculate_op_id(\n                source_type=source_type, target_type=target_type\n            )\n            result[op_id] = oc\n\n    for data_type_name, data_type_class in self._kiara.data_type_classes.items():\n        for attr in data_type_class.__dict__.keys():\n            if not attr.startswith(\"render_as__\"):\n                continue\n\n            target_type = attr[11:]\n            if target_type not in self._kiara.data_type_names:\n                log_message(\n                    \"operation_config.ignore\",\n                    operation_type=\"render_value\",\n                    source_type=data_type_name,\n                    target_type=target_type,\n                    reason=f\"Target type '{target_type}' not registered.\",\n                )  # type: ignore\n\n            # TODO: inspect signature?\n            doc = DocumentationMetadataModel.from_string(\n                f\"Render a '{data_type_name}' value as a {target_type}.\"\n            )\n            mc = {\n                \"source_type\": data_type_name,\n                \"target_type\": target_type,\n            }\n            oc = ManifestOperationConfig(\n                module_type=\"render.value\", module_config=mc, doc=doc\n            )\n\n            result[f\"_type_{data_type_name}_{target_type}\"] = oc\n\n    return result.values()\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[RenderValueDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[RenderValueDetails, None]:\n\n    if len(module.inputs_schema) != 2:\n        return None\n\n    if len(module.outputs_schema) != 1:\n        return None\n\n    if \"value\" not in module.inputs_schema.keys():\n        return None\n\n    if (\n        \"render_config\" not in module.inputs_schema.keys()\n        or module.inputs_schema[\"render_config\"].type != \"dict\"\n    ):\n        return None\n\n    if (\n        \"render_value_result\" not in module.outputs_schema.keys()\n        or module.outputs_schema[\"render_value_result\"].type\n        != \"render_value_result\"\n    ):\n        return None\n\n    source_type = module.inputs_schema[\"value\"].type\n    target_type = module.get_config_value(\"target_type\")\n\n    if source_type == \"any\":\n        op_id = f\"render.as.{target_type}\"\n    else:\n        op_id = f\"render.{source_type}.as.{target_type}\"\n\n    details = RenderValueDetails.create_operation_details(\n        module_inputs_schema=module.inputs_schema,\n        module_outputs_schema=module.outputs_schema,\n        operation_id=op_id,\n        source_data_type=source_type,\n        target_data_type=target_type,\n        is_internal_operation=True,\n    )\n\n    return details\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType.get_render_operations_for_source_type","title":"<code>get_render_operations_for_source_type(source_type: str) -&gt; Mapping[str, Operation]</code>","text":"<p>Return all render operations for the specified data type.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>the data type to render</p> required <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a mapping with the target type as key, and the operation as value</p> Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>def get_render_operations_for_source_type(\n    self, source_type: str\n) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations for the specified data type.\n\n    Arguments:\n        source_type: the data type to render\n\n    Returns:\n        a mapping with the target type as key, and the operation as value\n    \"\"\"\n\n    if source_type not in self._kiara.data_type_names:\n        source_type = \"any\"\n\n    lineage = self._kiara.type_registry.get_type_lineage(data_type_name=source_type)\n\n    result: Dict[str, Operation] = {}\n\n    for data_type in lineage:\n\n        for op_id, op in self.operations.items():\n            op_details = self.retrieve_operation_details(op)\n            match = op_details.source_data_type == data_type\n            if not match:\n                continue\n            target_type = op_details.target_data_type\n            if target_type in result.keys():\n                continue\n            result[target_type] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType.get_render_operations_for_target_type","title":"<code>get_render_operations_for_target_type(target_type: str) -&gt; Mapping[str, Operation]</code>","text":"<p>Return all render operations that renders to the specified data type.</p> <p>Parameters:</p> Name Type Description Default <code>target_type</code> <code>str</code> <p>the result data type</p> required <p>Returns:</p> Type Description <code>Mapping[str, Operation]</code> <p>a mapping with the source type as key, and the operation as value</p> Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>def get_render_operations_for_target_type(\n    self, target_type: str\n) -&gt; Mapping[str, Operation]:\n\"\"\"Return all render operations that renders to the specified data type.\n\n    Arguments:\n        target_type: the result data type\n\n    Returns:\n        a mapping with the source type as key, and the operation as value\n    \"\"\"\n\n    # TODO: consider type lineages\n\n    if target_type not in self._kiara.data_type_names:\n        raise Exception(f\"Invalid target data type: {target_type}\")\n\n    result: Dict[str, Operation] = {}\n\n    for op_id, op in self.operations.items():\n        op_details = self.retrieve_operation_details(op)\n        match = op_details.target_data_type == target_type\n        if not match:\n            continue\n        source_type = op_details.source_data_type\n        if source_type in result.keys():\n            continue\n\n        result[source_type] = op\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value.RenderValueOperationType.get_render_operation","title":"<code>get_render_operation(source_type: str, target_type: str) -&gt; Union[Operation, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/render_value.py</code> <pre><code>def get_render_operation(\n    self, source_type: str, target_type: str\n) -&gt; Union[Operation, None]:\n\n    all_ops = self.get_render_operations_for_source_type(source_type=source_type)\n    return all_ops.get(target_type, None)\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/render_value/#kiara.operations.included_core_operations.render_value-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/","title":"serialize","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize-classes","title":"Classes","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails","title":"<code>DeSerializeDetails</code>","text":"<p>         Bases: <code>BaseOperationDetails</code></p> Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>class DeSerializeDetails(BaseOperationDetails):\n\n    value_type: str = Field(\n        \"The name of the input field for the serialized version of the value.\"\n    )\n    value_input_field: str = Field(\n        \"The name of the input field for the serialized version of the value.\"\n    )\n    object_output_field: str = Field(\n        description=\"The (output) field name containing the deserialized python class.\"\n    )\n    serialization_profile: str = Field(\n        description=\"The name for the serialization profile used on the source value.\"\n    )\n    target_profile: str = Field(description=\"The target profile name.\")\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails.value_type","title":"<code>value_type: str = Field('The name of the input field for the serialized version of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails.value_input_field","title":"<code>value_input_field: str = Field('The name of the input field for the serialized version of the value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails.object_output_field","title":"<code>object_output_field: str = Field(description='The (output) field name containing the deserialized python class.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails.serialization_profile","title":"<code>serialization_profile: str = Field(description='The name for the serialization profile used on the source value.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeDetails.target_profile","title":"<code>target_profile: str = Field(description='The target profile name.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType","title":"<code>DeSerializeOperationType</code>","text":"<p>         Bases: <code>OperationType[DeSerializeDetails]</code></p> <p>An operation that takes a value, and serializes it into the format suitable to the <code>serialized_value</code> value type.</p> <p>For a module profile to be picked up by this operation type, it needs to have: - exactly one output field of type <code>serialized_value</code> - either one of (in this order):   - exactly one input field   - one input field where the field name equals the type name   - an input field called 'value'</p> Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>class DeSerializeOperationType(OperationType[DeSerializeDetails]):\n\"\"\"An operation that takes a value, and serializes it into the format suitable to the [`serialized_value`][kiara.data_types.included_core_types.SeriailzedValue] value type.\n\n    For a module profile to be picked up by this operation type, it needs to have:\n    - exactly one output field of type `serialized_value`\n    - either one of (in this order):\n      - exactly one input field\n      - one input field where the field name equals the type name\n      - an input field called 'value'\n    \"\"\"\n\n    _operation_type_name = \"deserialize\"\n\n    def retrieve_included_operation_configs(\n        self,\n    ) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n        result = []\n        for name, module_cls in self._kiara.module_type_classes.items():\n\n            if not hasattr(module_cls, \"retrieve_serialized_value_type\"):\n                continue\n            if not hasattr(module_cls, \"retrieve_supported_target_profiles\"):\n                continue\n            if not hasattr(module_cls, \"retrieve_supported_serialization_profile\"):\n                continue\n\n            try:\n                value_type = module_cls.retrieve_serialized_value_type()  # type: ignore\n            except TypeError:\n                raise Exception(\n                    f\"Can't retrieve source value type for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_source_value_type' method?\"\n                )\n            try:\n                serialization_profile = module_cls.retrieve_supported_serialization_profile()  # type: ignore\n            except TypeError:\n                raise Exception(\n                    f\"Can't retrieve supported serialization profiles for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_supported_serialization_profile' method?\"\n                )\n\n            try:\n                target_profiles = module_cls.retrieve_supported_target_profiles()  # type: ignore\n            except TypeError:\n                raise Exception(\n                    f\"Can't retrieve supported target profile for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_supported_target_profile' method?\"\n                )\n\n            for _profile_name, cls in target_profiles.items():\n                func_name = f\"to__{_profile_name}\"\n                attr = getattr(module_cls, func_name)\n                doc = DocumentationMetadataModel.from_function(attr)\n                mc = {\n                    \"value_type\": value_type,\n                    \"target_profile\": _profile_name,\n                    \"serialization_profile\": serialization_profile\n                    # \"target_class\": PythonClass.from_class(cls),\n                }\n                oc = ManifestOperationConfig(\n                    module_type=name, module_config=mc, doc=doc\n                )\n                result.append(oc)\n\n        return result\n\n    def check_matching_operation(\n        self, module: \"KiaraModule\"\n    ) -&gt; Union[DeSerializeDetails, None]:\n\n        details = self.extract_details(module)\n\n        if details is None:\n            return None\n        else:\n            return details\n\n    def extract_details(self, module: \"KiaraModule\") -&gt; Union[DeSerializeDetails, None]:\n\n        result_field_name = None\n        for field_name, schema in module.outputs_schema.items():\n            if schema.type != \"python_object\":\n                continue\n            else:\n                if result_field_name is not None:\n                    log_message(\n                        \"ignore.operation\",\n                        reason=f\"found more than one potential result value field: {result_field_name} -- {field_name}'\",\n                        module_type=module.module_type_name,\n                    )\n                    continue\n                else:\n                    result_field_name = field_name\n\n        if not result_field_name:\n            return None\n\n        input_field_name = None\n        for field_name, schema in module.inputs_schema.items():\n            if field_name != schema.type:\n                continue\n            if input_field_name is not None:\n                log_message(\n                    \"ignore.operation\",\n                    reason=f\"found more than one potential result value field: {result_field_name} -- {field_name}'\",\n                    module_type=module.module_type_name,\n                )\n                continue\n            else:\n                input_field_name = field_name\n\n        if not input_field_name:\n            return None\n\n        try:\n            value_type = module.config.get(\"value_type\")\n            target_profile = module.config.get(\"target_profile\")\n            serialization_profile = module.config.get(\"serialization_profile\")\n            # target_class = module.config.get(\"target_class\")\n        except Exception as e:\n            log_message(\n                \"ignore.operation\",\n                reason=str(e),\n                module_type=module.module_type_name,\n            )\n            return None\n\n        if value_type not in self._kiara.type_registry.data_type_names:\n            log_message(\n                \"ignore.operation\",\n                reason=f\"Invalid value type: {value_type}\",\n                module_type=module.module_type_name,\n            )\n            return None\n\n        if input_field_name == \"any\":\n            operation_id = \"deserialize.value\"\n        else:\n            operation_id = f\"deserialize.{input_field_name}.as.{target_profile}\"\n\n        details: Dict[str, Any] = {\n            \"module_inputs_schema\": module.inputs_schema,\n            \"module_outputs_schema\": module.outputs_schema,\n            \"operation_id\": operation_id,\n            \"value_type\": input_field_name,\n            \"value_input_field\": input_field_name,\n            \"object_output_field\": result_field_name,\n            \"target_profile\": target_profile,\n            \"serialization_profile\": serialization_profile,\n            # \"target_class\": target_class,\n            \"is_internal_operation\": True,\n        }\n\n        result = DeSerializeDetails.construct(**details)\n        return result\n\n    def find_deserialization_operations_for_type(\n        self, type_name: str\n    ) -&gt; List[Operation]:\n\n        lineage = self._kiara.type_registry.get_type_lineage(type_name)\n        result = []\n        for data_type in lineage:\n            match = []\n            for op in self.operations.values():\n                details = self.retrieve_operation_details(op)\n                if details.value_type == data_type:\n                    match.append(op)\n\n            result.extend(match)\n\n        return result\n\n    def find_deserialzation_operation_for_type_and_profile(\n        self, type_name: str, serialization_profile: str\n    ) -&gt; List[Operation]:\n\n        lineage = self._kiara.type_registry.get_type_lineage(type_name)\n        serialize_ops: List[Operation] = []\n        for data_type in lineage:\n            match = []\n            op = None\n            for op in self.operations.values():\n                details = self.retrieve_operation_details(op)\n                if (\n                    details.value_type == data_type\n                    and details.serialization_profile == serialization_profile\n                ):\n                    match.append(op)\n\n            if match:\n                if len(match) &gt; 1:\n                    assert op is not None\n                    raise Exception(\n                        f\"Multiple deserialization operations found for data type '{type_name}' and serialization profile '{serialization_profile}'. This is not supported (yet).\"\n                    )\n                serialize_ops.append(match[0])\n\n        return serialize_ops\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType-functions","title":"Functions","text":""},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType.retrieve_included_operation_configs","title":"<code>retrieve_included_operation_configs() -&gt; Iterable[Union[Mapping, OperationConfig]]</code>","text":"Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>def retrieve_included_operation_configs(\n    self,\n) -&gt; Iterable[Union[Mapping, OperationConfig]]:\n    result = []\n    for name, module_cls in self._kiara.module_type_classes.items():\n\n        if not hasattr(module_cls, \"retrieve_serialized_value_type\"):\n            continue\n        if not hasattr(module_cls, \"retrieve_supported_target_profiles\"):\n            continue\n        if not hasattr(module_cls, \"retrieve_supported_serialization_profile\"):\n            continue\n\n        try:\n            value_type = module_cls.retrieve_serialized_value_type()  # type: ignore\n        except TypeError:\n            raise Exception(\n                f\"Can't retrieve source value type for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_source_value_type' method?\"\n            )\n        try:\n            serialization_profile = module_cls.retrieve_supported_serialization_profile()  # type: ignore\n        except TypeError:\n            raise Exception(\n                f\"Can't retrieve supported serialization profiles for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_supported_serialization_profile' method?\"\n            )\n\n        try:\n            target_profiles = module_cls.retrieve_supported_target_profiles()  # type: ignore\n        except TypeError:\n            raise Exception(\n                f\"Can't retrieve supported target profile for deserialization module '{module_cls.__name__}'. This is most likely a bug, maybe you are missing a '@classmethod' annotation on the 'retrieve_supported_target_profile' method?\"\n            )\n\n        for _profile_name, cls in target_profiles.items():\n            func_name = f\"to__{_profile_name}\"\n            attr = getattr(module_cls, func_name)\n            doc = DocumentationMetadataModel.from_function(attr)\n            mc = {\n                \"value_type\": value_type,\n                \"target_profile\": _profile_name,\n                \"serialization_profile\": serialization_profile\n                # \"target_class\": PythonClass.from_class(cls),\n            }\n            oc = ManifestOperationConfig(\n                module_type=name, module_config=mc, doc=doc\n            )\n            result.append(oc)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType.check_matching_operation","title":"<code>check_matching_operation(module: KiaraModule) -&gt; Union[DeSerializeDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>def check_matching_operation(\n    self, module: \"KiaraModule\"\n) -&gt; Union[DeSerializeDetails, None]:\n\n    details = self.extract_details(module)\n\n    if details is None:\n        return None\n    else:\n        return details\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType.extract_details","title":"<code>extract_details(module: KiaraModule) -&gt; Union[DeSerializeDetails, None]</code>","text":"Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>def extract_details(self, module: \"KiaraModule\") -&gt; Union[DeSerializeDetails, None]:\n\n    result_field_name = None\n    for field_name, schema in module.outputs_schema.items():\n        if schema.type != \"python_object\":\n            continue\n        else:\n            if result_field_name is not None:\n                log_message(\n                    \"ignore.operation\",\n                    reason=f\"found more than one potential result value field: {result_field_name} -- {field_name}'\",\n                    module_type=module.module_type_name,\n                )\n                continue\n            else:\n                result_field_name = field_name\n\n    if not result_field_name:\n        return None\n\n    input_field_name = None\n    for field_name, schema in module.inputs_schema.items():\n        if field_name != schema.type:\n            continue\n        if input_field_name is not None:\n            log_message(\n                \"ignore.operation\",\n                reason=f\"found more than one potential result value field: {result_field_name} -- {field_name}'\",\n                module_type=module.module_type_name,\n            )\n            continue\n        else:\n            input_field_name = field_name\n\n    if not input_field_name:\n        return None\n\n    try:\n        value_type = module.config.get(\"value_type\")\n        target_profile = module.config.get(\"target_profile\")\n        serialization_profile = module.config.get(\"serialization_profile\")\n        # target_class = module.config.get(\"target_class\")\n    except Exception as e:\n        log_message(\n            \"ignore.operation\",\n            reason=str(e),\n            module_type=module.module_type_name,\n        )\n        return None\n\n    if value_type not in self._kiara.type_registry.data_type_names:\n        log_message(\n            \"ignore.operation\",\n            reason=f\"Invalid value type: {value_type}\",\n            module_type=module.module_type_name,\n        )\n        return None\n\n    if input_field_name == \"any\":\n        operation_id = \"deserialize.value\"\n    else:\n        operation_id = f\"deserialize.{input_field_name}.as.{target_profile}\"\n\n    details: Dict[str, Any] = {\n        \"module_inputs_schema\": module.inputs_schema,\n        \"module_outputs_schema\": module.outputs_schema,\n        \"operation_id\": operation_id,\n        \"value_type\": input_field_name,\n        \"value_input_field\": input_field_name,\n        \"object_output_field\": result_field_name,\n        \"target_profile\": target_profile,\n        \"serialization_profile\": serialization_profile,\n        # \"target_class\": target_class,\n        \"is_internal_operation\": True,\n    }\n\n    result = DeSerializeDetails.construct(**details)\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType.find_deserialization_operations_for_type","title":"<code>find_deserialization_operations_for_type(type_name: str) -&gt; List[Operation]</code>","text":"Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>def find_deserialization_operations_for_type(\n    self, type_name: str\n) -&gt; List[Operation]:\n\n    lineage = self._kiara.type_registry.get_type_lineage(type_name)\n    result = []\n    for data_type in lineage:\n        match = []\n        for op in self.operations.values():\n            details = self.retrieve_operation_details(op)\n            if details.value_type == data_type:\n                match.append(op)\n\n        result.extend(match)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize.DeSerializeOperationType.find_deserialzation_operation_for_type_and_profile","title":"<code>find_deserialzation_operation_for_type_and_profile(type_name: str, serialization_profile: str) -&gt; List[Operation]</code>","text":"Source code in <code>kiara/operations/included_core_operations/serialize.py</code> <pre><code>def find_deserialzation_operation_for_type_and_profile(\n    self, type_name: str, serialization_profile: str\n) -&gt; List[Operation]:\n\n    lineage = self._kiara.type_registry.get_type_lineage(type_name)\n    serialize_ops: List[Operation] = []\n    for data_type in lineage:\n        match = []\n        op = None\n        for op in self.operations.values():\n            details = self.retrieve_operation_details(op)\n            if (\n                details.value_type == data_type\n                and details.serialization_profile == serialization_profile\n            ):\n                match.append(op)\n\n        if match:\n            if len(match) &gt; 1:\n                assert op is not None\n                raise Exception(\n                    f\"Multiple deserialization operations found for data type '{type_name}' and serialization profile '{serialization_profile}'. This is not supported (yet).\"\n                )\n            serialize_ops.append(match[0])\n\n    return serialize_ops\n</code></pre>"},{"location":"reference/kiara/operations/included_core_operations/serialize/#kiara.operations.included_core_operations.serialize-functions","title":"Functions","text":""},{"location":"reference/kiara/processing/__init__/","title":"processing","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing-attributes","title":"Attributes","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.log","title":"<code>log = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing-classes","title":"Classes","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.JobStatusListener","title":"<code>JobStatusListener</code>","text":"<p>         Bases: <code>Protocol</code></p> Source code in <code>kiara/processing/__init__.py</code> <pre><code>class JobStatusListener(Protocol):\n    def job_status_changed(\n        self,\n        job_id: uuid.UUID,\n        old_status: Union[JobStatus, None],\n        new_status: JobStatus,\n    ):\n        pass\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.JobStatusListener-functions","title":"Functions","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.JobStatusListener.job_status_changed","title":"<code>job_status_changed(job_id: uuid.UUID, old_status: Union[JobStatus, None], new_status: JobStatus)</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def job_status_changed(\n    self,\n    job_id: uuid.UUID,\n    old_status: Union[JobStatus, None],\n    new_status: JobStatus,\n):\n    pass\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ProcessorConfig","title":"<code>ProcessorConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/processing/__init__.py</code> <pre><code>class ProcessorConfig(BaseModel):\n\n    module_processor_type: Literal[\"synchronous\", \"multi-threaded\"] = \"synchronous\"\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ProcessorConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.ProcessorConfig.module_processor_type","title":"<code>module_processor_type: Literal[synchronous, multi-threaded] = 'synchronous'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor","title":"<code>ModuleProcessor</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>kiara/processing/__init__.py</code> <pre><code>class ModuleProcessor(abc.ABC):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n        self._created_jobs: Dict[uuid.UUID, Dict[str, Any]] = {}\n        self._running_job_details: Dict[uuid.UUID, Dict[str, Any]] = {}\n        self._active_jobs: Dict[uuid.UUID, ActiveJob] = {}\n        self._failed_jobs: Dict[uuid.UUID, ActiveJob] = {}\n        self._finished_jobs: Dict[uuid.UUID, ActiveJob] = {}\n        self._output_refs: Dict[uuid.UUID, ValueMapWritable] = {}\n        self._job_records: Dict[uuid.UUID, JobRecord] = {}\n\n        self._listeners: List[JobStatusListener] = []\n\n    def _send_job_event(\n        self,\n        job_id: uuid.UUID,\n        old_status: Union[JobStatus, None],\n        new_status: JobStatus,\n    ):\n\n        for listener in self._listeners:\n            listener.job_status_changed(\n                job_id=job_id, old_status=old_status, new_status=new_status\n            )\n\n    def register_job_status_listener(self, listener: JobStatusListener):\n\n        self._listeners.append(listener)\n\n    def get_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n        if job_id in self._active_jobs.keys():\n            return self._active_jobs[job_id]\n        elif job_id in self._finished_jobs.keys():\n            return self._finished_jobs[job_id]\n        elif job_id in self._failed_jobs.keys():\n            return self._failed_jobs[job_id]\n        else:\n            raise Exception(f\"No job with id '{job_id}' registered.\")\n\n    def get_job_status(self, job_id: uuid.UUID) -&gt; JobStatus:\n\n        job = self.get_job(job_id=job_id)\n        return job.status\n\n    def get_job_record(self, job_id: uuid.UUID) -&gt; JobRecord:\n\n        if job_id in self._job_records.keys():\n            return self._job_records[job_id]\n        else:\n            raise Exception(f\"No job record for job with id '{job_id}' registered.\")\n\n    def create_job(\n        self, job_config: JobConfig, job_metadata: Union[None, Mapping[str, Any]]\n    ) -&gt; uuid.UUID:\n\n        environments = {\n            env_name: env.instance_id\n            for env_name, env in self._kiara.current_environments.items()\n        }\n\n        if job_metadata is None:\n            job_metadata = {}\n\n        result_pedigree = ValuePedigree(\n            kiara_id=self._kiara.id,\n            module_type=job_config.module_type,\n            module_config=job_config.module_config,\n            inputs=job_config.inputs,\n            environments=environments,\n        )\n\n        module = self._kiara.module_registry.create_module(manifest=job_config)\n        unique_result_values = module.characteristics.unique_result_values\n\n        outputs = ValueMapWritable.create_from_schema(\n            kiara=self._kiara,\n            schema=module.outputs_schema,\n            pedigree=result_pedigree,\n            unique_value_ids=unique_result_values,\n        )\n        job_id = ID_REGISTRY.generate(kiara_id=self._kiara.id)\n        job_log = JobLog()\n\n        job = ActiveJob(\n            job_id=job_id, job_config=job_config, job_log=job_log, results=None\n        )\n        ID_REGISTRY.update_metadata(job_id, obj=job)\n        job.job_log.add_log(\"job created\")\n\n        job_details = {\n            \"job_config\": job_config,\n            \"job\": job,\n            \"module\": module,\n            \"outputs\": outputs,\n            \"job_metadata\": job_metadata,\n        }\n        self._created_jobs[job_id] = job_details\n\n        self._send_job_event(\n            job_id=job_id, old_status=None, new_status=JobStatus.CREATED\n        )\n\n        if is_develop():\n\n            dev_settings = get_dev_config()\n\n            if dev_settings.log.log_pre_run and (\n                not module.characteristics.is_internal\n                or dev_settings.log.pre_run.internal_modules\n            ):\n\n                is_pipeline_step = job_metadata.get(\"is_pipeline_step\", False)\n                if is_pipeline_step:\n                    if dev_settings.log.pre_run.pipeline_steps:\n                        step_id = job_metadata.get(\"step_id\", None)\n                        assert step_id is not None\n                        title = (\n                            f\"Pre-run information for pipeline step: [i]{step_id}[/i]\"\n                        )\n                    else:\n                        title = None\n                else:\n                    title = f\"Pre-run information for module: [i]{module.module_type_name}[/i]\"\n\n                if title:\n                    from kiara.utils.debug import create_module_preparation_table\n                    from kiara.utils.develop import log_dev_message\n\n                    table = create_module_preparation_table(\n                        kiara=self._kiara,\n                        job_config=job_config,\n                        job_id=job_id,\n                        module=module,\n                    )\n                    log_dev_message(table, title=title)\n\n        return job_id\n\n    def queue_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n        job_details = self._created_jobs.pop(job_id)\n        self._running_job_details[job_id] = job_details\n        job_config: JobConfig = job_details.get(\"job_config\")  # type: ignore\n\n        job: ActiveJob = job_details.get(\"job\")  # type: ignore\n        module: KiaraModule = job_details.get(\"module\")  # type: ignore\n        outputs: ValueMapWritable = job_details.get(\"outputs\")  # type: ignore\n\n        self._active_jobs[job_id] = job  # type: ignore\n        self._output_refs[job_id] = outputs  # type: ignore\n\n        input_values = self._kiara.data_registry.load_values(job_config.inputs)\n\n        if module.is_pipeline():\n            module._set_job_registry(self._kiara.job_registry)  # type: ignore\n\n        try:\n            self._add_processing_task(\n                job_id=job_id,\n                module=module,\n                inputs=input_values,\n                outputs=outputs,\n                job_log=job.job_log,\n            )\n            return job\n\n        except Exception as e:\n            msg = str(e)\n            if not msg:\n                msg = repr(e)\n            job.error = msg\n\n            if isinstance(e, KiaraProcessingException):\n                e._module = module\n                e._inputs = ValueMapReadOnly.create_from_ids(\n                    data_registry=self._kiara.data_registry, **job_config.inputs\n                )\n                job._exception = e\n                log_exception(e)\n                raise e\n            else:\n                kpe = KiaraProcessingException(\n                    e,\n                    module=module,\n                    inputs=ValueMapReadOnly.create_from_ids(\n                        self._kiara.data_registry, **job_config.inputs\n                    ),\n                )\n                job._exception = kpe\n                log_exception(kpe)\n                raise e\n\n    def job_status_updated(\n        self, job_id: uuid.UUID, status: Union[JobStatus, str, Exception]\n    ):\n\n        job = self._active_jobs.get(job_id, None)\n        if job is None:\n            raise Exception(\n                f\"Can't retrieve active job with id '{job_id}', no such job registered.\"\n            )\n\n        old_status = job.status\n\n        if status == JobStatus.SUCCESS:\n            self._active_jobs.pop(job_id)\n            job.job_log.add_log(\"job finished successfully\")\n            job.status = JobStatus.SUCCESS\n            job.finished = datetime.now()\n            values = self._output_refs[job_id]\n            values.sync_values()\n            value_ids = values.get_all_value_ids()\n            job.results = value_ids\n            job.job_log.percent_finished = 100\n            job_record = JobRecord.from_active_job(active_job=job, kiara=self._kiara)\n            self._job_records[job_id] = job_record\n            self._finished_jobs[job_id] = job\n        elif status == JobStatus.FAILED or isinstance(status, (str, Exception)):\n            self._active_jobs.pop(job_id)\n            job.job_log.add_log(\"job failed\")\n            job.status = JobStatus.FAILED\n            job.finished = datetime.now()\n            if isinstance(status, str):\n                job.error = status\n            elif isinstance(status, Exception):\n                msg = str(status)\n                job.error = msg\n                job._exception = status\n            self._failed_jobs[job_id] = job\n            log.debug(\n                \"job.failed\",\n                job_id=str(job.job_id),\n                msg=job.error,\n                module_type=job.job_config.module_type,\n            )\n        elif status == JobStatus.STARTED:\n            job.job_log.add_log(\"job started\")\n            job.status = JobStatus.STARTED\n            job.started = datetime.now()\n        else:\n            raise ValueError(f\"Invalid value for status: {status}\")\n\n        log.debug(\n            \"job.status_updated\",\n            old_status=old_status.value,\n            new_status=job.status.value,\n            job_id=str(job.job_id),\n            module_type=job.job_config.module_type,\n        )\n\n        if status in [JobStatus.SUCCESS, JobStatus.FAILED]:\n            if is_develop():\n                dev_config = get_dev_config()\n                if dev_config.log.log_post_run:\n                    details = self._running_job_details[job_id]\n                    module: KiaraModule = details[\"module\"]\n                    skip = False\n                    if (\n                        module.characteristics.is_internal\n                        and not dev_config.log.post_run.internal_modules\n                    ):\n                        skip = True\n                    is_pipeline_step = details[\"job_metadata\"].get(\n                        \"is_pipeline_step\", False\n                    )\n                    if is_pipeline_step and not dev_config.log.post_run.pipeline_steps:\n                        skip = True\n\n                    if not skip:\n                        if is_pipeline_step:\n                            step_id = details[\"job_metadata\"][\"step_id\"]\n                            title = f\"Post-run information for pipeline step: {step_id}\"\n                        else:\n                            title = f\"Post-run information for module: {module.module_type_name}\"\n\n                        from kiara.utils.debug import create_post_run_table\n                        from kiara.utils.develop import log_dev_message\n\n                        rendered = create_post_run_table(\n                            kiara=self._kiara,\n                            job=job,\n                            module=module,\n                            job_config=details[\"job_config\"],\n                        )\n                        log_dev_message(rendered, title=title)\n\n            self._running_job_details.pop(job_id)\n\n        self._send_job_event(\n            job_id=job_id, old_status=old_status, new_status=job.status\n        )\n\n    def wait_for(self, *job_ids: uuid.UUID):\n\"\"\"Wait for the jobs with the specified ids, also optionally sync their outputs with the pipeline value state.\"\"\"\n\n        self._wait_for(*job_ids)\n\n        for job_id in job_ids:\n            job = self._job_records.get(job_id, None)\n            if job is None:\n                _job = self._failed_jobs.get(job_id, None)\n                if _job is None:\n                    raise Exception(f\"Can't find job with id: {job_id}\")\n\n    @abc.abstractmethod\n    def _wait_for(self, *job_ids: uuid.UUID):\n        pass\n\n    @abc.abstractmethod\n    def _add_processing_task(\n        self,\n        job_id: uuid.UUID,\n        module: \"KiaraModule\",\n        inputs: ValueMap,\n        outputs: ValueMapWritable,\n        job_log: JobLog,\n    ) -&gt; str:\n        pass\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor-functions","title":"Functions","text":""},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.register_job_status_listener","title":"<code>register_job_status_listener(listener: JobStatusListener)</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def register_job_status_listener(self, listener: JobStatusListener):\n\n    self._listeners.append(listener)\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.get_job","title":"<code>get_job(job_id: uuid.UUID) -&gt; ActiveJob</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def get_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n    if job_id in self._active_jobs.keys():\n        return self._active_jobs[job_id]\n    elif job_id in self._finished_jobs.keys():\n        return self._finished_jobs[job_id]\n    elif job_id in self._failed_jobs.keys():\n        return self._failed_jobs[job_id]\n    else:\n        raise Exception(f\"No job with id '{job_id}' registered.\")\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.get_job_status","title":"<code>get_job_status(job_id: uuid.UUID) -&gt; JobStatus</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def get_job_status(self, job_id: uuid.UUID) -&gt; JobStatus:\n\n    job = self.get_job(job_id=job_id)\n    return job.status\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.get_job_record","title":"<code>get_job_record(job_id: uuid.UUID) -&gt; JobRecord</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def get_job_record(self, job_id: uuid.UUID) -&gt; JobRecord:\n\n    if job_id in self._job_records.keys():\n        return self._job_records[job_id]\n    else:\n        raise Exception(f\"No job record for job with id '{job_id}' registered.\")\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.create_job","title":"<code>create_job(job_config: JobConfig, job_metadata: Union[None, Mapping[str, Any]]) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def create_job(\n    self, job_config: JobConfig, job_metadata: Union[None, Mapping[str, Any]]\n) -&gt; uuid.UUID:\n\n    environments = {\n        env_name: env.instance_id\n        for env_name, env in self._kiara.current_environments.items()\n    }\n\n    if job_metadata is None:\n        job_metadata = {}\n\n    result_pedigree = ValuePedigree(\n        kiara_id=self._kiara.id,\n        module_type=job_config.module_type,\n        module_config=job_config.module_config,\n        inputs=job_config.inputs,\n        environments=environments,\n    )\n\n    module = self._kiara.module_registry.create_module(manifest=job_config)\n    unique_result_values = module.characteristics.unique_result_values\n\n    outputs = ValueMapWritable.create_from_schema(\n        kiara=self._kiara,\n        schema=module.outputs_schema,\n        pedigree=result_pedigree,\n        unique_value_ids=unique_result_values,\n    )\n    job_id = ID_REGISTRY.generate(kiara_id=self._kiara.id)\n    job_log = JobLog()\n\n    job = ActiveJob(\n        job_id=job_id, job_config=job_config, job_log=job_log, results=None\n    )\n    ID_REGISTRY.update_metadata(job_id, obj=job)\n    job.job_log.add_log(\"job created\")\n\n    job_details = {\n        \"job_config\": job_config,\n        \"job\": job,\n        \"module\": module,\n        \"outputs\": outputs,\n        \"job_metadata\": job_metadata,\n    }\n    self._created_jobs[job_id] = job_details\n\n    self._send_job_event(\n        job_id=job_id, old_status=None, new_status=JobStatus.CREATED\n    )\n\n    if is_develop():\n\n        dev_settings = get_dev_config()\n\n        if dev_settings.log.log_pre_run and (\n            not module.characteristics.is_internal\n            or dev_settings.log.pre_run.internal_modules\n        ):\n\n            is_pipeline_step = job_metadata.get(\"is_pipeline_step\", False)\n            if is_pipeline_step:\n                if dev_settings.log.pre_run.pipeline_steps:\n                    step_id = job_metadata.get(\"step_id\", None)\n                    assert step_id is not None\n                    title = (\n                        f\"Pre-run information for pipeline step: [i]{step_id}[/i]\"\n                    )\n                else:\n                    title = None\n            else:\n                title = f\"Pre-run information for module: [i]{module.module_type_name}[/i]\"\n\n            if title:\n                from kiara.utils.debug import create_module_preparation_table\n                from kiara.utils.develop import log_dev_message\n\n                table = create_module_preparation_table(\n                    kiara=self._kiara,\n                    job_config=job_config,\n                    job_id=job_id,\n                    module=module,\n                )\n                log_dev_message(table, title=title)\n\n    return job_id\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.queue_job","title":"<code>queue_job(job_id: uuid.UUID) -&gt; ActiveJob</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def queue_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n    job_details = self._created_jobs.pop(job_id)\n    self._running_job_details[job_id] = job_details\n    job_config: JobConfig = job_details.get(\"job_config\")  # type: ignore\n\n    job: ActiveJob = job_details.get(\"job\")  # type: ignore\n    module: KiaraModule = job_details.get(\"module\")  # type: ignore\n    outputs: ValueMapWritable = job_details.get(\"outputs\")  # type: ignore\n\n    self._active_jobs[job_id] = job  # type: ignore\n    self._output_refs[job_id] = outputs  # type: ignore\n\n    input_values = self._kiara.data_registry.load_values(job_config.inputs)\n\n    if module.is_pipeline():\n        module._set_job_registry(self._kiara.job_registry)  # type: ignore\n\n    try:\n        self._add_processing_task(\n            job_id=job_id,\n            module=module,\n            inputs=input_values,\n            outputs=outputs,\n            job_log=job.job_log,\n        )\n        return job\n\n    except Exception as e:\n        msg = str(e)\n        if not msg:\n            msg = repr(e)\n        job.error = msg\n\n        if isinstance(e, KiaraProcessingException):\n            e._module = module\n            e._inputs = ValueMapReadOnly.create_from_ids(\n                data_registry=self._kiara.data_registry, **job_config.inputs\n            )\n            job._exception = e\n            log_exception(e)\n            raise e\n        else:\n            kpe = KiaraProcessingException(\n                e,\n                module=module,\n                inputs=ValueMapReadOnly.create_from_ids(\n                    self._kiara.data_registry, **job_config.inputs\n                ),\n            )\n            job._exception = kpe\n            log_exception(kpe)\n            raise e\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.job_status_updated","title":"<code>job_status_updated(job_id: uuid.UUID, status: Union[JobStatus, str, Exception])</code>","text":"Source code in <code>kiara/processing/__init__.py</code> <pre><code>def job_status_updated(\n    self, job_id: uuid.UUID, status: Union[JobStatus, str, Exception]\n):\n\n    job = self._active_jobs.get(job_id, None)\n    if job is None:\n        raise Exception(\n            f\"Can't retrieve active job with id '{job_id}', no such job registered.\"\n        )\n\n    old_status = job.status\n\n    if status == JobStatus.SUCCESS:\n        self._active_jobs.pop(job_id)\n        job.job_log.add_log(\"job finished successfully\")\n        job.status = JobStatus.SUCCESS\n        job.finished = datetime.now()\n        values = self._output_refs[job_id]\n        values.sync_values()\n        value_ids = values.get_all_value_ids()\n        job.results = value_ids\n        job.job_log.percent_finished = 100\n        job_record = JobRecord.from_active_job(active_job=job, kiara=self._kiara)\n        self._job_records[job_id] = job_record\n        self._finished_jobs[job_id] = job\n    elif status == JobStatus.FAILED or isinstance(status, (str, Exception)):\n        self._active_jobs.pop(job_id)\n        job.job_log.add_log(\"job failed\")\n        job.status = JobStatus.FAILED\n        job.finished = datetime.now()\n        if isinstance(status, str):\n            job.error = status\n        elif isinstance(status, Exception):\n            msg = str(status)\n            job.error = msg\n            job._exception = status\n        self._failed_jobs[job_id] = job\n        log.debug(\n            \"job.failed\",\n            job_id=str(job.job_id),\n            msg=job.error,\n            module_type=job.job_config.module_type,\n        )\n    elif status == JobStatus.STARTED:\n        job.job_log.add_log(\"job started\")\n        job.status = JobStatus.STARTED\n        job.started = datetime.now()\n    else:\n        raise ValueError(f\"Invalid value for status: {status}\")\n\n    log.debug(\n        \"job.status_updated\",\n        old_status=old_status.value,\n        new_status=job.status.value,\n        job_id=str(job.job_id),\n        module_type=job.job_config.module_type,\n    )\n\n    if status in [JobStatus.SUCCESS, JobStatus.FAILED]:\n        if is_develop():\n            dev_config = get_dev_config()\n            if dev_config.log.log_post_run:\n                details = self._running_job_details[job_id]\n                module: KiaraModule = details[\"module\"]\n                skip = False\n                if (\n                    module.characteristics.is_internal\n                    and not dev_config.log.post_run.internal_modules\n                ):\n                    skip = True\n                is_pipeline_step = details[\"job_metadata\"].get(\n                    \"is_pipeline_step\", False\n                )\n                if is_pipeline_step and not dev_config.log.post_run.pipeline_steps:\n                    skip = True\n\n                if not skip:\n                    if is_pipeline_step:\n                        step_id = details[\"job_metadata\"][\"step_id\"]\n                        title = f\"Post-run information for pipeline step: {step_id}\"\n                    else:\n                        title = f\"Post-run information for module: {module.module_type_name}\"\n\n                    from kiara.utils.debug import create_post_run_table\n                    from kiara.utils.develop import log_dev_message\n\n                    rendered = create_post_run_table(\n                        kiara=self._kiara,\n                        job=job,\n                        module=module,\n                        job_config=details[\"job_config\"],\n                    )\n                    log_dev_message(rendered, title=title)\n\n        self._running_job_details.pop(job_id)\n\n    self._send_job_event(\n        job_id=job_id, old_status=old_status, new_status=job.status\n    )\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing.ModuleProcessor.wait_for","title":"<code>wait_for(*job_ids: uuid.UUID)</code>","text":"<p>Wait for the jobs with the specified ids, also optionally sync their outputs with the pipeline value state.</p> Source code in <code>kiara/processing/__init__.py</code> <pre><code>def wait_for(self, *job_ids: uuid.UUID):\n\"\"\"Wait for the jobs with the specified ids, also optionally sync their outputs with the pipeline value state.\"\"\"\n\n    self._wait_for(*job_ids)\n\n    for job_id in job_ids:\n        job = self._job_records.get(job_id, None)\n        if job is None:\n            _job = self._failed_jobs.get(job_id, None)\n            if _job is None:\n                raise Exception(f\"Can't find job with id: {job_id}\")\n</code></pre>"},{"location":"reference/kiara/processing/__init__/#kiara.processing-functions","title":"Functions","text":""},{"location":"reference/kiara/processing/synchronous/","title":"synchronous","text":""},{"location":"reference/kiara/processing/synchronous/#kiara.processing.synchronous-classes","title":"Classes","text":""},{"location":"reference/kiara/processing/synchronous/#kiara.processing.synchronous.SynchronousProcessorConfig","title":"<code>SynchronousProcessorConfig</code>","text":"<p>         Bases: <code>ProcessorConfig</code></p> Source code in <code>kiara/processing/synchronous.py</code> <pre><code>class SynchronousProcessorConfig(ProcessorConfig):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/processing/synchronous/#kiara.processing.synchronous.SynchronousProcessor","title":"<code>SynchronousProcessor</code>","text":"<p>         Bases: <code>ModuleProcessor</code></p> Source code in <code>kiara/processing/synchronous.py</code> <pre><code>class SynchronousProcessor(ModuleProcessor):\n    def _add_processing_task(\n        self,\n        job_id: uuid.UUID,\n        module: \"KiaraModule\",\n        inputs: ValueMap,\n        outputs: ValueMapWritable,\n        job_log: JobLog,\n    ):\n\n        self.job_status_updated(job_id=job_id, status=JobStatus.STARTED)\n        try:\n            module.process_step(inputs=inputs, outputs=outputs, job_log=job_log)\n            # output_wrap._sync()\n            self.job_status_updated(job_id=job_id, status=JobStatus.SUCCESS)\n        except Exception as e:\n            self.job_status_updated(job_id=job_id, status=e)\n\n    def _wait_for(self, *job_ids: uuid.UUID):\n\n        # jobs will always be finished, since we were waiting for them in the 'process' method\n        return\n</code></pre>"},{"location":"reference/kiara/registries/__init__/","title":"registries","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.ARCHIVE_CONFIG_CLS","title":"<code>ARCHIVE_CONFIG_CLS = TypeVar('ARCHIVE_CONFIG_CLS', bound=ArchiveConfig)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.NON_ARCHIVE_DETAILS","title":"<code>NON_ARCHIVE_DETAILS = ArchiveDetails()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveConfig","title":"<code>ArchiveConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/registries/__init__.py</code> <pre><code>class ArchiveConfig(BaseModel):\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveConfig-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveConfig.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>class Config:\n    json_loads = orjson.loads\n    json_dumps = orjson_dumps\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveConfig.Config-attributes","title":"Attributes","text":"<code>json_loads = orjson.loads</code> <code>class-attribute</code> \u00b6 <code>json_dumps = orjson_dumps</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveDetails","title":"<code>ArchiveDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/registries/__init__.py</code> <pre><code>class ArchiveDetails(BaseModel):\n\n    size: Union[int, None] = Field(\n        description=\"The size of the stored archive.\", default=None\n    )\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.ArchiveDetails.size","title":"<code>size: Union[int, None] = Field(description='The size of the stored archive.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive","title":"<code>KiaraArchive</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>kiara/registries/__init__.py</code> <pre><code>class KiaraArchive(abc.ABC):\n\n    _config_cls = ArchiveConfig  # type: ignore\n\n    @classmethod\n    @abc.abstractmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n        pass\n\n    @classmethod\n    @abc.abstractmethod\n    def is_writeable(cls) -&gt; bool:\n        pass\n\n    @abc.abstractmethod\n    def register_archive(self, kiara: \"Kiara\"):\n        pass\n\n    @abc.abstractmethod\n    def retrieve_archive_id(self) -&gt; uuid.UUID:\n        pass\n\n    @property\n    def archive_id(self) -&gt; uuid.UUID:\n        return self.retrieve_archive_id()\n\n    @property\n    def config(self) -&gt; ArchiveConfig:\n        return self._get_config()\n\n    @abc.abstractmethod\n    def _get_config(self) -&gt; ArchiveConfig:\n        pass\n\n    def get_archive_details(self) -&gt; ArchiveDetails:\n        return NON_ARCHIVE_DETAILS\n\n    def delete_archive(self, archive_id: Union[uuid.UUID, None] = None):\n\n        if archive_id != self.archive_id:\n            raise Exception(\n                f\"Not deleting archive with id '{self.archive_id}': confirmation id '{archive_id}' does not match.\"\n            )\n\n        logger.info(\n            \"deleteing.archive\",\n            archive_id=self.archive_id,\n            item_types=self.supported_item_types(),\n            archive_type=self.__class__.__name__,\n        )\n        self._delete_archive()\n\n    @abc.abstractmethod\n    def _delete_archive(self):\n        pass\n\n    def __hash__(self):\n        return hash(self.archive_id)\n\n    def __eq__(self, other):\n\n        if not isinstance(other, self.__class__):\n            return False\n\n        return self.archive_id == other.archive_id\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive._config_cls","title":"<code>_config_cls = ArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.archive_id","title":"<code>archive_id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.config","title":"<code>config: ArchiveConfig</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef is_writeable(cls) -&gt; bool:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.register_archive","title":"<code>register_archive(kiara: Kiara)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>@abc.abstractmethod\ndef register_archive(self, kiara: \"Kiara\"):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.retrieve_archive_id","title":"<code>retrieve_archive_id() -&gt; uuid.UUID</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_archive_id(self) -&gt; uuid.UUID:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.get_archive_details","title":"<code>get_archive_details() -&gt; ArchiveDetails</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>def get_archive_details(self) -&gt; ArchiveDetails:\n    return NON_ARCHIVE_DETAILS\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.KiaraArchive.delete_archive","title":"<code>delete_archive(archive_id: Union[uuid.UUID, None] = None)</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>def delete_archive(self, archive_id: Union[uuid.UUID, None] = None):\n\n    if archive_id != self.archive_id:\n        raise Exception(\n            f\"Not deleting archive with id '{self.archive_id}': confirmation id '{archive_id}' does not match.\"\n        )\n\n    logger.info(\n        \"deleteing.archive\",\n        archive_id=self.archive_id,\n        item_types=self.supported_item_types(),\n        archive_type=self.__class__.__name__,\n    )\n    self._delete_archive()\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive","title":"<code>BaseArchive</code>","text":"<p>         Bases: <code>KiaraArchive</code>, <code>Generic[ARCHIVE_CONFIG_CLS]</code></p> Source code in <code>kiara/registries/__init__.py</code> <pre><code>class BaseArchive(KiaraArchive, Generic[ARCHIVE_CONFIG_CLS]):\n\n    _config_cls: Type[ARCHIVE_CONFIG_CLS] = ArchiveConfig  # type: ignore\n\n    def __init__(self, archive_id: uuid.UUID, config: ARCHIVE_CONFIG_CLS):\n\n        self._archive_id: uuid.UUID = archive_id\n        self._config: ARCHIVE_CONFIG_CLS = config\n        self._kiara: Union[\"Kiara\", None] = None\n\n    def _get_config(self) -&gt; ARCHIVE_CONFIG_CLS:\n        return self._config\n\n    def retrieve_archive_id(self) -&gt; uuid.UUID:\n        return self._archive_id\n\n    @property\n    def kiara_context(self) -&gt; \"Kiara\":\n        if self._kiara is None:\n            raise Exception(\"Archive not registered into a kiara context yet.\")\n        return self._kiara\n\n    def register_archive(self, kiara: \"Kiara\"):\n        if self._kiara is not None:\n            raise Exception(\"Archive already registered in a context.\")\n        self._kiara = kiara\n\n    def _delete_archive(self):\n\n        logger.info(\n            \"ignore.archive_delete_request\",\n            reason=\"not implemented/applicable\",\n            archive_id=self.archive_id,\n            item_types=self.supported_item_types(),\n            archive_type=self.__class__.__name__,\n        )\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive._config_cls","title":"<code>_config_cls: Type[ARCHIVE_CONFIG_CLS] = ArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive.kiara_context","title":"<code>kiara_context: Kiara</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive.retrieve_archive_id","title":"<code>retrieve_archive_id() -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>def retrieve_archive_id(self) -&gt; uuid.UUID:\n    return self._archive_id\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.BaseArchive.register_archive","title":"<code>register_archive(kiara: Kiara)</code>","text":"Source code in <code>kiara/registries/__init__.py</code> <pre><code>def register_archive(self, kiara: \"Kiara\"):\n    if self._kiara is not None:\n        raise Exception(\"Archive already registered in a context.\")\n    self._kiara = kiara\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.FileSystemArchiveConfig","title":"<code>FileSystemArchiveConfig</code>","text":"<p>         Bases: <code>ArchiveConfig</code></p> Source code in <code>kiara/registries/__init__.py</code> <pre><code>class FileSystemArchiveConfig(ArchiveConfig):\n\n    archive_path: str = Field(\n        description=\"The path where the data for this archive is stored.\"\n    )\n</code></pre>"},{"location":"reference/kiara/registries/__init__/#kiara.registries.FileSystemArchiveConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries.FileSystemArchiveConfig.archive_path","title":"<code>archive_path: str = Field(description='The path where the data for this archive is stored.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/__init__/#kiara.registries-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/__init__/","title":"aliases","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive","title":"<code>AliasArchive</code>","text":"<p>         Bases: <code>BaseArchive</code></p> Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>class AliasArchive(BaseArchive):\n    @classmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n        return [\"alias\"]\n\n    @abc.abstractmethod\n    def retrieve_all_aliases(self) -&gt; Union[Mapping[str, uuid.UUID], None]:\n\"\"\"Retrieve a list of all aliases registered in this archive.\n\n        The result of this method can be 'None', for cases where the aliases are determined dynamically.\n        In kiara, the result of this method is mostly used to improve performance when looking up an alias.\n\n        Returns:\n            a list of strings (the aliases), or 'None' if this archive does not support alias indexes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n        pass\n\n    @abc.abstractmethod\n    def find_aliases_for_value_id(self, value_id: uuid.UUID) -&gt; Union[Set[str], None]:\n        pass\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@classmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n    return [\"alias\"]\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive.retrieve_all_aliases","title":"<code>retrieve_all_aliases() -&gt; Union[Mapping[str, uuid.UUID], None]</code>  <code>abstractmethod</code>","text":"<p>Retrieve a list of all aliases registered in this archive.</p> <p>The result of this method can be 'None', for cases where the aliases are determined dynamically. In kiara, the result of this method is mostly used to improve performance when looking up an alias.</p> <p>Returns:</p> Type Description <code>Union[Mapping[str, uuid.UUID], None]</code> <p>a list of strings (the aliases), or 'None' if this archive does not support alias indexes.</p> Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_all_aliases(self) -&gt; Union[Mapping[str, uuid.UUID], None]:\n\"\"\"Retrieve a list of all aliases registered in this archive.\n\n    The result of this method can be 'None', for cases where the aliases are determined dynamically.\n    In kiara, the result of this method is mostly used to improve performance when looking up an alias.\n\n    Returns:\n        a list of strings (the aliases), or 'None' if this archive does not support alias indexes.\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive.find_value_id_for_alias","title":"<code>find_value_id_for_alias(alias: str) -&gt; Union[uuid.UUID, None]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@abc.abstractmethod\ndef find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive.find_aliases_for_value_id","title":"<code>find_aliases_for_value_id(value_id: uuid.UUID) -&gt; Union[Set[str], None]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@abc.abstractmethod\ndef find_aliases_for_value_id(self, value_id: uuid.UUID) -&gt; Union[Set[str], None]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasStore","title":"<code>AliasStore</code>","text":"<p>         Bases: <code>AliasArchive</code></p> Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>class AliasStore(AliasArchive):\n    @abc.abstractmethod\n    def register_aliases(self, value_id: uuid.UUID, *aliases: str):\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasStore.register_aliases","title":"<code>register_aliases(value_id: uuid.UUID, *aliases: str)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>@abc.abstractmethod\ndef register_aliases(self, value_id: uuid.UUID, *aliases: str):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem","title":"<code>AliasItem</code>","text":"<p>         Bases: <code>NamedTuple</code></p> Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>class AliasItem(NamedTuple):\n    full_alias: str\n    rel_alias: str\n    value_id: uuid.UUID\n    alias_archive: str\n    alias_archive_id: uuid.UUID\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem.full_alias","title":"<code>full_alias: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem.rel_alias","title":"<code>rel_alias: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem.value_id","title":"<code>value_id: uuid.UUID</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem.alias_archive","title":"<code>alias_archive: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasItem.alias_archive_id","title":"<code>alias_archive_id: uuid.UUID</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry","title":"<code>AliasRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>class AliasRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n        self._event_callback: Callable = self._kiara.event_registry.add_producer(self)\n\n        self._alias_archives: Dict[str, AliasArchive] = {}\n\"\"\"All registered archives/stores.\"\"\"\n\n        self._default_alias_store: Union[str, None] = None\n\"\"\"The alias of the store where new aliases are stored by default.\"\"\"\n\n        self._cached_aliases: Union[Dict[str, AliasItem], None] = None\n        self._cached_aliases_by_id: Union[Dict[uuid.UUID, Set[AliasItem]], None] = None\n\n    def register_archive(\n        self,\n        archive: AliasArchive,\n        alias: Union[str, None] = None,\n        set_as_default_store: Union[bool, None] = None,\n    ):\n\n        alias_archive_id = archive.archive_id\n        archive.register_archive(kiara=self._kiara)\n\n        if alias is None:\n            alias = str(alias_archive_id)\n\n        if \".\" in alias:\n            raise Exception(\n                f\"Can't register alias archive with as '{alias}': registered name is not allowed to contain a '.' character (yet).\"\n            )\n\n        if alias in self._alias_archives.keys():\n            raise Exception(f\"Can't add store, alias '{alias}' already registered.\")\n\n        self._alias_archives[alias] = archive\n        is_store = False\n        is_default_store = False\n        if isinstance(archive, AliasStore):\n            is_store = True\n            if set_as_default_store and self._default_alias_store is not None:\n                raise Exception(\n                    f\"Can't set alias store '{alias}' as default store: default store already set.\"\n                )\n\n            if self._default_alias_store is None:\n                is_default_store = True\n                self._default_alias_store = alias\n\n        event = AliasArchiveAddedEvent.construct(\n            kiara_id=self._kiara.id,\n            alias_archive_id=archive.archive_id,\n            alias_archive_alias=alias,\n            is_store=is_store,\n            is_default_store=is_default_store,\n        )\n        self._event_callback(event)\n\n    @property\n    def default_alias_store(self) -&gt; str:\n\n        if self._default_alias_store is None:\n            raise Exception(\"No default alias store set (yet).\")\n        return self._default_alias_store\n\n    @property\n    def alias_archives(self) -&gt; Mapping[str, AliasArchive]:\n        return self._alias_archives\n\n    def get_archive(\n        self, archive_id: Union[str, None] = None\n    ) -&gt; Union[AliasArchive, None]:\n        if archive_id is None:\n            archive_id = self.default_alias_store\n            if archive_id is None:\n                raise Exception(\"Can't retrieve default alias archive, none set (yet).\")\n\n        archive = self._alias_archives.get(archive_id, None)\n        return archive\n\n    @property\n    def all_aliases(self) -&gt; Iterable[str]:\n\n        return self.aliases.keys()\n\n    @property\n    def aliases_by_id(self) -&gt; Mapping[uuid.UUID, Set[AliasItem]]:\n        if self._cached_aliases_by_id is None:\n            self.aliases\n        return self._cached_aliases_by_id  # type: ignore\n\n    @property\n    def aliases(self) -&gt; Dict[str, AliasItem]:\n\"\"\"Retrieve a map of all available aliases, context wide, with the registered archive aliases as values.\"\"\"\n\n        if self._cached_aliases is not None:\n            return self._cached_aliases\n\n        # TODO: multithreading lock\n\n        all_aliases: Dict[str, AliasItem] = {}\n        all_aliases_by_id: Dict[uuid.UUID, Set[AliasItem]] = {}\n        for archive_alias, archive in self._alias_archives.items():\n            alias_map = archive.retrieve_all_aliases()\n            if alias_map is None:\n                continue\n            for alias, v_id in alias_map.items():\n                if archive_alias == self.default_alias_store:\n                    final_alias = alias\n                else:\n                    final_alias = f\"{archive_alias}.{alias}\"\n\n                if final_alias in all_aliases.keys():\n                    raise Exception(\n                        f\"Inconsistent alias registry: alias '{final_alias}' available more than once.\"\n                    )\n                item = AliasItem(\n                    full_alias=final_alias,\n                    rel_alias=alias,\n                    value_id=v_id,\n                    alias_archive=archive_alias,\n                    alias_archive_id=archive.archive_id,\n                )\n                all_aliases[final_alias] = item\n                all_aliases_by_id.setdefault(v_id, set()).add(item)\n\n        self._cached_aliases = {k: all_aliases[k] for k in sorted(all_aliases.keys())}\n        self._cached_aliases_by_id = all_aliases_by_id\n        return self._cached_aliases\n\n    def find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n\n        alias_item = self.aliases.get(alias, None)\n        if alias_item is not None:\n            return alias_item.value_id\n\n        if \".\" not in alias:\n            return None\n\n        archive_id, rest = alias.split(\".\", maxsplit=2)\n        archive = self.get_archive(archive_id=archive_id)\n\n        if archive is None:\n            # means no registered prefix\n            archive = self.get_archive()\n            assert archive is not None\n            v_id = archive.find_value_id_for_alias(alias)\n        else:\n            v_id = archive.find_value_id_for_alias(alias=rest)\n\n        # TODO: cache this?\n        return v_id\n\n    def _get_value_id(self, value_id: Union[uuid.UUID, ValueLink, str]) -&gt; uuid.UUID:\n\n        if not isinstance(value_id, uuid.UUID):\n            # fallbacks for common mistakes, this should error out if not a Value or string.\n            if hasattr(value_id, \"value_id\"):\n                _value_id: Union[uuid.UUID, str] = value_id.value_id  # type: ignore\n                if isinstance(_value_id, str):\n                    _value_id = uuid.UUID(_value_id)\n            else:\n                _value_id = uuid.UUID(\n                    value_id  # type: ignore\n                )  # this should fail if not string or wrong string format\n        else:\n            _value_id = value_id\n\n        if not _value_id:\n            raise Exception(f\"Could not resolve id: {value_id}\")\n        return _value_id\n\n    def find_aliases_for_value_id(\n        self,\n        value_id: Union[uuid.UUID, ValueLink, str],\n        search_dynamic_archives: bool = False,\n    ) -&gt; Set[str]:\n\n        value_id = self._get_value_id(value_id=value_id)\n\n        aliases = {a.full_alias for a in self.aliases_by_id.get(value_id, [])}\n\n        if search_dynamic_archives:\n            for archive_alias, archive in self._alias_archives.items():\n                _aliases = archive.find_aliases_for_value_id(value_id=value_id)\n                # TODO: cache those results\n                if _aliases:\n                    for a in _aliases:\n                        aliases.add(f\"{archive_alias}.{a}\")\n\n        return aliases\n\n    def register_aliases(\n        self,\n        value_id: Union[uuid.UUID, ValueLink, str],\n        *aliases: str,\n        allow_overwrite: bool = False,\n    ):\n\n        value_id = self._get_value_id(value_id=value_id)\n        store_name = self.default_alias_store\n        store: AliasStore = self.get_archive(archive_id=store_name)  # type: ignore\n        self.aliases  # noqu\n\n        if not allow_overwrite:\n            duplicates = []\n            for alias in aliases:\n                if alias in self.aliases.keys():\n                    duplicates.append(alias)\n\n            if duplicates:\n                raise Exception(f\"Duplicate aliases: {duplicates}\")\n\n        store.register_aliases(value_id, *aliases)\n\n        for alias in aliases:\n            alias_item = AliasItem(\n                full_alias=alias,\n                rel_alias=alias,\n                value_id=value_id,\n                alias_archive=store_name,\n                alias_archive_id=store.archive_id,\n            )\n\n            if alias in self.aliases.keys():\n                logger.info(\"alias.replace\", alias=alias)\n                # raise NotImplementedError()\n\n            self.aliases[alias] = alias_item\n            self._cached_aliases_by_id.setdefault(value_id, set()).add(alias_item)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.default_alias_store","title":"<code>default_alias_store: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.alias_archives","title":"<code>alias_archives: Mapping[str, AliasArchive]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.all_aliases","title":"<code>all_aliases: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.aliases_by_id","title":"<code>aliases_by_id: Mapping[uuid.UUID, Set[AliasItem]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.aliases","title":"<code>aliases: Dict[str, AliasItem]</code>  <code>property</code>","text":"<p>Retrieve a map of all available aliases, context wide, with the registered archive aliases as values.</p>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.register_archive","title":"<code>register_archive(archive: AliasArchive, alias: Union[str, None] = None, set_as_default_store: Union[bool, None] = None)</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>def register_archive(\n    self,\n    archive: AliasArchive,\n    alias: Union[str, None] = None,\n    set_as_default_store: Union[bool, None] = None,\n):\n\n    alias_archive_id = archive.archive_id\n    archive.register_archive(kiara=self._kiara)\n\n    if alias is None:\n        alias = str(alias_archive_id)\n\n    if \".\" in alias:\n        raise Exception(\n            f\"Can't register alias archive with as '{alias}': registered name is not allowed to contain a '.' character (yet).\"\n        )\n\n    if alias in self._alias_archives.keys():\n        raise Exception(f\"Can't add store, alias '{alias}' already registered.\")\n\n    self._alias_archives[alias] = archive\n    is_store = False\n    is_default_store = False\n    if isinstance(archive, AliasStore):\n        is_store = True\n        if set_as_default_store and self._default_alias_store is not None:\n            raise Exception(\n                f\"Can't set alias store '{alias}' as default store: default store already set.\"\n            )\n\n        if self._default_alias_store is None:\n            is_default_store = True\n            self._default_alias_store = alias\n\n    event = AliasArchiveAddedEvent.construct(\n        kiara_id=self._kiara.id,\n        alias_archive_id=archive.archive_id,\n        alias_archive_alias=alias,\n        is_store=is_store,\n        is_default_store=is_default_store,\n    )\n    self._event_callback(event)\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.get_archive","title":"<code>get_archive(archive_id: Union[str, None] = None) -&gt; Union[AliasArchive, None]</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>def get_archive(\n    self, archive_id: Union[str, None] = None\n) -&gt; Union[AliasArchive, None]:\n    if archive_id is None:\n        archive_id = self.default_alias_store\n        if archive_id is None:\n            raise Exception(\"Can't retrieve default alias archive, none set (yet).\")\n\n    archive = self._alias_archives.get(archive_id, None)\n    return archive\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.find_value_id_for_alias","title":"<code>find_value_id_for_alias(alias: str) -&gt; Union[uuid.UUID, None]</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>def find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n\n    alias_item = self.aliases.get(alias, None)\n    if alias_item is not None:\n        return alias_item.value_id\n\n    if \".\" not in alias:\n        return None\n\n    archive_id, rest = alias.split(\".\", maxsplit=2)\n    archive = self.get_archive(archive_id=archive_id)\n\n    if archive is None:\n        # means no registered prefix\n        archive = self.get_archive()\n        assert archive is not None\n        v_id = archive.find_value_id_for_alias(alias)\n    else:\n        v_id = archive.find_value_id_for_alias(alias=rest)\n\n    # TODO: cache this?\n    return v_id\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.find_aliases_for_value_id","title":"<code>find_aliases_for_value_id(value_id: Union[uuid.UUID, ValueLink, str], search_dynamic_archives: bool = False) -&gt; Set[str]</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>def find_aliases_for_value_id(\n    self,\n    value_id: Union[uuid.UUID, ValueLink, str],\n    search_dynamic_archives: bool = False,\n) -&gt; Set[str]:\n\n    value_id = self._get_value_id(value_id=value_id)\n\n    aliases = {a.full_alias for a in self.aliases_by_id.get(value_id, [])}\n\n    if search_dynamic_archives:\n        for archive_alias, archive in self._alias_archives.items():\n            _aliases = archive.find_aliases_for_value_id(value_id=value_id)\n            # TODO: cache those results\n            if _aliases:\n                for a in _aliases:\n                    aliases.add(f\"{archive_alias}.{a}\")\n\n    return aliases\n</code></pre>"},{"location":"reference/kiara/registries/aliases/__init__/#kiara.registries.aliases.AliasRegistry.register_aliases","title":"<code>register_aliases(value_id: Union[uuid.UUID, ValueLink, str], *aliases: str, allow_overwrite: bool = False)</code>","text":"Source code in <code>kiara/registries/aliases/__init__.py</code> <pre><code>def register_aliases(\n    self,\n    value_id: Union[uuid.UUID, ValueLink, str],\n    *aliases: str,\n    allow_overwrite: bool = False,\n):\n\n    value_id = self._get_value_id(value_id=value_id)\n    store_name = self.default_alias_store\n    store: AliasStore = self.get_archive(archive_id=store_name)  # type: ignore\n    self.aliases  # noqu\n\n    if not allow_overwrite:\n        duplicates = []\n        for alias in aliases:\n            if alias in self.aliases.keys():\n                duplicates.append(alias)\n\n        if duplicates:\n            raise Exception(f\"Duplicate aliases: {duplicates}\")\n\n    store.register_aliases(value_id, *aliases)\n\n    for alias in aliases:\n        alias_item = AliasItem(\n            full_alias=alias,\n            rel_alias=alias,\n            value_id=value_id,\n            alias_archive=store_name,\n            alias_archive_id=store.archive_id,\n        )\n\n        if alias in self.aliases.keys():\n            logger.info(\"alias.replace\", alias=alias)\n            # raise NotImplementedError()\n\n        self.aliases[alias] = alias_item\n        self._cached_aliases_by_id.setdefault(value_id, set()).add(alias_item)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/","title":"archives","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive","title":"<code>FileSystemAliasArchive</code>","text":"<p>         Bases: <code>AliasArchive</code></p> Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>class FileSystemAliasArchive(AliasArchive):\n\n    _archive_type_name = \"filesystem_alias_archive\"\n    _config_cls = FileSystemArchiveConfig  # type: ignore\n\n    def __init__(self, archive_id: uuid.UUID, config: ARCHIVE_CONFIG_CLS):\n\n        super().__init__(archive_id=archive_id, config=config)\n\n        self._base_path: Union[Path, None] = None\n\n    @property\n    def alias_store_path(self) -&gt; Path:\n\n        if self._base_path is not None:\n            return self._base_path\n\n        self._base_path = Path(self.config.archive_path).absolute()  # type: ignore\n        self._base_path = fix_windows_longpath(self._base_path)\n        self._base_path.mkdir(parents=True, exist_ok=True)\n        return self._base_path\n\n    @property\n    def aliases_path(self) -&gt; Path:\n        return self.alias_store_path / \"aliases\"\n\n    @property\n    def value_id_path(self) -&gt; Path:\n        return self.alias_store_path / \"value_ids\"\n\n    def _delete_archive(self):\n        shutil.rmtree(self.alias_store_path)\n\n    def _translate_alias(self, alias: str) -&gt; Path:\n\n        if \".\" in alias:\n            tokens = alias.split(\".\")\n            alias_path = (\n                self.aliases_path.joinpath(*tokens[0:-1]) / f\"{tokens[-1]}.alias\"\n            )\n        else:\n            alias_path = self.aliases_path / f\"{alias}.alias\"\n        return alias_path\n\n    def _translate_alias_path(self, alias_path: Path) -&gt; str:\n\n        relative = (\n            alias_path.absolute()\n            .relative_to(self.aliases_path.absolute())\n            .as_posix()[:-6]\n        )\n\n        relative = os.path.normpath(relative)\n\n        if os.path.sep not in relative:\n            alias = relative\n        else:\n            alias = \".\".join(relative.split(os.path.sep))\n\n        return alias\n\n    def _translate_value_id(self, value_id: uuid.UUID) -&gt; Path:\n\n        tokens = str(value_id).split(\"-\")\n        value_id_path = (\n            self.value_id_path.joinpath(*tokens[0:-1]) / f\"{tokens[-1]}.value\"\n        )\n        return value_id_path\n\n    def _translate_value_path(self, value_path: Path) -&gt; uuid.UUID:\n\n        relative = (\n            fix_windows_longpath(value_path.absolute())\n            .relative_to(fix_windows_longpath(self.value_id_path.absolute()))\n            .as_posix()[:-6]\n        )\n        relative = os.path.normpath(relative)\n        value_id_str = \"-\".join(relative.split(os.path.sep))\n\n        return uuid.UUID(value_id_str)\n\n    def retrieve_all_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n\n        all_aliases = self.aliases_path.rglob(\"*.alias\")\n        result = {}\n        for alias_path in all_aliases:\n            alias = self._translate_alias_path(alias_path=alias_path)\n            value_id = self._find_value_id_for_alias_path(alias_path=alias_path)\n            assert value_id is not None\n            result[alias] = value_id\n\n        return result\n\n    def find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n        alias_path = self._translate_alias(alias)\n        if not alias_path.exists():\n            return None\n        return self._find_value_id_for_alias_path(alias_path=alias_path)\n\n    def _find_value_id_for_alias_path(self, alias_path: Path) -&gt; Union[uuid.UUID, None]:\n\n        resolved = alias_path.resolve()\n\n        assert resolved.name.endswith(\".value\")\n\n        value_id = self._translate_value_path(value_path=resolved)\n        return value_id\n\n    def find_aliases_for_value_id(self, value_id: uuid.UUID) -&gt; Union[Set[str], None]:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive._config_cls","title":"<code>_config_cls = FileSystemArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.alias_store_path","title":"<code>alias_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.aliases_path","title":"<code>aliases_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.value_id_path","title":"<code>value_id_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.retrieve_all_aliases","title":"<code>retrieve_all_aliases() -&gt; Mapping[str, uuid.UUID]</code>","text":"Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>def retrieve_all_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n\n    all_aliases = self.aliases_path.rglob(\"*.alias\")\n    result = {}\n    for alias_path in all_aliases:\n        alias = self._translate_alias_path(alias_path=alias_path)\n        value_id = self._find_value_id_for_alias_path(alias_path=alias_path)\n        assert value_id is not None\n        result[alias] = value_id\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.find_value_id_for_alias","title":"<code>find_value_id_for_alias(alias: str) -&gt; Union[uuid.UUID, None]</code>","text":"Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>def find_value_id_for_alias(self, alias: str) -&gt; Union[uuid.UUID, None]:\n    alias_path = self._translate_alias(alias)\n    if not alias_path.exists():\n        return None\n    return self._find_value_id_for_alias_path(alias_path=alias_path)\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasArchive.find_aliases_for_value_id","title":"<code>find_aliases_for_value_id(value_id: uuid.UUID) -&gt; Union[Set[str], None]</code>","text":"Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>def find_aliases_for_value_id(self, value_id: uuid.UUID) -&gt; Union[Set[str], None]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasStore","title":"<code>FileSystemAliasStore</code>","text":"<p>         Bases: <code>FileSystemAliasArchive</code>, <code>AliasStore</code></p> Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>class FileSystemAliasStore(FileSystemAliasArchive, AliasStore):\n\n    _archive_type_name = \"filesystem_alias_store\"\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return True\n\n    def register_aliases(self, value_id: uuid.UUID, *aliases: str):\n\n        value_path = self._translate_value_id(value_id=value_id)\n        value_path.parent.mkdir(parents=True, exist_ok=True)\n        value_path.touch()\n\n        for alias in aliases:\n            alias_path = self._translate_alias(alias)\n            alias_path.parent.mkdir(parents=True, exist_ok=True)\n            if alias_path.exists():\n                resolved = alias_path.resolve()\n                if resolved == value_path:\n                    continue\n                alias_path.unlink()\n            alias_path.symlink_to(value_path)\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasStore.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives.FileSystemAliasStore.register_aliases","title":"<code>register_aliases(value_id: uuid.UUID, *aliases: str)</code>","text":"Source code in <code>kiara/registries/aliases/archives.py</code> <pre><code>def register_aliases(self, value_id: uuid.UUID, *aliases: str):\n\n    value_path = self._translate_value_id(value_id=value_id)\n    value_path.parent.mkdir(parents=True, exist_ok=True)\n    value_path.touch()\n\n    for alias in aliases:\n        alias_path = self._translate_alias(alias)\n        alias_path.parent.mkdir(parents=True, exist_ok=True)\n        if alias_path.exists():\n            resolved = alias_path.resolve()\n            if resolved == value_path:\n                continue\n            alias_path.unlink()\n        alias_path.symlink_to(value_path)\n</code></pre>"},{"location":"reference/kiara/registries/aliases/archives/#kiara.registries.aliases.archives-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/__init__/","title":"data","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.NONE_PERSISTED_DATA","title":"<code>NONE_PERSISTED_DATA = PersistedData.construct(data_type='none', data_type_config={}, serialization_profile='none', metadata=SerializationMetadata(), hash_codec='sha2-256', archive_id=NONE_STORE_ID, chunk_id_map={})</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.ValueLink","title":"<code>ValueLink</code>","text":"<p>         Bases: <code>Protocol</code></p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>class ValueLink(Protocol):\n\n    value_id: uuid.UUID\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.ValueLink-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.ValueLink.value_id","title":"<code>value_id: uuid.UUID</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.AliasResolver","title":"<code>AliasResolver</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>class AliasResolver(abc.ABC):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: \"Kiara\" = kiara\n\n    @abc.abstractmethod\n    def resolve_alias(self, alias: str) -&gt; uuid.UUID:\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.AliasResolver-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.AliasResolver.resolve_alias","title":"<code>resolve_alias(alias: str) -&gt; uuid.UUID</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>@abc.abstractmethod\ndef resolve_alias(self, alias: str) -&gt; uuid.UUID:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DefaultAliasResolver","title":"<code>DefaultAliasResolver</code>","text":"<p>         Bases: <code>AliasResolver</code></p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>class DefaultAliasResolver(AliasResolver):\n    def __init__(self, kiara: \"Kiara\"):\n\n        super().__init__(kiara=kiara)\n\n    def resolve_alias(self, alias: str) -&gt; uuid.UUID:\n\n        if \":\" in alias:\n            ref_type, rest = alias.split(\":\", maxsplit=1)\n\n            if ref_type == \"value\":\n                _value_id: Union[uuid.UUID, None] = uuid.UUID(rest)\n            elif ref_type == \"alias\":\n                _value_id = self._kiara.alias_registry.find_value_id_for_alias(\n                    alias=rest\n                )\n                if _value_id is None:\n                    raise NoSuchValueAliasException(\n                        alias=rest,\n                        msg=f\"Can't retrive value for alias '{rest}': no such alias registered.\",\n                    )\n            else:\n                raise Exception(\n                    f\"Can't retrieve value for '{alias}': invalid reference type '{ref_type}'.\"\n                )\n        else:\n            _value_id = self._kiara.alias_registry.find_value_id_for_alias(alias)\n            if _value_id is None:\n                raise Exception(\n                    f\"Can't retrieve value for alias '{alias}': no such alias registered.\"\n                )\n\n        if _value_id is None:\n            raise Exception(\n                f\"Can't retrieve value for alias '{alias}': no such alias registered.\"\n            )\n        return _value_id\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DefaultAliasResolver-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DefaultAliasResolver.resolve_alias","title":"<code>resolve_alias(alias: str) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def resolve_alias(self, alias: str) -&gt; uuid.UUID:\n\n    if \":\" in alias:\n        ref_type, rest = alias.split(\":\", maxsplit=1)\n\n        if ref_type == \"value\":\n            _value_id: Union[uuid.UUID, None] = uuid.UUID(rest)\n        elif ref_type == \"alias\":\n            _value_id = self._kiara.alias_registry.find_value_id_for_alias(\n                alias=rest\n            )\n            if _value_id is None:\n                raise NoSuchValueAliasException(\n                    alias=rest,\n                    msg=f\"Can't retrive value for alias '{rest}': no such alias registered.\",\n                )\n        else:\n            raise Exception(\n                f\"Can't retrieve value for '{alias}': invalid reference type '{ref_type}'.\"\n            )\n    else:\n        _value_id = self._kiara.alias_registry.find_value_id_for_alias(alias)\n        if _value_id is None:\n            raise Exception(\n                f\"Can't retrieve value for alias '{alias}': no such alias registered.\"\n            )\n\n    if _value_id is None:\n        raise Exception(\n            f\"Can't retrieve value for alias '{alias}': no such alias registered.\"\n        )\n    return _value_id\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry","title":"<code>DataRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>class DataRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n        self._event_callback: Callable = self._kiara.event_registry.add_producer(self)\n\n        self._data_archives: Dict[str, DataArchive] = {}\n\n        self._default_data_store: Union[str, None] = None\n        self._registered_values: Dict[uuid.UUID, Value] = {}\n\n        self._value_archive_lookup_map: Dict[uuid.UUID, str] = {}\n\"\"\"A cached dict that stores which archives which value ids belong to.\"\"\"\n\n        self._values_by_hash: Dict[str, Set[uuid.UUID]] = {}\n\n        self._cached_data: Dict[uuid.UUID, Any] = {}\n        self._persisted_value_descs: Dict[uuid.UUID, Union[PersistedData, None]] = {}\n\n        self._alias_resolver: AliasResolver = DefaultAliasResolver(kiara=self._kiara)\n\n        # initialize special values\n        special_value_cls = PythonClass.from_class(NoneType)\n        data_type_info = DataTypeInfo.construct(\n            data_type_name=\"none\",\n            characteristics=DEFAULT_SCALAR_DATATYPE_CHARACTERISTICS,\n            data_type_class=special_value_cls,\n        )\n        self._not_set_value: Value = Value(\n            value_id=NOT_SET_VALUE_ID,\n            kiara_id=self._kiara.id,\n            value_schema=ValueSchema(\n                type=\"none\",\n                default=SpecialValue.NOT_SET,\n                is_constant=True,\n                doc=\"Special value, indicating a field is not set.\",  # type: ignore\n            ),\n            environment_hashes={},\n            value_status=ValueStatus.NOT_SET,\n            value_size=0,\n            value_hash=INVALID_HASH_MARKER,\n            pedigree=ORPHAN,\n            pedigree_output_name=\"__void__\",\n            data_type_info=data_type_info,\n        )\n        self._not_set_value._data_registry = self\n        self._cached_data[NOT_SET_VALUE_ID] = SpecialValue.NOT_SET\n        self._registered_values[NOT_SET_VALUE_ID] = self._not_set_value\n        self._persisted_value_descs[NOT_SET_VALUE_ID] = NONE_PERSISTED_DATA\n\n        self._none_value: Value = Value(\n            value_id=NONE_VALUE_ID,\n            kiara_id=self._kiara.id,\n            value_schema=ValueSchema(\n                type=\"none\",\n                default=SpecialValue.NO_VALUE,\n                is_constant=True,\n                doc=\"Special value, indicating a field is set with a 'none' value.\",  # type: ignore\n            ),\n            environment_hashes={},\n            value_status=ValueStatus.NONE,\n            value_size=0,\n            value_hash=str(NONE_CID),\n            pedigree=ORPHAN,\n            pedigree_output_name=\"__void__\",\n            data_type_info=data_type_info,\n        )\n        self._none_value._data_registry = self\n        self._cached_data[NONE_VALUE_ID] = SpecialValue.NO_VALUE\n        self._registered_values[NONE_VALUE_ID] = self._none_value\n        self._persisted_value_descs[NONE_VALUE_ID] = NONE_PERSISTED_DATA\n\n    @property\n    def kiara_id(self) -&gt; uuid.UUID:\n        return self._kiara.id\n\n    @property\n    def NOT_SET_VALUE(self) -&gt; Value:\n        return self._not_set_value\n\n    @property\n    def NONE_VALUE(self) -&gt; Value:\n        return self._none_value\n\n    def retrieve_all_available_value_ids(self) -&gt; Set[uuid.UUID]:\n\n        result: Set[uuid.UUID] = set()\n        for store in self._data_archives.values():\n            ids = store.value_ids\n            if ids:\n                result.update(ids)\n\n        return result\n\n    def register_data_archive(\n        self,\n        archive: DataArchive,\n        alias: Union[str, None] = None,\n        set_as_default_store: Union[bool, None] = None,\n    ):\n\n        data_store_id = archive.archive_id\n        archive.register_archive(kiara=self._kiara)\n        if alias is None:\n            alias = str(data_store_id)\n\n        if alias in self._data_archives.keys():\n            raise Exception(\n                f\"Can't add data archive, alias '{alias}' already registered.\"\n            )\n        self._data_archives[alias] = archive\n        is_store = False\n        is_default_store = False\n        if isinstance(archive, DataStore):\n            is_store = True\n\n            if set_as_default_store and self._default_data_store is not None:\n                raise Exception(\n                    f\"Can't set data store '{alias}' as default store: default store already set.\"\n                )\n\n            if self._default_data_store is None or set_as_default_store:\n                is_default_store = True\n                self._default_data_store = alias\n\n        event = DataArchiveAddedEvent.construct(\n            kiara_id=self._kiara.id,\n            data_archive_id=archive.archive_id,\n            data_archive_alias=alias,\n            is_store=is_store,\n            is_default_store=is_default_store,\n        )\n        self._event_callback(event)\n\n    @property\n    def default_data_store(self) -&gt; str:\n        if self._default_data_store is None:\n            raise Exception(\"No default data store set.\")\n        return self._default_data_store\n\n    @property\n    def data_archives(self) -&gt; Mapping[str, DataArchive]:\n        return self._data_archives\n\n    def get_archive(\n        self, archive_id: Union[None, uuid.UUID, str] = None\n    ) -&gt; DataArchive:\n\n        if archive_id is None:\n            archive_id = self.default_data_store\n            if archive_id is None:\n                raise Exception(\"Can't retrieve default data archive, none set (yet).\")\n\n        if isinstance(archive_id, uuid.UUID):\n            for archive in self._data_archives.values():\n                if archive.archive_id == archive_id:\n                    return archive\n\n            raise Exception(\n                f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n            )\n\n        if archive_id in self._data_archives.keys():\n            return self._data_archives[archive_id]\n        else:\n            try:\n                _archive_id = uuid.UUID(archive_id)\n                for archive in self._data_archives.values():\n                    if archive.archive_id == _archive_id:\n                        return archive\n                    raise Exception(\n                        f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n                    )\n            except Exception:\n                pass\n\n        raise Exception(\n            f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n        )\n\n    def find_store_id_for_value(self, value_id: uuid.UUID) -&gt; Union[str, None]:\n\n        if value_id in self._value_archive_lookup_map.keys():\n            return self._value_archive_lookup_map[value_id]\n\n        matches = []\n        for store_id, store in self.data_archives.items():\n            match = store.has_value(value_id=value_id)\n            if match:\n                matches.append(store_id)\n\n        if len(matches) == 0:\n            return None\n        elif len(matches) &gt; 1:\n            raise Exception(\n                f\"Found value with id '{value_id}' in multiple archives, this is not supported (yet): {matches}\"\n            )\n\n        self._value_archive_lookup_map[value_id] = matches[0]\n        return matches[0]\n\n    def get_value(self, value: Union[uuid.UUID, ValueLink, str]) -&gt; Value:\n        _value_id = None\n\n        if not isinstance(value, uuid.UUID):\n            # fallbacks for common mistakes, this should error out if not a Value or string.\n            if hasattr(value, \"value_id\"):\n                _value_id: Union[uuid.UUID, str, None] = value.value_id  # type: ignore\n                if isinstance(_value_id, str):\n                    _value_id = uuid.UUID(_value_id)\n            else:\n\n                try:\n                    _value_id = uuid.UUID(\n                        value  # type: ignore\n                    )  # this should fail if not string or wrong string format\n                except ValueError:\n                    _value_id = None\n\n                if _value_id is None:\n\n                    if not isinstance(value, str):\n                        raise Exception(\n                            f\"Can't retrieve value for '{value}': invalid type '{type(value)}'.\"\n                        )\n\n                    _value_id = self._alias_resolver.resolve_alias(value)\n        else:\n            _value_id = value\n\n        assert _value_id is not None\n\n        if _value_id in self._registered_values.keys():\n            _value = self._registered_values[_value_id]\n            return _value\n\n        matches = []\n        for store_id, store in self.data_archives.items():\n            match = store.has_value(value_id=_value_id)\n            if match:\n                matches.append(store_id)\n\n        if len(matches) == 0:\n            raise NoSuchValueIdException(\n                value_id=_value_id, msg=f\"No value registered with id: {value}\"\n            )\n        elif len(matches) &gt; 1:\n            raise NoSuchValueIdException(\n                value_id=_value_id,\n                msg=f\"Found value with id '{value}' in multiple archives, this is not supported (yet): {matches}\",\n            )\n\n        self._value_archive_lookup_map[_value_id] = matches[0]\n        stored_value = self.get_archive(matches[0]).retrieve_value(value_id=_value_id)\n        stored_value._set_registry(self)\n        stored_value._is_stored = True\n\n        self._registered_values[_value_id] = stored_value\n        return self._registered_values[_value_id]\n\n    def store_value(\n        self,\n        value: Union[ValueLink, uuid.UUID, str],\n        store_id: Union[str, None] = None,\n    ) -&gt; Union[PersistedData, None]:\n\n        if store_id is None:\n            store_id = self.default_data_store\n\n        _value = self.get_value(value)\n\n        store: DataStore = self.get_archive(archive_id=store_id)  # type: ignore\n        if not isinstance(store, DataStore):\n            raise Exception(f\"Can't store value into store '{store_id}': not writable.\")\n\n        # make sure all property values are available\n        if _value.pedigree != ORPHAN:\n            for value_id in _value.pedigree.inputs.values():\n                self.store_value(value=value_id, store_id=store_id)\n\n        if not store.has_value(_value.value_id):\n            event = ValuePreStoreEvent.construct(kiara_id=self._kiara.id, value=_value)\n            self._event_callback(event)\n            persisted_value = store.store_value(_value)\n            _value._is_stored = True\n            self._value_archive_lookup_map[_value.value_id] = store_id\n            self._persisted_value_descs[_value.value_id] = persisted_value\n            property_values = _value.property_values\n\n            for property, property_value in property_values.items():\n                self.store_value(value=property_value, store_id=store_id)\n        else:\n            persisted_value = None\n\n        store_event = ValueStoredEvent.construct(kiara_id=self._kiara.id, value=_value)\n        self._event_callback(store_event)\n\n        return persisted_value\n\n    def lookup_aliases(self, value: Union[Value, uuid.UUID]) -&gt; Set[str]:\n\n        if isinstance(value, Value):\n            value = value.value_id\n\n        return self._kiara.alias_registry.find_aliases_for_value_id(value_id=value)\n\n    def create_value_info(self, value: Union[Value, uuid.UUID]) -&gt; ValueInfo:\n\n        if isinstance(value, uuid.UUID):\n            value = self.get_value(value=value)\n\n        value_info = ValueInfo.create_from_instance(kiara=self._kiara, instance=value)\n        return value_info\n\n    def find_values(self, matcher: ValueMatcher) -&gt; Dict[uuid.UUID, Value]:\n\n        matches: Dict[uuid.UUID, Value] = {}\n        for store_id, store in self.data_archives.items():\n            try:\n                _matches = store.find_values(matcher=matcher)\n                for value in _matches:\n                    if value.value_id in matches.keys():\n                        raise Exception(\n                            f\"Found value '{value.value_id}' multiple times, this is not supported yet.\"\n                        )\n                    self._value_archive_lookup_map[value.value_id] = store_id\n                    value._set_registry(self)\n                    value._is_stored = True\n                    self._registered_values[value.value_id] = value\n                    matches[value.value_id] = value\n                    self._values_by_hash.setdefault(value.value_hash, set()).add(\n                        value.value_id\n                    )\n            except NotImplementedError:\n                all_value_ids = store.value_ids\n                if all_value_ids is None:\n                    continue\n                for value_id in all_value_ids:\n                    value = store.retrieve_value(value_id=value_id)\n                    value._set_registry(self)\n                    value._is_stored = True\n\n                    self._registered_values[value.value_id] = value\n\n                    match = matcher.is_match(value, kiara=self._kiara)\n                    if match:\n                        if value.value_id in matches.keys():\n                            raise Exception(\n                                f\"Found value '{value.value_id}' multiple times, this is not supported yet.\"\n                            )\n                        matches[value.value_id] = value\n\n        return matches\n\n    def find_values_with_aliases(self, matcher: ValueMatcher) -&gt; Dict[str, Value]:\n\n        matcher = matcher.copy(update={\"has_aliases\": True})\n        all_values = self.find_values(matcher)\n        result = {}\n        for value in all_values.values():\n            aliases = self._kiara.alias_registry.find_aliases_for_value_id(\n                value_id=value.value_id\n            )\n            for a in aliases:\n                assert a not in result  # this is a bug\n                result[a] = value\n\n        return result\n\n    def find_values_for_hash(\n        self, value_hash: str, data_type_name: Union[str, None] = None\n    ) -&gt; Set[Value]:\n\n        if data_type_name:\n            raise NotImplementedError()\n\n        stored = self._values_by_hash.get(value_hash, None)\n        if stored is None:\n            matches: Dict[uuid.UUID, List[str]] = {}\n            for store_id, store in self.data_archives.items():\n                value_ids = store.find_values_with_hash(\n                    value_hash=value_hash, data_type_name=data_type_name\n                )\n                for v_id in value_ids:\n                    matches.setdefault(v_id, []).append(store_id)\n\n            stored = set()\n            for v_id, store_ids in matches.items():\n                if len(store_ids) &gt; 1:\n                    raise Exception(\n                        f\"Found multiple stores for value id '{v_id}', this is not supported (yet).\"\n                    )\n                self._value_archive_lookup_map[v_id] = store_ids[0]\n                stored.add(v_id)\n\n            if stored:\n                self._values_by_hash[value_hash] = stored\n\n        return {self.get_value(value=v_id) for v_id in stored}\n\n    def find_destinies_for_value(\n        self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n    ) -&gt; Mapping[str, uuid.UUID]:\n\n        if alias_filter:\n            raise NotImplementedError()\n\n        all_destinies: Dict[str, uuid.UUID] = {}\n        for archive_id, archive in self._data_archives.items():\n            destinies: Union[\n                Mapping[str, uuid.UUID], None\n            ] = archive.find_destinies_for_value(\n                value_id=value_id, alias_filter=alias_filter\n            )\n            if not destinies:\n                continue\n            for k, v in destinies.items():\n                if k in all_destinies.keys():\n                    raise Exception(f\"Duplicate destiny '{k}' for value '{value_id}'.\")\n                all_destinies[k] = v\n\n        return all_destinies\n\n    def register_data(\n        self,\n        data: Any,\n        schema: Union[ValueSchema, str, None] = None,\n        pedigree: Union[ValuePedigree, None] = None,\n        pedigree_output_name: Union[str, None] = None,\n        reuse_existing: bool = True,\n    ) -&gt; Value:\n\n        value, newly_created = self._create_value(\n            data=data,\n            schema=schema,\n            pedigree=pedigree,\n            pedigree_output_name=pedigree_output_name,\n            reuse_existing=reuse_existing,\n        )\n\n        if newly_created:\n            self._values_by_hash.setdefault(value.value_hash, set()).add(value.value_id)\n            self._registered_values[value.value_id] = value\n            self._cached_data[value.value_id] = data\n\n            event = ValueRegisteredEvent(kiara_id=self._kiara.id, value=value)\n            self._event_callback(event)\n\n        return value\n\n    def _find_existing_value(\n        self, data: Any, schema: Union[ValueSchema, None]\n    ) -&gt; Tuple[\n        Union[Value, None],\n        DataType,\n        Union[Any, None],\n        Union[str, SerializedData],\n        ValueStatus,\n        str,\n        int,\n    ]:\n\n        if schema is None:\n            raise NotImplementedError()\n\n        if isinstance(data, Value):\n\n            if data.value_id in self._registered_values.keys():\n\n                if data.is_set and data.is_serializable:\n                    serialized: Union[str, SerializedData] = data.serialized_data\n                else:\n                    serialized = NO_SERIALIZATION_MARKER\n                return (\n                    data,\n                    data.data_type,\n                    None,\n                    serialized,\n                    data.value_status,\n                    data.value_hash,\n                    data.value_size,\n                )\n\n            raise NotImplementedError(\"Importing values not supported (yet).\")\n            # self._registered_values[data.value_id] = data\n            # return data\n\n        try:\n            value = self.get_value(value=data)\n            if value.is_serializable:\n                serialized = value.serialized_data\n            else:\n                serialized = NO_SERIALIZATION_MARKER\n\n            return (\n                value,\n                value.data_type,\n                None,\n                serialized,\n                value.value_status,\n                value.value_hash,\n                value.value_size,\n            )\n        except NoSuchValueException as nsve:\n            raise nsve\n        except Exception:\n            # TODO: differentiate between 'value not found' and other type of errors\n            pass\n\n        # no obvious matches, so we try to find data that has the same hash\n        data_type = self._kiara.type_registry.retrieve_data_type(\n            data_type_name=schema.type, data_type_config=schema.type_config\n        )\n\n        data, serialized, status, value_hash, value_size = data_type._pre_examine_data(\n            data=data, schema=schema\n        )\n\n        existing_value: Union[Value, None] = None\n        if value_hash != INVALID_HASH_MARKER:\n            existing = self.find_values_for_hash(value_hash=value_hash)\n            if existing:\n                if len(existing) == 1:\n                    existing_value = next(iter(existing))\n                else:\n                    skalars = []\n                    for v in existing:\n                        if v.data_type.characteristics.is_scalar:\n                            skalars.append(v)\n\n                    if len(skalars) == 1:\n                        existing_value = skalars[0]\n                    elif skalars:\n                        orphans = []\n                        for v in skalars:\n                            if v.pedigree == ORPHAN:\n                                orphans.append(v)\n\n                        if len(orphans) == 1:\n                            existing_value = orphans[0]\n\n        if existing_value is not None:\n            self._persisted_value_descs[existing_value.value_id] = None\n            return (\n                existing_value,\n                data_type,\n                data,\n                serialized,\n                status,\n                value_hash,\n                value_size,\n            )\n\n        return (None, data_type, data, serialized, status, value_hash, value_size)\n\n    def _create_value(\n        self,\n        data: Any,\n        schema: Union[None, str, ValueSchema] = None,\n        pedigree: Union[ValuePedigree, None] = None,\n        pedigree_output_name: Union[str, None] = None,\n        reuse_existing: bool = True,\n    ) -&gt; Tuple[Value, bool]:\n\"\"\"Create a new value, or return an existing one that matches the incoming data or reference.\n\n        Arguments:\n            data: the (raw) data, or a reference to an existing value\n\n\n        Returns:\n            a tuple containing of the value object, and a boolean indicating whether the value was newly created (True), or already existing (False)\n        \"\"\"\n\n        if schema is None:\n            raise NotImplementedError()\n        elif isinstance(schema, str):\n            schema = ValueSchema(type=schema)\n\n        if schema.type not in self._kiara.data_type_names:\n            raise Exception(\n                f\"Can't register data of type '{schema.type}': type not registered. Available types: {', '.join(self._kiara.data_type_names)}\"\n            )\n\n        if data is SpecialValue.NOT_SET and schema.default is not SpecialValue.NOT_SET:\n            if callable(schema.default):\n                raise NotImplementedError()\n                data = schema.default()\n            else:\n                data = copy.deepcopy(schema.default)\n\n        if data is None:\n            data = SpecialValue.NO_VALUE\n\n        if reuse_existing and data not in [\n            SpecialValue.NO_VALUE,\n            SpecialValue.NOT_SET,\n        ]:\n            (\n                _existing,\n                data_type,\n                data,\n                serialized,\n                status,\n                value_hash,\n                value_size,\n            ) = self._find_existing_value(data=data, schema=schema)\n\n            if _existing is not None:\n                # TODO: check pedigree\n                return (_existing, False)\n        else:\n            data_type = self._kiara.type_registry.retrieve_data_type(\n                data_type_name=schema.type, data_type_config=schema.type_config\n            )\n\n            (\n                data,\n                serialized,\n                status,\n                value_hash,\n                value_size,\n            ) = data_type._pre_examine_data(data=data, schema=schema)\n\n        if pedigree is None:\n            pedigree = ORPHAN\n\n        if pedigree_output_name is None:\n            if pedigree == ORPHAN:\n                pedigree_output_name = ORPHAN_PEDIGREE_OUTPUT_NAME\n            else:\n                raise NotImplementedError()\n\n        v_id = ID_REGISTRY.generate(\n            type=\"value\", kiara_id=self._kiara.id, pre_registered=False\n        )\n\n        value, data = data_type.assemble_value(\n            value_id=v_id,\n            data=data,\n            schema=schema,\n            environment_hashes=self._kiara.environment_registry.environment_hashes,\n            serialized=serialized,\n            status=status,\n            value_hash=value_hash,\n            value_size=value_size,\n            pedigree=pedigree,\n            kiara_id=self._kiara.id,\n            pedigree_output_name=pedigree_output_name,\n        )\n\n        ID_REGISTRY.update_metadata(v_id, obj=value)\n        value._data_registry = self\n\n        event = ValueCreatedEvent(kiara_id=self._kiara.id, value=value)\n        self._event_callback(event)\n\n        return (value, True)\n\n    def retrieve_persisted_value_details(self, value_id: uuid.UUID) -&gt; PersistedData:\n\n        if (\n            value_id in self._persisted_value_descs.keys()\n            and self._persisted_value_descs[value_id] is not None\n        ):\n            persisted_details = self._persisted_value_descs[value_id]\n            assert persisted_details is not None\n        else:\n            # now, the value_store map should contain this value_id\n            store_id = self.find_store_id_for_value(value_id=value_id)\n            if store_id is None:\n                raise Exception(\n                    f\"Can't find store for persisted data of value: {value_id}\"\n                )\n\n            store = self.get_archive(store_id)\n            assert value_id in self._registered_values.keys()\n            # self.get_value(value_id=value_id)\n            persisted_details = store.retrieve_serialized_value(value=value_id)\n            for c in persisted_details.chunk_id_map.values():\n                c._data_registry = self._kiara.data_registry\n            self._persisted_value_descs[value_id] = persisted_details\n\n        return persisted_details\n\n    # def _retrieve_bytes(\n    #     self, chunk_id: str, as_link: bool = True\n    # ) -&gt; Union[str, bytes]:\n    #\n    #     # TODO: support multiple stores\n    #     return self.get_archive().retrieve_chunk(chunk_id=chunk_id, as_link=as_link)\n\n    def retrieve_serialized_value(\n        self, value_id: uuid.UUID\n    ) -&gt; Union[SerializedData, None]:\n\"\"\"Create a LoadConfig object from the details of the persisted version of this value.\"\"\"\n\n        pv = self.retrieve_persisted_value_details(value_id=value_id)\n        if pv is None:\n            return None\n\n        return pv\n\n    def retrieve_chunk(\n        self,\n        chunk_id: str,\n        archive_id: Union[uuid.UUID, None] = None,\n        as_file: Union[None, bool, str] = None,\n        symlink_ok: bool = True,\n    ) -&gt; Union[str, bytes]:\n\n        if archive_id is None:\n            raise NotImplementedError()\n\n        archive = self.get_archive(archive_id)\n        chunk = archive.retrieve_chunk(chunk_id, as_file=as_file, symlink_ok=symlink_ok)\n\n        return chunk\n\n    def retrieve_value_data(\n        self, value: Union[uuid.UUID, Value], target_profile: Union[str, None] = None\n    ) -&gt; Any:\n\n        if isinstance(value, uuid.UUID):\n            value = self.get_value(value=value)\n\n        if value.value_id in self._cached_data.keys():\n            return self._cached_data[value.value_id]\n\n        if value._serialized_data is None:\n            serialized_data: Union[\n                str, SerializedData\n            ] = self.retrieve_persisted_value_details(value_id=value.value_id)\n            value._serialized_data = serialized_data\n        else:\n            serialized_data = value._serialized_data\n\n        if isinstance(serialized_data, str):\n            raise Exception(\n                f\"Can't retrieve serialized version of value '{value.value_id}', this is most likely a bug.\"\n            )\n\n        manifest = serialized_data.metadata.deserialize.get(\"python_object\", None)\n        if manifest is None:\n            raise Exception(\n                f\"No deserialize operation found for data type: {value.data_type_name}\"\n            )\n\n        module = self._kiara.module_registry.create_module(manifest=manifest)\n        op = Operation.create_from_module(module=module)\n\n        input_field_match: Union[str, None] = None\n\n        if len(op.inputs_schema) == 1:\n            input_field_match = next(iter(op.inputs_schema.keys()))\n        else:\n            for input_field, schema in op.inputs_schema.items():\n                for dt in self._kiara.type_registry.get_type_lineage(\n                    value.data_type_name\n                ):\n                    if schema.type == dt:\n                        if input_field_match is not None:\n                            raise Exception(\n                                f\"Can't determine input field for deserialization operation '{module.module_type_name}': multiple input fields with type '{input_field_match}'.\"\n                            )\n                        else:\n                            input_field_match = input_field\n                            break\n                if input_field_match:\n                    break\n\n        if input_field_match is None:\n            raise Exception(\n                f\"Can't determine input field for deserialization operation '{module.module_type_name}'.\"\n            )\n\n        result_field_match: Union[str, None] = None\n        for result_field, schema in op.outputs_schema.items():\n            if schema.type == \"python_object\":\n                if result_field_match is not None:\n                    raise Exception(\n                        f\"Can't determine result field for deserialization operation '{module.module_type_name}': multiple result fields with type 'python_object'.\"\n                    )\n                else:\n                    result_field_match = result_field\n        if result_field_match is None:\n            raise Exception(\n                f\"Can't determine result field for deserialization operation '{module.module_type_name}'.\"\n            )\n\n        inputs = {input_field_match: value}\n\n        result = op.run(kiara=self._kiara, inputs=inputs)\n        python_object = result.get_value_data(result_field_match)\n\n        # TODO: can we do without this?\n        parsed = value.data_type.parse_python_obj(python_object)\n        value.data_type._validate(parsed)\n\n        self._cached_data[value.value_id] = parsed\n\n        return parsed\n\n    def load_values(\n        self,\n        values: Mapping[str, Union[uuid.UUID, None, str, ValueLink]],\n        values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n    ) -&gt; ValueMap:\n\n        value_items = {}\n        if values_schema:\n\n            schemas = values_schema\n            for k in schemas.keys():\n                if k not in values.keys():\n                    value_items[k] = self.get_value(NOT_SET_VALUE_ID)\n                else:\n                    value_id = values[k]\n                    if value_id is None:\n                        value_id = NONE_VALUE_ID\n\n                    value_items[k] = self.get_value(value_id)\n        else:\n            schemas = {}\n            for field_name, value_id in values.items():\n                if value_id is None:\n                    value_id = NONE_VALUE_ID\n\n                value = self.get_value(value=value_id)\n                value_items[field_name] = value\n                schemas[field_name] = value.value_schema\n\n        return ValueMapReadOnly(value_items=value_items, values_schema=schemas)\n\n    def load_data(\n        self, values: Mapping[str, Union[uuid.UUID, None]]\n    ) -&gt; Mapping[str, Any]:\n\n        result_values = self.load_values(values=values)\n        return {k: v.data for k, v in result_values.items()}\n\n    def create_valuemap(\n        self, data: Mapping[str, Any], schema: Mapping[str, ValueSchema]\n    ) -&gt; ValueMap:\n\"\"\"Extract a set of [Value][kiara.data.values.Value] from Python data and ValueSchemas.\"\"\"\n\n        input_details = {}\n        for input_name, value_schema in schema.items():\n            input_details[input_name] = {\"schema\": value_schema}\n\n        leftover = set(data.keys())\n        leftover.difference_update(input_details.keys())\n        if leftover:\n            if not STRICT_CHECKS:\n                log_message(\"unused.inputs\", input_names=leftover)\n            else:\n                raise Exception(\n                    f\"Can't create values instance, inputs contain unused/invalid fields: {', '.join(leftover)}\"\n                )\n\n        values = {}\n        failed = {}\n\n        _resolved: Dict[str, Value] = {}\n        _unresolved = {}\n        for input_name, details in input_details.items():\n            _d = data.get(input_name, SpecialValue.NOT_SET)\n            if isinstance(_d, str):\n                try:\n                    _d = uuid.UUID(_d)\n                except Exception:\n                    pass\n\n            if isinstance(_d, Value):\n                _resolved[input_name] = _d\n            elif isinstance(_d, uuid.UUID):\n                _resolved[input_name] = self.get_value(_d)\n            else:\n                _unresolved[input_name] = _d\n\n        for input_name, _value in _resolved.items():\n            # TODO: validate values against schema\n            values[input_name] = _value\n\n        for input_name, _data in _unresolved.items():\n\n            value_schema = input_details[input_name][\"schema\"]\n\n            if input_name not in data.keys():\n                value_data = SpecialValue.NOT_SET\n            elif data[input_name] in [\n                None,\n                SpecialValue.NO_VALUE,\n                SpecialValue.NOT_SET,\n            ]:\n                value_data = SpecialValue.NO_VALUE\n            else:\n                value_data = data[input_name]\n\n            try:\n                value = self.register_data(\n                    data=value_data, schema=value_schema, reuse_existing=True\n                )\n                values[input_name] = value\n\n            except Exception as e:\n\n                log_exception(e)\n\n                msg: Any = str(e)\n                if not msg:\n                    msg = e\n\n                log_message(\"invalid.valueset\", error_reason=msg, input_name=input_name)\n                failed[input_name] = e\n\n        if failed:\n            msg = []\n            for k, v in failed.items():\n                _v = str(v)\n                if not str(v):\n                    _v = type(v).__name__\n                msg.append(f\"{k}: {_v}\")\n            raise InvalidValuesException(\n                msg=f\"Can't create values instance: {', '.join(msg)}\",\n                invalid_values={k: str(v) for k, v in failed.items()},\n            )\n        return ValueMapReadOnly(value_items=values, values_schema=schema)  # type: ignore\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n        from kiara.utils.output import create_renderable_from_values\n\n        all_values = {str(i): v for i, v in self._registered_values.items()}\n\n        table = create_renderable_from_values(values=all_values, config=config)\n        return table\n\n    def pretty_print_data(\n        self,\n        value_id: uuid.UUID,\n        target_type=\"terminal_renderable\",\n        **render_config: Any,\n    ) -&gt; Any:\n\n        assert isinstance(value_id, uuid.UUID)\n\n        return pretty_print_data(\n            kiara=self._kiara,\n            value_id=value_id,\n            target_type=target_type,\n            **render_config,\n        )\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.kiara_id","title":"<code>kiara_id: uuid.UUID</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.NOT_SET_VALUE","title":"<code>NOT_SET_VALUE: Value</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.NONE_VALUE","title":"<code>NONE_VALUE: Value</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.default_data_store","title":"<code>default_data_store: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.data_archives","title":"<code>data_archives: Mapping[str, DataArchive]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.retrieve_all_available_value_ids","title":"<code>retrieve_all_available_value_ids() -&gt; Set[uuid.UUID]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def retrieve_all_available_value_ids(self) -&gt; Set[uuid.UUID]:\n\n    result: Set[uuid.UUID] = set()\n    for store in self._data_archives.values():\n        ids = store.value_ids\n        if ids:\n            result.update(ids)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.register_data_archive","title":"<code>register_data_archive(archive: DataArchive, alias: Union[str, None] = None, set_as_default_store: Union[bool, None] = None)</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def register_data_archive(\n    self,\n    archive: DataArchive,\n    alias: Union[str, None] = None,\n    set_as_default_store: Union[bool, None] = None,\n):\n\n    data_store_id = archive.archive_id\n    archive.register_archive(kiara=self._kiara)\n    if alias is None:\n        alias = str(data_store_id)\n\n    if alias in self._data_archives.keys():\n        raise Exception(\n            f\"Can't add data archive, alias '{alias}' already registered.\"\n        )\n    self._data_archives[alias] = archive\n    is_store = False\n    is_default_store = False\n    if isinstance(archive, DataStore):\n        is_store = True\n\n        if set_as_default_store and self._default_data_store is not None:\n            raise Exception(\n                f\"Can't set data store '{alias}' as default store: default store already set.\"\n            )\n\n        if self._default_data_store is None or set_as_default_store:\n            is_default_store = True\n            self._default_data_store = alias\n\n    event = DataArchiveAddedEvent.construct(\n        kiara_id=self._kiara.id,\n        data_archive_id=archive.archive_id,\n        data_archive_alias=alias,\n        is_store=is_store,\n        is_default_store=is_default_store,\n    )\n    self._event_callback(event)\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.get_archive","title":"<code>get_archive(archive_id: Union[None, uuid.UUID, str] = None) -&gt; DataArchive</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def get_archive(\n    self, archive_id: Union[None, uuid.UUID, str] = None\n) -&gt; DataArchive:\n\n    if archive_id is None:\n        archive_id = self.default_data_store\n        if archive_id is None:\n            raise Exception(\"Can't retrieve default data archive, none set (yet).\")\n\n    if isinstance(archive_id, uuid.UUID):\n        for archive in self._data_archives.values():\n            if archive.archive_id == archive_id:\n                return archive\n\n        raise Exception(\n            f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n        )\n\n    if archive_id in self._data_archives.keys():\n        return self._data_archives[archive_id]\n    else:\n        try:\n            _archive_id = uuid.UUID(archive_id)\n            for archive in self._data_archives.values():\n                if archive.archive_id == _archive_id:\n                    return archive\n                raise Exception(\n                    f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n                )\n        except Exception:\n            pass\n\n    raise Exception(\n        f\"Can't retrieve archive with id '{archive_id}': no archive with that id registered.\"\n    )\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.find_store_id_for_value","title":"<code>find_store_id_for_value(value_id: uuid.UUID) -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def find_store_id_for_value(self, value_id: uuid.UUID) -&gt; Union[str, None]:\n\n    if value_id in self._value_archive_lookup_map.keys():\n        return self._value_archive_lookup_map[value_id]\n\n    matches = []\n    for store_id, store in self.data_archives.items():\n        match = store.has_value(value_id=value_id)\n        if match:\n            matches.append(store_id)\n\n    if len(matches) == 0:\n        return None\n    elif len(matches) &gt; 1:\n        raise Exception(\n            f\"Found value with id '{value_id}' in multiple archives, this is not supported (yet): {matches}\"\n        )\n\n    self._value_archive_lookup_map[value_id] = matches[0]\n    return matches[0]\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.get_value","title":"<code>get_value(value: Union[uuid.UUID, ValueLink, str]) -&gt; Value</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def get_value(self, value: Union[uuid.UUID, ValueLink, str]) -&gt; Value:\n    _value_id = None\n\n    if not isinstance(value, uuid.UUID):\n        # fallbacks for common mistakes, this should error out if not a Value or string.\n        if hasattr(value, \"value_id\"):\n            _value_id: Union[uuid.UUID, str, None] = value.value_id  # type: ignore\n            if isinstance(_value_id, str):\n                _value_id = uuid.UUID(_value_id)\n        else:\n\n            try:\n                _value_id = uuid.UUID(\n                    value  # type: ignore\n                )  # this should fail if not string or wrong string format\n            except ValueError:\n                _value_id = None\n\n            if _value_id is None:\n\n                if not isinstance(value, str):\n                    raise Exception(\n                        f\"Can't retrieve value for '{value}': invalid type '{type(value)}'.\"\n                    )\n\n                _value_id = self._alias_resolver.resolve_alias(value)\n    else:\n        _value_id = value\n\n    assert _value_id is not None\n\n    if _value_id in self._registered_values.keys():\n        _value = self._registered_values[_value_id]\n        return _value\n\n    matches = []\n    for store_id, store in self.data_archives.items():\n        match = store.has_value(value_id=_value_id)\n        if match:\n            matches.append(store_id)\n\n    if len(matches) == 0:\n        raise NoSuchValueIdException(\n            value_id=_value_id, msg=f\"No value registered with id: {value}\"\n        )\n    elif len(matches) &gt; 1:\n        raise NoSuchValueIdException(\n            value_id=_value_id,\n            msg=f\"Found value with id '{value}' in multiple archives, this is not supported (yet): {matches}\",\n        )\n\n    self._value_archive_lookup_map[_value_id] = matches[0]\n    stored_value = self.get_archive(matches[0]).retrieve_value(value_id=_value_id)\n    stored_value._set_registry(self)\n    stored_value._is_stored = True\n\n    self._registered_values[_value_id] = stored_value\n    return self._registered_values[_value_id]\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.store_value","title":"<code>store_value(value: Union[ValueLink, uuid.UUID, str], store_id: Union[str, None] = None) -&gt; Union[PersistedData, None]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def store_value(\n    self,\n    value: Union[ValueLink, uuid.UUID, str],\n    store_id: Union[str, None] = None,\n) -&gt; Union[PersistedData, None]:\n\n    if store_id is None:\n        store_id = self.default_data_store\n\n    _value = self.get_value(value)\n\n    store: DataStore = self.get_archive(archive_id=store_id)  # type: ignore\n    if not isinstance(store, DataStore):\n        raise Exception(f\"Can't store value into store '{store_id}': not writable.\")\n\n    # make sure all property values are available\n    if _value.pedigree != ORPHAN:\n        for value_id in _value.pedigree.inputs.values():\n            self.store_value(value=value_id, store_id=store_id)\n\n    if not store.has_value(_value.value_id):\n        event = ValuePreStoreEvent.construct(kiara_id=self._kiara.id, value=_value)\n        self._event_callback(event)\n        persisted_value = store.store_value(_value)\n        _value._is_stored = True\n        self._value_archive_lookup_map[_value.value_id] = store_id\n        self._persisted_value_descs[_value.value_id] = persisted_value\n        property_values = _value.property_values\n\n        for property, property_value in property_values.items():\n            self.store_value(value=property_value, store_id=store_id)\n    else:\n        persisted_value = None\n\n    store_event = ValueStoredEvent.construct(kiara_id=self._kiara.id, value=_value)\n    self._event_callback(store_event)\n\n    return persisted_value\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.lookup_aliases","title":"<code>lookup_aliases(value: Union[Value, uuid.UUID]) -&gt; Set[str]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def lookup_aliases(self, value: Union[Value, uuid.UUID]) -&gt; Set[str]:\n\n    if isinstance(value, Value):\n        value = value.value_id\n\n    return self._kiara.alias_registry.find_aliases_for_value_id(value_id=value)\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.create_value_info","title":"<code>create_value_info(value: Union[Value, uuid.UUID]) -&gt; ValueInfo</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def create_value_info(self, value: Union[Value, uuid.UUID]) -&gt; ValueInfo:\n\n    if isinstance(value, uuid.UUID):\n        value = self.get_value(value=value)\n\n    value_info = ValueInfo.create_from_instance(kiara=self._kiara, instance=value)\n    return value_info\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.find_values","title":"<code>find_values(matcher: ValueMatcher) -&gt; Dict[uuid.UUID, Value]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def find_values(self, matcher: ValueMatcher) -&gt; Dict[uuid.UUID, Value]:\n\n    matches: Dict[uuid.UUID, Value] = {}\n    for store_id, store in self.data_archives.items():\n        try:\n            _matches = store.find_values(matcher=matcher)\n            for value in _matches:\n                if value.value_id in matches.keys():\n                    raise Exception(\n                        f\"Found value '{value.value_id}' multiple times, this is not supported yet.\"\n                    )\n                self._value_archive_lookup_map[value.value_id] = store_id\n                value._set_registry(self)\n                value._is_stored = True\n                self._registered_values[value.value_id] = value\n                matches[value.value_id] = value\n                self._values_by_hash.setdefault(value.value_hash, set()).add(\n                    value.value_id\n                )\n        except NotImplementedError:\n            all_value_ids = store.value_ids\n            if all_value_ids is None:\n                continue\n            for value_id in all_value_ids:\n                value = store.retrieve_value(value_id=value_id)\n                value._set_registry(self)\n                value._is_stored = True\n\n                self._registered_values[value.value_id] = value\n\n                match = matcher.is_match(value, kiara=self._kiara)\n                if match:\n                    if value.value_id in matches.keys():\n                        raise Exception(\n                            f\"Found value '{value.value_id}' multiple times, this is not supported yet.\"\n                        )\n                    matches[value.value_id] = value\n\n    return matches\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.find_values_with_aliases","title":"<code>find_values_with_aliases(matcher: ValueMatcher) -&gt; Dict[str, Value]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def find_values_with_aliases(self, matcher: ValueMatcher) -&gt; Dict[str, Value]:\n\n    matcher = matcher.copy(update={\"has_aliases\": True})\n    all_values = self.find_values(matcher)\n    result = {}\n    for value in all_values.values():\n        aliases = self._kiara.alias_registry.find_aliases_for_value_id(\n            value_id=value.value_id\n        )\n        for a in aliases:\n            assert a not in result  # this is a bug\n            result[a] = value\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.find_values_for_hash","title":"<code>find_values_for_hash(value_hash: str, data_type_name: Union[str, None] = None) -&gt; Set[Value]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def find_values_for_hash(\n    self, value_hash: str, data_type_name: Union[str, None] = None\n) -&gt; Set[Value]:\n\n    if data_type_name:\n        raise NotImplementedError()\n\n    stored = self._values_by_hash.get(value_hash, None)\n    if stored is None:\n        matches: Dict[uuid.UUID, List[str]] = {}\n        for store_id, store in self.data_archives.items():\n            value_ids = store.find_values_with_hash(\n                value_hash=value_hash, data_type_name=data_type_name\n            )\n            for v_id in value_ids:\n                matches.setdefault(v_id, []).append(store_id)\n\n        stored = set()\n        for v_id, store_ids in matches.items():\n            if len(store_ids) &gt; 1:\n                raise Exception(\n                    f\"Found multiple stores for value id '{v_id}', this is not supported (yet).\"\n                )\n            self._value_archive_lookup_map[v_id] = store_ids[0]\n            stored.add(v_id)\n\n        if stored:\n            self._values_by_hash[value_hash] = stored\n\n    return {self.get_value(value=v_id) for v_id in stored}\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.find_destinies_for_value","title":"<code>find_destinies_for_value(value_id: uuid.UUID, alias_filter: Union[str, None] = None) -&gt; Mapping[str, uuid.UUID]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def find_destinies_for_value(\n    self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n) -&gt; Mapping[str, uuid.UUID]:\n\n    if alias_filter:\n        raise NotImplementedError()\n\n    all_destinies: Dict[str, uuid.UUID] = {}\n    for archive_id, archive in self._data_archives.items():\n        destinies: Union[\n            Mapping[str, uuid.UUID], None\n        ] = archive.find_destinies_for_value(\n            value_id=value_id, alias_filter=alias_filter\n        )\n        if not destinies:\n            continue\n        for k, v in destinies.items():\n            if k in all_destinies.keys():\n                raise Exception(f\"Duplicate destiny '{k}' for value '{value_id}'.\")\n            all_destinies[k] = v\n\n    return all_destinies\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.register_data","title":"<code>register_data(data: Any, schema: Union[ValueSchema, str, None] = None, pedigree: Union[ValuePedigree, None] = None, pedigree_output_name: Union[str, None] = None, reuse_existing: bool = True) -&gt; Value</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def register_data(\n    self,\n    data: Any,\n    schema: Union[ValueSchema, str, None] = None,\n    pedigree: Union[ValuePedigree, None] = None,\n    pedigree_output_name: Union[str, None] = None,\n    reuse_existing: bool = True,\n) -&gt; Value:\n\n    value, newly_created = self._create_value(\n        data=data,\n        schema=schema,\n        pedigree=pedigree,\n        pedigree_output_name=pedigree_output_name,\n        reuse_existing=reuse_existing,\n    )\n\n    if newly_created:\n        self._values_by_hash.setdefault(value.value_hash, set()).add(value.value_id)\n        self._registered_values[value.value_id] = value\n        self._cached_data[value.value_id] = data\n\n        event = ValueRegisteredEvent(kiara_id=self._kiara.id, value=value)\n        self._event_callback(event)\n\n    return value\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.retrieve_persisted_value_details","title":"<code>retrieve_persisted_value_details(value_id: uuid.UUID) -&gt; PersistedData</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def retrieve_persisted_value_details(self, value_id: uuid.UUID) -&gt; PersistedData:\n\n    if (\n        value_id in self._persisted_value_descs.keys()\n        and self._persisted_value_descs[value_id] is not None\n    ):\n        persisted_details = self._persisted_value_descs[value_id]\n        assert persisted_details is not None\n    else:\n        # now, the value_store map should contain this value_id\n        store_id = self.find_store_id_for_value(value_id=value_id)\n        if store_id is None:\n            raise Exception(\n                f\"Can't find store for persisted data of value: {value_id}\"\n            )\n\n        store = self.get_archive(store_id)\n        assert value_id in self._registered_values.keys()\n        # self.get_value(value_id=value_id)\n        persisted_details = store.retrieve_serialized_value(value=value_id)\n        for c in persisted_details.chunk_id_map.values():\n            c._data_registry = self._kiara.data_registry\n        self._persisted_value_descs[value_id] = persisted_details\n\n    return persisted_details\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.retrieve_serialized_value","title":"<code>retrieve_serialized_value(value_id: uuid.UUID) -&gt; Union[SerializedData, None]</code>","text":"<p>Create a LoadConfig object from the details of the persisted version of this value.</p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def retrieve_serialized_value(\n    self, value_id: uuid.UUID\n) -&gt; Union[SerializedData, None]:\n\"\"\"Create a LoadConfig object from the details of the persisted version of this value.\"\"\"\n\n    pv = self.retrieve_persisted_value_details(value_id=value_id)\n    if pv is None:\n        return None\n\n    return pv\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.retrieve_chunk","title":"<code>retrieve_chunk(chunk_id: str, archive_id: Union[uuid.UUID, None] = None, as_file: Union[None, bool, str] = None, symlink_ok: bool = True) -&gt; Union[str, bytes]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def retrieve_chunk(\n    self,\n    chunk_id: str,\n    archive_id: Union[uuid.UUID, None] = None,\n    as_file: Union[None, bool, str] = None,\n    symlink_ok: bool = True,\n) -&gt; Union[str, bytes]:\n\n    if archive_id is None:\n        raise NotImplementedError()\n\n    archive = self.get_archive(archive_id)\n    chunk = archive.retrieve_chunk(chunk_id, as_file=as_file, symlink_ok=symlink_ok)\n\n    return chunk\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.retrieve_value_data","title":"<code>retrieve_value_data(value: Union[uuid.UUID, Value], target_profile: Union[str, None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def retrieve_value_data(\n    self, value: Union[uuid.UUID, Value], target_profile: Union[str, None] = None\n) -&gt; Any:\n\n    if isinstance(value, uuid.UUID):\n        value = self.get_value(value=value)\n\n    if value.value_id in self._cached_data.keys():\n        return self._cached_data[value.value_id]\n\n    if value._serialized_data is None:\n        serialized_data: Union[\n            str, SerializedData\n        ] = self.retrieve_persisted_value_details(value_id=value.value_id)\n        value._serialized_data = serialized_data\n    else:\n        serialized_data = value._serialized_data\n\n    if isinstance(serialized_data, str):\n        raise Exception(\n            f\"Can't retrieve serialized version of value '{value.value_id}', this is most likely a bug.\"\n        )\n\n    manifest = serialized_data.metadata.deserialize.get(\"python_object\", None)\n    if manifest is None:\n        raise Exception(\n            f\"No deserialize operation found for data type: {value.data_type_name}\"\n        )\n\n    module = self._kiara.module_registry.create_module(manifest=manifest)\n    op = Operation.create_from_module(module=module)\n\n    input_field_match: Union[str, None] = None\n\n    if len(op.inputs_schema) == 1:\n        input_field_match = next(iter(op.inputs_schema.keys()))\n    else:\n        for input_field, schema in op.inputs_schema.items():\n            for dt in self._kiara.type_registry.get_type_lineage(\n                value.data_type_name\n            ):\n                if schema.type == dt:\n                    if input_field_match is not None:\n                        raise Exception(\n                            f\"Can't determine input field for deserialization operation '{module.module_type_name}': multiple input fields with type '{input_field_match}'.\"\n                        )\n                    else:\n                        input_field_match = input_field\n                        break\n            if input_field_match:\n                break\n\n    if input_field_match is None:\n        raise Exception(\n            f\"Can't determine input field for deserialization operation '{module.module_type_name}'.\"\n        )\n\n    result_field_match: Union[str, None] = None\n    for result_field, schema in op.outputs_schema.items():\n        if schema.type == \"python_object\":\n            if result_field_match is not None:\n                raise Exception(\n                    f\"Can't determine result field for deserialization operation '{module.module_type_name}': multiple result fields with type 'python_object'.\"\n                )\n            else:\n                result_field_match = result_field\n    if result_field_match is None:\n        raise Exception(\n            f\"Can't determine result field for deserialization operation '{module.module_type_name}'.\"\n        )\n\n    inputs = {input_field_match: value}\n\n    result = op.run(kiara=self._kiara, inputs=inputs)\n    python_object = result.get_value_data(result_field_match)\n\n    # TODO: can we do without this?\n    parsed = value.data_type.parse_python_obj(python_object)\n    value.data_type._validate(parsed)\n\n    self._cached_data[value.value_id] = parsed\n\n    return parsed\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.load_values","title":"<code>load_values(values: Mapping[str, Union[uuid.UUID, None, str, ValueLink]], values_schema: Union[None, Mapping[str, ValueSchema]] = None) -&gt; ValueMap</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def load_values(\n    self,\n    values: Mapping[str, Union[uuid.UUID, None, str, ValueLink]],\n    values_schema: Union[None, Mapping[str, ValueSchema]] = None,\n) -&gt; ValueMap:\n\n    value_items = {}\n    if values_schema:\n\n        schemas = values_schema\n        for k in schemas.keys():\n            if k not in values.keys():\n                value_items[k] = self.get_value(NOT_SET_VALUE_ID)\n            else:\n                value_id = values[k]\n                if value_id is None:\n                    value_id = NONE_VALUE_ID\n\n                value_items[k] = self.get_value(value_id)\n    else:\n        schemas = {}\n        for field_name, value_id in values.items():\n            if value_id is None:\n                value_id = NONE_VALUE_ID\n\n            value = self.get_value(value=value_id)\n            value_items[field_name] = value\n            schemas[field_name] = value.value_schema\n\n    return ValueMapReadOnly(value_items=value_items, values_schema=schemas)\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.load_data","title":"<code>load_data(values: Mapping[str, Union[uuid.UUID, None]]) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def load_data(\n    self, values: Mapping[str, Union[uuid.UUID, None]]\n) -&gt; Mapping[str, Any]:\n\n    result_values = self.load_values(values=values)\n    return {k: v.data for k, v in result_values.items()}\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.create_valuemap","title":"<code>create_valuemap(data: Mapping[str, Any], schema: Mapping[str, ValueSchema]) -&gt; ValueMap</code>","text":"<p>Extract a set of Value from Python data and ValueSchemas.</p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def create_valuemap(\n    self, data: Mapping[str, Any], schema: Mapping[str, ValueSchema]\n) -&gt; ValueMap:\n\"\"\"Extract a set of [Value][kiara.data.values.Value] from Python data and ValueSchemas.\"\"\"\n\n    input_details = {}\n    for input_name, value_schema in schema.items():\n        input_details[input_name] = {\"schema\": value_schema}\n\n    leftover = set(data.keys())\n    leftover.difference_update(input_details.keys())\n    if leftover:\n        if not STRICT_CHECKS:\n            log_message(\"unused.inputs\", input_names=leftover)\n        else:\n            raise Exception(\n                f\"Can't create values instance, inputs contain unused/invalid fields: {', '.join(leftover)}\"\n            )\n\n    values = {}\n    failed = {}\n\n    _resolved: Dict[str, Value] = {}\n    _unresolved = {}\n    for input_name, details in input_details.items():\n        _d = data.get(input_name, SpecialValue.NOT_SET)\n        if isinstance(_d, str):\n            try:\n                _d = uuid.UUID(_d)\n            except Exception:\n                pass\n\n        if isinstance(_d, Value):\n            _resolved[input_name] = _d\n        elif isinstance(_d, uuid.UUID):\n            _resolved[input_name] = self.get_value(_d)\n        else:\n            _unresolved[input_name] = _d\n\n    for input_name, _value in _resolved.items():\n        # TODO: validate values against schema\n        values[input_name] = _value\n\n    for input_name, _data in _unresolved.items():\n\n        value_schema = input_details[input_name][\"schema\"]\n\n        if input_name not in data.keys():\n            value_data = SpecialValue.NOT_SET\n        elif data[input_name] in [\n            None,\n            SpecialValue.NO_VALUE,\n            SpecialValue.NOT_SET,\n        ]:\n            value_data = SpecialValue.NO_VALUE\n        else:\n            value_data = data[input_name]\n\n        try:\n            value = self.register_data(\n                data=value_data, schema=value_schema, reuse_existing=True\n            )\n            values[input_name] = value\n\n        except Exception as e:\n\n            log_exception(e)\n\n            msg: Any = str(e)\n            if not msg:\n                msg = e\n\n            log_message(\"invalid.valueset\", error_reason=msg, input_name=input_name)\n            failed[input_name] = e\n\n    if failed:\n        msg = []\n        for k, v in failed.items():\n            _v = str(v)\n            if not str(v):\n                _v = type(v).__name__\n            msg.append(f\"{k}: {_v}\")\n        raise InvalidValuesException(\n            msg=f\"Can't create values instance: {', '.join(msg)}\",\n            invalid_values={k: str(v) for k, v in failed.items()},\n        )\n    return ValueMapReadOnly(value_items=values, values_schema=schema)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"<p>Create a renderable for this module configuration.</p> Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n    from kiara.utils.output import create_renderable_from_values\n\n    all_values = {str(i): v for i, v in self._registered_values.items()}\n\n    table = create_renderable_from_values(values=all_values, config=config)\n    return table\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data.DataRegistry.pretty_print_data","title":"<code>pretty_print_data(value_id: uuid.UUID, target_type = 'terminal_renderable', **render_config: Any) -&gt; Any</code>","text":"Source code in <code>kiara/registries/data/__init__.py</code> <pre><code>def pretty_print_data(\n    self,\n    value_id: uuid.UUID,\n    target_type=\"terminal_renderable\",\n    **render_config: Any,\n) -&gt; Any:\n\n    assert isinstance(value_id, uuid.UUID)\n\n    return pretty_print_data(\n        kiara=self._kiara,\n        value_id=value_id,\n        target_type=target_type,\n        **render_config,\n    )\n</code></pre>"},{"location":"reference/kiara/registries/data/__init__/#kiara.registries.data-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/","title":"data_store","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive","title":"<code>DataArchive</code>","text":"<p>         Bases: <code>BaseArchive</code></p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>class DataArchive(BaseArchive):\n    @classmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n\n        return [\"data\"]\n\n    def __init__(self, archive_id: uuid.UUID, config: ARCHIVE_CONFIG_CLS):\n\n        super().__init__(archive_id=archive_id, config=config)\n\n        self._env_cache: Dict[str, Dict[str, Mapping[str, Any]]] = {}\n        self._value_cache: Dict[uuid.UUID, Value] = {}\n        self._persisted_value_cache: Dict[uuid.UUID, PersistedData] = {}\n        self._value_hash_index: Dict[str, Set[uuid.UUID]] = {}\n\n    def retrieve_serialized_value(\n        self, value: Union[uuid.UUID, Value]\n    ) -&gt; PersistedData:\n\n        if isinstance(value, Value):\n            value_id: uuid.UUID = value.value_id\n            _value: Union[Value, None] = value\n        else:\n            value_id = value\n            _value = None\n\n        if value_id in self._persisted_value_cache.keys():\n            return self._persisted_value_cache[value_id]\n\n        if _value is None:\n            _value = self.retrieve_value(value_id)\n\n        assert _value is not None\n\n        persisted_value = self._retrieve_serialized_value(value=_value)\n        self._persisted_value_cache[_value.value_id] = persisted_value\n        return persisted_value\n\n    @abc.abstractmethod\n    def _retrieve_serialized_value(self, value: Value) -&gt; PersistedData:\n        pass\n\n    def retrieve_value(self, value_id: uuid.UUID) -&gt; Value:\n\n        cached = self._value_cache.get(value_id, None)\n        if cached is not None:\n            return cached\n\n        value_data = self._retrieve_value_details(value_id=value_id)\n\n        value_schema = ValueSchema(**value_data[\"value_schema\"])\n        # data_type = self._kiara.get_value_type(\n        #         data_type=value_schema.type, data_type_config=value_schema.type_config\n        #     )\n\n        pedigree = ValuePedigree(**value_data[\"pedigree\"])\n        value = Value(\n            value_id=value_data[\"value_id\"],\n            kiara_id=self.kiara_context.id,\n            value_schema=value_schema,\n            value_status=value_data[\"value_status\"],\n            value_size=value_data[\"value_size\"],\n            value_hash=value_data[\"value_hash\"],\n            environment_hashes=value_data.get(\"environment_hashes\", {}),\n            pedigree=pedigree,\n            pedigree_output_name=value_data[\"pedigree_output_name\"],\n            data_type_info=value_data[\"data_type_info\"],\n            property_links=value_data[\"property_links\"],\n            destiny_backlinks=value_data[\"destiny_backlinks\"],\n        )\n\n        self._value_cache[value_id] = value\n        return self._value_cache[value_id]\n\n    @abc.abstractmethod\n    def _retrieve_value_details(self, value_id: uuid.UUID) -&gt; Mapping[str, Any]:\n        pass\n\n    @property\n    def value_ids(self) -&gt; Union[None, Iterable[uuid.UUID]]:\n        return self._retrieve_all_value_ids()\n\n    def _retrieve_all_value_ids(\n        self, data_type_name: Union[str, None] = None\n    ) -&gt; Union[None, Iterable[uuid.UUID]]:\n        pass\n\n    def has_value(self, value_id: uuid.UUID) -&gt; bool:\n\"\"\"Check whether the specific value_id is persisted in this data store.\n\n        Implementing classes are encouraged to override this method, and choose a suitable, implementation specific\n        way to quickly determine whether a value id is valid for this data store.\n\n        Arguments:\n            value_id: the id of the value to check.\n        Returns:\n            whether this data store contains the value with the specified id\n        \"\"\"\n\n        all_value_ids = self.value_ids\n        if all_value_ids is None:\n            return False\n        return value_id in all_value_ids\n\n    def retrieve_environment_details(\n        self, env_type: str, env_hash: str\n    ) -&gt; Mapping[str, Any]:\n\"\"\"Retrieve the environment details with the specified type and hash.\n\n        The environment is stored by the data store as a dictionary, including it's schema, not as the actual Python model.\n        This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.\n        \"\"\"\n\n        cached = self._env_cache.get(env_type, {}).get(env_hash, None)\n        if cached is not None:\n            return cached\n\n        env = self._retrieve_environment_details(env_type=env_type, env_hash=env_hash)\n        self._env_cache.setdefault(env_type, {})[env_hash] = env\n        return env\n\n    @abc.abstractmethod\n    def _retrieve_environment_details(\n        self, env_type: str, env_hash: str\n    ) -&gt; Mapping[str, Any]:\n        pass\n\n    def find_values(self, matcher: ValueMatcher) -&gt; Iterable[Value]:\n        raise NotImplementedError()\n\n    def find_values_with_hash(\n        self,\n        value_hash: str,\n        value_size: Union[int, None] = None,\n        data_type_name: Union[str, None] = None,\n    ) -&gt; Set[uuid.UUID]:\n\n        if data_type_name is not None:\n            raise NotImplementedError()\n\n        if value_size is not None:\n            raise NotImplementedError()\n\n        if value_hash in self._value_hash_index.keys():\n            value_ids: Union[Set[uuid.UUID], None] = self._value_hash_index[value_hash]\n        else:\n            value_ids = self._find_values_with_hash(\n                value_hash=value_hash, data_type_name=data_type_name\n            )\n            if value_ids is None:\n                value_ids = set()\n            self._value_hash_index[value_hash] = value_ids\n\n        assert value_ids is not None\n        return value_ids\n\n    @abc.abstractmethod\n    def _find_values_with_hash(\n        self,\n        value_hash: str,\n        value_size: Union[int, None] = None,\n        data_type_name: Union[str, None] = None,\n    ) -&gt; Union[Set[uuid.UUID], None]:\n        pass\n\n    def find_destinies_for_value(\n        self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n    ) -&gt; Union[Mapping[str, uuid.UUID], None]:\n\n        return self._find_destinies_for_value(\n            value_id=value_id, alias_filter=alias_filter\n        )\n\n    @abc.abstractmethod\n    def _find_destinies_for_value(\n        self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n    ) -&gt; Union[Mapping[str, uuid.UUID], None]:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_chunk(\n        self,\n        chunk_id: str,\n        as_file: Union[bool, str, None] = None,\n        symlink_ok: bool = True,\n    ) -&gt; Union[bytes, str]:\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.value_ids","title":"<code>value_ids: Union[None, Iterable[uuid.UUID]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>@classmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n\n    return [\"data\"]\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.retrieve_serialized_value","title":"<code>retrieve_serialized_value(value: Union[uuid.UUID, Value]) -&gt; PersistedData</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def retrieve_serialized_value(\n    self, value: Union[uuid.UUID, Value]\n) -&gt; PersistedData:\n\n    if isinstance(value, Value):\n        value_id: uuid.UUID = value.value_id\n        _value: Union[Value, None] = value\n    else:\n        value_id = value\n        _value = None\n\n    if value_id in self._persisted_value_cache.keys():\n        return self._persisted_value_cache[value_id]\n\n    if _value is None:\n        _value = self.retrieve_value(value_id)\n\n    assert _value is not None\n\n    persisted_value = self._retrieve_serialized_value(value=_value)\n    self._persisted_value_cache[_value.value_id] = persisted_value\n    return persisted_value\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.retrieve_value","title":"<code>retrieve_value(value_id: uuid.UUID) -&gt; Value</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def retrieve_value(self, value_id: uuid.UUID) -&gt; Value:\n\n    cached = self._value_cache.get(value_id, None)\n    if cached is not None:\n        return cached\n\n    value_data = self._retrieve_value_details(value_id=value_id)\n\n    value_schema = ValueSchema(**value_data[\"value_schema\"])\n    # data_type = self._kiara.get_value_type(\n    #         data_type=value_schema.type, data_type_config=value_schema.type_config\n    #     )\n\n    pedigree = ValuePedigree(**value_data[\"pedigree\"])\n    value = Value(\n        value_id=value_data[\"value_id\"],\n        kiara_id=self.kiara_context.id,\n        value_schema=value_schema,\n        value_status=value_data[\"value_status\"],\n        value_size=value_data[\"value_size\"],\n        value_hash=value_data[\"value_hash\"],\n        environment_hashes=value_data.get(\"environment_hashes\", {}),\n        pedigree=pedigree,\n        pedigree_output_name=value_data[\"pedigree_output_name\"],\n        data_type_info=value_data[\"data_type_info\"],\n        property_links=value_data[\"property_links\"],\n        destiny_backlinks=value_data[\"destiny_backlinks\"],\n    )\n\n    self._value_cache[value_id] = value\n    return self._value_cache[value_id]\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.has_value","title":"<code>has_value(value_id: uuid.UUID) -&gt; bool</code>","text":"<p>Check whether the specific value_id is persisted in this data store.</p> <p>Implementing classes are encouraged to override this method, and choose a suitable, implementation specific way to quickly determine whether a value id is valid for this data store.</p> <p>Parameters:</p> Name Type Description Default <code>value_id</code> <code>uuid.UUID</code> <p>the id of the value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>whether this data store contains the value with the specified id</p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def has_value(self, value_id: uuid.UUID) -&gt; bool:\n\"\"\"Check whether the specific value_id is persisted in this data store.\n\n    Implementing classes are encouraged to override this method, and choose a suitable, implementation specific\n    way to quickly determine whether a value id is valid for this data store.\n\n    Arguments:\n        value_id: the id of the value to check.\n    Returns:\n        whether this data store contains the value with the specified id\n    \"\"\"\n\n    all_value_ids = self.value_ids\n    if all_value_ids is None:\n        return False\n    return value_id in all_value_ids\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.retrieve_environment_details","title":"<code>retrieve_environment_details(env_type: str, env_hash: str) -&gt; Mapping[str, Any]</code>","text":"<p>Retrieve the environment details with the specified type and hash.</p> <p>The environment is stored by the data store as a dictionary, including it's schema, not as the actual Python model. This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.</p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def retrieve_environment_details(\n    self, env_type: str, env_hash: str\n) -&gt; Mapping[str, Any]:\n\"\"\"Retrieve the environment details with the specified type and hash.\n\n    The environment is stored by the data store as a dictionary, including it's schema, not as the actual Python model.\n    This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.\n    \"\"\"\n\n    cached = self._env_cache.get(env_type, {}).get(env_hash, None)\n    if cached is not None:\n        return cached\n\n    env = self._retrieve_environment_details(env_type=env_type, env_hash=env_hash)\n    self._env_cache.setdefault(env_type, {})[env_hash] = env\n    return env\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.find_values","title":"<code>find_values(matcher: ValueMatcher) -&gt; Iterable[Value]</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def find_values(self, matcher: ValueMatcher) -&gt; Iterable[Value]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.find_values_with_hash","title":"<code>find_values_with_hash(value_hash: str, value_size: Union[int, None] = None, data_type_name: Union[str, None] = None) -&gt; Set[uuid.UUID]</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def find_values_with_hash(\n    self,\n    value_hash: str,\n    value_size: Union[int, None] = None,\n    data_type_name: Union[str, None] = None,\n) -&gt; Set[uuid.UUID]:\n\n    if data_type_name is not None:\n        raise NotImplementedError()\n\n    if value_size is not None:\n        raise NotImplementedError()\n\n    if value_hash in self._value_hash_index.keys():\n        value_ids: Union[Set[uuid.UUID], None] = self._value_hash_index[value_hash]\n    else:\n        value_ids = self._find_values_with_hash(\n            value_hash=value_hash, data_type_name=data_type_name\n        )\n        if value_ids is None:\n            value_ids = set()\n        self._value_hash_index[value_hash] = value_ids\n\n    assert value_ids is not None\n    return value_ids\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.find_destinies_for_value","title":"<code>find_destinies_for_value(value_id: uuid.UUID, alias_filter: Union[str, None] = None) -&gt; Union[Mapping[str, uuid.UUID], None]</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def find_destinies_for_value(\n    self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n) -&gt; Union[Mapping[str, uuid.UUID], None]:\n\n    return self._find_destinies_for_value(\n        value_id=value_id, alias_filter=alias_filter\n    )\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataArchive.retrieve_chunk","title":"<code>retrieve_chunk(chunk_id: str, as_file: Union[bool, str, None] = None, symlink_ok: bool = True) -&gt; Union[bytes, str]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_chunk(\n    self,\n    chunk_id: str,\n    as_file: Union[bool, str, None] = None,\n    symlink_ok: bool = True,\n) -&gt; Union[bytes, str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataStore","title":"<code>DataStore</code>","text":"<p>         Bases: <code>DataArchive</code></p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>class DataStore(DataArchive):\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return True\n\n    @abc.abstractmethod\n    def store_value(self, value: Value) -&gt; PersistedData:\n\"\"\" \"Store the value, its data and metadata into the store.\n\n        Arguments:\n            value: the value to persist\n\n        Returns:\n            the load config that is needed to retrieve the value data later\n        \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataStore.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.DataStore.store_value","title":"<code>store_value(value: Value) -&gt; PersistedData</code>  <code>abstractmethod</code>","text":"<p>\"Store the value, its data and metadata into the store.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Value</code> <p>the value to persist</p> required <p>Returns:</p> Type Description <code>PersistedData</code> <p>the load config that is needed to retrieve the value data later</p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>@abc.abstractmethod\ndef store_value(self, value: Value) -&gt; PersistedData:\n\"\"\" \"Store the value, its data and metadata into the store.\n\n    Arguments:\n        value: the value to persist\n\n    Returns:\n        the load config that is needed to retrieve the value data later\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.BaseDataStore","title":"<code>BaseDataStore</code>","text":"<p>         Bases: <code>DataStore</code></p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>class BaseDataStore(DataStore):\n    # @abc.abstractmethod\n    # def _persist_bytes(self, bytes_structure: BytesStructure) -&gt; BytesAliasStructure:\n    #     pass\n\n    @abc.abstractmethod\n    def _persist_stored_value_info(self, value: Value, persisted_value: PersistedData):\n        pass\n\n    @abc.abstractmethod\n    def _persist_value_details(self, value: Value):\n        pass\n\n    @abc.abstractmethod\n    def _persist_value_data(self, value: Value) -&gt; PersistedData:\n        pass\n\n    @abc.abstractmethod\n    def _persist_value_pedigree(self, value: Value):\n\"\"\"Create an internal link from a value to its pedigree (and pedigree details).\n\n        This is so that the 'retrieve_job_record' can be used to prevent running the same job again, and the link of value\n        to the job that produced it is preserved.\n        \"\"\"\n\n    @abc.abstractmethod\n    def _persist_environment_details(\n        self, env_type: str, env_hash: str, env_data: Mapping[str, Any]\n    ):\n        pass\n\n    @abc.abstractmethod\n    def _persist_destiny_backlinks(self, value: Value):\n        pass\n\n    def store_value(self, value: Value) -&gt; PersistedData:\n\n        logger.debug(\n            \"store.value\",\n            data_type=value.value_schema.type,\n            value_id=value.value_id,\n            value_hash=value.value_hash,\n        )\n\n        # first, persist environment information\n        for env_type, env_hash in value.pedigree.environments.items():\n            cached = self._env_cache.get(env_type, {}).get(env_hash, None)\n            if cached is not None:\n                continue\n\n            env = self.kiara_context.environment_registry.get_environment_for_cid(\n                env_hash\n            )\n            self.persist_environment(env)\n\n        # save the value data and metadata\n        persisted_value = self._persist_value(value)\n        self._persisted_value_cache[value.value_id] = persisted_value\n        self._value_cache[value.value_id] = value\n        self._value_hash_index.setdefault(value.value_hash, set()).add(value.value_id)\n\n        # now link the output values to the manifest\n        # then, make sure the manifest is persisted\n        self._persist_value_pedigree(value=value)\n\n        return persisted_value\n\n    def _persist_value(self, value: Value) -&gt; PersistedData:\n\n        # TODO: check if value id is already persisted?\n        if value.is_set:\n            persisted_value_info: PersistedData = self._persist_value_data(value=value)\n            if not persisted_value_info:\n                raise Exception(\n                    \"Can't write persisted value info, no load config returned when persisting value.\"\n                )\n            if not isinstance(persisted_value_info, PersistedData):\n                raise Exception(\n                    f\"Can't write persisted value info, invalid result type '{type(persisted_value_info)}' when persisting value.\"\n                )\n        else:\n            persisted_value_info = PersistedData(\n                archive_id=self.archive_id,\n                data_type=value.data_type_name,\n                serialization_profile=\"none\",\n                data_type_config=value.data_type_config,\n                chunk_id_map={},\n            )\n\n        self._persist_stored_value_info(\n            value=value, persisted_value=persisted_value_info\n        )\n        self._persist_value_details(value=value)\n        if value.destiny_backlinks:\n            self._persist_destiny_backlinks(value=value)\n\n        return persisted_value_info\n\n    def persist_environment(self, environment: RuntimeEnvironment):\n\"\"\"Persist the specified environment.\n\n        The environment is stored as a dictionary, including it's schema, not as the actual Python model.\n        This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.\n        \"\"\"\n\n        env_type = environment.get_environment_type_name()\n        env_hash = str(environment.instance_cid)\n\n        env = self._env_cache.get(env_type, {}).get(env_hash, None)\n        if env is not None:\n            return\n\n        env_data = environment.as_dict_with_schema()\n        self._persist_environment_details(\n            env_type=env_type, env_hash=env_hash, env_data=env_data\n        )\n        self._env_cache.setdefault(env_type, {})[env_hash] = env_data\n\n    def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n        from kiara.utils.output import create_renderable_from_values\n\n        all_values = {}\n        all_value_ids = self.value_ids\n        if all_value_ids:\n            for value_id in all_value_ids:\n\n                value = self.kiara_context.data_registry.get_value(value_id)\n                all_values[str(value_id)] = value\n            table = create_renderable_from_values(values=all_values, config=config)\n\n            return table\n        else:\n            return \"Data archive does not support statically determined ids.\"\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.BaseDataStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.BaseDataStore.store_value","title":"<code>store_value(value: Value) -&gt; PersistedData</code>","text":"Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def store_value(self, value: Value) -&gt; PersistedData:\n\n    logger.debug(\n        \"store.value\",\n        data_type=value.value_schema.type,\n        value_id=value.value_id,\n        value_hash=value.value_hash,\n    )\n\n    # first, persist environment information\n    for env_type, env_hash in value.pedigree.environments.items():\n        cached = self._env_cache.get(env_type, {}).get(env_hash, None)\n        if cached is not None:\n            continue\n\n        env = self.kiara_context.environment_registry.get_environment_for_cid(\n            env_hash\n        )\n        self.persist_environment(env)\n\n    # save the value data and metadata\n    persisted_value = self._persist_value(value)\n    self._persisted_value_cache[value.value_id] = persisted_value\n    self._value_cache[value.value_id] = value\n    self._value_hash_index.setdefault(value.value_hash, set()).add(value.value_id)\n\n    # now link the output values to the manifest\n    # then, make sure the manifest is persisted\n    self._persist_value_pedigree(value=value)\n\n    return persisted_value\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.BaseDataStore.persist_environment","title":"<code>persist_environment(environment: RuntimeEnvironment)</code>","text":"<p>Persist the specified environment.</p> <p>The environment is stored as a dictionary, including it's schema, not as the actual Python model. This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.</p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def persist_environment(self, environment: RuntimeEnvironment):\n\"\"\"Persist the specified environment.\n\n    The environment is stored as a dictionary, including it's schema, not as the actual Python model.\n    This is to make sure it can still be loaded later on, in case the Python model has changed in later versions.\n    \"\"\"\n\n    env_type = environment.get_environment_type_name()\n    env_hash = str(environment.instance_cid)\n\n    env = self._env_cache.get(env_type, {}).get(env_hash, None)\n    if env is not None:\n        return\n\n    env_data = environment.as_dict_with_schema()\n    self._persist_environment_details(\n        env_type=env_type, env_hash=env_hash, env_data=env_data\n    )\n    self._env_cache.setdefault(env_type, {})[env_hash] = env_data\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/__init__/#kiara.registries.data.data_store.BaseDataStore.create_renderable","title":"<code>create_renderable(**config: Any) -&gt; RenderableType</code>","text":"<p>Create a renderable for this module configuration.</p> Source code in <code>kiara/registries/data/data_store/__init__.py</code> <pre><code>def create_renderable(self, **config: Any) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n    from kiara.utils.output import create_renderable_from_values\n\n    all_values = {}\n    all_value_ids = self.value_ids\n    if all_value_ids:\n        for value_id in all_value_ids:\n\n            value = self.kiara_context.data_registry.get_value(value_id)\n            all_values[str(value_id)] = value\n        table = create_renderable_from_values(values=all_values, config=config)\n\n        return table\n    else:\n        return \"Data archive does not support statically determined ids.\"\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/","title":"filesystem_store","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.VALUE_DETAILS_FILE_NAME","title":"<code>VALUE_DETAILS_FILE_NAME = 'value.json'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.DEFAULT_HASHFS_DEPTH","title":"<code>DEFAULT_HASHFS_DEPTH = 4</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.DEFAULT_HASHFS_WIDTH","title":"<code>DEFAULT_HASHFS_WIDTH = 1</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.DEFAULT_HASH_FS_ALGORITHM","title":"<code>DEFAULT_HASH_FS_ALGORITHM = 'sha256'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType","title":"<code>EntityType</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>class EntityType(Enum):\n\n    VALUE = \"values\"\n    VALUE_DATA = \"value_data\"\n    ENVIRONMENT = \"environments\"\n    MANIFEST = \"manifests\"\n    DESTINY_LINK = \"destiny_links\"\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType.VALUE","title":"<code>VALUE = 'values'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType.VALUE_DATA","title":"<code>VALUE_DATA = 'value_data'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType.ENVIRONMENT","title":"<code>ENVIRONMENT = 'environments'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType.MANIFEST","title":"<code>MANIFEST = 'manifests'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.EntityType.DESTINY_LINK","title":"<code>DESTINY_LINK = 'destiny_links'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive","title":"<code>FileSystemDataArchive</code>","text":"<p>         Bases: <code>DataArchive</code>, <code>JobArchive</code></p> <p>Data store that loads data from the local filesystem.</p> Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>class FileSystemDataArchive(DataArchive, JobArchive):\n\"\"\"Data store that loads data from the local filesystem.\"\"\"\n\n    _archive_type_name = \"filesystem_data_archive\"\n    _config_cls = FileSystemArchiveConfig  # type: ignore\n\n    # @classmethod\n    # def supported_item_types(cls) -&gt; Iterable[str]:\n    #\n    #     return [\"data\", \"job_record\"]\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n\n    def __init__(self, archive_id: uuid.UUID, config: FileSystemArchiveConfig):\n\n        DataArchive.__init__(self, archive_id=archive_id, config=config)\n        self._base_path: Union[Path, None] = None\n        self._hashfs_path: Union[Path, None] = None\n        self._hashfs: Union[HashFS, None] = None\n\n    # def get_job_archive_id(self) -&gt; uuid.UUID:\n    #     return self._kiara.id\n\n    def get_archive_details(self) -&gt; ArchiveDetails:\n\n        size = sum(\n            f.stat().st_size for f in self.data_store_path.glob(\"**/*\") if f.is_file()\n        )\n        return ArchiveDetails(size=size)\n\n    @property\n    def data_store_path(self) -&gt; Path:\n\n        if self._base_path is not None:\n            return self._base_path\n\n        self._base_path = Path(self.config.archive_path).absolute()  # type: ignore\n        self._base_path = fix_windows_longpath(self._base_path)\n        self._base_path.mkdir(parents=True, exist_ok=True)\n        return self._base_path\n\n    def _delete_archive(self):\n        shutil.rmtree(self.data_store_path)\n\n    @property\n    def hash_fs_path(self) -&gt; Path:\n\n        if self._hashfs_path is None:\n            self._hashfs_path = self.data_store_path / \"hash_fs\"\n        return self._hashfs_path\n\n    @property\n    def hashfs(self) -&gt; HashFS:\n\n        if self._hashfs is None:\n            self._hashfs = HashFS(\n                self.hash_fs_path.as_posix(),\n                depth=DEFAULT_HASHFS_DEPTH,\n                width=DEFAULT_HASHFS_WIDTH,\n                algorithm=DEFAULT_HASH_FS_ALGORITHM,\n            )\n        return self._hashfs\n\n    def get_path(\n        self,\n        entity_type: Union[EntityType, None] = None,\n        base_path: Union[Path, None] = None,\n    ) -&gt; Path:\n        if base_path is None:\n            if entity_type is None:\n                result = self.data_store_path\n            else:\n                result = self.data_store_path / entity_type.value\n        else:\n            if entity_type is None:\n                result = base_path\n            else:\n                result = base_path / entity_type.value\n\n        result.mkdir(parents=True, exist_ok=True)\n        return result\n\n    def _retrieve_environment_details(\n        self, env_type: str, env_hash: str\n    ) -&gt; Mapping[str, Any]:\n\n        base_path = self.get_path(entity_type=EntityType.ENVIRONMENT)\n        env_details_file = base_path / f\"{env_type}_{env_hash}.json\"\n\n        if not env_details_file.exists():\n            raise Exception(\n                f\"Can't load environment details, file does not exist: {env_details_file.as_posix()}\"\n            )\n\n        environment = orjson.loads(env_details_file.read_text())\n        return environment\n\n    def retrieve_all_job_hashes(\n        self,\n        manifest_hash: Union[str, None] = None,\n        inputs_hash: Union[str, None] = None,\n    ) -&gt; Iterable[str]:\n\n        raise NotImplementedError()\n\n    def _retrieve_record_for_job_hash(self, job_hash: str) -&gt; JobRecord:\n\n        raise NotImplementedError()\n\n    # def find_matching_job_record(\n    #     self, inputs_manifest: InputsManifest\n    # ) -&gt; Optional[JobRecord]:\n    #\n    #     manifest_hash = str(inputs_manifest.instance_cid)\n    #     jobs_hash = inputs_manifest.job_hash\n    #\n    #     base_path = self.get_path(entity_type=EntityType.MANIFEST)\n    #     manifest_folder = base_path / str(manifest_hash)\n    #\n    #     if not manifest_folder.exists():\n    #         return None\n    #\n    #     manifest_file = manifest_folder / \"manifest.json\"\n    #\n    #     if not manifest_file.exists():\n    #         raise Exception(\n    #             f\"No 'manifests.json' file for manifest with hash: {manifest_hash}\"\n    #         )\n    #\n    #     manifest_data = orjson.loads(manifest_file.read_text())\n    #\n    #     job_folder = manifest_folder / jobs_hash\n    #\n    #     if not job_folder.exists():\n    #         return None\n    #\n    #     inputs_file_name = job_folder / \"inputs.json\"\n    #     if not inputs_file_name.exists():\n    #         raise Exception(\n    #             f\"No 'inputs.json' file for manifest/inputs hash-combo: {manifest_hash} / {jobs_hash}\"\n    #         )\n    #\n    #     inputs_data = {\n    #         k: uuid.UUID(v)\n    #         for k, v in orjson.loads(inputs_file_name.read_text()).items()\n    #     }\n    #\n    #     outputs = {}\n    #     for output_file in job_folder.glob(\"output__*.json\"):\n    #         full_output_name = output_file.name[8:]\n    #         start_value_id = full_output_name.find(\"__value_id__\")\n    #         output_name = full_output_name[0:start_value_id]\n    #         value_id_str = full_output_name[start_value_id + 12 : -5]\n    #\n    #         value_id = uuid.UUID(value_id_str)\n    #         outputs[output_name] = value_id\n    #\n    #     job_id = ID_REGISTRY.generate(obj_type=JobRecord, desc=\"fake job id\")\n    #     job_record = JobRecord(\n    #         job_id=job_id,\n    #         module_type=manifest_data[\"module_type\"],\n    #         module_config=manifest_data[\"module_config\"],\n    #         inputs=inputs_data,\n    #         outputs=outputs,\n    #     )\n    #     return job_record\n\n    def _find_values_with_hash(\n        self,\n        value_hash: str,\n        value_size: Union[int, None] = None,\n        data_type_name: Union[str, None] = None,\n    ) -&gt; Set[uuid.UUID]:\n\n        value_data_folder = self.get_path(entity_type=EntityType.VALUE_DATA)\n\n        glob = f\"*/{value_hash}/value_id__*.json\"\n\n        matches = list(value_data_folder.glob(glob))\n\n        result = set()\n        for match in matches:\n            if not match.is_symlink():\n                log_message(\n                    f\"Ignoring value_id file, not a symlink: {match.as_posix()}\"\n                )\n                continue\n\n            uuid_str = match.name[10:-5]\n            value_id = uuid.UUID(uuid_str)\n            result.add(value_id)\n\n        return result\n\n    def _find_destinies_for_value(\n        self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n    ) -&gt; Union[Mapping[str, uuid.UUID], None]:\n\n        destiny_dir = self.get_path(entity_type=EntityType.DESTINY_LINK)\n        destiny_value_dir = destiny_dir / str(value_id)\n\n        if not destiny_value_dir.exists():\n            return None\n\n        destinies = {}\n        for alias_link in destiny_value_dir.glob(\"*.json\"):\n            assert alias_link.is_symlink()\n\n            alias = alias_link.name[0:-5]\n            resolved = alias_link.resolve()\n\n            value_id_str = resolved.parent.name\n            value_id = uuid.UUID(value_id_str)\n            destinies[alias] = value_id\n\n        return destinies\n\n    def _retrieve_all_value_ids(\n        self, data_type_name: Union[str, None] = None\n    ) -&gt; Iterable[uuid.UUID]:\n\n        if data_type_name is not None:\n            raise NotImplementedError()\n\n        childs = self.get_path(entity_type=EntityType.VALUE).glob(\"*\")\n        folders = [uuid.UUID(x.name) for x in childs if x.is_dir()]\n        return folders\n\n    def has_value(self, value_id: uuid.UUID) -&gt; bool:\n\"\"\"Check whether the specific value_id is persisted in this data store.\n        way to quickly determine whether a value id is valid for this data store.\n\n        Arguments:\n            value_id: the id of the value to check.\n        Returns:\n            whether this data store contains the value with the specified id\n        \"\"\"\n\n        base_path = (\n            self.get_path(entity_type=EntityType.VALUE)\n            / str(value_id)\n            / VALUE_DETAILS_FILE_NAME\n        )\n        return base_path.is_file()\n\n    def _retrieve_value_details(self, value_id: uuid.UUID) -&gt; Mapping[str, Any]:\n\n        base_path = (\n            self.get_path(entity_type=EntityType.VALUE)\n            / str(value_id)\n            / VALUE_DETAILS_FILE_NAME\n        )\n        if not base_path.is_file():\n            raise Exception(\n                f\"Can't retrieve details for value with id '{value_id}': no value with that id stored.\"\n            )\n\n        value_data = orjson.loads(base_path.read_text())\n        return value_data\n\n    def _retrieve_serialized_value(self, value: Value) -&gt; PersistedData:\n\n        base_path = self.get_path(entity_type=EntityType.VALUE_DATA)\n        data_dir = base_path / value.data_type_name / str(value.value_hash)\n\n        serialized_value_file = data_dir / \".serialized_value.json\"\n        data = orjson.loads(serialized_value_file.read_text())\n\n        return PersistedData(**data)\n\n    def retrieve_chunk(\n        self,\n        chunk_id: str,\n        as_file: Union[bool, str, None] = None,\n        symlink_ok: bool = True,\n    ) -&gt; Union[bytes, str]:\n\n        addr = self.hashfs.get(chunk_id)\n\n        if as_file in (None, True):\n            return addr.abspath\n        elif as_file is False:\n            return Path(addr.abspath).read_bytes()\n        else:\n            raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive._config_cls","title":"<code>_config_cls = FileSystemArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.data_store_path","title":"<code>data_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.hash_fs_path","title":"<code>hash_fs_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.hashfs","title":"<code>hashfs: HashFS</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.get_archive_details","title":"<code>get_archive_details() -&gt; ArchiveDetails</code>","text":"Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>def get_archive_details(self) -&gt; ArchiveDetails:\n\n    size = sum(\n        f.stat().st_size for f in self.data_store_path.glob(\"**/*\") if f.is_file()\n    )\n    return ArchiveDetails(size=size)\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.get_path","title":"<code>get_path(entity_type: Union[EntityType, None] = None, base_path: Union[Path, None] = None) -&gt; Path</code>","text":"Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>def get_path(\n    self,\n    entity_type: Union[EntityType, None] = None,\n    base_path: Union[Path, None] = None,\n) -&gt; Path:\n    if base_path is None:\n        if entity_type is None:\n            result = self.data_store_path\n        else:\n            result = self.data_store_path / entity_type.value\n    else:\n        if entity_type is None:\n            result = base_path\n        else:\n            result = base_path / entity_type.value\n\n    result.mkdir(parents=True, exist_ok=True)\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.retrieve_all_job_hashes","title":"<code>retrieve_all_job_hashes(manifest_hash: Union[str, None] = None, inputs_hash: Union[str, None] = None) -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>def retrieve_all_job_hashes(\n    self,\n    manifest_hash: Union[str, None] = None,\n    inputs_hash: Union[str, None] = None,\n) -&gt; Iterable[str]:\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.has_value","title":"<code>has_value(value_id: uuid.UUID) -&gt; bool</code>","text":"<p>Check whether the specific value_id is persisted in this data store. way to quickly determine whether a value id is valid for this data store.</p> <p>Parameters:</p> Name Type Description Default <code>value_id</code> <code>uuid.UUID</code> <p>the id of the value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>whether this data store contains the value with the specified id</p> Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>def has_value(self, value_id: uuid.UUID) -&gt; bool:\n\"\"\"Check whether the specific value_id is persisted in this data store.\n    way to quickly determine whether a value id is valid for this data store.\n\n    Arguments:\n        value_id: the id of the value to check.\n    Returns:\n        whether this data store contains the value with the specified id\n    \"\"\"\n\n    base_path = (\n        self.get_path(entity_type=EntityType.VALUE)\n        / str(value_id)\n        / VALUE_DETAILS_FILE_NAME\n    )\n    return base_path.is_file()\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FileSystemDataArchive.retrieve_chunk","title":"<code>retrieve_chunk(chunk_id: str, as_file: Union[bool, str, None] = None, symlink_ok: bool = True) -&gt; Union[bytes, str]</code>","text":"Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>def retrieve_chunk(\n    self,\n    chunk_id: str,\n    as_file: Union[bool, str, None] = None,\n    symlink_ok: bool = True,\n) -&gt; Union[bytes, str]:\n\n    addr = self.hashfs.get(chunk_id)\n\n    if as_file in (None, True):\n        return addr.abspath\n    elif as_file is False:\n        return Path(addr.abspath).read_bytes()\n    else:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store.FilesystemDataStore","title":"<code>FilesystemDataStore</code>","text":"<p>         Bases: <code>FileSystemDataArchive</code>, <code>BaseDataStore</code></p> <p>Data store that stores data as files on the local filesystem.</p> Source code in <code>kiara/registries/data/data_store/filesystem_store.py</code> <pre><code>class FilesystemDataStore(FileSystemDataArchive, BaseDataStore):\n\"\"\"Data store that stores data as files on the local filesystem.\"\"\"\n\n    _archive_type_name = \"filesystem_data_store\"\n\n    def _persist_environment_details(\n        self, env_type: str, env_hash: str, env_data: Mapping[str, Any]\n    ):\n\n        base_path = self.get_path(entity_type=EntityType.ENVIRONMENT)\n        env_details_file = base_path / f\"{env_type}_{env_hash}.json\"\n\n        if not env_details_file.exists():\n            env_details_file.write_text(orjson_dumps(env_data))\n\n    def _persist_stored_value_info(self, value: Value, persisted_value: PersistedData):\n\n        working_dir = self.get_path(entity_type=EntityType.VALUE_DATA)\n        data_dir = working_dir / value.data_type_name / str(value.value_hash)\n        sv_file = data_dir / \".serialized_value.json\"\n        data_dir.mkdir(exist_ok=True, parents=True)\n        sv_file.write_text(persisted_value.json())\n\n    def _persist_value_details(self, value: Value):\n\n        value_dir = self.get_path(entity_type=EntityType.VALUE) / str(value.value_id)\n\n        if value_dir.exists():\n            raise Exception(\n                f\"Can't persist value '{value.value_id}', value directory already exists: {value_dir}\"\n            )\n        else:\n            value_dir.mkdir(parents=True, exist_ok=False)\n\n        value_file = value_dir / VALUE_DETAILS_FILE_NAME\n        value_data = value.dict()\n        value_file.write_text(orjson_dumps(value_data, option=orjson.OPT_NON_STR_KEYS))\n\n    def _persist_destiny_backlinks(self, value: Value):\n\n        destiny_dir = self.get_path(entity_type=EntityType.DESTINY_LINK)\n\n        for value_id, backlink in value.destiny_backlinks.items():\n\n            destiny_value_dir = destiny_dir / str(value_id)\n            destiny_value_dir.mkdir(parents=True, exist_ok=True)\n            destiny_file = destiny_value_dir / f\"{backlink}.json\"\n            assert not destiny_file.exists()\n\n            value_dir = self.get_path(entity_type=EntityType.VALUE) / str(\n                value.value_id\n            )\n            value_file = value_dir / VALUE_DETAILS_FILE_NAME\n            assert value_file.exists()\n\n            fix_windows_symlink(value_file, destiny_file)\n\n    def _persist_value_data(self, value: Value) -&gt; PersistedData:\n\n        serialized_value: SerializedData = value.serialized_data\n\n        chunk_id_map = {}\n        for key in serialized_value.get_keys():\n\n            data_model = serialized_value.get_serialized_data(key)\n\n            if data_model.type == \"chunk\":  # type: ignore\n                chunks: Iterable[Union[str, BytesIO]] = [BytesIO(data_model.chunk)]  # type: ignore\n            elif data_model.type == \"chunks\":  # type: ignore\n                chunks = (BytesIO(c) for c in data_model.chunks)  # type: ignore\n            elif data_model.type == \"file\":  # type: ignore\n                chunks = [data_model.file]  # type: ignore\n            elif data_model.type == \"files\":  # type: ignore\n                chunks = data_model.files  # type: ignore\n            elif data_model.type == \"inline-json\":  # type: ignore\n                chunks = [BytesIO(data_model.as_json())]  # type: ignore\n            else:\n                raise Exception(\n                    f\"Invalid serialized data type: {type(data_model)}. Available types: {', '.join(SERIALIZE_TYPES)}\"\n                )\n\n            chunk_ids = []\n            for item in zip(serialized_value.get_cids_for_key(key), chunks):\n                cid = item[0]\n                _chunk = item[1]\n                addr: HashAddress = self.hashfs.put_with_precomputed_hash(\n                    _chunk, str(cid)\n                )\n                chunk_ids.append(addr.id)\n\n            scids = SerializedChunkIDs(\n                chunk_id_list=chunk_ids,\n                archive_id=self.archive_id,\n                size=data_model.get_size(),\n            )\n            scids._data_registry = self.kiara_context.data_registry\n            chunk_id_map[key] = scids\n\n        pers_value = PersistedData(\n            archive_id=self.archive_id,\n            chunk_id_map=chunk_id_map,\n            data_type=serialized_value.data_type,\n            data_type_config=serialized_value.data_type_config,\n            serialization_profile=serialized_value.serialization_profile,\n            metadata=serialized_value.metadata,\n        )\n\n        return pers_value\n\n    def _persist_value_pedigree(self, value: Value):\n\n        manifest_hash = value.pedigree.instance_cid\n        jobs_hash = value.pedigree.job_hash\n\n        base_path = self.get_path(entity_type=EntityType.MANIFEST)\n        manifest_folder = base_path / str(manifest_hash)\n        manifest_folder.mkdir(parents=True, exist_ok=True)\n\n        manifest_info_file = manifest_folder / \"manifest.json\"\n        if not manifest_info_file.exists():\n            manifest_info_file.write_text(value.pedigree.manifest_data_as_json())\n\n        job_folder = manifest_folder / str(jobs_hash)\n\n        job_folder.mkdir(parents=True, exist_ok=True)\n\n        inputs_details_file_name = job_folder / \"inputs.json\"\n        if not inputs_details_file_name.exists():\n            inputs_details_file_name.write_text(orjson_dumps(value.pedigree.inputs))\n\n        outputs_file_name = (\n            job_folder\n            / f\"output__{value.pedigree_output_name}__value_id__{value.value_id}.json\"\n        )\n\n        outputs_file_name = fix_windows_longpath(outputs_file_name)\n\n        if outputs_file_name.exists():\n            # if value.pedigree_output_name == \"__void__\":\n            #     return\n            # else:\n            raise Exception(f\"Can't write value '{value.value_id}': already exists.\")\n        else:\n            outputs_file_name.touch()\n\n        value_data_dir = (\n            self.get_path(entity_type=EntityType.VALUE_DATA)\n            / value.value_schema.type\n            / str(value.value_hash)\n        )\n        target_file = value_data_dir / f\"value_id__{value.value_id}.json\"\n\n        fix_windows_symlink(outputs_file_name, target_file)\n</code></pre>"},{"location":"reference/kiara/registries/data/data_store/filesystem_store/#kiara.registries.data.data_store.filesystem_store-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/__init__/","title":"destinies","text":""},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive","title":"<code>DestinyArchive</code>","text":"<p>         Bases: <code>BaseArchive</code></p> Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>class DestinyArchive(BaseArchive):\n    @classmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n        return [\"destiny\"]\n\n    def __init__(self, archive_id: uuid.UUID, config: ARCHIVE_CONFIG_CLS):\n\n        super().__init__(archive_id=archive_id, config=config)\n\n    @abc.abstractmethod\n    def get_all_value_ids(self) -&gt; Set[uuid.UUID]:\n\"\"\"Retrun a list of all value ids that have destinies stored in this archive.\"\"\"\n\n    @abc.abstractmethod\n    def get_destiny_aliases_for_value(\n        self, value_id: uuid.UUID\n    ) -&gt; Union[Set[str], None]:\n\"\"\"Retrieve all the destinies for the specified value within this archive.\n\n        In case this archive discovers its value destinies dynamically, this can return 'None'.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_destiny(self, value_id: uuid.UUID, destiny: str) -&gt; Destiny:\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>@classmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n    return [\"destiny\"]\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive.get_all_value_ids","title":"<code>get_all_value_ids() -&gt; Set[uuid.UUID]</code>  <code>abstractmethod</code>","text":"<p>Retrun a list of all value ids that have destinies stored in this archive.</p> Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>@abc.abstractmethod\ndef get_all_value_ids(self) -&gt; Set[uuid.UUID]:\n\"\"\"Retrun a list of all value ids that have destinies stored in this archive.\"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive.get_destiny_aliases_for_value","title":"<code>get_destiny_aliases_for_value(value_id: uuid.UUID) -&gt; Union[Set[str], None]</code>  <code>abstractmethod</code>","text":"<p>Retrieve all the destinies for the specified value within this archive.</p> <p>In case this archive discovers its value destinies dynamically, this can return 'None'.</p> Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>@abc.abstractmethod\ndef get_destiny_aliases_for_value(\n    self, value_id: uuid.UUID\n) -&gt; Union[Set[str], None]:\n\"\"\"Retrieve all the destinies for the specified value within this archive.\n\n    In case this archive discovers its value destinies dynamically, this can return 'None'.\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyArchive.get_destiny","title":"<code>get_destiny(value_id: uuid.UUID, destiny: str) -&gt; Destiny</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>@abc.abstractmethod\ndef get_destiny(self, value_id: uuid.UUID, destiny: str) -&gt; Destiny:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyStore","title":"<code>DestinyStore</code>","text":"<p>         Bases: <code>DestinyArchive</code></p> Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>class DestinyStore(DestinyArchive):\n    @abc.abstractmethod\n    def persist_destiny(self, destiny: Destiny):\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/__init__/#kiara.registries.destinies.DestinyStore.persist_destiny","title":"<code>persist_destiny(destiny: Destiny)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/destinies/__init__.py</code> <pre><code>@abc.abstractmethod\ndef persist_destiny(self, destiny: Destiny):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/","title":"filesystem_store","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive","title":"<code>FileSystemDestinyArchive</code>","text":"<p>         Bases: <code>DestinyArchive</code></p> Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>class FileSystemDestinyArchive(DestinyArchive):\n\n    _archive_type_name = \"filesystem_destiny_archive\"\n    _config_cls = FileSystemArchiveConfig  # type: ignore\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n\n    # @classmethod\n    # def create_from_kiara_context(cls, kiara: \"Kiara\"):\n    #\n    #     TODO = kiara_app_dirs.user_data_dir\n    #     base_path = Path(TODO) / \"destiny_store\"\n    #     base_path.mkdir(parents=True, exist_ok=True)\n    #     result = cls(base_path=base_path, store_id=kiara.id)\n    #     ID_REGISTRY.update_metadata(\n    #         result.get_destiny_archive_id(), kiara_id=kiara.id, obj=result\n    #     )\n    #     return result\n\n    def __init__(self, archive_id: uuid.UUID, config: FileSystemArchiveConfig):\n\n        super().__init__(archive_id=archive_id, config=config)\n        self._base_path: Union[Path, None] = None\n\n        # base_path = config.archive_path\n        # if not base_path.is_dir():\n        #     raise Exception(\n        #         f\"Can't create file system archive instance, base path does not exist or is not a folder: {base_path.as_posix()}.\"\n        #     )\n\n        # self._store_id: uuid.UUID = store_id\n        # self._base_path: Path = base_path\n        # self._destinies_path: Path = self._base_path / \"destinies\"\n        # self._value_id_path: Path = self._base_path / \"value_ids\"\n\n    @property\n    def destiny_store_path(self) -&gt; Path:\n\n        if self._base_path is not None:\n            return self._base_path\n\n        self._base_path = Path(self.config.archive_path).absolute()  # type: ignore\n        self._base_path = fix_windows_longpath(self._base_path)\n        self._base_path.mkdir(parents=True, exist_ok=True)\n        return self._base_path\n\n    def get_archive_details(self) -&gt; ArchiveDetails:\n\n        size = sum(\n            f.stat().st_size\n            for f in self.destiny_store_path.glob(\"**/*\")\n            if f.is_file()\n        )\n        return ArchiveDetails(size=size)\n\n    @property\n    def destinies_path(self) -&gt; Path:\n        return self.destiny_store_path / \"destinies\"\n\n    @property\n    def value_id_path(self) -&gt; Path:\n        return self.destiny_store_path / \"value_ids\"\n\n    def _translate_destiny_id_to_path(self, destiny_id: uuid.UUID) -&gt; Path:\n\n        tokens = str(destiny_id).split(\"-\")\n        destiny_path = (\n            self.destinies_path.joinpath(*tokens[0:-1]) / f\"{tokens[-1]}.json\"\n        )\n        return destiny_path\n\n    def _translate_destinies_path_to_id(self, destinies_path: Path) -&gt; uuid.UUID:\n\n        relative = destinies_path.relative_to(self.destinies_path).as_posix()[:-5]\n\n        destninies_id = \"-\".join(relative.split(os.path.sep))\n\n        return uuid.UUID(destninies_id)\n\n    def _translate_value_id(self, value_id: uuid.UUID, destiny_alias: str) -&gt; Path:\n\n        tokens = str(value_id).split(\"-\")\n        value_id_path = self.value_id_path.joinpath(*tokens)\n\n        full_path = value_id_path / f\"{destiny_alias}.json\"\n        return full_path\n\n    def _translate_value_id_path(self, value_path: Path) -&gt; uuid.UUID:\n\n        relative = value_path.relative_to(self.value_id_path)\n\n        value_id_str = \"-\".join(relative.as_posix().split(os.path.sep))\n        return uuid.UUID(value_id_str)\n\n    def _translate_alias_path(self, alias_path: Path) -&gt; Tuple[uuid.UUID, str]:\n\n        value_id = self._translate_value_id_path(alias_path.parent)\n\n        alias = alias_path.name[0:-5]\n\n        return value_id, alias\n\n    def get_all_value_ids(self) -&gt; Set[uuid.UUID]:\n\n        all_root_folders = self.value_id_path.glob(\"*/*/*/*/*\")\n\n        result = set()\n        for folder in all_root_folders:\n            if not folder.is_dir():\n                continue\n\n            value_id = self._translate_value_id_path(folder)\n            result.add(value_id)\n\n        return result\n\n    def get_destiny_aliases_for_value(self, value_id: uuid.UUID) -&gt; Set[str]:\n\n        tokens = str(value_id).split(\"-\")\n        value_id_path = self.value_id_path.joinpath(*tokens)\n\n        aliases = value_id_path.glob(\"*.json\")\n\n        return {a.name[0:-5] for a in aliases}\n\n    def get_destiny(self, value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny:\n\n        tokens = str(value_id).split(\"-\")\n        value_id_path = self.value_id_path.joinpath(*tokens)\n\n        destiny_path = value_id_path / f\"{destiny_alias}.json\"\n\n        destiny_data = orjson.loads(destiny_path.read_text())\n\n        destiny = Destiny.construct(**destiny_data)\n        return destiny\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive._config_cls","title":"<code>_config_cls = FileSystemArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.destiny_store_path","title":"<code>destiny_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.destinies_path","title":"<code>destinies_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.value_id_path","title":"<code>value_id_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.get_archive_details","title":"<code>get_archive_details() -&gt; ArchiveDetails</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>def get_archive_details(self) -&gt; ArchiveDetails:\n\n    size = sum(\n        f.stat().st_size\n        for f in self.destiny_store_path.glob(\"**/*\")\n        if f.is_file()\n    )\n    return ArchiveDetails(size=size)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.get_all_value_ids","title":"<code>get_all_value_ids() -&gt; Set[uuid.UUID]</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>def get_all_value_ids(self) -&gt; Set[uuid.UUID]:\n\n    all_root_folders = self.value_id_path.glob(\"*/*/*/*/*\")\n\n    result = set()\n    for folder in all_root_folders:\n        if not folder.is_dir():\n            continue\n\n        value_id = self._translate_value_id_path(folder)\n        result.add(value_id)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.get_destiny_aliases_for_value","title":"<code>get_destiny_aliases_for_value(value_id: uuid.UUID) -&gt; Set[str]</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>def get_destiny_aliases_for_value(self, value_id: uuid.UUID) -&gt; Set[str]:\n\n    tokens = str(value_id).split(\"-\")\n    value_id_path = self.value_id_path.joinpath(*tokens)\n\n    aliases = value_id_path.glob(\"*.json\")\n\n    return {a.name[0:-5] for a in aliases}\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyArchive.get_destiny","title":"<code>get_destiny(value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>def get_destiny(self, value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny:\n\n    tokens = str(value_id).split(\"-\")\n    value_id_path = self.value_id_path.joinpath(*tokens)\n\n    destiny_path = value_id_path / f\"{destiny_alias}.json\"\n\n    destiny_data = orjson.loads(destiny_path.read_text())\n\n    destiny = Destiny.construct(**destiny_data)\n    return destiny\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyStore","title":"<code>FileSystemDestinyStore</code>","text":"<p>         Bases: <code>FileSystemDestinyArchive</code>, <code>DestinyStore</code></p> Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>class FileSystemDestinyStore(FileSystemDestinyArchive, DestinyStore):\n\n    _archive_type_name = \"filesystem_destiny_store\"\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return True\n\n    def persist_destiny(self, destiny: Destiny):\n\n        destiny_path = self._translate_destiny_id_to_path(destiny_id=destiny.destiny_id)\n        destiny_path.parent.mkdir(parents=True, exist_ok=True)\n        destiny_path.write_text(destiny.json())\n\n        for value_id in destiny.fixed_inputs.values():\n\n            path = self._translate_value_id(\n                value_id=value_id, destiny_alias=destiny.destiny_alias\n            )\n            if path.exists():\n                logger.debug(\"replace.destiny.file\", path=path.as_posix())\n                path.unlink()\n                # raise Exception(\n                #     f\"Can't persist destiny '{destiny.destiny_id}': already persisted.\"\n                # )\n\n            path.parent.mkdir(parents=True, exist_ok=True)\n            fix_windows_symlink(destiny_path, path)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyStore.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store.FileSystemDestinyStore.persist_destiny","title":"<code>persist_destiny(destiny: Destiny)</code>","text":"Source code in <code>kiara/registries/destinies/filesystem_store.py</code> <pre><code>def persist_destiny(self, destiny: Destiny):\n\n    destiny_path = self._translate_destiny_id_to_path(destiny_id=destiny.destiny_id)\n    destiny_path.parent.mkdir(parents=True, exist_ok=True)\n    destiny_path.write_text(destiny.json())\n\n    for value_id in destiny.fixed_inputs.values():\n\n        path = self._translate_value_id(\n            value_id=value_id, destiny_alias=destiny.destiny_alias\n        )\n        if path.exists():\n            logger.debug(\"replace.destiny.file\", path=path.as_posix())\n            path.unlink()\n            # raise Exception(\n            #     f\"Can't persist destiny '{destiny.destiny_id}': already persisted.\"\n            # )\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n        fix_windows_symlink(destiny_path, path)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/filesystem_store/#kiara.registries.destinies.filesystem_store-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/registry/","title":"registry","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry","title":"<code>DestinyRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>class DestinyRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n        self._event_callback: Callable = self._kiara.event_registry.add_producer(self)\n\n        self._destiny_archives: Dict[str, DestinyArchive] = {}\n        self._default_destiny_store: Union[str, None] = None\n        # default_metadata_archive = FileSystemDestinyStore.create_from_kiara_context(\n        #     self._kiara\n        # )\n        # self.register_destiny_archive(\"metadata\", default_metadata_archive)\n\n        self._all_values: Union[Dict[uuid.UUID, Set[str]], None] = None\n        self._cached_value_aliases: Dict[\n            uuid.UUID, Dict[str, Union[Destiny, None]]\n        ] = {}\n\n        self._destinies: Dict[uuid.UUID, Destiny] = {}\n        self._destinies_by_value: Dict[uuid.UUID, Dict[str, Destiny]] = {}\n        self._destiny_store_map: Dict[uuid.UUID, str] = {}\n\n    @property\n    def default_destiny_store(self) -&gt; DestinyStore:\n\n        if self._default_destiny_store is None:\n            raise Exception(\"No default destiny store set (yet).\")\n\n        return self._destiny_archives[self._default_destiny_store]  # type: ignore\n\n    @property\n    def destiny_archives(self) -&gt; Mapping[str, DestinyArchive]:\n        return self._destiny_archives\n\n    def register_destiny_archive(\n        self,\n        archive: DestinyArchive,\n        alias: Union[str, None] = None,\n        set_as_default_store: Union[bool, None] = None,\n    ):\n\n        destiny_store_id = archive.archive_id\n        archive.register_archive(kiara=self._kiara)\n        if alias is None:\n            alias = str(destiny_store_id)\n\n        if alias in self._destiny_archives.keys():\n            raise Exception(\n                f\"Can't add destiny archive, alias '{alias}' already registered.\"\n            )\n\n        self._destiny_archives[alias] = archive\n\n        is_store = False\n        is_default_store = False\n\n        if isinstance(archive, DestinyStore):\n            is_store = True\n\n            if set_as_default_store and self._default_destiny_store is not None:\n                raise Exception(\n                    f\"Can't set data store '{alias}' as default store: default store already set.\"\n                )\n\n            if self._default_destiny_store is None or set_as_default_store:\n                is_default_store = True\n                self._default_destiny_store = alias\n\n        event = DestinyArchiveAddedEvent.construct(\n            kiara_id=self._kiara.id,\n            destiny_archive_id=archive.archive_id,\n            destiny_archive_alias=alias,\n            is_store=is_store,\n            is_default_store=is_default_store,\n        )\n        self._event_callback(event)\n\n        # if not registered_name.isalnum():\n        #     raise Exception(\n        #         f\"Can't register destiny archive with name '{registered_name}: name must only contain alphanumeric characters.'\"\n        #     )\n        #\n        # if registered_name in self._destiny_archives.keys():\n        #     raise Exception(\n        #         f\"Can't register alias store, store id already registered: {registered_name}.\"\n        #     )\n        #\n        # self._destiny_archives[registered_name] = alias_store\n        #\n        # if self._default_destiny_store is None and isinstance(\n        #     alias_store, DestinyStore\n        # ):\n        #     self._default_destiny_store = registered_name\n\n    def _extract_archive(self, alias: str) -&gt; Tuple[str, str]:\n\n        if \".\" not in alias:\n            assert self._default_destiny_store is not None\n            return (self._default_destiny_store, alias)\n\n        store_id, rest = alias.split(\".\", maxsplit=1)\n\n        if store_id not in self._destiny_archives.keys():\n            assert self._default_destiny_store is not None\n            return (self._default_destiny_store, alias)\n        else:\n            return (store_id, rest)\n\n    def add_destiny(\n        self,\n        destiny_alias: str,\n        values: Dict[str, uuid.UUID],\n        manifest: Manifest,\n        result_field_name: Union[str, None] = None,\n    ) -&gt; Destiny:\n\"\"\"Add a destiny for one (or in some rare cases several) values.\n\n        A destiny alias must be unique for every one of the involved input values.\n        \"\"\"\n\n        if not values:\n            raise Exception(\"Can't add destiny, no values provided.\")\n\n        store_id, alias = self._extract_archive(destiny_alias)\n\n        destiny = Destiny.create_from_values(\n            kiara=self._kiara,\n            destiny_alias=alias,\n            manifest=manifest,\n            result_field_name=result_field_name,\n            values=values,\n        )\n\n        for value_id in destiny.fixed_inputs.values():\n            self._destinies[destiny.destiny_id] = destiny\n            # TODO: store history?\n            self._destinies_by_value.setdefault(value_id, {})[destiny_alias] = destiny\n            self._cached_value_aliases.setdefault(value_id, {})[destiny_alias] = destiny\n\n        self._destiny_store_map[destiny.destiny_id] = store_id\n\n        return destiny\n\n    def get_destiny(self, value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny:\n\n        destiny = self._destinies_by_value.get(value_id, {}).get(destiny_alias, None)\n        if destiny is None:\n            raise Exception(\n                f\"No destiny '{destiny_alias}' available for value '{value_id}'.\"\n            )\n\n        return destiny\n\n    @property\n    def _all_values_store_map(self) -&gt; Dict[uuid.UUID, Set[str]]:\n\n        if self._all_values is not None:\n            return self._all_values\n\n        all_values: Dict[uuid.UUID, Set[str]] = {}\n        for archive_id, archive in self._destiny_archives.items():\n\n            all_value_ids = archive.get_all_value_ids()\n            for v_id in all_value_ids:\n                all_values.setdefault(v_id, set()).add(archive_id)\n\n        self._all_values = all_values\n        return self._all_values\n\n    @property\n    def all_values(self) -&gt; Iterable[uuid.UUID]:\n\n        all_stored_values = set(self._all_values_store_map.keys())\n        all_stored_values.update(self._destinies_by_value.keys())\n        return all_stored_values\n\n    def get_destiny_aliases_for_value(\n        self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n    ) -&gt; Iterable[str]:\n\n        # TODO: cache the result of this\n\n        if alias_filter is not None:\n            raise NotImplementedError()\n\n        all_stores = self._all_values_store_map.get(value_id)\n        aliases: Set[str] = set()\n        if all_stores:\n            for prefix in all_stores:\n                all_aliases = self._destiny_archives[\n                    prefix\n                ].get_destiny_aliases_for_value(value_id=value_id)\n                if all_aliases is not None:\n                    aliases.update((f\"{prefix}.{a}\" for a in all_aliases))\n\n        current = self._destinies_by_value.get(value_id, None)\n        if current:\n            aliases.update(current.keys())\n\n        return sorted(aliases)\n\n    # def get_destinies_for_value(\n    #     self,\n    #     value_id: uuid.UUID,\n    #     destiny_alias_filter: Optional[str] = None\n    # ) -&gt; Mapping[str, Destiny]:\n    #\n    #\n    #\n    #     return self._destinies_by_value.get(value_id, {})\n\n    def resolve_destiny(self, destiny: Destiny) -&gt; Value:\n\n        results = self._kiara.job_registry.execute_and_retrieve(\n            manifest=destiny, inputs=destiny.merged_inputs\n        )\n        value = results.get_value_obj(field_name=destiny.result_field_name)\n\n        destiny.result_value_id = value.value_id\n\n        return value\n\n    def attach_as_property(\n        self,\n        destiny: Union[uuid.UUID, Destiny],\n        field_names: Union[Iterable[str], None] = None,\n    ):\n\n        if field_names:\n            raise NotImplementedError()\n\n        if isinstance(destiny, uuid.UUID):\n            destiny = self._destinies[destiny]\n\n        values = self._kiara.data_registry.load_values(destiny.fixed_inputs)\n\n        already_stored: List[uuid.UUID] = []\n        for v in values.values():\n            if v.is_stored:\n                already_stored.append(v.value_id)\n\n        if already_stored:\n            stored = (str(v) for v in already_stored)\n            raise Exception(\n                f\"Can't attach destiny as property, value(s) already stored: {', '.join(stored)}\"\n            )\n\n        store_id = self._destiny_store_map[destiny.destiny_id]\n\n        full_path = f\"{store_id}.{destiny.destiny_alias}\"\n\n        for v in values.values():\n            assert destiny.result_value_id is not None\n            v.add_property(\n                value_id=destiny.result_value_id,\n                property_path=full_path,\n                add_origin_to_property_value=True,\n            )\n\n    def store_destiny(self, destiny_id: Union[Destiny, uuid.UUID]):\n\n        try:\n            _destiny_id: uuid.UUID = destiny_id.destiny_id  # type: ignore\n        except Exception:\n            # just in case this is a 'Destiny' object\n            _destiny_id = destiny_id  # type: ignore\n\n        store_id = self._destiny_store_map[_destiny_id]\n        destiny = self._destinies[_destiny_id]\n        store: DestinyStore = self._destiny_archives[store_id]  # type: ignore\n\n        if not isinstance(store, DestinyStore):\n            full_alias = f\"{store_id}.{destiny.destiny_alias}\"\n            raise Exception(\n                f\"Can't store destiny '{full_alias}': prefix '{store_id}' not writable in this kiara context.\"\n            )\n\n        store.persist_destiny(destiny=destiny)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.default_destiny_store","title":"<code>default_destiny_store: DestinyStore</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.destiny_archives","title":"<code>destiny_archives: Mapping[str, DestinyArchive]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.all_values","title":"<code>all_values: Iterable[uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.register_destiny_archive","title":"<code>register_destiny_archive(archive: DestinyArchive, alias: Union[str, None] = None, set_as_default_store: Union[bool, None] = None)</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def register_destiny_archive(\n    self,\n    archive: DestinyArchive,\n    alias: Union[str, None] = None,\n    set_as_default_store: Union[bool, None] = None,\n):\n\n    destiny_store_id = archive.archive_id\n    archive.register_archive(kiara=self._kiara)\n    if alias is None:\n        alias = str(destiny_store_id)\n\n    if alias in self._destiny_archives.keys():\n        raise Exception(\n            f\"Can't add destiny archive, alias '{alias}' already registered.\"\n        )\n\n    self._destiny_archives[alias] = archive\n\n    is_store = False\n    is_default_store = False\n\n    if isinstance(archive, DestinyStore):\n        is_store = True\n\n        if set_as_default_store and self._default_destiny_store is not None:\n            raise Exception(\n                f\"Can't set data store '{alias}' as default store: default store already set.\"\n            )\n\n        if self._default_destiny_store is None or set_as_default_store:\n            is_default_store = True\n            self._default_destiny_store = alias\n\n    event = DestinyArchiveAddedEvent.construct(\n        kiara_id=self._kiara.id,\n        destiny_archive_id=archive.archive_id,\n        destiny_archive_alias=alias,\n        is_store=is_store,\n        is_default_store=is_default_store,\n    )\n    self._event_callback(event)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.add_destiny","title":"<code>add_destiny(destiny_alias: str, values: Dict[str, uuid.UUID], manifest: Manifest, result_field_name: Union[str, None] = None) -&gt; Destiny</code>","text":"<p>Add a destiny for one (or in some rare cases several) values.</p> <p>A destiny alias must be unique for every one of the involved input values.</p> Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def add_destiny(\n    self,\n    destiny_alias: str,\n    values: Dict[str, uuid.UUID],\n    manifest: Manifest,\n    result_field_name: Union[str, None] = None,\n) -&gt; Destiny:\n\"\"\"Add a destiny for one (or in some rare cases several) values.\n\n    A destiny alias must be unique for every one of the involved input values.\n    \"\"\"\n\n    if not values:\n        raise Exception(\"Can't add destiny, no values provided.\")\n\n    store_id, alias = self._extract_archive(destiny_alias)\n\n    destiny = Destiny.create_from_values(\n        kiara=self._kiara,\n        destiny_alias=alias,\n        manifest=manifest,\n        result_field_name=result_field_name,\n        values=values,\n    )\n\n    for value_id in destiny.fixed_inputs.values():\n        self._destinies[destiny.destiny_id] = destiny\n        # TODO: store history?\n        self._destinies_by_value.setdefault(value_id, {})[destiny_alias] = destiny\n        self._cached_value_aliases.setdefault(value_id, {})[destiny_alias] = destiny\n\n    self._destiny_store_map[destiny.destiny_id] = store_id\n\n    return destiny\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.get_destiny","title":"<code>get_destiny(value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def get_destiny(self, value_id: uuid.UUID, destiny_alias: str) -&gt; Destiny:\n\n    destiny = self._destinies_by_value.get(value_id, {}).get(destiny_alias, None)\n    if destiny is None:\n        raise Exception(\n            f\"No destiny '{destiny_alias}' available for value '{value_id}'.\"\n        )\n\n    return destiny\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.get_destiny_aliases_for_value","title":"<code>get_destiny_aliases_for_value(value_id: uuid.UUID, alias_filter: Union[str, None] = None) -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def get_destiny_aliases_for_value(\n    self, value_id: uuid.UUID, alias_filter: Union[str, None] = None\n) -&gt; Iterable[str]:\n\n    # TODO: cache the result of this\n\n    if alias_filter is not None:\n        raise NotImplementedError()\n\n    all_stores = self._all_values_store_map.get(value_id)\n    aliases: Set[str] = set()\n    if all_stores:\n        for prefix in all_stores:\n            all_aliases = self._destiny_archives[\n                prefix\n            ].get_destiny_aliases_for_value(value_id=value_id)\n            if all_aliases is not None:\n                aliases.update((f\"{prefix}.{a}\" for a in all_aliases))\n\n    current = self._destinies_by_value.get(value_id, None)\n    if current:\n        aliases.update(current.keys())\n\n    return sorted(aliases)\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.resolve_destiny","title":"<code>resolve_destiny(destiny: Destiny) -&gt; Value</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def resolve_destiny(self, destiny: Destiny) -&gt; Value:\n\n    results = self._kiara.job_registry.execute_and_retrieve(\n        manifest=destiny, inputs=destiny.merged_inputs\n    )\n    value = results.get_value_obj(field_name=destiny.result_field_name)\n\n    destiny.result_value_id = value.value_id\n\n    return value\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.attach_as_property","title":"<code>attach_as_property(destiny: Union[uuid.UUID, Destiny], field_names: Union[Iterable[str], None] = None)</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def attach_as_property(\n    self,\n    destiny: Union[uuid.UUID, Destiny],\n    field_names: Union[Iterable[str], None] = None,\n):\n\n    if field_names:\n        raise NotImplementedError()\n\n    if isinstance(destiny, uuid.UUID):\n        destiny = self._destinies[destiny]\n\n    values = self._kiara.data_registry.load_values(destiny.fixed_inputs)\n\n    already_stored: List[uuid.UUID] = []\n    for v in values.values():\n        if v.is_stored:\n            already_stored.append(v.value_id)\n\n    if already_stored:\n        stored = (str(v) for v in already_stored)\n        raise Exception(\n            f\"Can't attach destiny as property, value(s) already stored: {', '.join(stored)}\"\n        )\n\n    store_id = self._destiny_store_map[destiny.destiny_id]\n\n    full_path = f\"{store_id}.{destiny.destiny_alias}\"\n\n    for v in values.values():\n        assert destiny.result_value_id is not None\n        v.add_property(\n            value_id=destiny.result_value_id,\n            property_path=full_path,\n            add_origin_to_property_value=True,\n        )\n</code></pre>"},{"location":"reference/kiara/registries/destinies/registry/#kiara.registries.destinies.registry.DestinyRegistry.store_destiny","title":"<code>store_destiny(destiny_id: Union[Destiny, uuid.UUID])</code>","text":"Source code in <code>kiara/registries/destinies/registry.py</code> <pre><code>def store_destiny(self, destiny_id: Union[Destiny, uuid.UUID]):\n\n    try:\n        _destiny_id: uuid.UUID = destiny_id.destiny_id  # type: ignore\n    except Exception:\n        # just in case this is a 'Destiny' object\n        _destiny_id = destiny_id  # type: ignore\n\n    store_id = self._destiny_store_map[_destiny_id]\n    destiny = self._destinies[_destiny_id]\n    store: DestinyStore = self._destiny_archives[store_id]  # type: ignore\n\n    if not isinstance(store, DestinyStore):\n        full_alias = f\"{store_id}.{destiny.destiny_alias}\"\n        raise Exception(\n            f\"Can't store destiny '{full_alias}': prefix '{store_id}' not writable in this kiara context.\"\n        )\n\n    store.persist_destiny(destiny=destiny)\n</code></pre>"},{"location":"reference/kiara/registries/environment/__init__/","title":"environment","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry","title":"<code>EnvironmentRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/environment/__init__.py</code> <pre><code>class EnvironmentRegistry(object):\n\n    _instance = None\n\n    @classmethod\n    def instance(cls) -&gt; \"EnvironmentRegistry\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n        if cls._instance is None:\n            cls._instance = EnvironmentRegistry()\n        return cls._instance\n\n    def __init__(\n        self,\n    ) -&gt; None:\n        self._environments: Union[Dict[str, RuntimeEnvironment], None] = None\n        self._environment_hashes: Union[Dict[str, Mapping[str, str]], None] = None\n\n        self._full_env_model: Union[BaseModel, None] = None\n\n    def get_environment_for_cid(self, env_cid: str) -&gt; RuntimeEnvironment:\n\n        envs = [env for env in self.environments.values() if env.instance_id == env_cid]\n        if len(envs) == 0:\n            raise Exception(f\"No environment with id '{env_cid}' available.\")\n        elif len(envs) &gt; 1:\n            raise Exception(\n                f\"Multipe environments with id '{env_cid}' available. This is most likely a bug.\"\n            )\n        return envs[0]\n\n    @property\n    def environment_hashes(self) -&gt; Mapping[str, Mapping[str, str]]:\n\n        if self._environment_hashes is not None:\n            return self._environment_hashes\n\n        result = {}\n        for env_name, env in self.environments.items():\n            result[env_name] = env.env_hashes\n\n        self._environment_hashes = result\n        return self._environment_hashes\n\n    @property\n    def environments(self) -&gt; Mapping[str, RuntimeEnvironment]:\n\"\"\"Return all environments in this kiara runtime context.\"\"\"\n\n        if self._environments is not None:\n            return self._environments\n\n        import kiara.models.runtime_environment.kiara\n        import kiara.models.runtime_environment.operating_system\n        import kiara.models.runtime_environment.python  # noqa\n\n        subclasses: Iterable[Type[RuntimeEnvironment]] = _get_all_subclasses(\n            RuntimeEnvironment  # type: ignore\n        )\n        envs = {}\n        for sc in subclasses:\n            if inspect.isabstract(sc):\n                if is_debug():\n                    logger.warning(\"class_loading.ignore_subclass\", subclass=sc)\n                else:\n                    logger.debug(\"class_loading.ignore_subclass\", subclass=sc)\n\n            name = sc.get_environment_type_name()\n            envs[name] = sc.create_environment_model()\n\n        self._environments = {k: envs[k] for k in sorted(envs.keys())}\n        return self._environments\n\n    @property\n    def full_model(self) -&gt; BaseModel:\n\"\"\"A model containing all environment data, incl. schemas and hashes of each sub-environment.\"\"\"\n\n        if self._full_env_model is not None:\n            return self._full_env_model\n\n        attrs = {k: (v.__class__, ...) for k, v in self.environments.items()}\n\n        models = {}\n        hashes = {}\n        schemas = {}\n\n        for k, v in attrs.items():\n            name = to_camel_case(f\"{k}_environment\")\n            k_cls: Type[RuntimeEnvironment] = create_model(\n                name,\n                __base__=v[0],\n                metadata_hash=(\n                    str,\n                    Field(\n                        description=\"The hash for this metadata (excl. this and the 'metadata_schema' field).\"\n                    ),\n                ),\n                metadata_schema=(\n                    str,\n                    Field(\n                        description=\"JsonSchema describing this metadata (excl. this and the 'metadata_hash' field).\"\n                    ),\n                ),\n            )\n            models[k] = (\n                k_cls,\n                Field(description=f\"Metadata describing the {k} environment.\"),\n            )\n            schemas[k] = v[0].schema_json()\n            hashes[k] = self.environments[k].instance_cid\n\n        cls: Type[BaseModel] = create_model(\"KiaraRuntimeInfo\", **models)  # type: ignore\n        data = {}\n        for k2, v2 in self.environments.items():\n            d = v2.dict()\n            assert \"metadata_hash\" not in d.keys()\n            assert \"metadata_schema\" not in d.keys()\n            d[\"metadata_hash\"] = str(hashes[k2])\n            d[\"metadata_schema\"] = schemas[k]\n            data[k2] = d\n        model = cls.construct(**data)  # type: ignore\n        self._full_env_model = model\n        return self._full_env_model\n\n    def create_renderable(self, **config: Any):\n\n        full_details = config.get(\"full_details\", False)\n\n        table = Table(show_header=True, box=box.SIMPLE)\n        table.add_column(\"environment key\", style=\"b\")\n        table.add_column(\"details\")\n\n        for env_name, env in self.environments.items():\n            renderable = env.create_renderable(summary=not full_details)\n            table.add_row(env_name, renderable)\n\n        return table\n</code></pre>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.environment_hashes","title":"<code>environment_hashes: Mapping[str, Mapping[str, str]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.environments","title":"<code>environments: Mapping[str, RuntimeEnvironment]</code>  <code>property</code>","text":"<p>Return all environments in this kiara runtime context.</p>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.full_model","title":"<code>full_model: BaseModel</code>  <code>property</code>","text":"<p>A model containing all environment data, incl. schemas and hashes of each sub-environment.</p>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.instance","title":"<code>instance() -&gt; EnvironmentRegistry</code>  <code>classmethod</code>","text":"<p>The default kiara context. In most cases, it's recommended you create and manage your own, though.</p> Source code in <code>kiara/registries/environment/__init__.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; \"EnvironmentRegistry\":\n\"\"\"The default *kiara* context. In most cases, it's recommended you create and manage your own, though.\"\"\"\n\n    if cls._instance is None:\n        cls._instance = EnvironmentRegistry()\n    return cls._instance\n</code></pre>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.get_environment_for_cid","title":"<code>get_environment_for_cid(env_cid: str) -&gt; RuntimeEnvironment</code>","text":"Source code in <code>kiara/registries/environment/__init__.py</code> <pre><code>def get_environment_for_cid(self, env_cid: str) -&gt; RuntimeEnvironment:\n\n    envs = [env for env in self.environments.values() if env.instance_id == env_cid]\n    if len(envs) == 0:\n        raise Exception(f\"No environment with id '{env_cid}' available.\")\n    elif len(envs) &gt; 1:\n        raise Exception(\n            f\"Multipe environments with id '{env_cid}' available. This is most likely a bug.\"\n        )\n    return envs[0]\n</code></pre>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment.EnvironmentRegistry.create_renderable","title":"<code>create_renderable(**config: Any)</code>","text":"Source code in <code>kiara/registries/environment/__init__.py</code> <pre><code>def create_renderable(self, **config: Any):\n\n    full_details = config.get(\"full_details\", False)\n\n    table = Table(show_header=True, box=box.SIMPLE)\n    table.add_column(\"environment key\", style=\"b\")\n    table.add_column(\"details\")\n\n    for env_name, env in self.environments.items():\n        renderable = env.create_renderable(summary=not full_details)\n        table.add_row(env_name, renderable)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/registries/environment/__init__/#kiara.registries.environment-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/events/__init__/","title":"events","text":""},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.EventListener","title":"<code>EventListener</code>","text":"<p>         Bases: <code>Protocol</code></p> Source code in <code>kiara/registries/events/__init__.py</code> <pre><code>class EventListener(Protocol):\n    def handle_events(self, *events: KiaraEvent) -&gt; Any:\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.EventListener-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.EventListener.handle_events","title":"<code>handle_events(*events: KiaraEvent) -&gt; Any</code>","text":"Source code in <code>kiara/registries/events/__init__.py</code> <pre><code>def handle_events(self, *events: KiaraEvent) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.AsyncEventListener","title":"<code>AsyncEventListener</code>","text":"<p>         Bases: <code>Protocol</code></p> Source code in <code>kiara/registries/events/__init__.py</code> <pre><code>class AsyncEventListener(Protocol):\n    def wait_for_processing(self, processing_id: Any):\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.AsyncEventListener-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.AsyncEventListener.wait_for_processing","title":"<code>wait_for_processing(processing_id: Any)</code>","text":"Source code in <code>kiara/registries/events/__init__.py</code> <pre><code>def wait_for_processing(self, processing_id: Any):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/events/__init__/#kiara.registries.events.EventProducer","title":"<code>EventProducer</code>","text":"<p>         Bases: <code>Protocol</code></p> Source code in <code>kiara/registries/events/__init__.py</code> <pre><code>class EventProducer(Protocol):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/events/metadata/","title":"metadata","text":""},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies","title":"<code>CreateMetadataDestinies</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/events/metadata.py</code> <pre><code>class CreateMetadataDestinies(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n        self._skip_internal_types: bool = True\n\n    def supported_event_types(self) -&gt; Iterable[str]:\n        return [\"value_created\", \"value_registered\"]\n\n    def handle_events(self, *events: KiaraEvent) -&gt; Any:\n\n        for event in events:\n            if event.get_event_type() == \"value_created\":  # type: ignore\n                if event.value.is_set:  # type: ignore\n                    self.attach_metadata(event.value)  # type: ignore\n\n        for event in events:\n            if event.get_event_type() == \"value_registered\":  # type: ignore\n                self.resolve_all_metadata(event.value)  # type: ignore\n\n    def attach_metadata(self, value: Value):\n\n        assert not value.is_stored\n\n        if self._skip_internal_types:\n\n            if value.value_schema.type == \"any\":\n                return\n            lineage = self._kiara.type_registry.get_type_lineage(\n                value.value_schema.type\n            )\n            if \"any\" not in lineage:\n                return\n\n        op_type: ExtractMetadataOperationType = self._kiara.operation_registry.get_operation_type(\"extract_metadata\")  # type: ignore\n        operations = op_type.get_operations_for_data_type(value.value_schema.type)\n        for metadata_key, op in operations.items():\n            op_details: ExtractMetadataDetails = op.operation_details  # type: ignore\n            input_field_name = op_details.input_field_name\n            result_field_name = op_details.result_field_name\n            self._kiara.destiny_registry.add_destiny(\n                destiny_alias=f\"metadata.{metadata_key}\",\n                values={input_field_name: value.value_id},\n                manifest=op,\n                result_field_name=result_field_name,\n            )\n\n    def resolve_all_metadata(self, value: Value):\n\n        if self._skip_internal_types:\n\n            lineage = self._kiara.type_registry.get_type_lineage(\n                value.value_schema.type\n            )\n            if \"any\" not in lineage:\n                return\n\n        assert not value.is_stored\n\n        aliases = self._kiara.destiny_registry.get_destiny_aliases_for_value(\n            value_id=value.value_id\n        )\n\n        for alias in aliases:\n            destiny = self._kiara.destiny_registry.get_destiny(\n                value_id=value.value_id, destiny_alias=alias\n            )\n            self._kiara.destiny_registry.resolve_destiny(destiny)\n            self._kiara.destiny_registry.attach_as_property(destiny)\n</code></pre>"},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies.supported_event_types","title":"<code>supported_event_types() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/registries/events/metadata.py</code> <pre><code>def supported_event_types(self) -&gt; Iterable[str]:\n    return [\"value_created\", \"value_registered\"]\n</code></pre>"},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies.handle_events","title":"<code>handle_events(*events: KiaraEvent) -&gt; Any</code>","text":"Source code in <code>kiara/registries/events/metadata.py</code> <pre><code>def handle_events(self, *events: KiaraEvent) -&gt; Any:\n\n    for event in events:\n        if event.get_event_type() == \"value_created\":  # type: ignore\n            if event.value.is_set:  # type: ignore\n                self.attach_metadata(event.value)  # type: ignore\n\n    for event in events:\n        if event.get_event_type() == \"value_registered\":  # type: ignore\n            self.resolve_all_metadata(event.value)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies.attach_metadata","title":"<code>attach_metadata(value: Value)</code>","text":"Source code in <code>kiara/registries/events/metadata.py</code> <pre><code>def attach_metadata(self, value: Value):\n\n    assert not value.is_stored\n\n    if self._skip_internal_types:\n\n        if value.value_schema.type == \"any\":\n            return\n        lineage = self._kiara.type_registry.get_type_lineage(\n            value.value_schema.type\n        )\n        if \"any\" not in lineage:\n            return\n\n    op_type: ExtractMetadataOperationType = self._kiara.operation_registry.get_operation_type(\"extract_metadata\")  # type: ignore\n    operations = op_type.get_operations_for_data_type(value.value_schema.type)\n    for metadata_key, op in operations.items():\n        op_details: ExtractMetadataDetails = op.operation_details  # type: ignore\n        input_field_name = op_details.input_field_name\n        result_field_name = op_details.result_field_name\n        self._kiara.destiny_registry.add_destiny(\n            destiny_alias=f\"metadata.{metadata_key}\",\n            values={input_field_name: value.value_id},\n            manifest=op,\n            result_field_name=result_field_name,\n        )\n</code></pre>"},{"location":"reference/kiara/registries/events/metadata/#kiara.registries.events.metadata.CreateMetadataDestinies.resolve_all_metadata","title":"<code>resolve_all_metadata(value: Value)</code>","text":"Source code in <code>kiara/registries/events/metadata.py</code> <pre><code>def resolve_all_metadata(self, value: Value):\n\n    if self._skip_internal_types:\n\n        lineage = self._kiara.type_registry.get_type_lineage(\n            value.value_schema.type\n        )\n        if \"any\" not in lineage:\n            return\n\n    assert not value.is_stored\n\n    aliases = self._kiara.destiny_registry.get_destiny_aliases_for_value(\n        value_id=value.value_id\n    )\n\n    for alias in aliases:\n        destiny = self._kiara.destiny_registry.get_destiny(\n            value_id=value.value_id, destiny_alias=alias\n        )\n        self._kiara.destiny_registry.resolve_destiny(destiny)\n        self._kiara.destiny_registry.attach_as_property(destiny)\n</code></pre>"},{"location":"reference/kiara/registries/events/registry/","title":"registry","text":""},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.AllEvents","title":"<code>AllEvents</code>","text":"<p>         Bases: <code>KiaraEvent</code></p> Source code in <code>kiara/registries/events/registry.py</code> <pre><code>class AllEvents(KiaraEvent):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.EventRegistry","title":"<code>EventRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/events/registry.py</code> <pre><code>class EventRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n        self._producers: Dict[uuid.UUID, EventProducer] = {}\n        self._listeners: Dict[uuid.UUID, EventListener] = {}\n        self._subscriptions: Dict[uuid.UUID, List[str]] = {}\n\n    def add_producer(self, producer: EventProducer) -&gt; Callable:\n\n        producer_id = ID_REGISTRY.generate(\n            obj=producer, comment=\"adding event producer\"\n        )\n        func = partial(self.handle_events, producer_id)\n        return func\n\n    def add_listener(self, listener, *subscriptions: str):\n\n        if not subscriptions:\n            _subscriptions = [\"*\"]\n        else:\n            _subscriptions = list(subscriptions)\n\n        listener_id = ID_REGISTRY.generate(\n            obj=listener, comment=\"adding event listener\"\n        )\n        self._listeners[listener_id] = listener\n        self._subscriptions[listener_id] = _subscriptions\n\n    def _matches_subscription(\n        self, events: Iterable[KiaraEvent], subscriptions: Iterable[str]\n    ) -&gt; Iterable[KiaraEvent]:\n\n        result = []\n        for subscription in subscriptions:\n            for event in events:\n                match = fnmatch.filter([event.get_event_type()], subscription)\n                if match:\n                    result.append(event)\n\n        return result\n\n    def handle_events(self, producer_id: uuid.UUID, *events: KiaraEvent):\n\n        event_targets: Dict[uuid.UUID, List[KiaraEvent]] = {}\n\n        for l_id, listener in self._listeners.items():\n            matches = self._matches_subscription(\n                events=events, subscriptions=self._subscriptions[l_id]\n            )\n            if matches:\n                event_targets.setdefault(l_id, []).extend(matches)\n\n        responses = {}\n        for l_id, l_events in event_targets.items():\n            listener = self._listeners[l_id]\n            response = listener.handle_events(*l_events)\n            responses[l_id] = response\n\n        for l_id, response in responses.items():\n            if response is None:\n                continue\n\n            a_listener: AsyncEventListener = self._listeners[l_id]  # type: ignore\n            if not hasattr(a_listener, \"wait_for_processing\"):\n                raise Exception(\n                    \"Can't wait for processing of event for listener: listener does not provide 'wait_for_processing' method.\"\n                )\n            a_listener.wait_for_processing(response)\n</code></pre>"},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.EventRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.EventRegistry.add_producer","title":"<code>add_producer(producer: EventProducer) -&gt; Callable</code>","text":"Source code in <code>kiara/registries/events/registry.py</code> <pre><code>def add_producer(self, producer: EventProducer) -&gt; Callable:\n\n    producer_id = ID_REGISTRY.generate(\n        obj=producer, comment=\"adding event producer\"\n    )\n    func = partial(self.handle_events, producer_id)\n    return func\n</code></pre>"},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.EventRegistry.add_listener","title":"<code>add_listener(listener, *subscriptions: str)</code>","text":"Source code in <code>kiara/registries/events/registry.py</code> <pre><code>def add_listener(self, listener, *subscriptions: str):\n\n    if not subscriptions:\n        _subscriptions = [\"*\"]\n    else:\n        _subscriptions = list(subscriptions)\n\n    listener_id = ID_REGISTRY.generate(\n        obj=listener, comment=\"adding event listener\"\n    )\n    self._listeners[listener_id] = listener\n    self._subscriptions[listener_id] = _subscriptions\n</code></pre>"},{"location":"reference/kiara/registries/events/registry/#kiara.registries.events.registry.EventRegistry.handle_events","title":"<code>handle_events(producer_id: uuid.UUID, *events: KiaraEvent)</code>","text":"Source code in <code>kiara/registries/events/registry.py</code> <pre><code>def handle_events(self, producer_id: uuid.UUID, *events: KiaraEvent):\n\n    event_targets: Dict[uuid.UUID, List[KiaraEvent]] = {}\n\n    for l_id, listener in self._listeners.items():\n        matches = self._matches_subscription(\n            events=events, subscriptions=self._subscriptions[l_id]\n        )\n        if matches:\n            event_targets.setdefault(l_id, []).extend(matches)\n\n    responses = {}\n    for l_id, l_events in event_targets.items():\n        listener = self._listeners[l_id]\n        response = listener.handle_events(*l_events)\n        responses[l_id] = response\n\n    for l_id, response in responses.items():\n        if response is None:\n            continue\n\n        a_listener: AsyncEventListener = self._listeners[l_id]  # type: ignore\n        if not hasattr(a_listener, \"wait_for_processing\"):\n            raise Exception(\n                \"Can't wait for processing of event for listener: listener does not provide 'wait_for_processing' method.\"\n            )\n        a_listener.wait_for_processing(response)\n</code></pre>"},{"location":"reference/kiara/registries/ids/__init__/","title":"ids","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.ID_REGISTRY","title":"<code>ID_REGISTRY = IdRegistry()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.NO_TYPE_MARKER","title":"<code>NO_TYPE_MARKER</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/ids/__init__.py</code> <pre><code>class NO_TYPE_MARKER(object):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.IdRegistry","title":"<code>IdRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/ids/__init__.py</code> <pre><code>class IdRegistry(object):\n    def __init__(self) -&gt; None:\n        self._ids: Dict[uuid.UUID, Dict[Type, Dict[str, Any]]] = {}\n        self._objs: Dict[uuid.UUID, WeakValueDictionary[Type, Any]] = {}\n\n    def generate(\n        self,\n        id: Union[uuid.UUID, None] = None,\n        obj_type: Union[Type, None] = None,\n        obj: Union[Any, None] = None,\n        **metadata: Any\n    ):\n\n        if id is None:\n            id = uuid.uuid4()\n\n        if is_debug() or is_develop():\n\n            # logger.debug(\"generate.id\", id=id, metadata=metadata)\n            if obj_type is None:\n                if obj:\n                    obj_type = obj.__class__\n                else:\n                    obj_type = NO_TYPE_MARKER\n            self._ids.setdefault(id, {}).setdefault(obj_type, {}).update(metadata)\n            if obj:\n                self._objs.setdefault(id, WeakValueDictionary())[obj_type] = obj\n\n        return id\n\n    def update_metadata(\n        self,\n        id: uuid.UUID,\n        obj_type: Union[Type, None] = None,\n        obj: Union[Any, None] = None,\n        **metadata\n    ):\n\n        if not is_debug() and not is_develop():\n            return\n\n        if obj_type is None:\n            if obj:\n                obj_type = obj.__class__\n            else:\n                obj_type = NO_TYPE_MARKER\n        self._ids.setdefault(id, {}).setdefault(obj_type, {}).update(metadata)\n        if obj:\n            self._objs.setdefault(id, WeakValueDictionary())[obj_type] = obj\n</code></pre>"},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.IdRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.IdRegistry.generate","title":"<code>generate(id: Union[uuid.UUID, None] = None, obj_type: Union[Type, None] = None, obj: Union[Any, None] = None, **metadata: Any)</code>","text":"Source code in <code>kiara/registries/ids/__init__.py</code> <pre><code>def generate(\n    self,\n    id: Union[uuid.UUID, None] = None,\n    obj_type: Union[Type, None] = None,\n    obj: Union[Any, None] = None,\n    **metadata: Any\n):\n\n    if id is None:\n        id = uuid.uuid4()\n\n    if is_debug() or is_develop():\n\n        # logger.debug(\"generate.id\", id=id, metadata=metadata)\n        if obj_type is None:\n            if obj:\n                obj_type = obj.__class__\n            else:\n                obj_type = NO_TYPE_MARKER\n        self._ids.setdefault(id, {}).setdefault(obj_type, {}).update(metadata)\n        if obj:\n            self._objs.setdefault(id, WeakValueDictionary())[obj_type] = obj\n\n    return id\n</code></pre>"},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids.IdRegistry.update_metadata","title":"<code>update_metadata(id: uuid.UUID, obj_type: Union[Type, None] = None, obj: Union[Any, None] = None, **metadata)</code>","text":"Source code in <code>kiara/registries/ids/__init__.py</code> <pre><code>def update_metadata(\n    self,\n    id: uuid.UUID,\n    obj_type: Union[Type, None] = None,\n    obj: Union[Any, None] = None,\n    **metadata\n):\n\n    if not is_debug() and not is_develop():\n        return\n\n    if obj_type is None:\n        if obj:\n            obj_type = obj.__class__\n        else:\n            obj_type = NO_TYPE_MARKER\n    self._ids.setdefault(id, {}).setdefault(obj_type, {}).update(metadata)\n    if obj:\n        self._objs.setdefault(id, WeakValueDictionary())[obj_type] = obj\n</code></pre>"},{"location":"reference/kiara/registries/ids/__init__/#kiara.registries.ids-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/","title":"jobs","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.MANIFEST_SUB_PATH","title":"<code>MANIFEST_SUB_PATH = 'manifests'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobArchive","title":"<code>JobArchive</code>","text":"<p>         Bases: <code>BaseArchive</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class JobArchive(BaseArchive):\n    # @abc.abstractmethod\n    # def find_matching_job_record(\n    #     self, inputs_manifest: InputsManifest\n    # ) -&gt; Optional[JobRecord]:\n    #     pass\n\n    @abc.abstractmethod\n    def retrieve_all_job_hashes(\n        self,\n        manifest_hash: Union[str, None] = None,\n        inputs_hash: Union[str, None] = None,\n    ) -&gt; Iterable[str]:\n\"\"\"Retrieve a list of all job record hashes (cids) that match the given filter arguments.\n\n        A job record hash includes information about the module type used in the job, the module configuration, as well as input field names and value ids for the values used in those inputs.\n\n        If the job archive retrieves its jobs in a dynamic way, this will return 'None'.\n        \"\"\"\n\n    @abc.abstractmethod\n    def _retrieve_record_for_job_hash(self, job_hash: str) -&gt; Union[JobRecord, None]:\n        pass\n\n    def retrieve_record_for_job_hash(self, job_hash: str) -&gt; Union[JobRecord, None]:\n\n        job_record = self._retrieve_record_for_job_hash(job_hash=job_hash)\n        return job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobArchive.retrieve_all_job_hashes","title":"<code>retrieve_all_job_hashes(manifest_hash: Union[str, None] = None, inputs_hash: Union[str, None] = None) -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"<p>Retrieve a list of all job record hashes (cids) that match the given filter arguments.</p> <p>A job record hash includes information about the module type used in the job, the module configuration, as well as input field names and value ids for the values used in those inputs.</p> <p>If the job archive retrieves its jobs in a dynamic way, this will return 'None'.</p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_all_job_hashes(\n    self,\n    manifest_hash: Union[str, None] = None,\n    inputs_hash: Union[str, None] = None,\n) -&gt; Iterable[str]:\n\"\"\"Retrieve a list of all job record hashes (cids) that match the given filter arguments.\n\n    A job record hash includes information about the module type used in the job, the module configuration, as well as input field names and value ids for the values used in those inputs.\n\n    If the job archive retrieves its jobs in a dynamic way, this will return 'None'.\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobArchive.retrieve_record_for_job_hash","title":"<code>retrieve_record_for_job_hash(job_hash: str) -&gt; Union[JobRecord, None]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def retrieve_record_for_job_hash(self, job_hash: str) -&gt; Union[JobRecord, None]:\n\n    job_record = self._retrieve_record_for_job_hash(job_hash=job_hash)\n    return job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobStore","title":"<code>JobStore</code>","text":"<p>         Bases: <code>JobArchive</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class JobStore(JobArchive):\n    @abc.abstractmethod\n    def store_job_record(self, job_record: JobRecord):\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobStore.store_job_record","title":"<code>store_job_record(job_record: JobRecord)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>@abc.abstractmethod\ndef store_job_record(self, job_record: JobRecord):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobMatcher","title":"<code>JobMatcher</code>","text":"<p>         Bases: <code>abc.ABC</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class JobMatcher(abc.ABC):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n    @abc.abstractmethod\n    def find_existing_job(\n        self, inputs_manifest: InputsManifest\n    ) -&gt; Union[JobRecord, None]:\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobMatcher.find_existing_job","title":"<code>find_existing_job(inputs_manifest: InputsManifest) -&gt; Union[JobRecord, None]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>@abc.abstractmethod\ndef find_existing_job(\n    self, inputs_manifest: InputsManifest\n) -&gt; Union[JobRecord, None]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.NoneJobMatcher","title":"<code>NoneJobMatcher</code>","text":"<p>         Bases: <code>JobMatcher</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class NoneJobMatcher(JobMatcher):\n    def find_existing_job(\n        self, inputs_manifest: InputsManifest\n    ) -&gt; Union[JobRecord, None]:\n        return None\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.NoneJobMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.NoneJobMatcher.find_existing_job","title":"<code>find_existing_job(inputs_manifest: InputsManifest) -&gt; Union[JobRecord, None]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def find_existing_job(\n    self, inputs_manifest: InputsManifest\n) -&gt; Union[JobRecord, None]:\n    return None\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.ValueIdJobMatcher","title":"<code>ValueIdJobMatcher</code>","text":"<p>         Bases: <code>JobMatcher</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class ValueIdJobMatcher(JobMatcher):\n    def find_existing_job(\n        self, inputs_manifest: InputsManifest\n    ) -&gt; Union[JobRecord, None]:\n\n        matches = []\n\n        for store_id, archive in self._kiara.job_registry.job_archives.items():\n\n            match = archive.retrieve_record_for_job_hash(\n                job_hash=inputs_manifest.job_hash\n            )\n            if match:\n                matches.append(match)\n\n        if len(matches) == 0:\n            return None\n        elif len(matches) &gt; 1:\n            raise Exception(\n                f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n            )\n\n        job_record = matches[0]\n        job_record._is_stored = True\n\n        return job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.ValueIdJobMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.ValueIdJobMatcher.find_existing_job","title":"<code>find_existing_job(inputs_manifest: InputsManifest) -&gt; Union[JobRecord, None]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def find_existing_job(\n    self, inputs_manifest: InputsManifest\n) -&gt; Union[JobRecord, None]:\n\n    matches = []\n\n    for store_id, archive in self._kiara.job_registry.job_archives.items():\n\n        match = archive.retrieve_record_for_job_hash(\n            job_hash=inputs_manifest.job_hash\n        )\n        if match:\n            matches.append(match)\n\n    if len(matches) == 0:\n        return None\n    elif len(matches) &gt; 1:\n        raise Exception(\n            f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n        )\n\n    job_record = matches[0]\n    job_record._is_stored = True\n\n    return job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.DataHashJobMatcher","title":"<code>DataHashJobMatcher</code>","text":"<p>         Bases: <code>JobMatcher</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class DataHashJobMatcher(JobMatcher):\n    def find_existing_job(\n        self, inputs_manifest: InputsManifest\n    ) -&gt; Union[JobRecord, None]:\n\n        matches = []\n\n        for store_id, archive in self._kiara.job_registry.job_archives.items():\n\n            match = archive.retrieve_record_for_job_hash(\n                job_hash=inputs_manifest.job_hash\n            )\n            if match:\n                matches.append(match)\n\n        if len(matches) &gt; 1:\n            raise Exception(\n                f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n            )\n\n        elif len(matches) == 1:\n\n            job_record = matches[0]\n            job_record._is_stored = True\n\n            return job_record\n\n        inputs_data_cid = inputs_manifest.calculate_inputs_data_cid(\n            data_registry=self._kiara.data_registry\n        )\n        if not inputs_data_cid:\n            return None\n\n        inputs_data_hash = str(inputs_data_cid)\n\n        matching_records = []\n        for store_id, archive in self._kiara.job_registry.job_archives.items():\n            _matches = archive.retrieve_all_job_hashes(\n                manifest_hash=inputs_manifest.manifest_hash\n            )\n            for _match in _matches:\n                _job_record = archive.retrieve_record_for_job_hash(_match)\n                assert _job_record is not None\n                if _job_record.inputs_data_hash == inputs_data_hash:\n                    matching_records.append(_job_record)\n\n        if not matching_records:\n            return None\n        elif len(matches) &gt; 1:\n            raise Exception(\n                f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n            )\n        else:\n            return matching_records[0]\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.DataHashJobMatcher-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.DataHashJobMatcher.find_existing_job","title":"<code>find_existing_job(inputs_manifest: InputsManifest) -&gt; Union[JobRecord, None]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def find_existing_job(\n    self, inputs_manifest: InputsManifest\n) -&gt; Union[JobRecord, None]:\n\n    matches = []\n\n    for store_id, archive in self._kiara.job_registry.job_archives.items():\n\n        match = archive.retrieve_record_for_job_hash(\n            job_hash=inputs_manifest.job_hash\n        )\n        if match:\n            matches.append(match)\n\n    if len(matches) &gt; 1:\n        raise Exception(\n            f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n        )\n\n    elif len(matches) == 1:\n\n        job_record = matches[0]\n        job_record._is_stored = True\n\n        return job_record\n\n    inputs_data_cid = inputs_manifest.calculate_inputs_data_cid(\n        data_registry=self._kiara.data_registry\n    )\n    if not inputs_data_cid:\n        return None\n\n    inputs_data_hash = str(inputs_data_cid)\n\n    matching_records = []\n    for store_id, archive in self._kiara.job_registry.job_archives.items():\n        _matches = archive.retrieve_all_job_hashes(\n            manifest_hash=inputs_manifest.manifest_hash\n        )\n        for _match in _matches:\n            _job_record = archive.retrieve_record_for_job_hash(_match)\n            assert _job_record is not None\n            if _job_record.inputs_data_hash == inputs_data_hash:\n                matching_records.append(_job_record)\n\n    if not matching_records:\n        return None\n    elif len(matches) &gt; 1:\n        raise Exception(\n            f\"Multiple stores have a record for inputs manifest '{inputs_manifest}', this is not supported (yet).\"\n        )\n    else:\n        return matching_records[0]\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry","title":"<code>JobRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>class JobRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n        self._job_matcher_cache: Dict[JobCacheStrategy, JobMatcher] = {}\n\n        self._active_jobs: bidict[str, uuid.UUID] = bidict()\n        self._failed_jobs: Dict[str, uuid.UUID] = {}\n        self._finished_jobs: Dict[str, uuid.UUID] = {}\n        self._archived_records: Dict[uuid.UUID, JobRecord] = {}\n\n        self._processor: ModuleProcessor = SynchronousProcessor(kiara=self._kiara)\n        self._processor.register_job_status_listener(self)\n        self._job_archives: Dict[str, JobArchive] = {}\n        self._default_job_store: Union[str, None] = None\n\n        self._event_callback = self._kiara.event_registry.add_producer(self)\n\n        # default_archive = FileSystemJobStore.create_from_kiara_context(self._kiara)\n        # self.register_job_archive(default_archive, store_alias=DEFAULT_STORE_MARKER)\n\n        # default_file_store = self._kiara.data_registry.get_archive(DEFAULT_STORE_MARKER)\n        # self.register_job_archive(default_file_store, store_alias=\"default_data_store\")  # type: ignore\n\n    @property\n    def job_matcher(self) -&gt; JobMatcher:\n\n        from kiara.context.config import JobCacheStrategy\n\n        strategy = self._kiara.runtime_config.job_cache\n        if is_develop():\n            dev_config = get_dev_config()\n            if not dev_config.job_cache:\n                logger.debug(\n                    \"disable.job_cache\",\n                    reason=\"dev mode enabled and 'disable_job_cache' is set.\",\n                )\n                strategy = JobCacheStrategy.no_cache\n\n        job_matcher = self._job_matcher_cache.get(strategy, None)\n        if job_matcher is None:\n            if strategy == JobCacheStrategy.no_cache:\n                job_matcher = NoneJobMatcher(kiara=self._kiara)\n            elif strategy == JobCacheStrategy.value_id:\n                job_matcher = ValueIdJobMatcher(kiara=self._kiara)\n            elif strategy == JobCacheStrategy.data_hash:\n                job_matcher = DataHashJobMatcher(kiara=self._kiara)\n            else:\n                raise Exception(f\"Job cache strategy not implemented: {strategy}\")\n            self._job_matcher_cache[strategy] = job_matcher\n\n        return job_matcher\n\n    def suppoerted_event_types(self) -&gt; Iterable[Type[KiaraEvent]]:\n\n        return [JobArchiveAddedEvent, JobRecordPreStoreEvent, JobRecordStoredEvent]\n\n    def register_job_archive(self, archive: JobArchive, alias: Union[str, None] = None):\n\n        if alias is None:\n            alias = str(archive.archive_id)\n\n        if alias in self._job_archives.keys():\n            raise Exception(\n                f\"Can't register job store, store id already registered: {alias}.\"\n            )\n\n        self._job_archives[alias] = archive\n\n        is_store = False\n        is_default_store = False\n        if isinstance(archive, JobStore):\n            is_store = True\n            if self._default_job_store is None:\n                self._default_job_store = alias\n\n        event = JobArchiveAddedEvent.construct(\n            kiara_id=self._kiara.id,\n            job_archive_id=archive.archive_id,\n            job_archive_alias=alias,\n            is_store=is_store,\n            is_default_store=is_default_store,\n        )\n        self._event_callback(event)\n\n    @property\n    def default_job_store(self) -&gt; str:\n\n        if self._default_job_store is None:\n            raise Exception(\"No default job store set (yet).\")\n        return self._default_job_store  # type: ignore\n\n    def get_archive(self, store_id: Union[str, None] = None) -&gt; JobArchive:\n\n        if store_id is None:\n            store_id = self.default_job_store\n            if store_id is None:\n                raise Exception(\"Can't retrieve deafult job archive, none set (yet).\")\n\n        return self._job_archives[store_id]\n\n    @property\n    def job_archives(self) -&gt; Mapping[str, JobArchive]:\n        return self._job_archives\n\n    def job_status_changed(\n        self,\n        job_id: uuid.UUID,\n        old_status: Union[JobStatus, None],\n        new_status: JobStatus,\n    ):\n\n        # print(f\"JOB STATUS CHANGED: {job_id} - {old_status} - {new_status.value}\")\n        if job_id in self._active_jobs.values() and new_status is JobStatus.FAILED:\n            job_hash = self._active_jobs.inverse.pop(job_id)\n            self._failed_jobs[job_hash] = job_id\n        elif job_id in self._active_jobs.values() and new_status is JobStatus.SUCCESS:\n            job_hash = self._active_jobs.inverse.pop(job_id)\n\n            job_record = self._processor.get_job_record(job_id)\n\n            self._finished_jobs[job_hash] = job_id\n            self._archived_records[job_id] = job_record\n\n    def store_job_record(self, job_id: uuid.UUID):\n\n        if job_id not in self._archived_records.keys():\n            raise Exception(\n                f\"Can't store job with id '{job_id}': no job record with that id exists.\"\n            )\n\n        job_record = self._archived_records[job_id]\n\n        if job_record._is_stored:\n            logger.debug(\n                \"ignore.store.job_record\", reason=\"already stored\", job_id=str(job_id)\n            )\n            return\n\n        store: JobStore = self.get_archive()  # type: ignore\n        if not isinstance(store, JobStore):\n            raise Exception(\"Can't store job record to archive: not writable.\")\n\n        # if job_record.job_id in self._finished_jobs.values():\n        #     logger.debug(\n        #         \"ignore.store.job_record\",\n        #         reason=\"already stored in store\",\n        #         job_id=str(job_id),\n        #     )\n        #     return\n\n        logger.debug(\n            \"store.job_record\",\n            job_hash=job_record.job_hash,\n            module_type=job_record.module_type,\n        )\n\n        pre_store_event = JobRecordPreStoreEvent.construct(\n            kiara_id=self._kiara.id, job_record=job_record\n        )\n        self._event_callback(pre_store_event)\n\n        store.store_job_record(job_record)\n\n        stored_event = JobRecordStoredEvent.construct(\n            kiara_id=self._kiara.id, job_record=job_record\n        )\n        self._event_callback(stored_event)\n\n    def get_job_record_in_session(self, job_id: uuid.UUID) -&gt; JobRecord:\n\n        return self._processor.get_job_record(job_id)\n\n    def get_job_record(self, job_id: uuid.UUID) -&gt; Union[JobRecord, None]:\n\n        if job_id in self._archived_records.keys():\n            return self._archived_records[job_id]\n\n        try:\n            job_record = self._processor.get_job_record(job_id=job_id)\n            return job_record\n        except Exception:\n            pass\n\n        job = self._processor.get_job(job_id=job_id)\n        if job is not None:\n            if job.status == JobStatus.FAILED:\n                return None\n\n        raise NotImplementedError()\n\n    def retrieve_all_job_records(self) -&gt; Mapping[str, JobRecord]:\n\n        all_records: Dict[str, JobRecord] = {}\n        for archive in self.job_archives.values():\n            all_record_ids = archive.retrieve_all_job_hashes()\n            if all_record_ids is None:\n                return {}\n            for r in all_record_ids:\n                assert r not in all_records.keys()\n                job_record = archive.retrieve_record_for_job_hash(r)\n                assert job_record is not None\n                all_records[r] = job_record\n\n        return all_records\n\n    def find_matching_job_record(\n        self, inputs_manifest: InputsManifest\n    ) -&gt; Union[uuid.UUID, None]:\n\"\"\"Check if a job with same inputs manifest already ran some time before.\n\n        Arguments:\n            inputs_manifest: the manifest incl. inputs\n\n        Returns:\n            'None' if no such job exists, a (uuid) job-id if the job is currently running or has run in the past\n        \"\"\"\n\n        log = logger.bind(module_type=inputs_manifest.module_type)\n        if inputs_manifest.job_hash in self._active_jobs.keys():\n            log.debug(\"job.use_running\")\n            return self._active_jobs[inputs_manifest.job_hash]\n\n        if inputs_manifest.job_hash in self._finished_jobs.keys():\n            job_id = self._finished_jobs[inputs_manifest.job_hash]\n            return job_id\n\n        module = self._kiara.module_registry.create_module(manifest=inputs_manifest)\n        if not module.characteristics.is_idempotent:\n            log.debug(\n                \"skip.job_matching\",\n                reason=\"module is not idempotent\",\n                module_type=inputs_manifest.module_type,\n            )\n            return None\n\n        job_record = self.job_matcher.find_existing_job(inputs_manifest=inputs_manifest)\n        if job_record is None:\n            return None\n\n        self._finished_jobs[inputs_manifest.job_hash] = job_record.job_id\n        self._archived_records[job_record.job_id] = job_record\n        log.debug(\n            \"job.found_cached_record\",\n            job_id=str(job_record.job_id),\n            job_hash=inputs_manifest.job_hash,\n            module_type=inputs_manifest.module_type,\n        )\n        return job_record.job_id\n\n    def prepare_job_config(\n        self, manifest: Manifest, inputs: Mapping[str, Any]\n    ) -&gt; JobConfig:\n\n        module = self._kiara.module_registry.create_module(manifest=manifest)\n\n        job_config = JobConfig.create_from_module(\n            data_registry=self._kiara.data_registry, module=module, inputs=inputs\n        )\n\n        return job_config\n\n    def execute(\n        self,\n        manifest: Manifest,\n        inputs: Mapping[str, Any],\n        wait: bool = False,\n        job_metadata: Union[None, Any] = None,\n    ) -&gt; uuid.UUID:\n\n        job_config = self.prepare_job_config(manifest=manifest, inputs=inputs)\n        return self.execute_job(job_config, wait=wait, job_metadata=job_metadata)\n\n    def execute_job(\n        self,\n        job_config: JobConfig,\n        wait: bool = False,\n        job_metadata: Union[None, Any] = None,\n    ) -&gt; uuid.UUID:\n\n        log = logger.bind(\n            module_type=job_config.module_type,\n            module_config=job_config.module_config,\n            inputs={k: str(v) for k, v in job_config.inputs.items()},\n            job_hash=job_config.job_hash,\n        )\n\n        stored_job = self.find_matching_job_record(inputs_manifest=job_config)\n        if stored_job is not None:\n            log.debug(\n                \"job.use_cached\",\n                job_id=str(stored_job),\n                module_type=job_config.module_type,\n            )\n            return stored_job\n\n        if job_metadata is None:\n            job_metadata = {}\n\n        is_pipeline_step = job_metadata.get(\"is_pipeline_step\", False)\n        dbg_data = {\n            \"module_type\": job_config.module_type,\n            \"is_pipeline_step\": is_pipeline_step,\n        }\n        if is_pipeline_step:\n            dbg_data[\"step_id\"] = job_metadata[\"step_id\"]\n        log.debug(\"job.execute\", **dbg_data)\n\n        job_id = self._processor.create_job(\n            job_config=job_config, job_metadata=job_metadata\n        )\n        self._active_jobs[job_config.job_hash] = job_id\n\n        try:\n            self._processor.queue_job(job_id=job_id)\n        except Exception as e:\n            log.error(\"error.queue_job\", job_id=job_id)\n            raise e\n\n        if wait:\n            self._processor.wait_for(job_id)\n\n        return job_id\n\n    def get_active_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n        if job_id in self._active_jobs.keys() or job_id in self._failed_jobs.keys():\n            return self._processor.get_job(job_id)\n        else:\n            if job_id in self._archived_records.keys():\n                raise Exception(\n                    f\"Can't retrieve active job with id '{job_id}': job is archived.\"\n                )\n            elif job_id in self._processor._failed_jobs.keys():\n                job = self._processor.get_job(job_id)\n                msg = job.error\n                if not msg and job._exception:\n                    msg = str(job._exception)\n                    if not msg:\n                        msg = repr(job._exception)\n                raise FailedJobException(job=job, msg=msg, parent=job._exception)\n            else:\n                raise Exception(f\"Can't retrieve job with id '{job_id}': no such job.\")\n\n    def get_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n        return self._processor.get_job(job_id=job_id)\n\n    def get_job_status(self, job_id: uuid.UUID) -&gt; JobStatus:\n\n        if job_id in self._archived_records.keys():\n            return JobStatus.SUCCESS\n        elif job_id in self._failed_jobs.values():\n            return JobStatus.FAILED\n\n        return self._processor.get_job_status(job_id=job_id)\n\n    def wait_for(self, *job_id: uuid.UUID):\n        not_finished = (j for j in job_id if j not in self._archived_records.keys())\n        if not_finished:\n            self._processor.wait_for(*not_finished)\n\n    def retrieve_result(self, job_id: uuid.UUID) -&gt; ValueMap:\n\n        if job_id not in self._archived_records.keys():\n            self._processor.wait_for(job_id)\n\n        if job_id in self._archived_records.keys():\n            job_record = self._archived_records[job_id]\n            results = self._kiara.data_registry.load_values(job_record.outputs)\n            return results\n        elif job_id in self._failed_jobs.values():\n            j = self._processor.get_job(job_id=job_id)\n            raise FailedJobException(job=j, parent=j._exception)\n        else:\n            raise Exception(f\"Could not find job with id: {job_id}\")\n\n    def execute_and_retrieve(\n        self, manifest: Manifest, inputs: Mapping[str, Any]\n    ) -&gt; ValueMap:\n\n        job_id = self.execute(manifest=manifest, inputs=inputs, wait=True)\n        results = self.retrieve_result(job_id=job_id)\n        return results\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.job_matcher","title":"<code>job_matcher: JobMatcher</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.default_job_store","title":"<code>default_job_store: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.job_archives","title":"<code>job_archives: Mapping[str, JobArchive]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.suppoerted_event_types","title":"<code>suppoerted_event_types() -&gt; Iterable[Type[KiaraEvent]]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def suppoerted_event_types(self) -&gt; Iterable[Type[KiaraEvent]]:\n\n    return [JobArchiveAddedEvent, JobRecordPreStoreEvent, JobRecordStoredEvent]\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.register_job_archive","title":"<code>register_job_archive(archive: JobArchive, alias: Union[str, None] = None)</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def register_job_archive(self, archive: JobArchive, alias: Union[str, None] = None):\n\n    if alias is None:\n        alias = str(archive.archive_id)\n\n    if alias in self._job_archives.keys():\n        raise Exception(\n            f\"Can't register job store, store id already registered: {alias}.\"\n        )\n\n    self._job_archives[alias] = archive\n\n    is_store = False\n    is_default_store = False\n    if isinstance(archive, JobStore):\n        is_store = True\n        if self._default_job_store is None:\n            self._default_job_store = alias\n\n    event = JobArchiveAddedEvent.construct(\n        kiara_id=self._kiara.id,\n        job_archive_id=archive.archive_id,\n        job_archive_alias=alias,\n        is_store=is_store,\n        is_default_store=is_default_store,\n    )\n    self._event_callback(event)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_archive","title":"<code>get_archive(store_id: Union[str, None] = None) -&gt; JobArchive</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_archive(self, store_id: Union[str, None] = None) -&gt; JobArchive:\n\n    if store_id is None:\n        store_id = self.default_job_store\n        if store_id is None:\n            raise Exception(\"Can't retrieve deafult job archive, none set (yet).\")\n\n    return self._job_archives[store_id]\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.job_status_changed","title":"<code>job_status_changed(job_id: uuid.UUID, old_status: Union[JobStatus, None], new_status: JobStatus)</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def job_status_changed(\n    self,\n    job_id: uuid.UUID,\n    old_status: Union[JobStatus, None],\n    new_status: JobStatus,\n):\n\n    # print(f\"JOB STATUS CHANGED: {job_id} - {old_status} - {new_status.value}\")\n    if job_id in self._active_jobs.values() and new_status is JobStatus.FAILED:\n        job_hash = self._active_jobs.inverse.pop(job_id)\n        self._failed_jobs[job_hash] = job_id\n    elif job_id in self._active_jobs.values() and new_status is JobStatus.SUCCESS:\n        job_hash = self._active_jobs.inverse.pop(job_id)\n\n        job_record = self._processor.get_job_record(job_id)\n\n        self._finished_jobs[job_hash] = job_id\n        self._archived_records[job_id] = job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.store_job_record","title":"<code>store_job_record(job_id: uuid.UUID)</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def store_job_record(self, job_id: uuid.UUID):\n\n    if job_id not in self._archived_records.keys():\n        raise Exception(\n            f\"Can't store job with id '{job_id}': no job record with that id exists.\"\n        )\n\n    job_record = self._archived_records[job_id]\n\n    if job_record._is_stored:\n        logger.debug(\n            \"ignore.store.job_record\", reason=\"already stored\", job_id=str(job_id)\n        )\n        return\n\n    store: JobStore = self.get_archive()  # type: ignore\n    if not isinstance(store, JobStore):\n        raise Exception(\"Can't store job record to archive: not writable.\")\n\n    # if job_record.job_id in self._finished_jobs.values():\n    #     logger.debug(\n    #         \"ignore.store.job_record\",\n    #         reason=\"already stored in store\",\n    #         job_id=str(job_id),\n    #     )\n    #     return\n\n    logger.debug(\n        \"store.job_record\",\n        job_hash=job_record.job_hash,\n        module_type=job_record.module_type,\n    )\n\n    pre_store_event = JobRecordPreStoreEvent.construct(\n        kiara_id=self._kiara.id, job_record=job_record\n    )\n    self._event_callback(pre_store_event)\n\n    store.store_job_record(job_record)\n\n    stored_event = JobRecordStoredEvent.construct(\n        kiara_id=self._kiara.id, job_record=job_record\n    )\n    self._event_callback(stored_event)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_job_record_in_session","title":"<code>get_job_record_in_session(job_id: uuid.UUID) -&gt; JobRecord</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_job_record_in_session(self, job_id: uuid.UUID) -&gt; JobRecord:\n\n    return self._processor.get_job_record(job_id)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_job_record","title":"<code>get_job_record(job_id: uuid.UUID) -&gt; Union[JobRecord, None]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_job_record(self, job_id: uuid.UUID) -&gt; Union[JobRecord, None]:\n\n    if job_id in self._archived_records.keys():\n        return self._archived_records[job_id]\n\n    try:\n        job_record = self._processor.get_job_record(job_id=job_id)\n        return job_record\n    except Exception:\n        pass\n\n    job = self._processor.get_job(job_id=job_id)\n    if job is not None:\n        if job.status == JobStatus.FAILED:\n            return None\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.retrieve_all_job_records","title":"<code>retrieve_all_job_records() -&gt; Mapping[str, JobRecord]</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def retrieve_all_job_records(self) -&gt; Mapping[str, JobRecord]:\n\n    all_records: Dict[str, JobRecord] = {}\n    for archive in self.job_archives.values():\n        all_record_ids = archive.retrieve_all_job_hashes()\n        if all_record_ids is None:\n            return {}\n        for r in all_record_ids:\n            assert r not in all_records.keys()\n            job_record = archive.retrieve_record_for_job_hash(r)\n            assert job_record is not None\n            all_records[r] = job_record\n\n    return all_records\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.find_matching_job_record","title":"<code>find_matching_job_record(inputs_manifest: InputsManifest) -&gt; Union[uuid.UUID, None]</code>","text":"<p>Check if a job with same inputs manifest already ran some time before.</p> <p>Parameters:</p> Name Type Description Default <code>inputs_manifest</code> <code>InputsManifest</code> <p>the manifest incl. inputs</p> required <p>Returns:</p> Type Description <code>Union[uuid.UUID, None]</code> <p>'None' if no such job exists, a (uuid) job-id if the job is currently running or has run in the past</p> Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def find_matching_job_record(\n    self, inputs_manifest: InputsManifest\n) -&gt; Union[uuid.UUID, None]:\n\"\"\"Check if a job with same inputs manifest already ran some time before.\n\n    Arguments:\n        inputs_manifest: the manifest incl. inputs\n\n    Returns:\n        'None' if no such job exists, a (uuid) job-id if the job is currently running or has run in the past\n    \"\"\"\n\n    log = logger.bind(module_type=inputs_manifest.module_type)\n    if inputs_manifest.job_hash in self._active_jobs.keys():\n        log.debug(\"job.use_running\")\n        return self._active_jobs[inputs_manifest.job_hash]\n\n    if inputs_manifest.job_hash in self._finished_jobs.keys():\n        job_id = self._finished_jobs[inputs_manifest.job_hash]\n        return job_id\n\n    module = self._kiara.module_registry.create_module(manifest=inputs_manifest)\n    if not module.characteristics.is_idempotent:\n        log.debug(\n            \"skip.job_matching\",\n            reason=\"module is not idempotent\",\n            module_type=inputs_manifest.module_type,\n        )\n        return None\n\n    job_record = self.job_matcher.find_existing_job(inputs_manifest=inputs_manifest)\n    if job_record is None:\n        return None\n\n    self._finished_jobs[inputs_manifest.job_hash] = job_record.job_id\n    self._archived_records[job_record.job_id] = job_record\n    log.debug(\n        \"job.found_cached_record\",\n        job_id=str(job_record.job_id),\n        job_hash=inputs_manifest.job_hash,\n        module_type=inputs_manifest.module_type,\n    )\n    return job_record.job_id\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.prepare_job_config","title":"<code>prepare_job_config(manifest: Manifest, inputs: Mapping[str, Any]) -&gt; JobConfig</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def prepare_job_config(\n    self, manifest: Manifest, inputs: Mapping[str, Any]\n) -&gt; JobConfig:\n\n    module = self._kiara.module_registry.create_module(manifest=manifest)\n\n    job_config = JobConfig.create_from_module(\n        data_registry=self._kiara.data_registry, module=module, inputs=inputs\n    )\n\n    return job_config\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.execute","title":"<code>execute(manifest: Manifest, inputs: Mapping[str, Any], wait: bool = False, job_metadata: Union[None, Any] = None) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def execute(\n    self,\n    manifest: Manifest,\n    inputs: Mapping[str, Any],\n    wait: bool = False,\n    job_metadata: Union[None, Any] = None,\n) -&gt; uuid.UUID:\n\n    job_config = self.prepare_job_config(manifest=manifest, inputs=inputs)\n    return self.execute_job(job_config, wait=wait, job_metadata=job_metadata)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.execute_job","title":"<code>execute_job(job_config: JobConfig, wait: bool = False, job_metadata: Union[None, Any] = None) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def execute_job(\n    self,\n    job_config: JobConfig,\n    wait: bool = False,\n    job_metadata: Union[None, Any] = None,\n) -&gt; uuid.UUID:\n\n    log = logger.bind(\n        module_type=job_config.module_type,\n        module_config=job_config.module_config,\n        inputs={k: str(v) for k, v in job_config.inputs.items()},\n        job_hash=job_config.job_hash,\n    )\n\n    stored_job = self.find_matching_job_record(inputs_manifest=job_config)\n    if stored_job is not None:\n        log.debug(\n            \"job.use_cached\",\n            job_id=str(stored_job),\n            module_type=job_config.module_type,\n        )\n        return stored_job\n\n    if job_metadata is None:\n        job_metadata = {}\n\n    is_pipeline_step = job_metadata.get(\"is_pipeline_step\", False)\n    dbg_data = {\n        \"module_type\": job_config.module_type,\n        \"is_pipeline_step\": is_pipeline_step,\n    }\n    if is_pipeline_step:\n        dbg_data[\"step_id\"] = job_metadata[\"step_id\"]\n    log.debug(\"job.execute\", **dbg_data)\n\n    job_id = self._processor.create_job(\n        job_config=job_config, job_metadata=job_metadata\n    )\n    self._active_jobs[job_config.job_hash] = job_id\n\n    try:\n        self._processor.queue_job(job_id=job_id)\n    except Exception as e:\n        log.error(\"error.queue_job\", job_id=job_id)\n        raise e\n\n    if wait:\n        self._processor.wait_for(job_id)\n\n    return job_id\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_active_job","title":"<code>get_active_job(job_id: uuid.UUID) -&gt; ActiveJob</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_active_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n\n    if job_id in self._active_jobs.keys() or job_id in self._failed_jobs.keys():\n        return self._processor.get_job(job_id)\n    else:\n        if job_id in self._archived_records.keys():\n            raise Exception(\n                f\"Can't retrieve active job with id '{job_id}': job is archived.\"\n            )\n        elif job_id in self._processor._failed_jobs.keys():\n            job = self._processor.get_job(job_id)\n            msg = job.error\n            if not msg and job._exception:\n                msg = str(job._exception)\n                if not msg:\n                    msg = repr(job._exception)\n            raise FailedJobException(job=job, msg=msg, parent=job._exception)\n        else:\n            raise Exception(f\"Can't retrieve job with id '{job_id}': no such job.\")\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_job","title":"<code>get_job(job_id: uuid.UUID) -&gt; ActiveJob</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_job(self, job_id: uuid.UUID) -&gt; ActiveJob:\n    return self._processor.get_job(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.get_job_status","title":"<code>get_job_status(job_id: uuid.UUID) -&gt; JobStatus</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def get_job_status(self, job_id: uuid.UUID) -&gt; JobStatus:\n\n    if job_id in self._archived_records.keys():\n        return JobStatus.SUCCESS\n    elif job_id in self._failed_jobs.values():\n        return JobStatus.FAILED\n\n    return self._processor.get_job_status(job_id=job_id)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.wait_for","title":"<code>wait_for(*job_id: uuid.UUID)</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def wait_for(self, *job_id: uuid.UUID):\n    not_finished = (j for j in job_id if j not in self._archived_records.keys())\n    if not_finished:\n        self._processor.wait_for(*not_finished)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.retrieve_result","title":"<code>retrieve_result(job_id: uuid.UUID) -&gt; ValueMap</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def retrieve_result(self, job_id: uuid.UUID) -&gt; ValueMap:\n\n    if job_id not in self._archived_records.keys():\n        self._processor.wait_for(job_id)\n\n    if job_id in self._archived_records.keys():\n        job_record = self._archived_records[job_id]\n        results = self._kiara.data_registry.load_values(job_record.outputs)\n        return results\n    elif job_id in self._failed_jobs.values():\n        j = self._processor.get_job(job_id=job_id)\n        raise FailedJobException(job=j, parent=j._exception)\n    else:\n        raise Exception(f\"Could not find job with id: {job_id}\")\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs.JobRegistry.execute_and_retrieve","title":"<code>execute_and_retrieve(manifest: Manifest, inputs: Mapping[str, Any]) -&gt; ValueMap</code>","text":"Source code in <code>kiara/registries/jobs/__init__.py</code> <pre><code>def execute_and_retrieve(\n    self, manifest: Manifest, inputs: Mapping[str, Any]\n) -&gt; ValueMap:\n\n    job_id = self.execute(manifest=manifest, inputs=inputs, wait=True)\n    results = self.retrieve_result(job_id=job_id)\n    return results\n</code></pre>"},{"location":"reference/kiara/registries/jobs/__init__/#kiara.registries.jobs-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/job_store/__init__/","title":"job_store","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/","title":"filesystem_store","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.log","title":"<code>log = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive","title":"<code>FileSystemJobArchive</code>","text":"<p>         Bases: <code>JobArchive</code></p> Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>class FileSystemJobArchive(JobArchive):\n\n    _archive_type_name = \"filesystem_job_archive\"\n    _config_cls = FileSystemArchiveConfig  # type: ignore\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n\n    @classmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n        return [\"job_record\"]\n\n    def __init__(self, archive_id: uuid.UUID, config: FileSystemArchiveConfig):\n\n        super().__init__(archive_id=archive_id, config=config)\n        self._base_path: Union[Path, None] = None\n\n    def get_archive_details(self) -&gt; ArchiveDetails:\n\n        size = sum(\n            f.stat().st_size for f in self.job_store_path.glob(\"**/*\") if f.is_file()\n        )\n        return ArchiveDetails(size=size)\n\n    @property\n    def job_store_path(self) -&gt; Path:\n\n        if self._base_path is not None:\n            return self._base_path\n\n        self._base_path = Path(self.config.archive_path).absolute()  # type: ignore\n        self._base_path = fix_windows_longpath(self._base_path)\n        self._base_path.mkdir(parents=True, exist_ok=True)\n        return self._base_path\n\n    def _delete_archive(self) -&gt; None:\n\n        shutil.rmtree(self.job_store_path)\n\n    def retrieve_all_job_hashes(\n        self,\n        manifest_hash: Union[str, None] = None,\n        inputs_hash: Union[str, None] = None,\n    ) -&gt; Iterable[str]:\n\n        base_path = self.job_store_path / MANIFEST_SUB_PATH\n        if not manifest_hash:\n            if not inputs_hash:\n                records = base_path.glob(\"*/*/*.job_record\")\n            else:\n                records = base_path.glob(f\"*/{inputs_hash}/*.job_record\")\n        else:\n            if not inputs_hash:\n                records = base_path.glob(f\"{manifest_hash}/*/*.job_record\")\n            else:\n                records = base_path.glob(f\"{manifest_hash}/{inputs_hash}/*.job_record\")\n\n        result = []\n        for record in records:\n            result.append(record.name[0:-11])\n        return result\n\n    def _retrieve_record_for_job_hash(self, job_hash: str) -&gt; Union[JobRecord, None]:\n\n        base_path = self.job_store_path / MANIFEST_SUB_PATH\n        records = list(base_path.glob(f\"*/*/{job_hash}.job_record\"))\n\n        if not records:\n            return None\n\n        assert len(records) == 1\n        details_file = records[0]\n\n        details_content = details_file.read_text()\n        details: Dict[str, Any] = orjson.loads(details_content)\n\n        job_record = JobRecord(**details)\n        job_record._is_stored = True\n        return job_record\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive._config_cls","title":"<code>_config_cls = FileSystemArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive.job_store_path","title":"<code>job_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>@classmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n    return [\"job_record\"]\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive.get_archive_details","title":"<code>get_archive_details() -&gt; ArchiveDetails</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>def get_archive_details(self) -&gt; ArchiveDetails:\n\n    size = sum(\n        f.stat().st_size for f in self.job_store_path.glob(\"**/*\") if f.is_file()\n    )\n    return ArchiveDetails(size=size)\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobArchive.retrieve_all_job_hashes","title":"<code>retrieve_all_job_hashes(manifest_hash: Union[str, None] = None, inputs_hash: Union[str, None] = None) -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>def retrieve_all_job_hashes(\n    self,\n    manifest_hash: Union[str, None] = None,\n    inputs_hash: Union[str, None] = None,\n) -&gt; Iterable[str]:\n\n    base_path = self.job_store_path / MANIFEST_SUB_PATH\n    if not manifest_hash:\n        if not inputs_hash:\n            records = base_path.glob(\"*/*/*.job_record\")\n        else:\n            records = base_path.glob(f\"*/{inputs_hash}/*.job_record\")\n    else:\n        if not inputs_hash:\n            records = base_path.glob(f\"{manifest_hash}/*/*.job_record\")\n        else:\n            records = base_path.glob(f\"{manifest_hash}/{inputs_hash}/*.job_record\")\n\n    result = []\n    for record in records:\n        result.append(record.name[0:-11])\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobStore","title":"<code>FileSystemJobStore</code>","text":"<p>         Bases: <code>FileSystemJobArchive</code>, <code>JobStore</code></p> Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>class FileSystemJobStore(FileSystemJobArchive, JobStore):\n\n    _archive_type_name = \"filesystem_job_store\"\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n\n    def store_job_record(self, job_record: JobRecord):\n\n        manifest_cid = job_record.manifest_cid\n        inputs_hash = job_record.inputs_hash\n\n        base_path = self.job_store_path / MANIFEST_SUB_PATH\n        manifest_folder = base_path / str(manifest_cid)\n\n        manifest_folder.mkdir(parents=True, exist_ok=True)\n\n        manifest_info_file = manifest_folder / \"manifest.json\"\n        if not manifest_info_file.exists():\n            manifest_info_file.write_text(job_record.manifest_data_as_json())\n\n        job_folder = manifest_folder / inputs_hash\n        job_folder = fix_windows_longpath(job_folder)\n        job_folder.mkdir(parents=True, exist_ok=True)\n\n        job_details_file = job_folder / f\"{job_record.job_hash}.job_record\"\n        job_details_file = fix_windows_longpath(job_details_file)\n\n        exists = False\n        if job_details_file.exists():\n            exists = True\n            # TODO: check details match? or overwrite\n            file_m_time = datetime.datetime.fromtimestamp(\n                job_details_file.stat().st_mtime\n            ).timestamp()\n            archive = job_folder / \".archive\"\n            archive.mkdir(parents=True, exist_ok=True)\n            backup = archive / f\"{job_details_file.name}.{file_m_time}\"\n            log.debug(\n                \"overwrite.store_job_record\",\n                reason=\"job record already exists\",\n                job_hash=job_record.job_hash,\n                new_path=backup.as_posix(),\n            )\n            shutil.move(job_details_file.as_posix(), backup)\n\n        job_details_file.write_text(job_record.json())\n\n        for output_name, output_v_id in job_record.outputs.items():\n\n            outputs_file_name = (\n                job_folder / f\"output__{output_name}__value_id__{output_v_id}.json\"\n            )\n\n            if outputs_file_name.exists() and not exists:\n                # if value.pedigree_output_name == \"__void__\":\n                #     return\n                # else:\n                raise Exception(f\"Can't write value '{output_v_id}': already exists.\")\n            else:\n                outputs_file_name.touch()\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobStore.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store.FileSystemJobStore.store_job_record","title":"<code>store_job_record(job_record: JobRecord)</code>","text":"Source code in <code>kiara/registries/jobs/job_store/filesystem_store.py</code> <pre><code>def store_job_record(self, job_record: JobRecord):\n\n    manifest_cid = job_record.manifest_cid\n    inputs_hash = job_record.inputs_hash\n\n    base_path = self.job_store_path / MANIFEST_SUB_PATH\n    manifest_folder = base_path / str(manifest_cid)\n\n    manifest_folder.mkdir(parents=True, exist_ok=True)\n\n    manifest_info_file = manifest_folder / \"manifest.json\"\n    if not manifest_info_file.exists():\n        manifest_info_file.write_text(job_record.manifest_data_as_json())\n\n    job_folder = manifest_folder / inputs_hash\n    job_folder = fix_windows_longpath(job_folder)\n    job_folder.mkdir(parents=True, exist_ok=True)\n\n    job_details_file = job_folder / f\"{job_record.job_hash}.job_record\"\n    job_details_file = fix_windows_longpath(job_details_file)\n\n    exists = False\n    if job_details_file.exists():\n        exists = True\n        # TODO: check details match? or overwrite\n        file_m_time = datetime.datetime.fromtimestamp(\n            job_details_file.stat().st_mtime\n        ).timestamp()\n        archive = job_folder / \".archive\"\n        archive.mkdir(parents=True, exist_ok=True)\n        backup = archive / f\"{job_details_file.name}.{file_m_time}\"\n        log.debug(\n            \"overwrite.store_job_record\",\n            reason=\"job record already exists\",\n            job_hash=job_record.job_hash,\n            new_path=backup.as_posix(),\n        )\n        shutil.move(job_details_file.as_posix(), backup)\n\n    job_details_file.write_text(job_record.json())\n\n    for output_name, output_v_id in job_record.outputs.items():\n\n        outputs_file_name = (\n            job_folder / f\"output__{output_name}__value_id__{output_v_id}.json\"\n        )\n\n        if outputs_file_name.exists() and not exists:\n            # if value.pedigree_output_name == \"__void__\":\n            #     return\n            # else:\n            raise Exception(f\"Can't write value '{output_v_id}': already exists.\")\n        else:\n            outputs_file_name.touch()\n</code></pre>"},{"location":"reference/kiara/registries/jobs/job_store/filesystem_store/#kiara.registries.jobs.job_store.filesystem_store-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/models/__init__/","title":"models","text":""},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry","title":"<code>ModelRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/models/__init__.py</code> <pre><code>class ModelRegistry(object):\n\n    _instance = None\n\n    @classmethod\n    def instance(cls) -&gt; \"ModelRegistry\":\n\"\"\"The default ModelRegistry instance.\n\n        Can be a simgleton because it only contains data that is determined by the current Python environment.\n        \"\"\"\n\n        if cls._instance is None:\n            cls._instance = ModelRegistry()\n        return cls._instance\n\n    def __init__(self) -&gt; None:\n\n        self._all_models: Union[KiaraModelClassesInfo, None] = None\n        self._models_per_package: Dict[str, KiaraModelClassesInfo] = {}\n        self._sub_models: Dict[Type[KiaraModel], KiaraModelClassesInfo] = {}\n\n    @property\n    def all_models(self) -&gt; KiaraModelClassesInfo:\n\n        if self._all_models is not None:\n            return self._all_models\n\n        self._all_models = KiaraModelClassesInfo.find_kiara_models()\n        return self._all_models\n\n    def get_model_cls(\n        self,\n        kiara_model_id: str,\n        required_subclass: Union[Type[KiaraModel], None] = None,\n    ) -&gt; Type[KiaraModel]:\n\n        model_info = self.all_models.item_infos.get(kiara_model_id, None)\n        if model_info is None:\n            raise Exception(\n                f\"Can't retrieve model class for id '{kiara_model_id}': id not registered.\"\n            )\n\n        cls = model_info.python_class.get_class()  # type: ignore\n        if required_subclass:\n            if not issubclass(cls, required_subclass):\n                raise Exception(\n                    f\"Can't retrieve sub model of '{required_subclass.__name__}' with id '{kiara_model_id}': exists, but not the required subclass.\"\n                )\n\n        return cls  # type: ignore\n\n    def get_models_for_package(self, package_name: str) -&gt; KiaraModelClassesInfo:\n\n        if package_name in self._models_per_package.keys():\n            return self._models_per_package[package_name]\n\n        temp = {}\n        for key, info in self.all_models.item_infos.items():\n            if info.context.labels.get(\"package\") == package_name:\n                temp[key] = info\n\n        group = KiaraModelClassesInfo.construct(\n            group_alias=f\"kiara_models.{package_name}\", item_infos=temp  # type: ignore\n        )\n\n        self._models_per_package[package_name] = group\n        return group\n\n    def get_models_of_type(self, model_type: Type[KiaraModel]) -&gt; KiaraModelClassesInfo:\n\n        if model_type in self._sub_models.keys():\n            return self._sub_models[model_type]\n\n        sub_classes = {}\n        for model_id, type_info in self.all_models.item_infos.items():\n            cls: Type[KiaraModel] = type_info.python_class.get_class()  # type: ignore\n\n            if issubclass(cls, model_type):\n                sub_classes[model_id] = type_info\n\n        classes = KiaraModelClassesInfo(\n            group_title=f\"{model_type.__name__}-submodels\", item_infos=sub_classes\n        )\n        self._sub_models[model_type] = classes\n        return classes\n</code></pre>"},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry.all_models","title":"<code>all_models: KiaraModelClassesInfo</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry.instance","title":"<code>instance() -&gt; ModelRegistry</code>  <code>classmethod</code>","text":"<p>The default ModelRegistry instance.</p> <p>Can be a simgleton because it only contains data that is determined by the current Python environment.</p> Source code in <code>kiara/registries/models/__init__.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; \"ModelRegistry\":\n\"\"\"The default ModelRegistry instance.\n\n    Can be a simgleton because it only contains data that is determined by the current Python environment.\n    \"\"\"\n\n    if cls._instance is None:\n        cls._instance = ModelRegistry()\n    return cls._instance\n</code></pre>"},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry.get_model_cls","title":"<code>get_model_cls(kiara_model_id: str, required_subclass: Union[Type[KiaraModel], None] = None) -&gt; Type[KiaraModel]</code>","text":"Source code in <code>kiara/registries/models/__init__.py</code> <pre><code>def get_model_cls(\n    self,\n    kiara_model_id: str,\n    required_subclass: Union[Type[KiaraModel], None] = None,\n) -&gt; Type[KiaraModel]:\n\n    model_info = self.all_models.item_infos.get(kiara_model_id, None)\n    if model_info is None:\n        raise Exception(\n            f\"Can't retrieve model class for id '{kiara_model_id}': id not registered.\"\n        )\n\n    cls = model_info.python_class.get_class()  # type: ignore\n    if required_subclass:\n        if not issubclass(cls, required_subclass):\n            raise Exception(\n                f\"Can't retrieve sub model of '{required_subclass.__name__}' with id '{kiara_model_id}': exists, but not the required subclass.\"\n            )\n\n    return cls  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry.get_models_for_package","title":"<code>get_models_for_package(package_name: str) -&gt; KiaraModelClassesInfo</code>","text":"Source code in <code>kiara/registries/models/__init__.py</code> <pre><code>def get_models_for_package(self, package_name: str) -&gt; KiaraModelClassesInfo:\n\n    if package_name in self._models_per_package.keys():\n        return self._models_per_package[package_name]\n\n    temp = {}\n    for key, info in self.all_models.item_infos.items():\n        if info.context.labels.get(\"package\") == package_name:\n            temp[key] = info\n\n    group = KiaraModelClassesInfo.construct(\n        group_alias=f\"kiara_models.{package_name}\", item_infos=temp  # type: ignore\n    )\n\n    self._models_per_package[package_name] = group\n    return group\n</code></pre>"},{"location":"reference/kiara/registries/models/__init__/#kiara.registries.models.ModelRegistry.get_models_of_type","title":"<code>get_models_of_type(model_type: Type[KiaraModel]) -&gt; KiaraModelClassesInfo</code>","text":"Source code in <code>kiara/registries/models/__init__.py</code> <pre><code>def get_models_of_type(self, model_type: Type[KiaraModel]) -&gt; KiaraModelClassesInfo:\n\n    if model_type in self._sub_models.keys():\n        return self._sub_models[model_type]\n\n    sub_classes = {}\n    for model_id, type_info in self.all_models.item_infos.items():\n        cls: Type[KiaraModel] = type_info.python_class.get_class()  # type: ignore\n\n        if issubclass(cls, model_type):\n            sub_classes[model_id] = type_info\n\n    classes = KiaraModelClassesInfo(\n        group_title=f\"{model_type.__name__}-submodels\", item_infos=sub_classes\n    )\n    self._sub_models[model_type] = classes\n    return classes\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/","title":"modules","text":"<p>Base module for code that handles the import and management of KiaraModule sub-classes.</p>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.logget","title":"<code>logget = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry","title":"<code>ModuleRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>class ModuleRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n\n        self._cached_modules: Dict[str, Dict[CID, KiaraModule]] = {}\n\n        from kiara.utils.class_loading import find_all_kiara_modules\n\n        module_classes = find_all_kiara_modules()\n\n        self._module_classes: Mapping[str, Type[KiaraModule]] = {}\n        self._module_class_metadata: Dict[str, ModuleTypeInfo] = {}\n\n        for k, v in module_classes.items():\n            self._module_classes[k] = v\n\n    @property\n    def module_types(self) -&gt; Mapping[str, Type[\"KiaraModule\"]]:\n        return self._module_classes\n\n    def get_module_class(self, module_type: str) -&gt; Type[\"KiaraModule\"]:\n\n        cls = self._module_classes.get(module_type, None)\n        if cls is None:\n            raise InvalidManifestException(\n                f\"No module of type '{module_type}' available.\",\n                module_type=module_type,\n                available_module_types=self._module_classes.keys(),\n            )\n        return cls\n\n    def get_module_type_names(self) -&gt; Iterable[str]:\n        return self._module_classes.keys()\n\n    def get_module_type_metadata(self, type_name: str) -&gt; ModuleTypeInfo:\n\n        md = self._module_class_metadata.get(type_name, None)\n        if md is None:\n            md = ModuleTypeInfo.create_from_type_class(\n                type_cls=self.get_module_class(module_type=type_name), kiara=self._kiara\n            )\n            self._module_class_metadata[type_name] = md\n        return self._module_class_metadata[type_name]\n\n    def get_context_metadata(\n        self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n    ) -&gt; ModuleTypesInfo:\n\n        result = {}\n        for type_name in self.module_types.keys():\n            md = self.get_module_type_metadata(type_name=type_name)\n            if only_for_package:\n                if md.context.labels.get(\"package\") == only_for_package:\n                    result[type_name] = md\n            else:\n                result[type_name] = md\n\n        return ModuleTypesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n\n    def create_module(self, manifest: Union[Manifest, str]) -&gt; \"KiaraModule\":\n\"\"\"Create a [KiaraModule][kiara.module.KiaraModule] object from a module configuration.\n\n        Arguments:\n            manifest: the module configuration\n        \"\"\"\n\n        if isinstance(manifest, str):\n            manifest = Manifest.construct(module_type=manifest, module_config={})\n\n        m_cls: Type[KiaraModule] = self.get_module_class(manifest.module_type)\n\n        if not manifest.is_resolved:\n            try:\n                resolved = m_cls._resolve_module_config(**manifest.module_config)\n            except Exception as e:\n                raise InvalidManifestException(\n                    f\"Error while resolving module config for module '{manifest.module_type}': {e}\",\n                    module_type=manifest.module_type,\n                    module_config=manifest.module_config,\n                    parent=e,\n                )\n            manifest.module_config = resolved.dict()\n            manifest.is_resolved = True\n\n        if self._cached_modules.setdefault(manifest.module_type, {}).get(\n            manifest.instance_cid, None\n        ):\n            return self._cached_modules[manifest.module_type][manifest.instance_cid]\n\n        if manifest.module_type in self.get_module_type_names():\n            kiara_module = m_cls(module_config=manifest.module_config)\n            kiara_module._manifest_cache = Manifest.construct(\n                module_type=manifest.module_type,\n                module_config=manifest.module_config,\n                is_resolved=manifest.is_resolved,\n            )\n\n        else:\n            raise Exception(\n                f\"Invalid module type '{manifest.module_type}'. Available type names: {', '.join(self.get_module_type_names())}\"\n            )\n\n        return kiara_module\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.module_types","title":"<code>module_types: Mapping[str, Type[KiaraModule]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.get_module_class","title":"<code>get_module_class(module_type: str) -&gt; Type[KiaraModule]</code>","text":"Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>def get_module_class(self, module_type: str) -&gt; Type[\"KiaraModule\"]:\n\n    cls = self._module_classes.get(module_type, None)\n    if cls is None:\n        raise InvalidManifestException(\n            f\"No module of type '{module_type}' available.\",\n            module_type=module_type,\n            available_module_types=self._module_classes.keys(),\n        )\n    return cls\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.get_module_type_names","title":"<code>get_module_type_names() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>def get_module_type_names(self) -&gt; Iterable[str]:\n    return self._module_classes.keys()\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.get_module_type_metadata","title":"<code>get_module_type_metadata(type_name: str) -&gt; ModuleTypeInfo</code>","text":"Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>def get_module_type_metadata(self, type_name: str) -&gt; ModuleTypeInfo:\n\n    md = self._module_class_metadata.get(type_name, None)\n    if md is None:\n        md = ModuleTypeInfo.create_from_type_class(\n            type_cls=self.get_module_class(module_type=type_name), kiara=self._kiara\n        )\n        self._module_class_metadata[type_name] = md\n    return self._module_class_metadata[type_name]\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.get_context_metadata","title":"<code>get_context_metadata(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; ModuleTypesInfo</code>","text":"Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>def get_context_metadata(\n    self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; ModuleTypesInfo:\n\n    result = {}\n    for type_name in self.module_types.keys():\n        md = self.get_module_type_metadata(type_name=type_name)\n        if only_for_package:\n            if md.context.labels.get(\"package\") == only_for_package:\n                result[type_name] = md\n        else:\n            result[type_name] = md\n\n    return ModuleTypesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/modules/__init__/#kiara.registries.modules.ModuleRegistry.create_module","title":"<code>create_module(manifest: Union[Manifest, str]) -&gt; KiaraModule</code>","text":"<p>Create a KiaraModule object from a module configuration.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Union[Manifest, str]</code> <p>the module configuration</p> required Source code in <code>kiara/registries/modules/__init__.py</code> <pre><code>def create_module(self, manifest: Union[Manifest, str]) -&gt; \"KiaraModule\":\n\"\"\"Create a [KiaraModule][kiara.module.KiaraModule] object from a module configuration.\n\n    Arguments:\n        manifest: the module configuration\n    \"\"\"\n\n    if isinstance(manifest, str):\n        manifest = Manifest.construct(module_type=manifest, module_config={})\n\n    m_cls: Type[KiaraModule] = self.get_module_class(manifest.module_type)\n\n    if not manifest.is_resolved:\n        try:\n            resolved = m_cls._resolve_module_config(**manifest.module_config)\n        except Exception as e:\n            raise InvalidManifestException(\n                f\"Error while resolving module config for module '{manifest.module_type}': {e}\",\n                module_type=manifest.module_type,\n                module_config=manifest.module_config,\n                parent=e,\n            )\n        manifest.module_config = resolved.dict()\n        manifest.is_resolved = True\n\n    if self._cached_modules.setdefault(manifest.module_type, {}).get(\n        manifest.instance_cid, None\n    ):\n        return self._cached_modules[manifest.module_type][manifest.instance_cid]\n\n    if manifest.module_type in self.get_module_type_names():\n        kiara_module = m_cls(module_config=manifest.module_config)\n        kiara_module._manifest_cache = Manifest.construct(\n            module_type=manifest.module_type,\n            module_config=manifest.module_config,\n            is_resolved=manifest.is_resolved,\n        )\n\n    else:\n        raise Exception(\n            f\"Invalid module type '{manifest.module_type}'. Available type names: {', '.join(self.get_module_type_names())}\"\n        )\n\n    return kiara_module\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/","title":"operations","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OP_TYPE","title":"<code>OP_TYPE = TypeVar('OP_TYPE', bound=OperationType)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry","title":"<code>OperationRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>class OperationRegistry(object):\n    def __init__(\n        self,\n        kiara: \"Kiara\",\n        operation_type_classes: Union[Mapping[str, Type[OperationType]], None] = None,\n    ):\n\n        self._kiara: \"Kiara\" = kiara\n\n        self._operation_type_classes: Union[\n            Dict[str, Type[\"OperationType\"]], None\n        ] = None\n\n        if operation_type_classes is not None:\n            self._operation_type_classes = dict(operation_type_classes)\n\n        self._operation_type_metadata: Dict[str, OperationTypeInfo] = {}\n\n        self._operation_types: Union[Dict[str, OperationType], None] = None\n\n        self._operations: Union[Dict[str, Operation], None] = None\n        self._operations_by_type: Union[Dict[str, List[str]], None] = None\n\n        self._module_map: Union[Dict[str, Dict[str, Any]], None] = None\n\n        self._invalid_operations: Dict[str, Any] = {}\n\n    @property\n    def is_initialized(self) -&gt; bool:\n\n        return self._operations is not None\n\n    def get_module_map(self) -&gt; Mapping[str, Mapping[str, Any]]:\n\n        if not self.is_initialized:\n            raise Exception(\n                \"Can't retrieve module map: operations not initialized yet.\"\n            )\n\n        if self._module_map is not None:\n            return self._module_map\n\n        module_map = {}\n        for k, v in self.operations.items():\n            module_map[k] = {\n                \"module_type\": v.module_type,\n                \"module_config\": v.module_config,\n            }\n        self._module_map = module_map\n        return self._module_map\n\n    @property\n    def operation_types(self) -&gt; Mapping[str, OperationType]:\n\n        if self._operation_types is not None:\n            return self._operation_types\n\n        # TODO: support op type config\n        _operation_types = {}\n        for op_name, op_cls in self.operation_type_classes.items():\n            try:\n                _operation_types[op_name] = op_cls(\n                    kiara=self._kiara, op_type_name=op_name\n                )\n            except Exception as e:\n                log_exception(e)\n                logger.debug(\"ignore.operation_type\", operation_name=op_name, reason=e)\n\n        self._operation_types = _operation_types\n        return self._operation_types\n\n    def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OP_TYPE:\n\n        if not isinstance(op_type, str):\n            try:\n                op_type = op_type._operation_type_name  # type: ignore\n            except Exception:\n                raise ValueError(\n                    f\"Can't retrieve operation type, invalid input type '{type(op_type)}'.\"\n                )\n\n        if op_type not in self.operation_types.keys():\n            raise Exception(\n                f\"No operation type '{op_type}' registered. Available operation types: {', '.join(self.operation_types.keys())}.\"\n            )\n\n        return self.operation_types[op_type]  # type: ignore\n\n    def get_type_metadata(self, type_name: str) -&gt; OperationTypeInfo:\n\n        md = self._operation_type_metadata.get(type_name, None)\n        if md is None:\n            md = OperationTypeInfo.create_from_type_class(\n                kiara=self._kiara, type_cls=self.operation_type_classes[type_name]\n            )\n            self._operation_type_metadata[type_name] = md\n        return self._operation_type_metadata[type_name]\n\n    def get_context_metadata(\n        self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n    ) -&gt; OperationTypeClassesInfo:\n\n        result = {}\n        for type_name in self.operation_type_classes.keys():\n            md = self.get_type_metadata(type_name=type_name)\n            if only_for_package:\n                if md.context.labels.get(\"package\") == only_for_package:\n                    result[type_name] = md\n            else:\n                result[type_name] = md\n\n        return OperationTypeClassesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n\n    @property\n    def operation_type_classes(\n        self,\n    ) -&gt; Mapping[str, Type[\"OperationType\"]]:\n\n        if self._operation_type_classes is not None:\n            return self._operation_type_classes\n\n        from kiara.utils.class_loading import find_all_operation_types\n\n        self._operation_type_classes = find_all_operation_types()\n        return self._operation_type_classes\n\n    # @property\n    # def operation_ids(self) -&gt; List[str]:\n    #     return list(self.profiles.keys())\n\n    @property\n    def operation_ids(self) -&gt; Iterable[str]:\n        return self.operations.keys()\n\n    @property\n    def operations(self) -&gt; Mapping[str, Operation]:\n\n        if self._operations is not None:\n            return self._operations\n\n        all_op_configs: Set[OperationConfig] = set()\n        for op_type in self.operation_types.values():\n            included_ops = op_type.retrieve_included_operation_configs()\n            for op in included_ops:\n                if isinstance(op, Mapping):\n                    op = ManifestOperationConfig(**op)\n                all_op_configs.add(op)\n\n        for data_type in self._kiara.data_type_classes.values():\n            if hasattr(data_type, \"retrieve_included_operations\"):\n                for op in all_op_configs:\n                    if isinstance(op, Mapping):\n                        op = ManifestOperationConfig(**op)\n                    all_op_configs.add(op)\n\n        operations: Dict[str, Operation] = {}\n        operations_by_type: Dict[str, List[str]] = {}\n\n        deferred_module_names: Dict[str, List[OperationConfig]] = {}\n\n        # first iteration\n        for op_config in all_op_configs:\n\n            try:\n\n                if isinstance(op_config, PipelineOperationConfig):\n                    for mt in op_config.required_module_types:\n                        if mt not in self._kiara.module_type_names:\n                            deferred_module_names.setdefault(mt, []).append(op_config)\n                    deferred_module_names.setdefault(\n                        op_config.pipeline_name, []\n                    ).append(op_config)\n                    continue\n\n            except Exception as e:\n                details: Dict[str, Any] = {}\n                module_id = op_config.retrieve_module_type(kiara=self._kiara)\n                details[\"module_id\"] = module_id\n                if module_id == \"pipeline\":\n                    details[\"pipeline_name\"] = op_config.pipeline_name  # type: ignore\n                msg: Union[str, Exception] = str(e)\n                if not msg:\n                    msg = e\n                details[\"details\"] = msg\n                logger.error(\"invalid.operation\", **details)\n                self._invalid_operations[op_config.pipeline_name] = details  # type: ignore\n                log_exception(e)\n                continue\n\n            try:\n\n                module_type = op_config.retrieve_module_type(kiara=self._kiara)\n                if module_type not in self._kiara.module_type_names:\n                    deferred_module_names.setdefault(module_type, []).append(op_config)\n                else:\n                    module_config = op_config.retrieve_module_config(kiara=self._kiara)\n\n                    manifest = Manifest.construct(\n                        module_type=module_type, module_config=module_config\n                    )\n\n                    ops = self._create_operations(manifest=manifest, doc=op_config.doc)\n\n                    for op_type_name, _op in ops.items():\n                        if _op.operation_id in operations.keys():\n                            logger.debug(\n                                \"duplicate_operation_id\",\n                                op_id=_op.operation_id,\n                                left_module=operations[_op.operation_id].module_type,\n                                right_module=_op.module_type,\n                            )\n                            raise Exception(\n                                f\"Duplicate operation id: {_op.operation_id}\"\n                            )\n                        operations[_op.operation_id] = _op\n                        operations_by_type.setdefault(op_type_name, []).append(\n                            _op.operation_id\n                        )\n            except Exception as e:\n                details = {}\n                module_id = op_config.retrieve_module_type(kiara=self._kiara)\n                details[\"module_id\"] = module_id\n                if module_id == \"pipeline\":\n                    details[\"pipeline_name\"] = op_config.pipeline_name  # type: ignore\n                msg = str(e)\n                if not msg:\n                    msg = e\n                details[\"details\"] = msg\n                logger.error(\"invalid.operation\", **details)\n                log_exception(e)\n                continue\n\n        error_details = {}\n        while deferred_module_names:\n\n            deferred_length = len(deferred_module_names)\n\n            remove_deferred_names = set()\n\n            for missing_op_id in deferred_module_names.keys():\n                if missing_op_id in operations.keys():\n                    remove_deferred_names.add(missing_op_id)\n                    continue\n\n                for op_config in deferred_module_names[missing_op_id]:\n                    try:\n\n                        if isinstance(op_config, PipelineOperationConfig):\n\n                            if all(\n                                mt in self._kiara.module_type_names\n                                or mt in operations.keys()\n                                for mt in op_config.required_module_types\n                            ):\n                                module_map = {}\n                                for mt in op_config.required_module_types:\n                                    if mt in operations.keys():\n                                        module_map[mt] = {\n                                            \"module_type\": operations[mt].module_type,\n                                            \"module_config\": operations[\n                                                mt\n                                            ].module_config,\n                                        }\n                                op_config.module_map.update(module_map)\n                                module_config = op_config.retrieve_module_config(\n                                    kiara=self._kiara\n                                )\n\n                                manifest = Manifest.construct(\n                                    module_type=\"pipeline\",\n                                    module_config=module_config,\n                                )\n                                ops = self._create_operations(\n                                    manifest=manifest,\n                                    doc=op_config.doc,\n                                    metadata=op_config.metadata,\n                                )\n\n                            else:\n                                missing = (\n                                    mt\n                                    for mt in op_config.required_module_types\n                                    if mt not in self._kiara.module_type_names\n                                    and mt not in operations.keys()\n                                )\n                                raise Exception(\n                                    f\"Can't find all required module types when processing pipeline '{missing_op_id}': {', '.join(missing)}\"\n                                )\n\n                        else:\n                            raise NotImplementedError(\n                                f\"Invalid type: {type(op_config)}\"\n                            )\n                            # module_type = op_config.retrieve_module_type(kiara=self._kiara)\n                            # module_config = op_config.retrieve_module_config(kiara=self._kiara)\n                            #\n                            # # TODO: merge dicts instead of update?\n                            # new_module_config = dict(base_config)\n                            # new_module_config.update(module_config)\n                            #\n                            # manifest = Manifest.construct(module_type=operation.module_type,\n                            #                       module_config=new_module_config)\n\n                        for op_type_name, _op in ops.items():\n\n                            if _op.operation_id in operations.keys():\n                                raise Exception(\n                                    f\"Duplicate operation id: {_op.operation_id}\"\n                                )\n\n                            operations[_op.operation_id] = _op\n                            operations_by_type.setdefault(op_type_name, []).append(\n                                _op.operation_id\n                            )\n                            assert _op.operation_id == op_config.pipeline_name\n\n                        for _op_id in deferred_module_names.keys():\n                            if op_config in deferred_module_names[_op_id]:\n                                deferred_module_names[_op_id].remove(op_config)\n                    except Exception as e:\n                        details = {}\n                        module_id = op_config.retrieve_module_type(kiara=self._kiara)\n                        details[\"module_id\"] = module_id\n                        try:\n                            details[\"module_config\"] = op_config.retrieve_module_config(\n                                kiara=self._kiara\n                            )\n                        except Exception as xe:\n                            details[\"module_config\"] = str(xe)\n                        if module_id == \"pipeline\":\n                            details[\"pipeline_name\"] = op_config.pipeline_name  # type: ignore\n\n                        msg = str(e)\n                        if not msg:\n                            msg = e\n                        details[\"details\"] = msg\n                        error_details[missing_op_id] = details\n                        exc_info = sys.exc_info()\n                        details[\"parent\"] = exc_info[1]\n\n                        continue\n\n            for name, dependencies in deferred_module_names.items():\n                if not dependencies:\n                    remove_deferred_names.add(name)\n\n            for rdn in remove_deferred_names:\n                deferred_module_names.pop(rdn)\n\n            if len(deferred_module_names) == deferred_length:\n                for mn in deferred_module_names:\n                    if mn in operations.keys():\n                        continue\n                    details = error_details.get(missing_op_id, {\"details\": \"-- n/a --\"})\n                    exception = details.get(\"parent\", None)\n                    if exception:\n                        log_exception(exception)\n\n                    self._invalid_operations[mn] = details\n                    log_message(f\"invalid.operation.{mn}\", operation_id=mn, **details)\n                break\n\n        self._operations = {}\n        for missing_op_id in sorted(operations.keys()):\n            self._operations[missing_op_id] = operations[missing_op_id]\n\n        self._operations_by_type = {}\n        for op_type_name in sorted(operations_by_type.keys()):\n            self._operations_by_type.setdefault(\n                op_type_name, sorted(operations_by_type[op_type_name])\n            )\n\n        return self._operations\n\n    def register_pipelines(self, *paths: Union[str, Path]) -&gt; Dict[str, Operation]:\n\"\"\"Register pipelines from one or more paths.\n\n        Args:\n            *paths: one or more paths to load pipelines from.\n        \"\"\"\n\n        pipeline_data = find_pipeline_data_in_paths(\n            {k if isinstance(k, str) else k.as_posix(): {} for k in paths}\n        )\n        duplicates = set()\n        for op_id in pipeline_data.keys():\n            if op_id in self.operations.keys():\n                duplicates.add(op_id)\n\n        if duplicates:\n            raise Exception(\n                \"Can't register pipelines from the provided path(s), duplicate operation ids found: \"\n                + \", \".join(sorted(duplicates))\n            )\n\n        ops = {}\n        for op_id, op_data in pipeline_data.items():\n            # TODO: what to do with the additional data, like source and source type?\n            op = self.register_pipeline(data=op_data[\"data\"], operation_id=op_id)\n            ops[op.operation_id] = op\n        return ops\n\n    def register_pipeline(\n        self,\n        data: Union[Path, str, Mapping[str, Any]],\n        operation_id: Union[str, None] = None,\n    ) -&gt; Operation:\n\n        if isinstance(data, Path):\n            if not data.is_file():\n                raise Exception(\n                    f\"Can't register operation from path '{data.as_posix()}: path is not a file.\"\n                )\n\n            pipeline_config = PipelineConfig.from_file(\n                data.as_posix(), kiara=self._kiara, pipeline_name=operation_id\n            )\n        elif isinstance(data, Mapping):\n\n            pipeline_config = PipelineConfig.from_config(\n                pipeline_name=operation_id, data=data, kiara=self._kiara\n            )\n        elif isinstance(data, str):\n            if os.path.isfile((os.path.realpath(data))):\n                pipeline_config = PipelineConfig.from_file(\n                    data, kiara=self._kiara, pipeline_name=operation_id\n                )\n            else:\n                config_data = None\n                try:\n                    config_data = json.loads(data)\n                except Exception:\n                    try:\n                        config_data = yaml.load(data)\n                    except Exception:\n                        pass\n                if config_data:\n                    pipeline_config = PipelineConfig.from_config(\n                        pipeline_name=operation_id, data=config_data, kiara=self._kiara\n                    )\n                else:\n                    raise Exception(\n                        f\"Can't register pipeline with id '{operation_id}': can't parse data as file path, json or yaml.\"\n                    )\n        else:\n            raise Exception(\n                f\"Can't register pipeline with id '{operation_id}': invalid type '{type(data)}' for pipeline data: {type(data)}\"\n            )\n\n        _operation_id = pipeline_config.pipeline_name\n        if operation_id:\n            assert _operation_id == operation_id\n\n        if _operation_id in self.operation_ids:\n            raise Exception(\n                f\"Can't register pipeline with id '{_operation_id}': operation id already in use.\"\n            )\n\n        manifest = Manifest.construct(\n            module_type=\"pipeline\", module_config=pipeline_config.dict()\n        )\n        module = self._kiara.module_registry.create_module(manifest)\n\n        from kiara.operations.included_core_operations.pipeline import (\n            PipelineOperationDetails,\n        )\n\n        op_details = PipelineOperationDetails.create_operation_details(\n            operation_id=module.config.pipeline_name,\n            pipeline_inputs_schema=module.inputs_schema,\n            pipeline_outputs_schema=module.outputs_schema,\n            pipeline_config=module.config,\n        )\n\n        metadata: Dict[str, Any] = {}\n        operation = Operation(\n            module_type=manifest.module_type,\n            module_config=manifest.module_config,\n            operation_id=_operation_id,\n            operation_details=op_details,\n            module_details=KiaraModuleInstance.from_module(module),\n            metadata=metadata,\n            doc=pipeline_config.doc,\n        )\n        operation._module = module\n        assert self._operations is not None\n        self._operations[_operation_id] = operation\n        current_pipelines = self.operations_by_type.get(\"pipeline\", [])\n        current_pipelines.append(_operation_id)  # type: ignore\n        assert self._operations_by_type is not None\n        self._operations_by_type[\"pipeline\"] = sorted(current_pipelines)\n\n        logger.debug(\"pipeline.registered\", operation_id=_operation_id)\n        return operation\n\n    def _create_operations(\n        self,\n        manifest: Manifest,\n        doc: Any,\n        metadata: Union[Mapping[str, Any], None] = None,\n    ) -&gt; Dict[str, Operation]:\n\n        module = self._kiara.module_registry.create_module(manifest)\n        op_types = {}\n\n        if metadata is None:\n            metadata = {}\n\n        for op_name, op_type in self.operation_types.items():\n\n            op_details = op_type.check_matching_operation(module=module)\n            if not op_details:\n                continue\n\n            operation = Operation(\n                module_type=manifest.module_type,\n                module_config=manifest.module_config,\n                operation_id=op_details.operation_id,\n                operation_details=op_details,\n                module_details=KiaraModuleInstance.from_module(module),\n                metadata=metadata,\n                doc=doc,\n            )\n            operation._module = module\n\n            op_types[op_name] = operation\n\n        return op_types\n\n    def get_operation(self, operation_id: str) -&gt; Operation:\n\n        if operation_id not in self.operation_ids:\n            if operation_id in self._invalid_operations.keys():\n                raise InvalidOperationException(self._invalid_operations[operation_id])\n            else:\n                raise NoSuchOperationException(\n                    operation_id=operation_id,\n                    available_operations=sorted(self.operation_ids),\n                )\n\n        op = self.operations[operation_id]\n        return op\n\n    def find_all_operation_types(self, operation_id: str) -&gt; Set[str]:\n\n        result = set()\n        for op_type, ops in self.operations_by_type.items():\n            if operation_id in ops:\n                result.add(op_type)\n\n        return result\n\n    @property\n    def operations_by_type(self) -&gt; Mapping[str, Iterable[str]]:\n\n        if self._operations_by_type is None:\n            self.operations\n        return self._operations_by_type  # type: ignore\n\n    def find_operation_id(self, manifest: Manifest) -&gt; Union[str, None]:\n\n        for op in self.operations.values():\n            if manifest.manifest_cid == op.manifest_cid:\n                return op.operation_id\n\n        return None\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.is_initialized","title":"<code>is_initialized: bool</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.operation_types","title":"<code>operation_types: Mapping[str, OperationType]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.operation_type_classes","title":"<code>operation_type_classes: Mapping[str, Type[OperationType]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.operation_ids","title":"<code>operation_ids: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.operations","title":"<code>operations: Mapping[str, Operation]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.operations_by_type","title":"<code>operations_by_type: Mapping[str, Iterable[str]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.get_module_map","title":"<code>get_module_map() -&gt; Mapping[str, Mapping[str, Any]]</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def get_module_map(self) -&gt; Mapping[str, Mapping[str, Any]]:\n\n    if not self.is_initialized:\n        raise Exception(\n            \"Can't retrieve module map: operations not initialized yet.\"\n        )\n\n    if self._module_map is not None:\n        return self._module_map\n\n    module_map = {}\n    for k, v in self.operations.items():\n        module_map[k] = {\n            \"module_type\": v.module_type,\n            \"module_config\": v.module_config,\n        }\n    self._module_map = module_map\n    return self._module_map\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.get_operation_type","title":"<code>get_operation_type(op_type: Union[str, Type[OP_TYPE]]) -&gt; OP_TYPE</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def get_operation_type(self, op_type: Union[str, Type[OP_TYPE]]) -&gt; OP_TYPE:\n\n    if not isinstance(op_type, str):\n        try:\n            op_type = op_type._operation_type_name  # type: ignore\n        except Exception:\n            raise ValueError(\n                f\"Can't retrieve operation type, invalid input type '{type(op_type)}'.\"\n            )\n\n    if op_type not in self.operation_types.keys():\n        raise Exception(\n            f\"No operation type '{op_type}' registered. Available operation types: {', '.join(self.operation_types.keys())}.\"\n        )\n\n    return self.operation_types[op_type]  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.get_type_metadata","title":"<code>get_type_metadata(type_name: str) -&gt; OperationTypeInfo</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def get_type_metadata(self, type_name: str) -&gt; OperationTypeInfo:\n\n    md = self._operation_type_metadata.get(type_name, None)\n    if md is None:\n        md = OperationTypeInfo.create_from_type_class(\n            kiara=self._kiara, type_cls=self.operation_type_classes[type_name]\n        )\n        self._operation_type_metadata[type_name] = md\n    return self._operation_type_metadata[type_name]\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.get_context_metadata","title":"<code>get_context_metadata(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; OperationTypeClassesInfo</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def get_context_metadata(\n    self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; OperationTypeClassesInfo:\n\n    result = {}\n    for type_name in self.operation_type_classes.keys():\n        md = self.get_type_metadata(type_name=type_name)\n        if only_for_package:\n            if md.context.labels.get(\"package\") == only_for_package:\n                result[type_name] = md\n        else:\n            result[type_name] = md\n\n    return OperationTypeClassesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.register_pipelines","title":"<code>register_pipelines(*paths: Union[str, Path]) -&gt; Dict[str, Operation]</code>","text":"<p>Register pipelines from one or more paths.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[str, Path]</code> <p>one or more paths to load pipelines from.</p> <code>()</code> Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def register_pipelines(self, *paths: Union[str, Path]) -&gt; Dict[str, Operation]:\n\"\"\"Register pipelines from one or more paths.\n\n    Args:\n        *paths: one or more paths to load pipelines from.\n    \"\"\"\n\n    pipeline_data = find_pipeline_data_in_paths(\n        {k if isinstance(k, str) else k.as_posix(): {} for k in paths}\n    )\n    duplicates = set()\n    for op_id in pipeline_data.keys():\n        if op_id in self.operations.keys():\n            duplicates.add(op_id)\n\n    if duplicates:\n        raise Exception(\n            \"Can't register pipelines from the provided path(s), duplicate operation ids found: \"\n            + \", \".join(sorted(duplicates))\n        )\n\n    ops = {}\n    for op_id, op_data in pipeline_data.items():\n        # TODO: what to do with the additional data, like source and source type?\n        op = self.register_pipeline(data=op_data[\"data\"], operation_id=op_id)\n        ops[op.operation_id] = op\n    return ops\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.register_pipeline","title":"<code>register_pipeline(data: Union[Path, str, Mapping[str, Any]], operation_id: Union[str, None] = None) -&gt; Operation</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def register_pipeline(\n    self,\n    data: Union[Path, str, Mapping[str, Any]],\n    operation_id: Union[str, None] = None,\n) -&gt; Operation:\n\n    if isinstance(data, Path):\n        if not data.is_file():\n            raise Exception(\n                f\"Can't register operation from path '{data.as_posix()}: path is not a file.\"\n            )\n\n        pipeline_config = PipelineConfig.from_file(\n            data.as_posix(), kiara=self._kiara, pipeline_name=operation_id\n        )\n    elif isinstance(data, Mapping):\n\n        pipeline_config = PipelineConfig.from_config(\n            pipeline_name=operation_id, data=data, kiara=self._kiara\n        )\n    elif isinstance(data, str):\n        if os.path.isfile((os.path.realpath(data))):\n            pipeline_config = PipelineConfig.from_file(\n                data, kiara=self._kiara, pipeline_name=operation_id\n            )\n        else:\n            config_data = None\n            try:\n                config_data = json.loads(data)\n            except Exception:\n                try:\n                    config_data = yaml.load(data)\n                except Exception:\n                    pass\n            if config_data:\n                pipeline_config = PipelineConfig.from_config(\n                    pipeline_name=operation_id, data=config_data, kiara=self._kiara\n                )\n            else:\n                raise Exception(\n                    f\"Can't register pipeline with id '{operation_id}': can't parse data as file path, json or yaml.\"\n                )\n    else:\n        raise Exception(\n            f\"Can't register pipeline with id '{operation_id}': invalid type '{type(data)}' for pipeline data: {type(data)}\"\n        )\n\n    _operation_id = pipeline_config.pipeline_name\n    if operation_id:\n        assert _operation_id == operation_id\n\n    if _operation_id in self.operation_ids:\n        raise Exception(\n            f\"Can't register pipeline with id '{_operation_id}': operation id already in use.\"\n        )\n\n    manifest = Manifest.construct(\n        module_type=\"pipeline\", module_config=pipeline_config.dict()\n    )\n    module = self._kiara.module_registry.create_module(manifest)\n\n    from kiara.operations.included_core_operations.pipeline import (\n        PipelineOperationDetails,\n    )\n\n    op_details = PipelineOperationDetails.create_operation_details(\n        operation_id=module.config.pipeline_name,\n        pipeline_inputs_schema=module.inputs_schema,\n        pipeline_outputs_schema=module.outputs_schema,\n        pipeline_config=module.config,\n    )\n\n    metadata: Dict[str, Any] = {}\n    operation = Operation(\n        module_type=manifest.module_type,\n        module_config=manifest.module_config,\n        operation_id=_operation_id,\n        operation_details=op_details,\n        module_details=KiaraModuleInstance.from_module(module),\n        metadata=metadata,\n        doc=pipeline_config.doc,\n    )\n    operation._module = module\n    assert self._operations is not None\n    self._operations[_operation_id] = operation\n    current_pipelines = self.operations_by_type.get(\"pipeline\", [])\n    current_pipelines.append(_operation_id)  # type: ignore\n    assert self._operations_by_type is not None\n    self._operations_by_type[\"pipeline\"] = sorted(current_pipelines)\n\n    logger.debug(\"pipeline.registered\", operation_id=_operation_id)\n    return operation\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.get_operation","title":"<code>get_operation(operation_id: str) -&gt; Operation</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def get_operation(self, operation_id: str) -&gt; Operation:\n\n    if operation_id not in self.operation_ids:\n        if operation_id in self._invalid_operations.keys():\n            raise InvalidOperationException(self._invalid_operations[operation_id])\n        else:\n            raise NoSuchOperationException(\n                operation_id=operation_id,\n                available_operations=sorted(self.operation_ids),\n            )\n\n    op = self.operations[operation_id]\n    return op\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.find_all_operation_types","title":"<code>find_all_operation_types(operation_id: str) -&gt; Set[str]</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def find_all_operation_types(self, operation_id: str) -&gt; Set[str]:\n\n    result = set()\n    for op_type, ops in self.operations_by_type.items():\n        if operation_id in ops:\n            result.add(op_type)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations.OperationRegistry.find_operation_id","title":"<code>find_operation_id(manifest: Manifest) -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/registries/operations/__init__.py</code> <pre><code>def find_operation_id(self, manifest: Manifest) -&gt; Union[str, None]:\n\n    for op in self.operations.values():\n        if manifest.manifest_cid == op.manifest_cid:\n            return op.operation_id\n\n    return None\n</code></pre>"},{"location":"reference/kiara/registries/operations/__init__/#kiara.registries.operations-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/rendering/__init__/","title":"rendering","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry","title":"<code>RenderRegistry</code>","text":"<p>         Bases: <code>object</code></p> <p>A registry collecting all Renderer types/objects that are available to render Value objects or internal kiara models.</p> Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>class RenderRegistry(object):\n\"\"\"A registry collecting all Renderer types/objects that are available to render Value objects or internal kiara models.\"\"\"\n\n    _instance = None\n\n    def __init__(self, kiara: \"Kiara\") -&gt; None:\n\n        self._kiara: Kiara = kiara\n\n        self._renderer_types: Union[Mapping[str, Type[KiaraRenderer]], None] = None\n        self._registered_renderers: Dict[str, KiaraRenderer] = {}\n\n        self._template_pkg_loaders: Union[None, Dict[str, PackageLoader]] = None\n        self._template_folders: Union[None, Dict[str, FileSystemLoader]] = None\n\n        self._template_loader: Union[None, PrefixLoader] = None\n        self._default_jinja_env: Union[None, Environment] = None\n\n    def register_renderer_cls(self, renderer_cls: Type[KiaraRenderer]):\n\n        try:\n            self.register_renderer(renderer_type=renderer_cls)\n        except Exception as e:\n            log_message(\n                \"ignore.renderer\",\n                error=e,\n                renderer_cls=renderer_cls,\n                reason=\"can't initiate default renderer instance\",\n            )\n\n        if hasattr(renderer_cls, \"_renderer_profiles\"):\n\n            try:\n                profiles = renderer_cls._renderer_profiles  # type: ignore\n                if callable(profiles):\n                    profiles = profiles()\n                for config in profiles.values():  # type: ignore\n                    try:\n                        self.register_renderer(renderer_cls, config)  # type: ignore\n                    except Exception as e:\n                        log_exception(e)\n                        log_message(\n                            \"ignore.renderer.profile\",\n                            error=e,\n                            renderer_cls=renderer_cls,\n                            config=config,\n                        )\n            except Exception as xe:\n                log_exception(xe)\n                log_message(\n                    \"ignore.renderer.profiles\", error=xe, renderer_cls=renderer_cls\n                )\n\n        from kiara.renderers.included_renderers.value import ValueRenderer\n\n        if renderer_cls == ValueRenderer:\n            target_types = set()\n            op_type: RenderValueOperationType = self._kiara.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n            for op in op_type.operations.values():\n                details = op_type.retrieve_operation_details(op)\n                target_type = details.target_data_type\n                target_types.add(target_type)\n\n            for target_type in target_types:\n                self.register_renderer(\n                    renderer_type=ValueRenderer,\n                    renderer_config={\"target_type\": target_type},\n                )\n\n    def register_renderer(\n        self,\n        renderer_type: Union[str, Type[KiaraRenderer]],\n        renderer_config: Union[Mapping[str, Any], None] = None,\n    ):\n\n        if isinstance(renderer_type, str):\n            renderer_cls = self.renderer_types.get(renderer_type, None)\n        else:\n            renderer_cls = renderer_type\n\n        if renderer_cls is None:\n            raise Exception(f\"No renderer found for type: {renderer_type}.\")\n\n        if renderer_config is None:\n            renderer_config = {}\n        else:\n            renderer_config = dict(renderer_config)\n\n        if BaseJinjaRenderer in renderer_cls.mro():\n            if \"env\" not in renderer_config:\n                default_env = JinjaEnv()\n                renderer_config[\"env\"] = default_env\n\n            assert renderer_config[\"env\"]._render_registry is None\n            renderer_config[\"env\"]._render_registry = self\n\n        renderer = renderer_cls(kiara=self._kiara, renderer_config=renderer_config)\n        alias = renderer.get_renderer_alias()\n        if alias in self._registered_renderers.keys():\n            raise Exception(\n                f\"Can't register renderer, duplicate renderer alias: {alias}\"\n            )\n\n        self._registered_renderers[alias] = renderer\n\n    @property\n    def renderer_types(self) -&gt; Mapping[str, Type[KiaraRenderer]]:\n\n        if self._renderer_types is not None:\n            return self._renderer_types\n\n        self._renderer_types = find_all_kiara_renderers()\n        for value in self._renderer_types.values():\n            self.register_renderer_cls(value)\n        return self._renderer_types\n\n    @property\n    def default_jinja_environment(self) -&gt; Environment:\n\n        return self.retrieve_jinja_env()\n\n    @property\n    def template_loaders(self) -&gt; Mapping[str, BaseLoader]:\n\n        if self._template_pkg_loaders is not None:\n            return self._template_pkg_loaders\n\n        template_pkg_loaders = {}\n        template_pkg_loaders[\"kiara\"] = PackageLoader(\n            package_name=\"kiara\", package_path=\"resources/templates/render\"\n        )\n\n        from importlib_metadata import entry_points\n\n        for name, value in entry_points(group=\"kiara.plugin\"):\n            try:\n                template_pkg_loaders[value.value] = PackageLoader(\n                    package_name=value.value, package_path=\"resources/templates\"\n                )\n            except ValueError:\n                # means no templates directory exists\n                pass\n\n        self._template_pkg_loaders = template_pkg_loaders\n        self._template_loader = None\n        return self._template_pkg_loaders\n\n    @property\n    def template_folders(self) -&gt; Mapping[str, FileSystemLoader]:\n\n        if self._template_folders is not None:\n            return self._template_folders\n\n        self._template_folders = {}\n        return self._template_folders\n\n    def retrieve_jinja_env(self, template_base: Union[str, None] = None) -&gt; Environment:\n\n        if not template_base:\n            if self._default_jinja_env is not None:\n                return self._default_jinja_env\n            loader: BaseLoader = self.template_loader\n        else:\n\n            if template_base in self.template_folders.keys():\n                loader = self.template_folders[template_base]\n            elif template_base in self.template_loaders.keys():\n                loader = self.template_loaders[template_base]\n            else:\n                msg = \"Available template bases:\\n\\n\"\n                bases = sorted(\n                    list(self.template_folders.keys())\n                    + list(self.template_loaders.keys())\n                )\n                for base in bases:\n                    msg += f\" - {base}\\n\"\n                raise KiaraException(\n                    f\"No template base found for: {template_base}\", details=msg\n                )\n\n        env = Environment(loader=loader, autoescape=select_autoescape())\n\n        env.filters[\"render_model\"] = partial(render_model_filter, self)\n        env.filters[\"render_bool\"] = boolean_filter\n        env.filters[\"render_default\"] = default_filter\n        try:\n            markdown = mistune.create_markdown()\n        except Exception:\n            # depends on version of mistune that is installed\n            markdown = mistune.Markdown()\n        env.filters[\"markdown\"] = partial(render_markdown, markdown)\n        env.filters[\"extract_raw_data\"] = partial(extract_raw_value, self._kiara)\n\n        if not template_base:\n            self._default_jinja_env = env\n\n        return env\n\n    @property\n    def registered_renderers(self) -&gt; Iterable[KiaraRenderer]:\n\n        # make sure all the renderers are registered\n        self.renderer_types\n        return self._registered_renderers.values()\n\n    def retrieve_renderers_for_source_type(\n        self, source_type: str\n    ) -&gt; List[KiaraRenderer]:\n\n        result = []\n        for renderer in self.registered_renderers:\n            if source_type in renderer.retrieve_supported_render_sources():\n                result.append(renderer)\n        return result\n\n    def retrieve_renderers_for_source_target_combination(\n        self, source_type: str, target_type: str\n    ) -&gt; List[KiaraRenderer]:\n\n        result = []\n        for renderer in self.registered_renderers:\n            if (\n                source_type in renderer.retrieve_supported_render_sources()\n                and target_type in renderer.retrieve_supported_render_targets()\n            ):\n                result.append(renderer)\n        return result\n\n    def render(\n        self,\n        source_type: str,\n        item: Any,\n        target_type: str,\n        render_config: Union[Mapping[str, Any], None] = None,\n    ) -&gt; Any:\n\n        renderers = self.retrieve_renderers_for_source_target_combination(\n            source_type, target_type\n        )\n        if not renderers:\n            raise Exception(\n                f\"No renderer(s) available for rendering '{source_type}' to '{target_type}'.\"\n            )\n\n        if len(renderers) &gt; 1:\n            raise Exception(\n                f\"Multiple renderers available for rendering '{source_type}' to '{target_type}': {renderers}. This is not implemented yet.\"\n            )\n\n        renderer_instance = next(iter(renderers))\n        rc = renderer_instance.__class__._inputs_schema(**render_config)\n\n        return renderer_instance.render(item, render_config=rc)\n\n    @property\n    def template_loader(self) -&gt; PrefixLoader:\n\n        if self._template_loader is not None:\n            return self._template_loader\n\n        loaders: Dict[str, BaseLoader] = dict(self.template_loaders)\n        loaders.update(self.template_folders)\n\n        self._template_loader = PrefixLoader(loaders)\n        return self._template_loader\n\n    def register_template_folder(self, alias: str, path: str):\n\n        if alias in self.template_folders.keys():\n            raise Exception(f\"Duplicate template alias: {alias}\")\n        if alias in self.template_loaders.keys():\n            raise Exception(f\"Duplicate template alias: {alias}\")\n        if not os.path.isdir(path):\n            raise Exception(f\"Template path doesn't exist or is not a folder: {path}\")\n\n        self.template_folders[alias] = FileSystemLoader(path)  # type: ignore\n        self._template_loader = None\n\n    def register_template_pkg_location(self, alias: str, pkg_name: str, path: str):\n\n        if alias in self.template_loaders.keys():\n            raise Exception(f\"Duplicate template alias: {alias}\")\n        if alias in self.template_folders.keys():\n            raise Exception(f\"Duplicate template alias: {alias}\")\n\n        self.template_loaders[alias] = PackageLoader(  # type: ignore\n            package_name=pkg_name, package_path=path\n        )\n\n        self._template_loader = None\n\n    def get_template(\n        self, name: str, template_base: Union[str, None] = None\n    ) -&gt; Template:\n        env = self.retrieve_jinja_env(template_base=template_base)\n        try:\n            return env.get_template(name=name)\n        except TemplateNotFound:\n            available_templates = env.list_templates()\n            if not available_templates:\n                if template_base:\n                    details = \"No templates registered in default jinja environment.\"\n                else:\n                    details = f\"No templates registered in jinja environment with template base: {template_base}.\"\n            else:\n                details = \"Available templates:\\n\\n\"\n                for at in available_templates:\n                    details += f\"- {at}\\n\"\n\n            raise KiaraException(f\"Template not found: {name}\", details=details)\n\n    def get_template_names(self, template_base: Union[str, None] = None) -&gt; List[str]:\n\"\"\"List all available template names.\"\"\"\n\n        env = self.retrieve_jinja_env(template_base=template_base)\n        return env.list_templates()\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.renderer_types","title":"<code>renderer_types: Mapping[str, Type[KiaraRenderer]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.default_jinja_environment","title":"<code>default_jinja_environment: Environment</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.template_loaders","title":"<code>template_loaders: Mapping[str, BaseLoader]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.template_folders","title":"<code>template_folders: Mapping[str, FileSystemLoader]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.registered_renderers","title":"<code>registered_renderers: Iterable[KiaraRenderer]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.template_loader","title":"<code>template_loader: PrefixLoader</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.register_renderer_cls","title":"<code>register_renderer_cls(renderer_cls: Type[KiaraRenderer])</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def register_renderer_cls(self, renderer_cls: Type[KiaraRenderer]):\n\n    try:\n        self.register_renderer(renderer_type=renderer_cls)\n    except Exception as e:\n        log_message(\n            \"ignore.renderer\",\n            error=e,\n            renderer_cls=renderer_cls,\n            reason=\"can't initiate default renderer instance\",\n        )\n\n    if hasattr(renderer_cls, \"_renderer_profiles\"):\n\n        try:\n            profiles = renderer_cls._renderer_profiles  # type: ignore\n            if callable(profiles):\n                profiles = profiles()\n            for config in profiles.values():  # type: ignore\n                try:\n                    self.register_renderer(renderer_cls, config)  # type: ignore\n                except Exception as e:\n                    log_exception(e)\n                    log_message(\n                        \"ignore.renderer.profile\",\n                        error=e,\n                        renderer_cls=renderer_cls,\n                        config=config,\n                    )\n        except Exception as xe:\n            log_exception(xe)\n            log_message(\n                \"ignore.renderer.profiles\", error=xe, renderer_cls=renderer_cls\n            )\n\n    from kiara.renderers.included_renderers.value import ValueRenderer\n\n    if renderer_cls == ValueRenderer:\n        target_types = set()\n        op_type: RenderValueOperationType = self._kiara.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n        for op in op_type.operations.values():\n            details = op_type.retrieve_operation_details(op)\n            target_type = details.target_data_type\n            target_types.add(target_type)\n\n        for target_type in target_types:\n            self.register_renderer(\n                renderer_type=ValueRenderer,\n                renderer_config={\"target_type\": target_type},\n            )\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.register_renderer","title":"<code>register_renderer(renderer_type: Union[str, Type[KiaraRenderer]], renderer_config: Union[Mapping[str, Any], None] = None)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def register_renderer(\n    self,\n    renderer_type: Union[str, Type[KiaraRenderer]],\n    renderer_config: Union[Mapping[str, Any], None] = None,\n):\n\n    if isinstance(renderer_type, str):\n        renderer_cls = self.renderer_types.get(renderer_type, None)\n    else:\n        renderer_cls = renderer_type\n\n    if renderer_cls is None:\n        raise Exception(f\"No renderer found for type: {renderer_type}.\")\n\n    if renderer_config is None:\n        renderer_config = {}\n    else:\n        renderer_config = dict(renderer_config)\n\n    if BaseJinjaRenderer in renderer_cls.mro():\n        if \"env\" not in renderer_config:\n            default_env = JinjaEnv()\n            renderer_config[\"env\"] = default_env\n\n        assert renderer_config[\"env\"]._render_registry is None\n        renderer_config[\"env\"]._render_registry = self\n\n    renderer = renderer_cls(kiara=self._kiara, renderer_config=renderer_config)\n    alias = renderer.get_renderer_alias()\n    if alias in self._registered_renderers.keys():\n        raise Exception(\n            f\"Can't register renderer, duplicate renderer alias: {alias}\"\n        )\n\n    self._registered_renderers[alias] = renderer\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.retrieve_jinja_env","title":"<code>retrieve_jinja_env(template_base: Union[str, None] = None) -&gt; Environment</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def retrieve_jinja_env(self, template_base: Union[str, None] = None) -&gt; Environment:\n\n    if not template_base:\n        if self._default_jinja_env is not None:\n            return self._default_jinja_env\n        loader: BaseLoader = self.template_loader\n    else:\n\n        if template_base in self.template_folders.keys():\n            loader = self.template_folders[template_base]\n        elif template_base in self.template_loaders.keys():\n            loader = self.template_loaders[template_base]\n        else:\n            msg = \"Available template bases:\\n\\n\"\n            bases = sorted(\n                list(self.template_folders.keys())\n                + list(self.template_loaders.keys())\n            )\n            for base in bases:\n                msg += f\" - {base}\\n\"\n            raise KiaraException(\n                f\"No template base found for: {template_base}\", details=msg\n            )\n\n    env = Environment(loader=loader, autoescape=select_autoescape())\n\n    env.filters[\"render_model\"] = partial(render_model_filter, self)\n    env.filters[\"render_bool\"] = boolean_filter\n    env.filters[\"render_default\"] = default_filter\n    try:\n        markdown = mistune.create_markdown()\n    except Exception:\n        # depends on version of mistune that is installed\n        markdown = mistune.Markdown()\n    env.filters[\"markdown\"] = partial(render_markdown, markdown)\n    env.filters[\"extract_raw_data\"] = partial(extract_raw_value, self._kiara)\n\n    if not template_base:\n        self._default_jinja_env = env\n\n    return env\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.retrieve_renderers_for_source_type","title":"<code>retrieve_renderers_for_source_type(source_type: str) -&gt; List[KiaraRenderer]</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def retrieve_renderers_for_source_type(\n    self, source_type: str\n) -&gt; List[KiaraRenderer]:\n\n    result = []\n    for renderer in self.registered_renderers:\n        if source_type in renderer.retrieve_supported_render_sources():\n            result.append(renderer)\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.retrieve_renderers_for_source_target_combination","title":"<code>retrieve_renderers_for_source_target_combination(source_type: str, target_type: str) -&gt; List[KiaraRenderer]</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def retrieve_renderers_for_source_target_combination(\n    self, source_type: str, target_type: str\n) -&gt; List[KiaraRenderer]:\n\n    result = []\n    for renderer in self.registered_renderers:\n        if (\n            source_type in renderer.retrieve_supported_render_sources()\n            and target_type in renderer.retrieve_supported_render_targets()\n        ):\n            result.append(renderer)\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.render","title":"<code>render(source_type: str, item: Any, target_type: str, render_config: Union[Mapping[str, Any], None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def render(\n    self,\n    source_type: str,\n    item: Any,\n    target_type: str,\n    render_config: Union[Mapping[str, Any], None] = None,\n) -&gt; Any:\n\n    renderers = self.retrieve_renderers_for_source_target_combination(\n        source_type, target_type\n    )\n    if not renderers:\n        raise Exception(\n            f\"No renderer(s) available for rendering '{source_type}' to '{target_type}'.\"\n        )\n\n    if len(renderers) &gt; 1:\n        raise Exception(\n            f\"Multiple renderers available for rendering '{source_type}' to '{target_type}': {renderers}. This is not implemented yet.\"\n        )\n\n    renderer_instance = next(iter(renderers))\n    rc = renderer_instance.__class__._inputs_schema(**render_config)\n\n    return renderer_instance.render(item, render_config=rc)\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.register_template_folder","title":"<code>register_template_folder(alias: str, path: str)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def register_template_folder(self, alias: str, path: str):\n\n    if alias in self.template_folders.keys():\n        raise Exception(f\"Duplicate template alias: {alias}\")\n    if alias in self.template_loaders.keys():\n        raise Exception(f\"Duplicate template alias: {alias}\")\n    if not os.path.isdir(path):\n        raise Exception(f\"Template path doesn't exist or is not a folder: {path}\")\n\n    self.template_folders[alias] = FileSystemLoader(path)  # type: ignore\n    self._template_loader = None\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.register_template_pkg_location","title":"<code>register_template_pkg_location(alias: str, pkg_name: str, path: str)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def register_template_pkg_location(self, alias: str, pkg_name: str, path: str):\n\n    if alias in self.template_loaders.keys():\n        raise Exception(f\"Duplicate template alias: {alias}\")\n    if alias in self.template_folders.keys():\n        raise Exception(f\"Duplicate template alias: {alias}\")\n\n    self.template_loaders[alias] = PackageLoader(  # type: ignore\n        package_name=pkg_name, package_path=path\n    )\n\n    self._template_loader = None\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.get_template","title":"<code>get_template(name: str, template_base: Union[str, None] = None) -&gt; Template</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def get_template(\n    self, name: str, template_base: Union[str, None] = None\n) -&gt; Template:\n    env = self.retrieve_jinja_env(template_base=template_base)\n    try:\n        return env.get_template(name=name)\n    except TemplateNotFound:\n        available_templates = env.list_templates()\n        if not available_templates:\n            if template_base:\n                details = \"No templates registered in default jinja environment.\"\n            else:\n                details = f\"No templates registered in jinja environment with template base: {template_base}.\"\n        else:\n            details = \"Available templates:\\n\\n\"\n            for at in available_templates:\n                details += f\"- {at}\\n\"\n\n        raise KiaraException(f\"Template not found: {name}\", details=details)\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.RenderRegistry.get_template_names","title":"<code>get_template_names(template_base: Union[str, None] = None) -&gt; List[str]</code>","text":"<p>List all available template names.</p> Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def get_template_names(self, template_base: Union[str, None] = None) -&gt; List[str]:\n\"\"\"List all available template names.\"\"\"\n\n    env = self.retrieve_jinja_env(template_base=template_base)\n    return env.list_templates()\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.render_model_filter","title":"<code>render_model_filter(render_registry: RenderRegistry, instance: KiaraModel)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def render_model_filter(render_registry: \"RenderRegistry\", instance: \"KiaraModel\"):\n\n    template = render_registry.get_template(\"kiara/render/models/model_data.html\")\n    rendered = template.render(instance=instance)\n    return rendered\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.boolean_filter","title":"<code>boolean_filter(data: bool)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def boolean_filter(data: bool):\n\n    return \"yes\" if data else \"no\"\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.default_filter","title":"<code>default_filter(data: Any)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def default_filter(data: Any):\n\n    if data in [None, SpecialValue.NO_VALUE, SpecialValue.NOT_SET]:\n        return \"\"\n    elif callable(data):\n        return str(data())\n    else:\n        return str(data)\n</code></pre>"},{"location":"reference/kiara/registries/rendering/__init__/#kiara.registries.rendering.render_markdown","title":"<code>render_markdown(markdown: mistune.Markdown, markdown_str: str)</code>","text":"Source code in <code>kiara/registries/rendering/__init__.py</code> <pre><code>def render_markdown(markdown: mistune.Markdown, markdown_str: str):\n    return markdown(markdown_str)\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/","title":"templates","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry","title":"<code>TemplateRegistry</code>","text":"<p>         Bases: <code>object</code></p> <p>A registry collecting all the (jinja) templates that are available in the current environment.</p> <p>Packages can register templates by specifying an entrypoint under 'kiara.templates', pointing to a Python module that has template files</p> Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>class TemplateRegistry(object):\n\"\"\"A registry collecting all the (jinja) templates that are available in the current environment.\n\n    Packages can register templates by specifying an entrypoint under 'kiara.templates', pointing to a Python module\n    that has template files\n    \"\"\"\n\n    _instance = None\n\n    @classmethod\n    def instance(cls) -&gt; \"TemplateRegistry\":\n\"\"\"The default *kiara* TemplateRegistry instance.\n\n        Can be a simgleton because it only contains data that is determined by the current Python environment.\n        \"\"\"\n\n        if cls._instance is None:\n            cls._instance = TemplateRegistry()\n        return cls._instance\n\n    def __init__(self) -&gt; None:\n\n        self._template_dirs: Union[None, Mapping[str, Path]] = None\n        self._template_loader: Union[None, PrefixLoader] = None\n        self._environment: Union[None, Environment] = None\n\n    @property\n    def environment(self) -&gt; Environment:\n\n        if self._environment is not None:\n            return self._environment\n\n        self._environment = Environment(\n            loader=self.template_loader, autoescape=select_autoescape()\n        )\n        self._environment.filters[\"render_model\"] = partial(render_model_filter, self)\n        self._environment.filters[\"render_bool\"] = boolean_filter\n        self._environment.filters[\"render_default\"] = default_filter\n        try:\n            markdown = mistune.create_markdown()\n        except Exception:\n            markdown = mistune.Markdown()\n        self._environment.filters[\"markdown\"] = partial(render_markdown, markdown)\n        return self._environment\n\n    @property\n    def template_dirs(self) -&gt; Mapping[str, Path]:\n\n        if self._template_dirs is not None:\n            return self._template_dirs\n\n        discovered_plugins = {}\n\n        try:\n            import kiara_plugin  # type: ignore\n\n            plugin_modules_available = True\n        except Exception:\n            plugin_modules_available = False\n            plugin_modules = []\n\n        if plugin_modules_available:\n            plugin_modules = [\n                name\n                for finder, name, ispkg in pkgutil.iter_modules(\n                    kiara_plugin.__path__, kiara_plugin.__name__ + \".\"  # type: ignore\n                )\n            ] + [\n                name\n                for finder, name, ispkg in pkgutil.iter_modules()\n                if name.startswith(\"kiara\")\n            ]\n\n        for module_name in plugin_modules:  # type: ignore\n\n            try:\n                module = importlib.import_module(module_name)\n                discovered_plugins[module_name] = module\n            except Exception as e:\n                log_exception(e)\n\n        all_template_dirs = {}\n        for plugin_name, module in discovered_plugins.items():\n            if not module.__file__:\n                logger.warning(\n                    \"skip.discovered_plugin\", plugin_name=plugin_name, module=module\n                )\n                continue\n            templates_folder = os.path.join(\n                os.path.dirname(module.__file__), \"resources\", \"templates\"\n            )\n            if not os.path.isdir(templates_folder):\n                continue\n            all_template_dirs[plugin_name] = Path(templates_folder)\n            logger.debug(\n                \"registered.templates_dir\", package=plugin_name, path=templates_folder\n            )\n\n        self._template_dirs = all_template_dirs\n        return self._template_dirs\n\n    @property\n    def template_loader(self) -&gt; PrefixLoader:\n\n        if self._template_loader is not None:\n            return self._template_loader\n\n        loaders = {}\n        for plugin_name, path in self.template_dirs.items():\n            loaders[plugin_name] = FileSystemLoader(searchpath=path)\n\n        self._template_loader = PrefixLoader(loaders)\n        return self._template_loader\n\n    def get_template(self, name: str) -&gt; Template:\n\n        return self.environment.get_template(name=name)\n\n    @property\n    def template_names(self) -&gt; List[str]:\n\"\"\"List all available template names.\"\"\"\n\n        return self.environment.list_templates()\n\n    def get_template_for_model_type(\n        self,\n        model_type: str,\n        template_format: str = \"html\",\n        use_generic_if_none: bool = False,\n    ) -&gt; Union[Template, None]:\n\n        matches = [\n            template_name\n            for template_name in self.template_names\n            if template_name.endswith(f\"{model_type}.{template_format}\")\n        ]\n\n        if not matches and use_generic_if_none:\n            matches = [\n                template_name\n                for template_name in self.template_names\n                if template_name.endswith(f\"generic_model_info.{template_format}\")\n            ]\n\n        if not matches:\n            return None\n        elif len(matches) &gt; 1:\n            raise Exception(\n                f\"Multiple templates found for model type '{model_type}' and format '{template_format}'. This is not supported yet.\"\n            )\n\n        return self.get_template(matches[0])\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.environment","title":"<code>environment: Environment</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.template_dirs","title":"<code>template_dirs: Mapping[str, Path]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.template_loader","title":"<code>template_loader: PrefixLoader</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.template_names","title":"<code>template_names: List[str]</code>  <code>property</code>","text":"<p>List all available template names.</p>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.instance","title":"<code>instance() -&gt; TemplateRegistry</code>  <code>classmethod</code>","text":"<p>The default kiara TemplateRegistry instance.</p> <p>Can be a simgleton because it only contains data that is determined by the current Python environment.</p> Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; \"TemplateRegistry\":\n\"\"\"The default *kiara* TemplateRegistry instance.\n\n    Can be a simgleton because it only contains data that is determined by the current Python environment.\n    \"\"\"\n\n    if cls._instance is None:\n        cls._instance = TemplateRegistry()\n    return cls._instance\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.get_template","title":"<code>get_template(name: str) -&gt; Template</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def get_template(self, name: str) -&gt; Template:\n\n    return self.environment.get_template(name=name)\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.TemplateRegistry.get_template_for_model_type","title":"<code>get_template_for_model_type(model_type: str, template_format: str = 'html', use_generic_if_none: bool = False) -&gt; Union[Template, None]</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def get_template_for_model_type(\n    self,\n    model_type: str,\n    template_format: str = \"html\",\n    use_generic_if_none: bool = False,\n) -&gt; Union[Template, None]:\n\n    matches = [\n        template_name\n        for template_name in self.template_names\n        if template_name.endswith(f\"{model_type}.{template_format}\")\n    ]\n\n    if not matches and use_generic_if_none:\n        matches = [\n            template_name\n            for template_name in self.template_names\n            if template_name.endswith(f\"generic_model_info.{template_format}\")\n        ]\n\n    if not matches:\n        return None\n    elif len(matches) &gt; 1:\n        raise Exception(\n            f\"Multiple templates found for model type '{model_type}' and format '{template_format}'. This is not supported yet.\"\n        )\n\n    return self.get_template(matches[0])\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.render_model_filter","title":"<code>render_model_filter(template_registry: TemplateRegistry, instance: KiaraModel)</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def render_model_filter(template_registry: \"TemplateRegistry\", instance: \"KiaraModel\"):\n\n    template = template_registry.get_template(\"kiara/render/models/model_data.html\")\n    rendered = template.render(instance=instance)\n    return rendered\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.boolean_filter","title":"<code>boolean_filter(data: bool)</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def boolean_filter(data: bool):\n\n    return \"yes\" if data else \"no\"\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.default_filter","title":"<code>default_filter(data: Any)</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def default_filter(data: Any):\n\n    if data in [None, SpecialValue.NO_VALUE, SpecialValue.NOT_SET]:\n        return \"\"\n    elif callable(data):\n        return str(data())\n    else:\n        return str(data)\n</code></pre>"},{"location":"reference/kiara/registries/templates/__init__/#kiara.registries.templates.render_markdown","title":"<code>render_markdown(markdown: mistune.Markdown, markdown_str: str)</code>","text":"Source code in <code>kiara/registries/templates/__init__.py</code> <pre><code>def render_markdown(markdown: mistune.Markdown, markdown_str: str):\n    return markdown(markdown_str)\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/","title":"types","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry","title":"<code>TypeRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>class TypeRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n        self._data_types: Union[bidict[str, Type[DataType]], None] = None\n        self._data_type_metadata: Dict[str, DataTypeClassInfo] = {}\n        self._cached_data_type_objects: Dict[int, DataType] = {}\n        # self._registered_python_classes: Dict[Type, typing.List[str]] = None  # type: ignore\n        self._type_hierarchy: Union[nx.DiGraph, None] = None\n        self._lineages_cache: Dict[str, List[str]] = {}\n\n        self._type_profiles: Union[Dict[str, Mapping[str, Any]], None] = None\n\n    def invalidate_types(self):\n\n        self._data_types = None\n        # self._registered_python_classes = None\n\n    def retrieve_data_type(\n        self,\n        data_type_name: str,\n        data_type_config: Union[Mapping[str, Any], None] = None,\n    ) -&gt; DataType:\n\n        if data_type_config is None:\n            data_type_config = {}\n        else:\n            data_type_config = dict(data_type_config)\n\n        if data_type_name not in self.data_type_profiles.keys():\n            raise Exception(f\"Data type name not registered: {data_type_name}\")\n\n        data_type: str = self.data_type_profiles[data_type_name][\"type_name\"]\n        type_config = self.data_type_profiles[data_type_name][\"type_config\"]\n\n        if data_type_config:\n            type_config = dict(type_config)\n            type_config.update(data_type_config)\n\n        cls = self.get_data_type_cls(type_name=data_type)\n\n        hash = cls._calculate_data_type_hash(type_config)\n        if hash in self._cached_data_type_objects.keys():\n            return self._cached_data_type_objects[hash]\n\n        result = cls(**type_config)\n        assert result.data_type_hash == hash\n        self._cached_data_type_objects[result.data_type_hash] = result\n        return result\n\n    @property\n    def data_type_classes(self) -&gt; bidict[str, Type[DataType]]:\n\n        if self._data_types is not None:\n            return self._data_types\n\n        self._data_types = bidict(find_all_data_types())\n        profiles: Dict[str, Mapping[str, Any]] = {\n            dn: {\"type_name\": dn, \"type_config\": {}} for dn in self._data_types.keys()\n        }\n\n        for name, cls in self._data_types.items():\n            cls_profiles = cls.retrieve_available_type_profiles()\n            for profile_name, type_config in cls_profiles.items():\n                if profile_name in profiles.keys():\n                    raise Exception(f\"Duplicate data type profile: {profile_name}\")\n                profiles[profile_name] = {\"type_name\": name, \"type_config\": type_config}\n\n        self._type_profiles = profiles\n        return self._data_types\n\n    @property\n    def data_type_profiles(self) -&gt; Mapping[str, Mapping[str, Any]]:\n\n        if self._type_profiles is None:\n            self.data_type_classes\n        assert self._type_profiles is not None\n        return self._type_profiles\n\n    @property\n    def data_type_hierarchy(self) -&gt; \"nx.DiGraph\":\n\n        if self._type_hierarchy is not None:\n            return self._type_hierarchy\n\n        def recursive_base_find(cls: Type, current: Union[List[str], None] = None):\n\n            if current is None:\n                current = []\n\n            for base in cls.__bases__:\n\n                if base in self.data_type_classes.values():\n                    current.append(self.data_type_classes.inverse[base])\n\n                recursive_base_find(base, current=current)\n\n            return current\n\n        bases = {}\n        for name, cls in self.data_type_classes.items():\n            bases[name] = recursive_base_find(cls)\n\n        for profile_name, details in self.data_type_profiles.items():\n\n            if not details[\"type_config\"]:\n                continue\n            if profile_name in bases.keys():\n                raise Exception(\n                    f\"Invalid profile name '{profile_name}': shadowing data type. This is most likely a bug.\"\n                )\n            bases[profile_name] = [details[\"type_name\"]]\n\n        import networkx as nx\n\n        hierarchy = nx.DiGraph()\n        hierarchy.add_node(KIARA_ROOT_TYPE_NAME)\n\n        for name, _bases in bases.items():\n            profile_details = self.data_type_profiles[name]\n            cls = self.data_type_classes[profile_details[\"type_name\"]]\n            hierarchy.add_node(name, cls=cls)\n            if not _bases:\n                hierarchy.add_edge(KIARA_ROOT_TYPE_NAME, name)\n            else:\n                # we only need the first parent, all others will be taken care of by the parent of the parent\n                hierarchy.add_edge(_bases[0], name)\n\n        self._type_hierarchy = hierarchy\n        return self._type_hierarchy\n\n    def get_sub_hierarchy(self, data_type: str):\n\n        import networkx as nx\n\n        graph: nx.DiGraph = self.data_type_hierarchy\n\n        desc = nx.descendants(graph, data_type)\n        desc.add(data_type)\n        sub_graph = graph.subgraph(desc)\n        return sub_graph\n\n    def get_type_lineage(self, data_type_name: str) -&gt; List[str]:\n\"\"\"Returns the shortest path between the specified type and the root, in reverse direction starting from the specified type.\"\"\"\n\n        if data_type_name not in self.data_type_profiles.keys():\n            raise DataTypeUnknownException(data_type=data_type_name)\n\n        if data_type_name in self._lineages_cache.keys():\n            return self._lineages_cache[data_type_name]\n\n        import networkx as nx\n\n        path = nx.shortest_path(\n            self.data_type_hierarchy, KIARA_ROOT_TYPE_NAME, data_type_name\n        )\n        path.remove(KIARA_ROOT_TYPE_NAME)\n        self._lineages_cache[data_type_name] = list(reversed(path))\n        return self._lineages_cache[data_type_name]\n\n    def get_sub_types(self, data_type_name: str) -&gt; Set[str]:\n\n        if data_type_name not in self.data_type_classes.keys():\n            raise Exception(f\"No data type '{data_type_name}' registered.\")\n\n        import networkx as nx\n\n        desc = nx.descendants(self.data_type_hierarchy, data_type_name)\n        return desc\n\n    def is_profile(self, data_type_name: str) -&gt; bool:\n\n        type_config = self.data_type_profiles.get(data_type_name, {}).get(\n            \"type_config\", None\n        )\n        return True if type_config else False\n\n    def get_profile_parent(self, data_type_name: str) -&gt; Union[None, bool]:\n\"\"\"Return the parent data type of the specified data type (if that is indeed a profile name).\n\n        If the specified data type is not a profile name, 'None' will be returned.\n        \"\"\"\n\n        return self.data_type_profiles.get(data_type_name, {}).get(\"type_name\", None)\n\n    def get_associated_profiles(\n        self, data_type_name: str\n    ) -&gt; Mapping[str, Mapping[str, Any]]:\n\n        if data_type_name not in self.data_type_classes.keys():\n            raise Exception(f\"No data type '{data_type_name}' registered.\")\n\n        result = {}\n        for profile_name, details in self.data_type_profiles.items():\n            if (\n                profile_name != data_type_name\n                and data_type_name == details[\"type_name\"]\n            ):\n                result[profile_name] = details\n\n        return result\n\n    @property\n    def data_type_names(self) -&gt; List[str]:\n        return list(self.data_type_profiles.keys())\n\n    def get_data_type_cls(self, type_name: str) -&gt; Type[DataType]:\n\n        _type_details = self.data_type_profiles.get(type_name, None)\n        if _type_details is None:\n            raise Exception(\n                f\"No value type '{type_name}', available types: {', '.join(self.data_type_profiles.keys())}\"\n            )\n\n        resolved_type_name: str = _type_details[\"type_name\"]\n\n        t = self.data_type_classes.get(resolved_type_name, None)\n        if t is None:\n            raise Exception(\n                f\"No value type '{type_name}', available types: {', '.join(self.data_type_profiles.keys())}\"\n            )\n        return t\n\n    def get_data_type_instance(\n        self, type_name: str, type_config: Union[None, Mapping[str, Any]] = None\n    ) -&gt; DataType:\n\n        cls = self.get_data_type_cls(type_name=type_name)\n        if not type_config:\n            obj = cls()\n        else:\n            obj = cls(**type_config)\n        return obj\n\n    def get_type_metadata(self, type_name: str) -&gt; DataTypeClassInfo:\n\n        md = self._data_type_metadata.get(type_name, None)\n        if md is None:\n            md = DataTypeClassInfo.create_from_type_class(\n                type_cls=self.get_data_type_cls(type_name=type_name), kiara=self._kiara\n            )\n            self._data_type_metadata[type_name] = md\n        return self._data_type_metadata[type_name]\n\n    def get_context_metadata(\n        self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n    ) -&gt; DataTypeClassesInfo:\n\n        result = {}\n        for type_name in self.data_type_classes.keys():\n            md = self.get_type_metadata(type_name=type_name)\n            if only_for_package:\n                if md.context.labels.get(\"package\") == only_for_package:\n                    result[type_name] = md\n            else:\n                result[type_name] = md\n\n        _result = DataTypeClassesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n        _result._kiara = self._kiara\n        return _result\n\n    def is_internal_type(self, data_type_name: str) -&gt; bool:\n\n        if data_type_name not in self.data_type_profiles.keys():\n            return False\n\n        lineage = self.get_type_lineage(data_type_name=data_type_name)\n        return \"any\" not in lineage\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.data_type_classes","title":"<code>data_type_classes: bidict[str, Type[DataType]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.data_type_profiles","title":"<code>data_type_profiles: Mapping[str, Mapping[str, Any]]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.data_type_hierarchy","title":"<code>data_type_hierarchy: nx.DiGraph</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.data_type_names","title":"<code>data_type_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.invalidate_types","title":"<code>invalidate_types()</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def invalidate_types(self):\n\n    self._data_types = None\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.retrieve_data_type","title":"<code>retrieve_data_type(data_type_name: str, data_type_config: Union[Mapping[str, Any], None] = None) -&gt; DataType</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def retrieve_data_type(\n    self,\n    data_type_name: str,\n    data_type_config: Union[Mapping[str, Any], None] = None,\n) -&gt; DataType:\n\n    if data_type_config is None:\n        data_type_config = {}\n    else:\n        data_type_config = dict(data_type_config)\n\n    if data_type_name not in self.data_type_profiles.keys():\n        raise Exception(f\"Data type name not registered: {data_type_name}\")\n\n    data_type: str = self.data_type_profiles[data_type_name][\"type_name\"]\n    type_config = self.data_type_profiles[data_type_name][\"type_config\"]\n\n    if data_type_config:\n        type_config = dict(type_config)\n        type_config.update(data_type_config)\n\n    cls = self.get_data_type_cls(type_name=data_type)\n\n    hash = cls._calculate_data_type_hash(type_config)\n    if hash in self._cached_data_type_objects.keys():\n        return self._cached_data_type_objects[hash]\n\n    result = cls(**type_config)\n    assert result.data_type_hash == hash\n    self._cached_data_type_objects[result.data_type_hash] = result\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_sub_hierarchy","title":"<code>get_sub_hierarchy(data_type: str)</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_sub_hierarchy(self, data_type: str):\n\n    import networkx as nx\n\n    graph: nx.DiGraph = self.data_type_hierarchy\n\n    desc = nx.descendants(graph, data_type)\n    desc.add(data_type)\n    sub_graph = graph.subgraph(desc)\n    return sub_graph\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_type_lineage","title":"<code>get_type_lineage(data_type_name: str) -&gt; List[str]</code>","text":"<p>Returns the shortest path between the specified type and the root, in reverse direction starting from the specified type.</p> Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_type_lineage(self, data_type_name: str) -&gt; List[str]:\n\"\"\"Returns the shortest path between the specified type and the root, in reverse direction starting from the specified type.\"\"\"\n\n    if data_type_name not in self.data_type_profiles.keys():\n        raise DataTypeUnknownException(data_type=data_type_name)\n\n    if data_type_name in self._lineages_cache.keys():\n        return self._lineages_cache[data_type_name]\n\n    import networkx as nx\n\n    path = nx.shortest_path(\n        self.data_type_hierarchy, KIARA_ROOT_TYPE_NAME, data_type_name\n    )\n    path.remove(KIARA_ROOT_TYPE_NAME)\n    self._lineages_cache[data_type_name] = list(reversed(path))\n    return self._lineages_cache[data_type_name]\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_sub_types","title":"<code>get_sub_types(data_type_name: str) -&gt; Set[str]</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_sub_types(self, data_type_name: str) -&gt; Set[str]:\n\n    if data_type_name not in self.data_type_classes.keys():\n        raise Exception(f\"No data type '{data_type_name}' registered.\")\n\n    import networkx as nx\n\n    desc = nx.descendants(self.data_type_hierarchy, data_type_name)\n    return desc\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.is_profile","title":"<code>is_profile(data_type_name: str) -&gt; bool</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def is_profile(self, data_type_name: str) -&gt; bool:\n\n    type_config = self.data_type_profiles.get(data_type_name, {}).get(\n        \"type_config\", None\n    )\n    return True if type_config else False\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_profile_parent","title":"<code>get_profile_parent(data_type_name: str) -&gt; Union[None, bool]</code>","text":"<p>Return the parent data type of the specified data type (if that is indeed a profile name).</p> <p>If the specified data type is not a profile name, 'None' will be returned.</p> Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_profile_parent(self, data_type_name: str) -&gt; Union[None, bool]:\n\"\"\"Return the parent data type of the specified data type (if that is indeed a profile name).\n\n    If the specified data type is not a profile name, 'None' will be returned.\n    \"\"\"\n\n    return self.data_type_profiles.get(data_type_name, {}).get(\"type_name\", None)\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_associated_profiles","title":"<code>get_associated_profiles(data_type_name: str) -&gt; Mapping[str, Mapping[str, Any]]</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_associated_profiles(\n    self, data_type_name: str\n) -&gt; Mapping[str, Mapping[str, Any]]:\n\n    if data_type_name not in self.data_type_classes.keys():\n        raise Exception(f\"No data type '{data_type_name}' registered.\")\n\n    result = {}\n    for profile_name, details in self.data_type_profiles.items():\n        if (\n            profile_name != data_type_name\n            and data_type_name == details[\"type_name\"]\n        ):\n            result[profile_name] = details\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_data_type_cls","title":"<code>get_data_type_cls(type_name: str) -&gt; Type[DataType]</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_data_type_cls(self, type_name: str) -&gt; Type[DataType]:\n\n    _type_details = self.data_type_profiles.get(type_name, None)\n    if _type_details is None:\n        raise Exception(\n            f\"No value type '{type_name}', available types: {', '.join(self.data_type_profiles.keys())}\"\n        )\n\n    resolved_type_name: str = _type_details[\"type_name\"]\n\n    t = self.data_type_classes.get(resolved_type_name, None)\n    if t is None:\n        raise Exception(\n            f\"No value type '{type_name}', available types: {', '.join(self.data_type_profiles.keys())}\"\n        )\n    return t\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_data_type_instance","title":"<code>get_data_type_instance(type_name: str, type_config: Union[None, Mapping[str, Any]] = None) -&gt; DataType</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_data_type_instance(\n    self, type_name: str, type_config: Union[None, Mapping[str, Any]] = None\n) -&gt; DataType:\n\n    cls = self.get_data_type_cls(type_name=type_name)\n    if not type_config:\n        obj = cls()\n    else:\n        obj = cls(**type_config)\n    return obj\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_type_metadata","title":"<code>get_type_metadata(type_name: str) -&gt; DataTypeClassInfo</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_type_metadata(self, type_name: str) -&gt; DataTypeClassInfo:\n\n    md = self._data_type_metadata.get(type_name, None)\n    if md is None:\n        md = DataTypeClassInfo.create_from_type_class(\n            type_cls=self.get_data_type_cls(type_name=type_name), kiara=self._kiara\n        )\n        self._data_type_metadata[type_name] = md\n    return self._data_type_metadata[type_name]\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.get_context_metadata","title":"<code>get_context_metadata(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; DataTypeClassesInfo</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def get_context_metadata(\n    self, alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; DataTypeClassesInfo:\n\n    result = {}\n    for type_name in self.data_type_classes.keys():\n        md = self.get_type_metadata(type_name=type_name)\n        if only_for_package:\n            if md.context.labels.get(\"package\") == only_for_package:\n                result[type_name] = md\n        else:\n            result[type_name] = md\n\n    _result = DataTypeClassesInfo.construct(group_alias=alias, item_infos=result)  # type: ignore\n    _result._kiara = self._kiara\n    return _result\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types.TypeRegistry.is_internal_type","title":"<code>is_internal_type(data_type_name: str) -&gt; bool</code>","text":"Source code in <code>kiara/registries/types/__init__.py</code> <pre><code>def is_internal_type(self, data_type_name: str) -&gt; bool:\n\n    if data_type_name not in self.data_type_profiles.keys():\n        return False\n\n    lineage = self.get_type_lineage(data_type_name=data_type_name)\n    return \"any\" not in lineage\n</code></pre>"},{"location":"reference/kiara/registries/types/__init__/#kiara.registries.types-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/__init__/","title":"workflows","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive","title":"<code>WorkflowArchive</code>","text":"<p>         Bases: <code>BaseArchive</code></p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>class WorkflowArchive(BaseArchive):\n    @classmethod\n    def supported_item_types(cls) -&gt; Iterable[str]:\n        return [\"workflow\"]\n\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return False\n\n    @abc.abstractmethod\n    def retrieve_all_workflow_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_all_workflow_ids(self) -&gt; Iterable[uuid.UUID]:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_workflow_metadata(self, workflow_id: uuid.UUID):\n        pass\n\n    # @abc.abstractmethod\n    # def retrieve_workflow_states(\n    #     self, workflow_id: uuid.UUID, filter: Union[WorkflowStateFilter, None] = None\n    # ) -&gt; Dict[str, WorkflowState]:\n    #     pass\n\n    @abc.abstractmethod\n    def retrieve_workflow_state(self, workflow_state_id: str) -&gt; WorkflowState:\n\"\"\"Retrieve workflow state details for the provided state id.\n\n        Arguments:\n            workflow_id: id of the workflow\n            workflow_state_id: the id of the workflow state\n        \"\"\"\n\n    @abc.abstractmethod\n    def retrieve_all_states_for_workflow(\n        self, workflow_id: uuid.UUID\n    ) -&gt; Mapping[str, WorkflowState]:\n\"\"\"Retrieve workflow state details for the provided state id.\n\n        Arguments:\n            workflow_id: id of the workflow\n            workflow_state_id: the id of the workflow state\n        \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.supported_item_types","title":"<code>supported_item_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@classmethod\ndef supported_item_types(cls) -&gt; Iterable[str]:\n    return [\"workflow\"]\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return False\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.retrieve_all_workflow_aliases","title":"<code>retrieve_all_workflow_aliases() -&gt; Mapping[str, uuid.UUID]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_all_workflow_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.retrieve_all_workflow_ids","title":"<code>retrieve_all_workflow_ids() -&gt; Iterable[uuid.UUID]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_all_workflow_ids(self) -&gt; Iterable[uuid.UUID]:\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.retrieve_workflow_metadata","title":"<code>retrieve_workflow_metadata(workflow_id: uuid.UUID)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_workflow_metadata(self, workflow_id: uuid.UUID):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.retrieve_workflow_state","title":"<code>retrieve_workflow_state(workflow_state_id: str) -&gt; WorkflowState</code>  <code>abstractmethod</code>","text":"<p>Retrieve workflow state details for the provided state id.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <p>id of the workflow</p> required <code>workflow_state_id</code> <code>str</code> <p>the id of the workflow state</p> required Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_workflow_state(self, workflow_state_id: str) -&gt; WorkflowState:\n\"\"\"Retrieve workflow state details for the provided state id.\n\n    Arguments:\n        workflow_id: id of the workflow\n        workflow_state_id: the id of the workflow state\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowArchive.retrieve_all_states_for_workflow","title":"<code>retrieve_all_states_for_workflow(workflow_id: uuid.UUID) -&gt; Mapping[str, WorkflowState]</code>  <code>abstractmethod</code>","text":"<p>Retrieve workflow state details for the provided state id.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_id</code> <code>uuid.UUID</code> <p>id of the workflow</p> required <code>workflow_state_id</code> <p>the id of the workflow state</p> required Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_all_states_for_workflow(\n    self, workflow_id: uuid.UUID\n) -&gt; Mapping[str, WorkflowState]:\n\"\"\"Retrieve workflow state details for the provided state id.\n\n    Arguments:\n        workflow_id: id of the workflow\n        workflow_state_id: the id of the workflow state\n    \"\"\"\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore","title":"<code>WorkflowStore</code>","text":"<p>         Bases: <code>WorkflowArchive</code></p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>class WorkflowStore(WorkflowArchive):\n    @classmethod\n    def is_writeable(cls) -&gt; bool:\n        return True\n\n    def register_workflow(\n        self,\n        workflow_metadata: WorkflowMetadata,\n        workflow_aliases: Union[Iterable[str], None] = None,\n    ):\n\n        self._register_workflow_metadata(workflow_metadata=workflow_metadata)\n        if workflow_aliases:\n            if isinstance(workflow_aliases, str):\n                workflow_aliases = [workflow_aliases]\n            for workflow_alias in workflow_aliases:\n                self.register_alias(\n                    workflow_id=workflow_metadata.workflow_id, alias=workflow_alias\n                )\n        return workflow_metadata\n\n    def unregister_alias(self, alias: str) -&gt; bool:\n\"\"\"Unregister a workflow alias.\n\n        Returns:\n            'True' if an alias existed and was unregistered, 'False' otherwise\n        \"\"\"\n\n        raise NotImplementedError()\n\n    def update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n        self._update_workflow_metadata(workflow_metadata=workflow_metadata)\n\n    @abc.abstractmethod\n    def _register_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n        pass\n\n    @abc.abstractmethod\n    def _update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n        pass\n\n    @abc.abstractmethod\n    def add_workflow_state(self, workflow_state: WorkflowState):\n        pass\n\n    @abc.abstractmethod\n    def register_alias(self, workflow_id: uuid.UUID, alias: str):\n        pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.is_writeable","title":"<code>is_writeable() -&gt; bool</code>  <code>classmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@classmethod\ndef is_writeable(cls) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.register_workflow","title":"<code>register_workflow(workflow_metadata: WorkflowMetadata, workflow_aliases: Union[Iterable[str], None] = None)</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def register_workflow(\n    self,\n    workflow_metadata: WorkflowMetadata,\n    workflow_aliases: Union[Iterable[str], None] = None,\n):\n\n    self._register_workflow_metadata(workflow_metadata=workflow_metadata)\n    if workflow_aliases:\n        if isinstance(workflow_aliases, str):\n            workflow_aliases = [workflow_aliases]\n        for workflow_alias in workflow_aliases:\n            self.register_alias(\n                workflow_id=workflow_metadata.workflow_id, alias=workflow_alias\n            )\n    return workflow_metadata\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.unregister_alias","title":"<code>unregister_alias(alias: str) -&gt; bool</code>","text":"<p>Unregister a workflow alias.</p> <p>Returns:</p> Type Description <code>bool</code> <p>'True' if an alias existed and was unregistered, 'False' otherwise</p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def unregister_alias(self, alias: str) -&gt; bool:\n\"\"\"Unregister a workflow alias.\n\n    Returns:\n        'True' if an alias existed and was unregistered, 'False' otherwise\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.update_workflow_metadata","title":"<code>update_workflow_metadata(workflow_metadata: WorkflowMetadata)</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n    self._update_workflow_metadata(workflow_metadata=workflow_metadata)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.add_workflow_state","title":"<code>add_workflow_state(workflow_state: WorkflowState)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef add_workflow_state(self, workflow_state: WorkflowState):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowStore.register_alias","title":"<code>register_alias(workflow_id: uuid.UUID, alias: str)</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>@abc.abstractmethod\ndef register_alias(self, workflow_id: uuid.UUID, alias: str):\n    pass\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry","title":"<code>WorkflowRegistry</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>class WorkflowRegistry(object):\n    def __init__(self, kiara: \"Kiara\"):\n\n        self._kiara: Kiara = kiara\n        self._event_callback: Callable = self._kiara.event_registry.add_producer(self)\n\n        self._workflow_archives: Dict[str, WorkflowArchive] = {}\n\"\"\"All registered archives/stores.\"\"\"\n\n        self._default_alias_store: Union[str, None] = None\n\"\"\"The alias of the store where new aliases are stored by default.\"\"\"\n\n        self._all_aliases: Union[Dict[str, uuid.UUID], None] = None\n\"\"\"All workflow aliases.\"\"\"\n\n        self._all_workflow_ids: Union[Dict[uuid.UUID, str], None] = None\n\"\"\"All workflow ids, with store alias as values\"\"\"\n\n        self._cached_workflow_metadata_items: Dict[uuid.UUID, WorkflowMetadata] = {}\n\n    def register_archive(\n        self,\n        archive: WorkflowArchive,\n        alias: Union[str, None] = None,\n        set_as_default_store: Union[bool, None] = None,\n    ):\n\n        workflow_archive_id = archive.archive_id\n        archive.register_archive(kiara=self._kiara)\n\n        if alias is None:\n            alias = str(workflow_archive_id)\n\n        if \".\" in alias:\n            raise Exception(\n                f\"Can't register workflow archive with as '{alias}': registered name is not allowed to contain a '.' character (yet).\"\n            )\n\n        if alias in self._workflow_archives.keys():\n            raise Exception(\n                f\"Can't add store, workflow archive alias '{alias}' already registered.\"\n            )\n\n        self._workflow_archives[alias] = archive\n        is_store = False\n        is_default_store = False\n        if isinstance(archive, WorkflowStore):\n            is_store = True\n            if set_as_default_store and self._default_alias_store is not None:\n                raise Exception(\n                    f\"Can't set alias store '{alias}' as default store: default store already set.\"\n                )\n\n            if self._default_alias_store is None:\n                is_default_store = True\n                self._default_alias_store = alias\n\n        event = WorkflowArchiveAddedEvent.construct(\n            kiara_id=self._kiara.id,\n            workflow_archive_id=archive.archive_id,\n            workflow_archive_alias=alias,\n            is_store=is_store,\n            is_default_store=is_default_store,\n        )\n        self._event_callback(event)\n\n    @property\n    def default_alias_store(self) -&gt; str:\n\n        if self._default_alias_store is None:\n            raise Exception(\"No default alias store set (yet).\")\n        return self._default_alias_store\n\n    @property\n    def workflow_archives(self) -&gt; Mapping[str, WorkflowArchive]:\n        return self._workflow_archives\n\n    def get_archive(\n        self, archive_id: Union[str, None] = None\n    ) -&gt; Union[WorkflowArchive, None]:\n        if archive_id is None:\n            archive_id = self.default_alias_store\n            if archive_id is None:\n                raise Exception(\"Can't retrieve default alias archive, none set (yet).\")\n\n        archive = self._workflow_archives.get(archive_id, None)\n        return archive\n\n    def get_aliases(self, workflow_id: uuid.UUID) -&gt; List[str]:\n\"\"\"Return all aliases for the specified workflow id.\"\"\"\n\n        return [\n            alias\n            for alias, w_id in self.workflow_aliases.items()\n            if w_id == workflow_id\n        ]\n\n    @property\n    def workflow_aliases(self) -&gt; Dict[str, uuid.UUID]:\n\"\"\"Retrieve all registered workflow aliases.\"\"\"\n\n        if self._all_aliases is not None:\n            return self._all_aliases\n\n        all_workflows: Dict[str, uuid.UUID] = {}\n        for archive_alias, archive in self._workflow_archives.items():\n            workflow_map = archive.retrieve_all_workflow_aliases()\n            for alias, w_id in workflow_map.items():\n                if archive_alias == self.default_alias_store:\n                    final_alias = alias\n                else:\n                    final_alias = f\"{archive_alias}.{alias}\"\n\n                if final_alias in all_workflows.keys():\n                    raise Exception(\n                        f\"Inconsistent alias registry: alias '{final_alias}' available more than once.\"\n                    )\n                all_workflows[final_alias] = w_id\n        self._all_aliases = all_workflows\n        return self._all_aliases\n\n    @property\n    def all_workflow_ids(self) -&gt; Iterable[uuid.UUID]:\n\n        if self._all_workflow_ids is not None:\n            return self._all_workflow_ids.keys()\n\n        all_ids: Dict[uuid.UUID, str] = {}\n        for archive_alias, archive in self._workflow_archives.items():\n            ids = archive.retrieve_all_workflow_ids()\n\n            for _id in ids:\n                assert _id not in all_ids.keys()\n                all_ids[_id] = archive_alias\n\n        self._all_workflow_ids = all_ids\n        return self._all_workflow_ids.keys()\n\n    def get_workflow_id(self, workflow_alias: str) -&gt; uuid.UUID:\n\n        workflow_id = self.workflow_aliases.get(workflow_alias, None)\n\n        if workflow_id is None:\n            raise NoSuchWorkflowException(\n                workflow=workflow_alias,\n                msg=f\"Can't retrieve workflow with id/alias '{workflow_alias}': alias not registered.\",\n            )\n\n        return workflow_id\n\n    def get_workflow_metadata(\n        self, workflow: Union[str, uuid.UUID]\n    ) -&gt; WorkflowMetadata:\n\n        if isinstance(workflow, str):\n            try:\n                workflow_id = uuid.UUID(workflow)\n            except Exception:\n                workflow_id = self.get_workflow_id(workflow_alias=workflow)\n        else:\n            workflow_id = workflow\n\n        if workflow_id in self._cached_workflow_metadata_items.keys():\n            return self._cached_workflow_metadata_items[workflow_id]\n\n        if self._all_workflow_ids is None:\n            self.all_workflow_ids\n\n        store_alias = self._all_workflow_ids[workflow_id]  # type: ignore\n        store = self._workflow_archives[store_alias]\n\n        workflow_details = store.retrieve_workflow_metadata(workflow_id=workflow_id)\n        # workflow_metadata._kiara = self._kiara\n        # workflow = Workflow(kiara=self._kiara, workflow_metadata=workflow_metadata)\n        self._cached_workflow_metadata_items[workflow_id] = workflow_details\n\n        # states = store.retrieve_workflow_states(workflow_id=workflow_id)\n        # workflow._snapshots = states\n        # workflow.load_state()\n\n        return workflow_details\n\n    def unregister_alias(self, alias: str) -&gt; bool:\n\"\"\"Unregister a workflow alias.\n\n        Arguments:\n            alias: the alias\n\n        Returns:\n            whether an alias existed and was unregistered (True), or not (False)\n        \"\"\"\n\n        try:\n            self.get_workflow_id(workflow_alias=alias)\n        except NoSuchWorkflowException:\n            return False\n\n        store_name = self.default_alias_store\n        store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n        result = store.unregister_alias(alias=alias)\n        self.workflow_aliases.pop(alias)\n        return result\n\n    def register_workflow(\n        self,\n        workflow_metadata: Union[None, WorkflowMetadata, str] = None,\n        workflow_aliases: Union[Iterable[str], None] = None,\n    ) -&gt; WorkflowMetadata:\n\"\"\"Register a workflow.\n\n        If no details are specified, a new WorkflowMetadata object will be created. If a string is provided, a new\n        WorkflowMetadata object will be created that uses the string as documentation/description.\n\n        Arguments:\n            workflow_metadata: the (optional) metadata of the workflow\n            workflow_aliases: (optional) aliases to register the workflow under\n        \"\"\"\n\n        if workflow_aliases:\n            for workflow_alias in workflow_aliases:\n                if workflow_alias in self.workflow_aliases.keys():\n                    raise Exception(\n                        f\"Can't register workflow with alias '{workflow_alias}': alias already registered.\"\n                    )\n\n        store_name = self.default_alias_store\n        store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n        if workflow_metadata is None:\n            _workflow_id = ID_REGISTRY.generate(comment=\"New workflow object.\")\n            workflow_metadata = WorkflowMetadata(workflow_id=_workflow_id)\n            workflow_metadata._kiara = self._kiara\n        elif isinstance(workflow_metadata, str):\n            workflow_metadata = WorkflowMetadata(documentation=workflow_metadata)  # type: ignore\n            workflow_metadata._kiara = self._kiara\n\n        if self._all_workflow_ids is None:\n            self.all_workflow_ids\n\n        store.register_workflow(\n            workflow_metadata=workflow_metadata, workflow_aliases=workflow_aliases\n        )\n\n        self._all_workflow_ids[workflow_metadata.workflow_id] = store_name  # type: ignore\n        self._cached_workflow_metadata_items[\n            workflow_metadata.workflow_id\n        ] = workflow_metadata\n\n        if workflow_aliases:\n            for workflow_alias in workflow_aliases:\n                self._all_workflow_ids[workflow_metadata.workflow_id] = store_name  # type: ignore\n                self.workflow_aliases[workflow_alias] = workflow_metadata.workflow_id\n\n        return workflow_metadata\n\n    def get_workflow_state(\n        self,\n        workflow_state_id: Union[str, None] = None,\n        workflow: Union[None, uuid.UUID, str] = None,\n    ) -&gt; WorkflowState:\n\n        if workflow is None and workflow_state_id is None:\n            raise Exception(\n                \"Can't retrieve workflow state, neither workflow nor workflow state id specified.\"\n            )\n\n        if workflow:\n            workflow_details = self.get_workflow_metadata(workflow=workflow)\n            if workflow_state_id is None:\n                workflow_state_id = workflow_details.current_state\n            else:\n                if workflow_state_id not in workflow_details.workflow_history.values():\n                    raise Exception(\n                        f\"Can't retrieve workflow state '{workflow_state_id}' for workflow '{workflow}': state not registered for workflow.\"\n                    )\n        else:\n            raise NotImplementedError()\n\n        if workflow_state_id is None:\n            raise Exception(\n                f\"Can't retrieve current workflow state, no state exists yet for workflow '{workflow}'.\"\n            )\n\n        if self._all_workflow_ids is None:\n            self.all_workflow_ids\n        archive_alias = self._all_workflow_ids[workflow_details.workflow_id]  # type: ignore\n\n        archive = self.get_archive(archive_alias)\n        if archive is None:\n            raise Exception(\n                f\"Can't retrieve workflow archive '{archive_alias}', this is most likely a bug.\"\n            )\n        state = archive.retrieve_workflow_state(\n            workflow_state_id=workflow_state_id,\n        )\n        state._kiara = self._kiara\n\n        return state\n\n    def get_all_states_for_workflow(\n        self, workflow: Union[uuid.UUID, str]\n    ) -&gt; Mapping[str, WorkflowState]:\n\n        workflow_details = self.get_workflow_metadata(workflow=workflow)\n\n        if self._all_workflow_ids is None:\n            self.all_workflow_ids\n        archive_alias = self._all_workflow_ids[workflow_details.workflow_id]  # type: ignore\n\n        archive = self.get_archive(archive_alias)\n        if archive is None:\n            raise Exception(\n                f\"Can't retrieve workflow archive '{archive_alias}', this is most likely a bug.\"\n            )\n\n        states = archive.retrieve_all_states_for_workflow(\n            workflow_id=workflow_details.workflow_id\n        )\n        return states\n\n    def add_workflow_state(\n        self,\n        workflow: Union[str, uuid.UUID],\n        workflow_state: WorkflowState,\n        timestamp: Union[None, datetime.datetime] = None,\n        set_current: bool = True,\n    ) -&gt; WorkflowMetadata:\n\n        workflow_details = self.get_workflow_metadata(workflow=workflow)\n\n        if timestamp is None:\n            timestamp = datetime.datetime.now(pytz.utc)\n\n        if timestamp in workflow_details.workflow_history.keys():\n            if (\n                workflow_details.workflow_history[timestamp]\n                != workflow_state.instance_id\n            ):\n                raise Exception(\n                    f\"Can't register workflow for timestamp '{timestamp}': timestamp already registered.\"\n                )\n\n        workflow_details.workflow_history[timestamp] = workflow_state.instance_id\n\n        for field_name, value_id in workflow_state.inputs.items():\n            self._kiara.data_registry.store_value(value=value_id)\n\n        store_name = self.default_alias_store\n        store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n        store.add_workflow_state(workflow_state=workflow_state)\n        if set_current:\n            workflow_details.current_state = workflow_state.instance_id\n\n        store.update_workflow_metadata(workflow_details)\n\n        return workflow_details\n\n    def update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n        store_name = self.default_alias_store\n        store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n        store.update_workflow_metadata(workflow_metadata=workflow_metadata)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.default_alias_store","title":"<code>default_alias_store: str</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.workflow_archives","title":"<code>workflow_archives: Mapping[str, WorkflowArchive]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.workflow_aliases","title":"<code>workflow_aliases: Dict[str, uuid.UUID]</code>  <code>property</code>","text":"<p>Retrieve all registered workflow aliases.</p>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.all_workflow_ids","title":"<code>all_workflow_ids: Iterable[uuid.UUID]</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.register_archive","title":"<code>register_archive(archive: WorkflowArchive, alias: Union[str, None] = None, set_as_default_store: Union[bool, None] = None)</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def register_archive(\n    self,\n    archive: WorkflowArchive,\n    alias: Union[str, None] = None,\n    set_as_default_store: Union[bool, None] = None,\n):\n\n    workflow_archive_id = archive.archive_id\n    archive.register_archive(kiara=self._kiara)\n\n    if alias is None:\n        alias = str(workflow_archive_id)\n\n    if \".\" in alias:\n        raise Exception(\n            f\"Can't register workflow archive with as '{alias}': registered name is not allowed to contain a '.' character (yet).\"\n        )\n\n    if alias in self._workflow_archives.keys():\n        raise Exception(\n            f\"Can't add store, workflow archive alias '{alias}' already registered.\"\n        )\n\n    self._workflow_archives[alias] = archive\n    is_store = False\n    is_default_store = False\n    if isinstance(archive, WorkflowStore):\n        is_store = True\n        if set_as_default_store and self._default_alias_store is not None:\n            raise Exception(\n                f\"Can't set alias store '{alias}' as default store: default store already set.\"\n            )\n\n        if self._default_alias_store is None:\n            is_default_store = True\n            self._default_alias_store = alias\n\n    event = WorkflowArchiveAddedEvent.construct(\n        kiara_id=self._kiara.id,\n        workflow_archive_id=archive.archive_id,\n        workflow_archive_alias=alias,\n        is_store=is_store,\n        is_default_store=is_default_store,\n    )\n    self._event_callback(event)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_archive","title":"<code>get_archive(archive_id: Union[str, None] = None) -&gt; Union[WorkflowArchive, None]</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_archive(\n    self, archive_id: Union[str, None] = None\n) -&gt; Union[WorkflowArchive, None]:\n    if archive_id is None:\n        archive_id = self.default_alias_store\n        if archive_id is None:\n            raise Exception(\"Can't retrieve default alias archive, none set (yet).\")\n\n    archive = self._workflow_archives.get(archive_id, None)\n    return archive\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_aliases","title":"<code>get_aliases(workflow_id: uuid.UUID) -&gt; List[str]</code>","text":"<p>Return all aliases for the specified workflow id.</p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_aliases(self, workflow_id: uuid.UUID) -&gt; List[str]:\n\"\"\"Return all aliases for the specified workflow id.\"\"\"\n\n    return [\n        alias\n        for alias, w_id in self.workflow_aliases.items()\n        if w_id == workflow_id\n    ]\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_workflow_id","title":"<code>get_workflow_id(workflow_alias: str) -&gt; uuid.UUID</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_workflow_id(self, workflow_alias: str) -&gt; uuid.UUID:\n\n    workflow_id = self.workflow_aliases.get(workflow_alias, None)\n\n    if workflow_id is None:\n        raise NoSuchWorkflowException(\n            workflow=workflow_alias,\n            msg=f\"Can't retrieve workflow with id/alias '{workflow_alias}': alias not registered.\",\n        )\n\n    return workflow_id\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_workflow_metadata","title":"<code>get_workflow_metadata(workflow: Union[str, uuid.UUID]) -&gt; WorkflowMetadata</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_workflow_metadata(\n    self, workflow: Union[str, uuid.UUID]\n) -&gt; WorkflowMetadata:\n\n    if isinstance(workflow, str):\n        try:\n            workflow_id = uuid.UUID(workflow)\n        except Exception:\n            workflow_id = self.get_workflow_id(workflow_alias=workflow)\n    else:\n        workflow_id = workflow\n\n    if workflow_id in self._cached_workflow_metadata_items.keys():\n        return self._cached_workflow_metadata_items[workflow_id]\n\n    if self._all_workflow_ids is None:\n        self.all_workflow_ids\n\n    store_alias = self._all_workflow_ids[workflow_id]  # type: ignore\n    store = self._workflow_archives[store_alias]\n\n    workflow_details = store.retrieve_workflow_metadata(workflow_id=workflow_id)\n    # workflow_metadata._kiara = self._kiara\n    # workflow = Workflow(kiara=self._kiara, workflow_metadata=workflow_metadata)\n    self._cached_workflow_metadata_items[workflow_id] = workflow_details\n\n    # states = store.retrieve_workflow_states(workflow_id=workflow_id)\n    # workflow._snapshots = states\n    # workflow.load_state()\n\n    return workflow_details\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.unregister_alias","title":"<code>unregister_alias(alias: str) -&gt; bool</code>","text":"<p>Unregister a workflow alias.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>the alias</p> required <p>Returns:</p> Type Description <code>bool</code> <p>whether an alias existed and was unregistered (True), or not (False)</p> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def unregister_alias(self, alias: str) -&gt; bool:\n\"\"\"Unregister a workflow alias.\n\n    Arguments:\n        alias: the alias\n\n    Returns:\n        whether an alias existed and was unregistered (True), or not (False)\n    \"\"\"\n\n    try:\n        self.get_workflow_id(workflow_alias=alias)\n    except NoSuchWorkflowException:\n        return False\n\n    store_name = self.default_alias_store\n    store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n    result = store.unregister_alias(alias=alias)\n    self.workflow_aliases.pop(alias)\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.register_workflow","title":"<code>register_workflow(workflow_metadata: Union[None, WorkflowMetadata, str] = None, workflow_aliases: Union[Iterable[str], None] = None) -&gt; WorkflowMetadata</code>","text":"<p>Register a workflow.</p> <p>If no details are specified, a new WorkflowMetadata object will be created. If a string is provided, a new WorkflowMetadata object will be created that uses the string as documentation/description.</p> <p>Parameters:</p> Name Type Description Default <code>workflow_metadata</code> <code>Union[None, WorkflowMetadata, str]</code> <p>the (optional) metadata of the workflow</p> <code>None</code> <code>workflow_aliases</code> <code>Union[Iterable[str], None]</code> <p>(optional) aliases to register the workflow under</p> <code>None</code> Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def register_workflow(\n    self,\n    workflow_metadata: Union[None, WorkflowMetadata, str] = None,\n    workflow_aliases: Union[Iterable[str], None] = None,\n) -&gt; WorkflowMetadata:\n\"\"\"Register a workflow.\n\n    If no details are specified, a new WorkflowMetadata object will be created. If a string is provided, a new\n    WorkflowMetadata object will be created that uses the string as documentation/description.\n\n    Arguments:\n        workflow_metadata: the (optional) metadata of the workflow\n        workflow_aliases: (optional) aliases to register the workflow under\n    \"\"\"\n\n    if workflow_aliases:\n        for workflow_alias in workflow_aliases:\n            if workflow_alias in self.workflow_aliases.keys():\n                raise Exception(\n                    f\"Can't register workflow with alias '{workflow_alias}': alias already registered.\"\n                )\n\n    store_name = self.default_alias_store\n    store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n    if workflow_metadata is None:\n        _workflow_id = ID_REGISTRY.generate(comment=\"New workflow object.\")\n        workflow_metadata = WorkflowMetadata(workflow_id=_workflow_id)\n        workflow_metadata._kiara = self._kiara\n    elif isinstance(workflow_metadata, str):\n        workflow_metadata = WorkflowMetadata(documentation=workflow_metadata)  # type: ignore\n        workflow_metadata._kiara = self._kiara\n\n    if self._all_workflow_ids is None:\n        self.all_workflow_ids\n\n    store.register_workflow(\n        workflow_metadata=workflow_metadata, workflow_aliases=workflow_aliases\n    )\n\n    self._all_workflow_ids[workflow_metadata.workflow_id] = store_name  # type: ignore\n    self._cached_workflow_metadata_items[\n        workflow_metadata.workflow_id\n    ] = workflow_metadata\n\n    if workflow_aliases:\n        for workflow_alias in workflow_aliases:\n            self._all_workflow_ids[workflow_metadata.workflow_id] = store_name  # type: ignore\n            self.workflow_aliases[workflow_alias] = workflow_metadata.workflow_id\n\n    return workflow_metadata\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_workflow_state","title":"<code>get_workflow_state(workflow_state_id: Union[str, None] = None, workflow: Union[None, uuid.UUID, str] = None) -&gt; WorkflowState</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_workflow_state(\n    self,\n    workflow_state_id: Union[str, None] = None,\n    workflow: Union[None, uuid.UUID, str] = None,\n) -&gt; WorkflowState:\n\n    if workflow is None and workflow_state_id is None:\n        raise Exception(\n            \"Can't retrieve workflow state, neither workflow nor workflow state id specified.\"\n        )\n\n    if workflow:\n        workflow_details = self.get_workflow_metadata(workflow=workflow)\n        if workflow_state_id is None:\n            workflow_state_id = workflow_details.current_state\n        else:\n            if workflow_state_id not in workflow_details.workflow_history.values():\n                raise Exception(\n                    f\"Can't retrieve workflow state '{workflow_state_id}' for workflow '{workflow}': state not registered for workflow.\"\n                )\n    else:\n        raise NotImplementedError()\n\n    if workflow_state_id is None:\n        raise Exception(\n            f\"Can't retrieve current workflow state, no state exists yet for workflow '{workflow}'.\"\n        )\n\n    if self._all_workflow_ids is None:\n        self.all_workflow_ids\n    archive_alias = self._all_workflow_ids[workflow_details.workflow_id]  # type: ignore\n\n    archive = self.get_archive(archive_alias)\n    if archive is None:\n        raise Exception(\n            f\"Can't retrieve workflow archive '{archive_alias}', this is most likely a bug.\"\n        )\n    state = archive.retrieve_workflow_state(\n        workflow_state_id=workflow_state_id,\n    )\n    state._kiara = self._kiara\n\n    return state\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.get_all_states_for_workflow","title":"<code>get_all_states_for_workflow(workflow: Union[uuid.UUID, str]) -&gt; Mapping[str, WorkflowState]</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def get_all_states_for_workflow(\n    self, workflow: Union[uuid.UUID, str]\n) -&gt; Mapping[str, WorkflowState]:\n\n    workflow_details = self.get_workflow_metadata(workflow=workflow)\n\n    if self._all_workflow_ids is None:\n        self.all_workflow_ids\n    archive_alias = self._all_workflow_ids[workflow_details.workflow_id]  # type: ignore\n\n    archive = self.get_archive(archive_alias)\n    if archive is None:\n        raise Exception(\n            f\"Can't retrieve workflow archive '{archive_alias}', this is most likely a bug.\"\n        )\n\n    states = archive.retrieve_all_states_for_workflow(\n        workflow_id=workflow_details.workflow_id\n    )\n    return states\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.add_workflow_state","title":"<code>add_workflow_state(workflow: Union[str, uuid.UUID], workflow_state: WorkflowState, timestamp: Union[None, datetime.datetime] = None, set_current: bool = True) -&gt; WorkflowMetadata</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def add_workflow_state(\n    self,\n    workflow: Union[str, uuid.UUID],\n    workflow_state: WorkflowState,\n    timestamp: Union[None, datetime.datetime] = None,\n    set_current: bool = True,\n) -&gt; WorkflowMetadata:\n\n    workflow_details = self.get_workflow_metadata(workflow=workflow)\n\n    if timestamp is None:\n        timestamp = datetime.datetime.now(pytz.utc)\n\n    if timestamp in workflow_details.workflow_history.keys():\n        if (\n            workflow_details.workflow_history[timestamp]\n            != workflow_state.instance_id\n        ):\n            raise Exception(\n                f\"Can't register workflow for timestamp '{timestamp}': timestamp already registered.\"\n            )\n\n    workflow_details.workflow_history[timestamp] = workflow_state.instance_id\n\n    for field_name, value_id in workflow_state.inputs.items():\n        self._kiara.data_registry.store_value(value=value_id)\n\n    store_name = self.default_alias_store\n    store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n    store.add_workflow_state(workflow_state=workflow_state)\n    if set_current:\n        workflow_details.current_state = workflow_state.instance_id\n\n    store.update_workflow_metadata(workflow_details)\n\n    return workflow_details\n</code></pre>"},{"location":"reference/kiara/registries/workflows/__init__/#kiara.registries.workflows.WorkflowRegistry.update_workflow_metadata","title":"<code>update_workflow_metadata(workflow_metadata: WorkflowMetadata)</code>","text":"Source code in <code>kiara/registries/workflows/__init__.py</code> <pre><code>def update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n    store_name = self.default_alias_store\n    store: WorkflowStore = self.get_archive(archive_id=store_name)  # type: ignore\n\n    store.update_workflow_metadata(workflow_metadata=workflow_metadata)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/","title":"archives","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives-classes","title":"Classes","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive","title":"<code>FileSystemWorkflowArchive</code>","text":"<p>         Bases: <code>WorkflowArchive</code></p> Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>class FileSystemWorkflowArchive(WorkflowArchive):\n\n    _archive_type_name = \"filesystem_workflow_archive\"\n    _config_cls = FileSystemArchiveConfig  # type: ignore\n\n    def __init__(self, archive_id: uuid.UUID, config: ARCHIVE_CONFIG_CLS):\n\n        super().__init__(archive_id=archive_id, config=config)\n\n        self._base_path: Union[Path, None] = None\n        self.alias_store_path.mkdir(parents=True, exist_ok=True)\n\n    @property\n    def workflow_store_path(self) -&gt; Path:\n\n        if self._base_path is not None:\n            return self._base_path\n\n        self._base_path = Path(self.config.archive_path).absolute()  # type: ignore\n        self._base_path = fix_windows_longpath(self._base_path)\n        self._base_path.mkdir(parents=True, exist_ok=True)\n        return self._base_path\n\n    @property\n    def alias_store_path(self) -&gt; Path:\n\n        return self.workflow_store_path / \"aliases\"\n\n    def _delete_archive(self):\n        shutil.rmtree(self.workflow_store_path)\n\n    @property\n    def workflow_path(self) -&gt; Path:\n        return self.workflow_store_path / \"workflows\"\n\n    @property\n    def workflow_states_path(self) -&gt; Path:\n        return self.workflow_store_path / \"states\"\n\n    def get_workflow_details_path(self, workflow_id: uuid.UUID) -&gt; Path:\n\n        return self.workflow_path / str(workflow_id) / \"workflow.json\"\n\n    def get_alias_path(self, alias: str):\n\n        return self.alias_store_path / f\"{alias}.alias\"\n\n    def retrieve_all_workflow_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n\n        all_aliases = self.alias_store_path.glob(\"*.alias\")\n        result: Dict[str, uuid.UUID] = {}\n        for path in all_aliases:\n            alias = path.name[0:-6]\n            workflow_path = path.resolve()\n            workflow_id = uuid.UUID(workflow_path.parent.name)\n            if alias in result.keys():\n                raise Exception(\n                    f\"Invalid internal state for workflow archive '{self.archive_id}': duplicate alias '{alias}'.\"\n                )\n            result[alias] = workflow_id\n\n        return result\n\n    def retrieve_all_workflow_ids(self) -&gt; Iterable[uuid.UUID]:\n\n        all_ids = self.workflow_path.glob(\"*\")\n        result = []\n        for path in all_ids:\n            workflow_id = uuid.UUID(path.name)\n            result.append(workflow_id)\n        return result\n\n    def retrieve_workflow_metadata(self, workflow_id: uuid.UUID) -&gt; WorkflowMetadata:\n\n        workflow_path = self.get_workflow_details_path(workflow_id=workflow_id)\n        if not workflow_path.exists():\n            raise NoSuchWorkflowException(\n                workflow=workflow_id,\n                msg=f\"Can't retrieve workflow with id '{workflow_id}': id does not exist.\",\n            )\n\n        workflow_json = workflow_path.read_text()\n\n        workflow_data = orjson.loads(workflow_json)\n        workflow = WorkflowMetadata(**workflow_data)\n        workflow._kiara = self.kiara_context\n\n        return workflow\n\n    def retrieve_workflow_state(self, workflow_state_id: str) -&gt; WorkflowState:\n\n        workflow_state_path = self.workflow_states_path / f\"{workflow_state_id}.state\"\n\n        if not workflow_state_path.exists():\n            raise Exception(f\"No workflow state with id '{workflow_state_id}' exists.\")\n\n        _data = workflow_state_path.read_text()\n        _json = orjson.loads(_data)\n        # _json[\"pipeline_info\"][\"pipeline_structure\"] = {\n        #     \"pipeline_config\": _json[\"pipeline_info\"][\"pipeline_structure\"][\n        #         \"pipeline_config\"\n        #     ]\n        # }\n        _state = WorkflowState(**_json)\n        _state.pipeline_info._kiara = self.kiara_context\n        _state._kiara = self.kiara_context\n        return _state\n\n    def retrieve_all_states_for_workflow(\n        self, workflow_id: uuid.UUID\n    ) -&gt; Mapping[str, WorkflowState]:\n\n        details = self.retrieve_workflow_metadata(workflow_id=workflow_id)\n\n        result = {}\n        for ws_id in details.workflow_history.values():\n            ws_state = self.retrieve_workflow_state(workflow_state_id=ws_id)\n            result[ws_id] = ws_state\n\n        return result\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive-attributes","title":"Attributes","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive._config_cls","title":"<code>_config_cls = FileSystemArchiveConfig</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.workflow_store_path","title":"<code>workflow_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.alias_store_path","title":"<code>alias_store_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.workflow_path","title":"<code>workflow_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.workflow_states_path","title":"<code>workflow_states_path: Path</code>  <code>property</code>","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.get_workflow_details_path","title":"<code>get_workflow_details_path(workflow_id: uuid.UUID) -&gt; Path</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def get_workflow_details_path(self, workflow_id: uuid.UUID) -&gt; Path:\n\n    return self.workflow_path / str(workflow_id) / \"workflow.json\"\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.get_alias_path","title":"<code>get_alias_path(alias: str)</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def get_alias_path(self, alias: str):\n\n    return self.alias_store_path / f\"{alias}.alias\"\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.retrieve_all_workflow_aliases","title":"<code>retrieve_all_workflow_aliases() -&gt; Mapping[str, uuid.UUID]</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def retrieve_all_workflow_aliases(self) -&gt; Mapping[str, uuid.UUID]:\n\n    all_aliases = self.alias_store_path.glob(\"*.alias\")\n    result: Dict[str, uuid.UUID] = {}\n    for path in all_aliases:\n        alias = path.name[0:-6]\n        workflow_path = path.resolve()\n        workflow_id = uuid.UUID(workflow_path.parent.name)\n        if alias in result.keys():\n            raise Exception(\n                f\"Invalid internal state for workflow archive '{self.archive_id}': duplicate alias '{alias}'.\"\n            )\n        result[alias] = workflow_id\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.retrieve_all_workflow_ids","title":"<code>retrieve_all_workflow_ids() -&gt; Iterable[uuid.UUID]</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def retrieve_all_workflow_ids(self) -&gt; Iterable[uuid.UUID]:\n\n    all_ids = self.workflow_path.glob(\"*\")\n    result = []\n    for path in all_ids:\n        workflow_id = uuid.UUID(path.name)\n        result.append(workflow_id)\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.retrieve_workflow_metadata","title":"<code>retrieve_workflow_metadata(workflow_id: uuid.UUID) -&gt; WorkflowMetadata</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def retrieve_workflow_metadata(self, workflow_id: uuid.UUID) -&gt; WorkflowMetadata:\n\n    workflow_path = self.get_workflow_details_path(workflow_id=workflow_id)\n    if not workflow_path.exists():\n        raise NoSuchWorkflowException(\n            workflow=workflow_id,\n            msg=f\"Can't retrieve workflow with id '{workflow_id}': id does not exist.\",\n        )\n\n    workflow_json = workflow_path.read_text()\n\n    workflow_data = orjson.loads(workflow_json)\n    workflow = WorkflowMetadata(**workflow_data)\n    workflow._kiara = self.kiara_context\n\n    return workflow\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.retrieve_workflow_state","title":"<code>retrieve_workflow_state(workflow_state_id: str) -&gt; WorkflowState</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def retrieve_workflow_state(self, workflow_state_id: str) -&gt; WorkflowState:\n\n    workflow_state_path = self.workflow_states_path / f\"{workflow_state_id}.state\"\n\n    if not workflow_state_path.exists():\n        raise Exception(f\"No workflow state with id '{workflow_state_id}' exists.\")\n\n    _data = workflow_state_path.read_text()\n    _json = orjson.loads(_data)\n    # _json[\"pipeline_info\"][\"pipeline_structure\"] = {\n    #     \"pipeline_config\": _json[\"pipeline_info\"][\"pipeline_structure\"][\n    #         \"pipeline_config\"\n    #     ]\n    # }\n    _state = WorkflowState(**_json)\n    _state.pipeline_info._kiara = self.kiara_context\n    _state._kiara = self.kiara_context\n    return _state\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowArchive.retrieve_all_states_for_workflow","title":"<code>retrieve_all_states_for_workflow(workflow_id: uuid.UUID) -&gt; Mapping[str, WorkflowState]</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def retrieve_all_states_for_workflow(\n    self, workflow_id: uuid.UUID\n) -&gt; Mapping[str, WorkflowState]:\n\n    details = self.retrieve_workflow_metadata(workflow_id=workflow_id)\n\n    result = {}\n    for ws_id in details.workflow_history.values():\n        ws_state = self.retrieve_workflow_state(workflow_state_id=ws_id)\n        result[ws_id] = ws_state\n\n    return result\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowStore","title":"<code>FileSystemWorkflowStore</code>","text":"<p>         Bases: <code>FileSystemWorkflowArchive</code>, <code>WorkflowStore</code></p> Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>class FileSystemWorkflowStore(FileSystemWorkflowArchive, WorkflowStore):\n\n    _archive_type_name = \"filesystem_workflow_store\"\n\n    def _register_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n        workflow_path = self.get_workflow_details_path(\n            workflow_id=workflow_metadata.workflow_id\n        )\n\n        if workflow_path.exists():\n            raise Exception(\n                f\"Can't register workflow with id '{workflow_metadata.workflow_id}': id already registered.\"\n            )\n\n        workflow_path.parent.mkdir(parents=True, exist_ok=False)\n\n        workflow_json = workflow_metadata.json(option=orjson.OPT_NON_STR_KEYS)\n        workflow_path.write_text(workflow_json)\n\n    def _update_workflow_metadata(self, workflow_metadata: WorkflowMetadata):\n\n        workflow_path = self.get_workflow_details_path(\n            workflow_id=workflow_metadata.workflow_id\n        )\n\n        if not workflow_path.exists():\n            raise Exception(\n                f\"Can't update workflow with id '{workflow_metadata.workflow_id}': id not registered.\"\n            )\n\n        workflow_json = workflow_metadata.json(option=orjson.OPT_NON_STR_KEYS)\n        workflow_path.write_text(workflow_json)\n\n    def register_alias(self, workflow_id: uuid.UUID, alias: str, force: bool = False):\n\n        alias_path = self.get_alias_path(alias=alias)\n        if not force and alias_path.exists():\n            raise Exception(\n                f\"Can't register workflow alias '{alias}': alias already registered.\"\n            )\n        elif alias_path.exists():\n            alias_path.unlink()\n\n        workflow_path = self.get_workflow_details_path(workflow_id=workflow_id)\n        if not workflow_path.exists():\n            raise Exception(\n                f\"Can't register workflow alias '{alias}': target id '{workflow_id}' not registered.\"\n            )\n\n        alias_path.symlink_to(workflow_path)\n\n    def unregister_alias(self, alias: str) -&gt; bool:\n\n        alias_path = self.get_alias_path(alias=alias)\n\n        if not alias_path.exists():\n            return False\n\n        alias_path.unlink()\n        return True\n\n    def add_workflow_state(self, workflow_state: WorkflowState):\n\n        self.workflow_states_path.mkdir(exist_ok=True, parents=True)\n        workflow_state_path = (\n            self.workflow_states_path / f\"{workflow_state.instance_id}.state\"\n        )\n\n        workflow_state_json = workflow_state.json(option=orjson.OPT_NON_STR_KEYS)\n        workflow_state_path.write_text(workflow_state_json)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowStore-functions","title":"Functions","text":""},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowStore.register_alias","title":"<code>register_alias(workflow_id: uuid.UUID, alias: str, force: bool = False)</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def register_alias(self, workflow_id: uuid.UUID, alias: str, force: bool = False):\n\n    alias_path = self.get_alias_path(alias=alias)\n    if not force and alias_path.exists():\n        raise Exception(\n            f\"Can't register workflow alias '{alias}': alias already registered.\"\n        )\n    elif alias_path.exists():\n        alias_path.unlink()\n\n    workflow_path = self.get_workflow_details_path(workflow_id=workflow_id)\n    if not workflow_path.exists():\n        raise Exception(\n            f\"Can't register workflow alias '{alias}': target id '{workflow_id}' not registered.\"\n        )\n\n    alias_path.symlink_to(workflow_path)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowStore.unregister_alias","title":"<code>unregister_alias(alias: str) -&gt; bool</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def unregister_alias(self, alias: str) -&gt; bool:\n\n    alias_path = self.get_alias_path(alias=alias)\n\n    if not alias_path.exists():\n        return False\n\n    alias_path.unlink()\n    return True\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives.FileSystemWorkflowStore.add_workflow_state","title":"<code>add_workflow_state(workflow_state: WorkflowState)</code>","text":"Source code in <code>kiara/registries/workflows/archives.py</code> <pre><code>def add_workflow_state(self, workflow_state: WorkflowState):\n\n    self.workflow_states_path.mkdir(exist_ok=True, parents=True)\n    workflow_state_path = (\n        self.workflow_states_path / f\"{workflow_state.instance_id}.state\"\n    )\n\n    workflow_state_json = workflow_state.json(option=orjson.OPT_NON_STR_KEYS)\n    workflow_state_path.write_text(workflow_state_json)\n</code></pre>"},{"location":"reference/kiara/registries/workflows/archives/#kiara.registries.workflows.archives-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/__init__/","title":"renderers","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.RENDERER_CONFIG","title":"<code>RENDERER_CONFIG = TypeVar('RENDERER_CONFIG', bound=KiaraRendererConfig)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SOURCE_TYPE","title":"<code>SOURCE_TYPE = TypeVar('SOURCE_TYPE')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.INPUTS_SCHEMA","title":"<code>INPUTS_SCHEMA = TypeVar('INPUTS_SCHEMA', bound=RenderInputsSchema)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.TARGET_TYPE","title":"<code>TARGET_TYPE = TypeVar('TARGET_TYPE')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers-classes","title":"Classes","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRendererConfig","title":"<code>KiaraRendererConfig</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>class KiaraRendererConfig(KiaraModel):\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.RenderInputsSchema","title":"<code>RenderInputsSchema</code>","text":"<p>         Bases: <code>KiaraModel</code></p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>class RenderInputsSchema(KiaraModel):\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SourceTransformer","title":"<code>SourceTransformer</code>","text":"<p>         Bases: <code>Generic[SOURCE_TYPE]</code></p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>class SourceTransformer(Generic[SOURCE_TYPE]):\n    def __init__(self) -&gt; None:\n        self._doc: Union[DocumentationMetadataModel, None] = None\n\n    @abc.abstractmethod\n    def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n        pass\n\n    @abc.abstractmethod\n    def validate_and_transform(self, source: Any) -&gt; Union[SOURCE_TYPE, None]:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n        pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SourceTransformer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SourceTransformer.retrieve_supported_python_classes","title":"<code>retrieve_supported_python_classes() -&gt; Iterable[Type]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SourceTransformer.validate_and_transform","title":"<code>validate_and_transform(source: Any) -&gt; Union[SOURCE_TYPE, None]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>@abc.abstractmethod\ndef validate_and_transform(self, source: Any) -&gt; Union[SOURCE_TYPE, None]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.SourceTransformer.retrieve_supported_inputs_descs","title":"<code>retrieve_supported_inputs_descs() -&gt; Union[str, Iterable[str]]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.NoOpSourceTransformer","title":"<code>NoOpSourceTransformer</code>","text":"<p>         Bases: <code>SourceTransformer</code></p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>class NoOpSourceTransformer(SourceTransformer):\n    def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n        return [object]\n\n    def validate_and_transform(self, source: Any) -&gt; Any:\n        return source\n\n    def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n        return \"any Python input, unchecked\"\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.NoOpSourceTransformer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.NoOpSourceTransformer.retrieve_supported_python_classes","title":"<code>retrieve_supported_python_classes() -&gt; Iterable[Type]</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n    return [object]\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.NoOpSourceTransformer.validate_and_transform","title":"<code>validate_and_transform(source: Any) -&gt; Any</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def validate_and_transform(self, source: Any) -&gt; Any:\n    return source\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.NoOpSourceTransformer.retrieve_supported_inputs_descs","title":"<code>retrieve_supported_inputs_descs() -&gt; Union[str, Iterable[str]]</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n    return \"any Python input, unchecked\"\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer","title":"<code>KiaraRenderer</code>","text":"<p>         Bases: <code>abc.ABC</code>, <code>Generic[SOURCE_TYPE, INPUTS_SCHEMA, TARGET_TYPE, RENDERER_CONFIG]</code></p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>class KiaraRenderer(\n    abc.ABC, Generic[SOURCE_TYPE, INPUTS_SCHEMA, TARGET_TYPE, RENDERER_CONFIG]\n):\n\n    _renderer_config_cls: Type[RENDERER_CONFIG] = KiaraRendererConfig  # type: ignore\n    _inputs_schema: Type[INPUTS_SCHEMA] = RenderInputsSchema  # type: ignore\n\n    def __init__(\n        self,\n        kiara: \"Kiara\",\n        renderer_config: Union[None, Mapping[str, Any], KiaraRendererConfig] = None,\n    ):\n\n        self._kiara: \"Kiara\" = kiara\n        self._source_transformers: Union[None, Iterable[SourceTransformer]] = None\n        self._doc: Union[DocumentationMetadataModel, None] = None\n        self._supported_inputs_desc: Union[None, Iterable[str]] = None\n\n        if renderer_config is None:\n            self._config: RENDERER_CONFIG = self.__class__._renderer_config_cls()\n        elif isinstance(renderer_config, Mapping):\n            self._config = self.__class__._renderer_config_cls(**renderer_config)\n        elif not isinstance(renderer_config, self.__class__._renderer_config_cls):\n            raise Exception(\n                f\"Can't create renderer instance, invalid config type: {type(renderer_config)}, must be: {self.__class__._renderer_config_cls.__name__}\"\n            )\n        else:\n            self._config = renderer_config\n\n    @property\n    def renderer_config(self) -&gt; RENDERER_CONFIG:\n        return self._config\n\n    @property\n    def supported_inputs_descs(self) -&gt; Iterable[str]:\n\n        if self._supported_inputs_desc is not None:\n            return self._supported_inputs_desc\n\n        transformers: List[str] = []\n        for transformer in self.source_transformers:\n            descs = transformer.retrieve_supported_inputs_descs()\n            if isinstance(descs, str):\n                descs = [descs]\n            transformers.extend(descs)\n        return transformers\n\n    def retrieve_doc(self) -&gt; Union[str, None]:\n        return None\n\n    @property\n    def doc(self) -&gt; DocumentationMetadataModel:\n        if self._doc is not None:\n            return self._doc\n\n        doc = self.retrieve_doc()\n        if doc is None:\n            doc = self.__class__.__doc__\n            if not doc:\n                doc = \"\"\n            doc = f\"{inspect.cleandoc(doc)}\\n\\n\"\n\n        transformers_list = \"Supported inputs:\\n\\n\"\n        for transformer in self.supported_inputs_descs:\n            transformers_list += f\"- {transformer}\\n\"\n\n        doc = f\"{doc}\\n\\n{transformers_list}\"\n\n        self._doc = DocumentationMetadataModel.create(doc)\n        return self._doc\n\n    @property\n    def source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        if self._source_transformers is None:\n            self._source_transformers = self.retrieve_source_transformers()\n        return self._source_transformers\n\n    def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        return [NoOpSourceTransformer()]\n\n    def retrieve_supported_python_classes(self) -&gt; Set[Type]:\n\"\"\"Retrieve the set of Python classes that this renderer supports as inputs.\"\"\"\n\n        result: Set[Type] = set()\n        for x in self.source_transformers:\n            result.update(x.retrieve_supported_python_classes())\n        return result\n\n    def get_renderer_alias(self) -&gt; str:\n        return self.__class__._renderer_name  # type: ignore\n\n    @abc.abstractmethod\n    def retrieve_supported_render_sources(self) -&gt; Union[Iterable[str], str]:\n        pass\n\n    @abc.abstractmethod\n    def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n        pass\n\n    @abc.abstractmethod\n    def _render(\n        self, instance: SOURCE_TYPE, render_config: INPUTS_SCHEMA\n    ) -&gt; TARGET_TYPE:\n        pass\n\n    def _post_process(self, rendered: Any) -&gt; TARGET_TYPE:\n        return rendered\n\n    def render(self, instance: SOURCE_TYPE, render_config: INPUTS_SCHEMA) -&gt; Any:\n\n        transformed = None\n        for transformer in self.source_transformers:\n            try:\n\n                for cls in transformer.retrieve_supported_python_classes():\n                    if isinstance(instance, cls):\n                        transformed = transformer.validate_and_transform(instance)\n                        if transformed is not None:\n                            break\n            except Exception as e:\n                raise KiaraException(\"Error transforming source object.\", parent=e)\n\n        if not transformed:\n            raise Exception(f\"Can't transform input object: {instance}.\")\n\n        try:\n            rendered: TARGET_TYPE = self._render(\n                instance=transformed, render_config=render_config\n            )\n        except Exception as e:\n\n            if isinstance(e, TemplateNotFound):\n                details = f\"Template not found: {e}\"\n                raise KiaraException(\"Error while rendering item.\", details=details)\n            else:\n                raise e\n\n        try:\n            post_processed: TARGET_TYPE = self._post_process(rendered=rendered)\n        except Exception as e:\n            raise KiaraException(\"Error post-processing rendered item.\", parent=e)\n\n        return post_processed\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.renderer_config","title":"<code>renderer_config: RENDERER_CONFIG</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.supported_inputs_descs","title":"<code>supported_inputs_descs: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.doc","title":"<code>doc: DocumentationMetadataModel</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.source_transformers","title":"<code>source_transformers: Iterable[SourceTransformer]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.retrieve_doc","title":"<code>retrieve_doc() -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def retrieve_doc(self) -&gt; Union[str, None]:\n    return None\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.retrieve_source_transformers","title":"<code>retrieve_source_transformers() -&gt; Iterable[SourceTransformer]</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n    return [NoOpSourceTransformer()]\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.retrieve_supported_python_classes","title":"<code>retrieve_supported_python_classes() -&gt; Set[Type]</code>","text":"<p>Retrieve the set of Python classes that this renderer supports as inputs.</p> Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def retrieve_supported_python_classes(self) -&gt; Set[Type]:\n\"\"\"Retrieve the set of Python classes that this renderer supports as inputs.\"\"\"\n\n    result: Set[Type] = set()\n    for x in self.source_transformers:\n        result.update(x.retrieve_supported_python_classes())\n    return result\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.get_renderer_alias","title":"<code>get_renderer_alias() -&gt; str</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def get_renderer_alias(self) -&gt; str:\n    return self.__class__._renderer_name  # type: ignore\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; Union[Iterable[str], str]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_supported_render_sources(self) -&gt; Union[Iterable[str], str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Iterable[str], str]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>@abc.abstractmethod\ndef retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/__init__/#kiara.renderers.KiaraRenderer.render","title":"<code>render(instance: SOURCE_TYPE, render_config: INPUTS_SCHEMA) -&gt; Any</code>","text":"Source code in <code>kiara/renderers/__init__.py</code> <pre><code>def render(self, instance: SOURCE_TYPE, render_config: INPUTS_SCHEMA) -&gt; Any:\n\n    transformed = None\n    for transformer in self.source_transformers:\n        try:\n\n            for cls in transformer.retrieve_supported_python_classes():\n                if isinstance(instance, cls):\n                    transformed = transformer.validate_and_transform(instance)\n                    if transformed is not None:\n                        break\n        except Exception as e:\n            raise KiaraException(\"Error transforming source object.\", parent=e)\n\n    if not transformed:\n        raise Exception(f\"Can't transform input object: {instance}.\")\n\n    try:\n        rendered: TARGET_TYPE = self._render(\n            instance=transformed, render_config=render_config\n        )\n    except Exception as e:\n\n        if isinstance(e, TemplateNotFound):\n            details = f\"Template not found: {e}\"\n            raise KiaraException(\"Error while rendering item.\", details=details)\n        else:\n            raise e\n\n    try:\n        post_processed: TARGET_TYPE = self._post_process(rendered=rendered)\n    except Exception as e:\n        raise KiaraException(\"Error post-processing rendered item.\", parent=e)\n\n    return post_processed\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/","title":"jinja","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja-classes","title":"Classes","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaEnv","title":"<code>JinjaEnv</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/renderers/jinja.py</code> <pre><code>class JinjaEnv(BaseModel):\n\n    template_base: Union[str, None] = Field(\n        description=\"The alias of the base loader to use. Defaults to a special loader that combines all template sources.\",\n        default=None,\n    )\n\n    _render_registry: \"RenderRegistry\" = PrivateAttr(default=None)\n\n    @property\n    def instance(self) -&gt; Environment:\n\n        return self._render_registry.retrieve_jinja_env(self.template_base)\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaEnv-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaEnv.template_base","title":"<code>template_base: Union[str, None] = Field(description='The alias of the base loader to use. Defaults to a special loader that combines all template sources.', default=None)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaEnv.instance","title":"<code>instance: Environment</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRndererConfig","title":"<code>JinjaRndererConfig</code>","text":"<p>         Bases: <code>KiaraRendererConfig</code></p> Source code in <code>kiara/renderers/jinja.py</code> <pre><code>class JinjaRndererConfig(KiaraRendererConfig):\n\n    env: JinjaEnv = Field(description=\"The loader to use for the jinja environment.\")\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRndererConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRndererConfig.env","title":"<code>env: JinjaEnv = Field(description='The loader to use for the jinja environment.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer","title":"<code>BaseJinjaRenderer</code>","text":"<p>         Bases: <code>KiaraRenderer[SOURCE_TYPE, INPUTS_SCHEMA, str, JinjaRndererConfig]</code>, <code>Generic[SOURCE_TYPE, INPUTS_SCHEMA]</code></p> Source code in <code>kiara/renderers/jinja.py</code> <pre><code>class BaseJinjaRenderer(\n    KiaraRenderer[SOURCE_TYPE, INPUTS_SCHEMA, str, JinjaRndererConfig],\n    Generic[SOURCE_TYPE, INPUTS_SCHEMA],\n):\n\n    _renderer_config_cls = JinjaRndererConfig\n\n    def __init__(\n        self,\n        kiara: \"Kiara\",\n        renderer_config: Union[None, Mapping[str, Any], KiaraRendererConfig] = None,\n    ):\n\n        self._jinja_env: Union[Environment, None] = None\n        super().__init__(kiara=kiara, renderer_config=renderer_config)\n\n    def get_jinja_env(self) -&gt; Environment:\n\n        if self._jinja_env is None:\n            je = self.retrieve_jinja_env()\n            je._render_registry = self._kiara.render_registry\n            self._jinja_env = je.instance\n        return self._jinja_env\n\n    def retrieve_jinja_env(self) -&gt; JinjaEnv:\n        return JinjaEnv()\n\n    @abc.abstractmethod\n    def get_template(self, render_config: INPUTS_SCHEMA) -&gt; Template:\n        pass\n\n    @abc.abstractmethod\n    def assemble_render_inputs(\n        self, instance: Any, render_config: INPUTS_SCHEMA\n    ) -&gt; Mapping[str, Any]:\n        pass\n\n    def _render(self, instance: SOURCE_TYPE, render_config: INPUTS_SCHEMA) -&gt; str:\n\n        template = self.get_template(render_config=render_config)\n        if template is None:\n            msg = \"Available templates:\\n\"\n            for template_name in self.get_jinja_env().list_templates():\n                msg += f\" - {template_name}\\n\"\n            raise KiaraException(msg=f\"Could not find requested template for renderer '{self.__class__._renderer_name}'\", details=msg)  # type: ignore\n\n        inputs = self.assemble_render_inputs(instance, render_config=render_config)\n        rendered = template.render(**inputs)\n        return rendered\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer.get_jinja_env","title":"<code>get_jinja_env() -&gt; Environment</code>","text":"Source code in <code>kiara/renderers/jinja.py</code> <pre><code>def get_jinja_env(self) -&gt; Environment:\n\n    if self._jinja_env is None:\n        je = self.retrieve_jinja_env()\n        je._render_registry = self._kiara.render_registry\n        self._jinja_env = je.instance\n    return self._jinja_env\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer.retrieve_jinja_env","title":"<code>retrieve_jinja_env() -&gt; JinjaEnv</code>","text":"Source code in <code>kiara/renderers/jinja.py</code> <pre><code>def retrieve_jinja_env(self) -&gt; JinjaEnv:\n    return JinjaEnv()\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer.get_template","title":"<code>get_template(render_config: INPUTS_SCHEMA) -&gt; Template</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/jinja.py</code> <pre><code>@abc.abstractmethod\ndef get_template(self, render_config: INPUTS_SCHEMA) -&gt; Template:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.BaseJinjaRenderer.assemble_render_inputs","title":"<code>assemble_render_inputs(instance: Any, render_config: INPUTS_SCHEMA) -&gt; Mapping[str, Any]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/jinja.py</code> <pre><code>@abc.abstractmethod\ndef assemble_render_inputs(\n    self, instance: Any, render_config: INPUTS_SCHEMA\n) -&gt; Mapping[str, Any]:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderInputsSchema","title":"<code>JinjaRenderInputsSchema</code>","text":"<p>         Bases: <code>RenderInputsSchema</code></p> Source code in <code>kiara/renderers/jinja.py</code> <pre><code>class JinjaRenderInputsSchema(RenderInputsSchema):\n    template: str = Field(description=\"The template to use for rendering.\")\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderInputsSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderInputsSchema.template","title":"<code>template: str = Field(description='The template to use for rendering.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderer","title":"<code>JinjaRenderer</code>","text":"<p>         Bases: <code>BaseJinjaRenderer[Any, JinjaRenderInputsSchema]</code></p> Source code in <code>kiara/renderers/jinja.py</code> <pre><code>class JinjaRenderer(BaseJinjaRenderer[Any, JinjaRenderInputsSchema]):\n\n    _renderer_name = \"jinja\"\n    _inputs_schema_cls = JinjaRenderInputsSchema\n\n    def get_template(self, render_config: JinjaRenderInputsSchema) -&gt; Template:\n\n        try:\n            template = self.get_jinja_env().get_template(render_config.template)\n            return template\n        except Exception as e:\n            raise Exception(f\"Error loading template '{render_config.template}': {e}\")\n</code></pre>"},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/jinja/#kiara.renderers.jinja.JinjaRenderer.get_template","title":"<code>get_template(render_config: JinjaRenderInputsSchema) -&gt; Template</code>","text":"Source code in <code>kiara/renderers/jinja.py</code> <pre><code>def get_template(self, render_config: JinjaRenderInputsSchema) -&gt; Template:\n\n    try:\n        template = self.get_jinja_env().get_template(render_config.template)\n        return template\n    except Exception as e:\n        raise Exception(f\"Error loading template '{render_config.template}': {e}\")\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/__init__/","title":"included_renderers","text":""},{"location":"reference/kiara/renderers/included_renderers/api/","title":"api","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api-classes","title":"Classes","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderInputsSchema","title":"<code>ApiRenderInputsSchema</code>","text":"<p>         Bases: <code>RenderInputsSchema</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiRenderInputsSchema(RenderInputsSchema):\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRendererConfig","title":"<code>ApiRendererConfig</code>","text":"<p>         Bases: <code>KiaraRendererConfig</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiRendererConfig(KiaraRendererConfig):\n\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint","title":"<code>ApiEndpoint</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiEndpoint(object):\n    def __init__(self, func: Callable):\n\n        self._func = func\n        self._wrapped: Union[None, ValidatedFunction] = None\n        self._arg_names: Union[None, List[str]] = None\n        self._arg_details: Union[None, Dict[str, Any]] = None\n        self._doc_string: Union[None, str] = None\n        self._parsed_doc: Union[Docstring, None] = None\n        self._doc: Union[DocumentationMetadataModel, None] = None\n\n    @property\n    def doc_string(self):\n\n        if self._doc_string is not None:\n            return self._doc_string\n\n        _doc_string = self._func.__doc__\n        if _doc_string is None:\n            _doc_string = \"\"\n\n        self._doc_string = inspect.cleandoc(_doc_string)\n        return self._doc_string\n\n    @property\n    def doc(self) -&gt; DocumentationMetadataModel:\n\n        if self._doc is not None:\n            return self._doc\n\n        self._doc = DocumentationMetadataModel(\n            description=self.parsed_doc.short_description,\n            doc=self.parsed_doc.long_description,\n        )\n        return self._doc\n\n    @property\n    def parsed_doc(self) -&gt; Docstring:\n\n        if self._parsed_doc is not None:\n            return self._parsed_doc\n\n        parsed = parse(self.doc_string)\n        self._parsed_doc = parsed\n        return self._parsed_doc\n\n    def get_arg_doc(self, arg_name: str) -&gt; str:\n\n        for p in self.parsed_doc.params:\n            if p.arg_name == arg_name:\n                return p.description if p.description else \"\"\n\n        return \"\"\n\n    @property\n    def validated_func(self) -&gt; ValidatedFunction:\n\n        if self._wrapped is not None:\n            return self._wrapped\n\n        self._wrapped = ValidatedFunction(self._func, None)\n        return self._wrapped\n\n    @property\n    def arg_model(self) -&gt; Type[BaseModel]:\n\n        return self.validated_func.model\n\n    @property\n    def argument_names(self) -&gt; List[str]:\n\n        if self._arg_names is not None:\n            return self._arg_names\n\n        self._arg_names = [\n            x\n            for x in self.validated_func.model.__fields__\n            if x not in [\"self\", \"v__duplicate_kwargs\", \"args\", \"kwargs\"]\n        ]\n        return self._arg_names\n\n    @property\n    def arg_schema(self) -&gt; Dict[str, ModelField]:\n\n        if self._arg_details is not None:\n            return self._arg_details\n\n        self._arg_details = {\n            k: self.validated_func.model.__fields__[k] for k in self.argument_names\n        }\n        return self._arg_details\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.doc_string","title":"<code>doc_string</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.doc","title":"<code>doc: DocumentationMetadataModel</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.parsed_doc","title":"<code>parsed_doc: Docstring</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.validated_func","title":"<code>validated_func: ValidatedFunction</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.arg_model","title":"<code>arg_model: Type[BaseModel]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.argument_names","title":"<code>argument_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.arg_schema","title":"<code>arg_schema: Dict[str, ModelField]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoint.get_arg_doc","title":"<code>get_arg_doc(arg_name: str) -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def get_arg_doc(self, arg_name: str) -&gt; str:\n\n    for p in self.parsed_doc.params:\n        if p.arg_name == arg_name:\n            return p.description if p.description else \"\"\n\n    return \"\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoints","title":"<code>ApiEndpoints</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiEndpoints(object):\n    def __init__(self, api_cls: Type):\n\n        self._api_cls = api_cls\n        self._api_endpoint_names: Union[None, List[str]] = None\n        self._endpoint_details: Dict[str, ApiEndpoint] = {}\n\n    @property\n    def api_endpint_names(self) -&gt; List[str]:\n\n        if self._api_endpoint_names is not None:\n            return self._api_endpoint_names\n\n        temp = []\n        for func_name in dir(KiaraAPI):\n            if func_name.startswith(\"_\"):\n                continue\n            temp.append(func_name)\n\n        self._api_endpoint_names = sorted(temp)\n        return self._api_endpoint_names\n\n    def get_api_endpoint(self, endpoint_name: str) -&gt; ApiEndpoint:\n\n        if endpoint_name in self._endpoint_details:\n            return self._endpoint_details[endpoint_name]\n\n        func = getattr(KiaraAPI, endpoint_name)\n        result = ApiEndpoint(func)\n        self._endpoint_details[endpoint_name] = result\n        return result\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoints-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoints.api_endpint_names","title":"<code>api_endpint_names: List[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoints-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiEndpoints.get_api_endpoint","title":"<code>get_api_endpoint(endpoint_name: str) -&gt; ApiEndpoint</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def get_api_endpoint(self, endpoint_name: str) -&gt; ApiEndpoint:\n\n    if endpoint_name in self._endpoint_details:\n        return self._endpoint_details[endpoint_name]\n\n    func = getattr(KiaraAPI, endpoint_name)\n    result = ApiEndpoint(func)\n    self._endpoint_details[endpoint_name] = result\n    return result\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer","title":"<code>ApiRenderer</code>","text":"<p>         Bases: <code>KiaraRenderer[KiaraAPI, ApiRenderInputsSchema, RenderValueResult, ApiRendererConfig]</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiRenderer(\n    KiaraRenderer[KiaraAPI, ApiRenderInputsSchema, RenderValueResult, ApiRendererConfig]\n):\n    _inputs_schema = ApiRenderInputsSchema\n    _renderer_config_cls = ApiRendererConfig\n\n    def __init__(\n        self,\n        kiara: \"Kiara\",\n        renderer_config: Union[None, Mapping[str, Any], KiaraRendererConfig] = None,\n    ):\n\n        self._api_endpoints: ApiEndpoints = ApiEndpoints(api_cls=KiaraAPI)\n        super().__init__(kiara=kiara, renderer_config=renderer_config)\n\n    @property\n    def api_endpoints(self) -&gt; ApiEndpoints:\n        return self._api_endpoints\n\n    def get_renderer_alias(self) -&gt; str:\n        return f\"api_to_{self.get_target_type()}\"\n\n    def retrieve_supported_render_sources(self) -&gt; str:\n        return \"kiara_api\"\n\n    def retrieve_doc(self) -&gt; Union[str, None]:\n\n        return f\"Render the kiara (of a supported type) to: '{self.get_target_type()}'.\"\n\n    @abc.abstractmethod\n    def get_target_type(self) -&gt; str:\n        pass\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer.api_endpoints","title":"<code>api_endpoints: ApiEndpoints</code>  <code>property</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer.get_renderer_alias","title":"<code>get_renderer_alias() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def get_renderer_alias(self) -&gt; str:\n    return f\"api_to_{self.get_target_type()}\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def retrieve_supported_render_sources(self) -&gt; str:\n    return \"kiara_api\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer.retrieve_doc","title":"<code>retrieve_doc() -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def retrieve_doc(self) -&gt; Union[str, None]:\n\n    return f\"Render the kiara (of a supported type) to: '{self.get_target_type()}'.\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiRenderer.get_target_type","title":"<code>get_target_type() -&gt; str</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>@abc.abstractmethod\ndef get_target_type(self) -&gt; str:\n    pass\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiDocRenderer","title":"<code>ApiDocRenderer</code>","text":"<p>         Bases: <code>ApiRenderer</code></p> Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>class ApiDocRenderer(ApiRenderer):\n\n    _renderer_name = \"api_doc_renderer\"\n\n    def get_target_type(self) -&gt; str:\n        return \"html\"\n\n    def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n        return \"html\"\n\n    def _render(self, instance: KiaraAPI, render_config: ApiRenderInputsSchema) -&gt; Any:\n\n        # details = self.api_endpoints.get_api_endpoint(\"get_value\")\n        details = self.api_endpoints.get_api_endpoint(\"retrieve_aliases_info\")\n\n        # for k, v in details.arg_schema.items():\n        #     print(k)\n        #     print(type(v))\n\n        terminal_print(create_table_from_base_model_cls(details.arg_model))\n\n        return \"xxx\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiDocRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiDocRenderer.get_target_type","title":"<code>get_target_type() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def get_target_type(self) -&gt; str:\n    return \"html\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api.ApiDocRenderer.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Iterable[str], str]</code>","text":"Source code in <code>kiara/renderers/included_renderers/api.py</code> <pre><code>def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n    return \"html\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/api/#kiara.renderers.included_renderers.api-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/","title":"pipeline","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline-classes","title":"Classes","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineTransformer","title":"<code>PipelineTransformer</code>","text":"<p>         Bases: <code>SourceTransformer</code></p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineTransformer(SourceTransformer):\n    def __init__(self, kiara: \"Kiara\"):\n        self._kiara: \"Kiara\" = kiara\n        super().__init__()\n\n    def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n        return [PipelineConfig, Pipeline, PipelineStructure, str, Mapping]\n\n    def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n        return [\n            \"a registered pipeline operation\",\n            \"a path to a pipeline file\",\n            \"the pipeline configuration as a Python dict\",\n        ]\n\n    def validate_and_transform(self, source: Any) -&gt; Union[Pipeline, None]:\n\n        if isinstance(source, Pipeline):\n            return source\n        elif isinstance(source, (PipelineConfig, PipelineStructure, Mapping, str)):\n            pipeline = Pipeline.create_pipeline(kiara=self._kiara, pipeline=source)\n            return pipeline\n        else:\n            return None\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineTransformer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineTransformer.retrieve_supported_python_classes","title":"<code>retrieve_supported_python_classes() -&gt; Iterable[Type]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n    return [PipelineConfig, Pipeline, PipelineStructure, str, Mapping]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineTransformer.retrieve_supported_inputs_descs","title":"<code>retrieve_supported_inputs_descs() -&gt; Union[str, Iterable[str]]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n    return [\n        \"a registered pipeline operation\",\n        \"a path to a pipeline file\",\n        \"the pipeline configuration as a Python dict\",\n    ]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineTransformer.validate_and_transform","title":"<code>validate_and_transform(source: Any) -&gt; Union[Pipeline, None]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def validate_and_transform(self, source: Any) -&gt; Union[Pipeline, None]:\n\n    if isinstance(source, Pipeline):\n        return source\n    elif isinstance(source, (PipelineConfig, PipelineStructure, Mapping, str)):\n        pipeline = Pipeline.create_pipeline(kiara=self._kiara, pipeline=source)\n        return pipeline\n    else:\n        return None\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml","title":"<code>PipelineRendererHtml</code>","text":"<p>         Bases: <code>BaseJinjaRenderer[Type[Pipeline], RenderInputsSchema]</code></p> <p>Renders a pipeline structure as static html page.</p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineRendererHtml(BaseJinjaRenderer[Type[Pipeline], RenderInputsSchema]):\n\"\"\"Renders a pipeline structure as static html page.\"\"\"\n\n    _renderer_name = \"pipeline_html\"\n\n    # _render_profiles: Mapping[str, Mapping[str, Any]] = {\"html\": {}}\n\n    def retrieve_supported_render_sources(cls) -&gt; str:\n        return \"pipeline\"\n\n    def retrieve_supported_render_targets(self) -&gt; Union[Set[str], str]:\n        return \"html\"\n\n    def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        return [PipelineTransformer(kiara=self._kiara)]\n\n    def retrieve_jinja_env(self) -&gt; JinjaEnv:\n\n        jinja_env = JinjaEnv(template_base=\"kiara\")\n        return jinja_env\n\n    def get_template(self, render_config: RenderInputsSchema) -&gt; Template:\n\n        return self.get_jinja_env().get_template(\"pipeline/static_page/page.html.j2\")\n\n    def assemble_render_inputs(\n        self, instance: Any, render_config: RenderInputsSchema\n    ) -&gt; Mapping[str, Any]:\n\n        inputs = render_config.dict()\n        inputs[\"pipeline\"] = instance\n        return inputs\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_sources(cls) -&gt; str:\n    return \"pipeline\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Set[str], str]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_targets(self) -&gt; Union[Set[str], str]:\n    return \"html\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.retrieve_source_transformers","title":"<code>retrieve_source_transformers() -&gt; Iterable[SourceTransformer]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n    return [PipelineTransformer(kiara=self._kiara)]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.retrieve_jinja_env","title":"<code>retrieve_jinja_env() -&gt; JinjaEnv</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_jinja_env(self) -&gt; JinjaEnv:\n\n    jinja_env = JinjaEnv(template_base=\"kiara\")\n    return jinja_env\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.get_template","title":"<code>get_template(render_config: RenderInputsSchema) -&gt; Template</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def get_template(self, render_config: RenderInputsSchema) -&gt; Template:\n\n    return self.get_jinja_env().get_template(\"pipeline/static_page/page.html.j2\")\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererHtml.assemble_render_inputs","title":"<code>assemble_render_inputs(instance: Any, render_config: RenderInputsSchema) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def assemble_render_inputs(\n    self, instance: Any, render_config: RenderInputsSchema\n) -&gt; Mapping[str, Any]:\n\n    inputs = render_config.dict()\n    inputs[\"pipeline\"] = instance\n    return inputs\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown","title":"<code>PipelineRendererMarkdown</code>","text":"<p>         Bases: <code>BaseJinjaRenderer[Type[Pipeline], RenderInputsSchema]</code></p> <p>Renders a pipeline structure as static html page.</p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineRendererMarkdown(BaseJinjaRenderer[Type[Pipeline], RenderInputsSchema]):\n\"\"\"Renders a pipeline structure as static html page.\"\"\"\n\n    _renderer_name = \"pipeline_markdown\"\n\n    # _render_profiles: Mapping[str, Mapping[str, Any]] = {\"html\": {}}\n\n    def retrieve_supported_render_sources(cls) -&gt; str:\n        return \"pipeline\"\n\n    def retrieve_supported_render_targets(self) -&gt; Union[Set[str], str]:\n        return \"markdown\"\n\n    def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        return [PipelineTransformer(kiara=self._kiara)]\n\n    def retrieve_jinja_env(self) -&gt; JinjaEnv:\n\n        jinja_env = JinjaEnv(template_base=\"kiara\")\n        return jinja_env\n\n    def get_template(self, render_config: RenderInputsSchema) -&gt; Template:\n\n        return self.get_jinja_env().get_template(\"pipeline/markdown/pipeline.md.j2\")\n\n    def assemble_render_inputs(\n        self, instance: Any, render_config: RenderInputsSchema\n    ) -&gt; Mapping[str, Any]:\n\n        inputs = render_config.dict()\n        inputs[\"pipeline\"] = instance\n        return inputs\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_sources(cls) -&gt; str:\n    return \"pipeline\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Set[str], str]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_targets(self) -&gt; Union[Set[str], str]:\n    return \"markdown\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.retrieve_source_transformers","title":"<code>retrieve_source_transformers() -&gt; Iterable[SourceTransformer]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n    return [PipelineTransformer(kiara=self._kiara)]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.retrieve_jinja_env","title":"<code>retrieve_jinja_env() -&gt; JinjaEnv</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_jinja_env(self) -&gt; JinjaEnv:\n\n    jinja_env = JinjaEnv(template_base=\"kiara\")\n    return jinja_env\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.get_template","title":"<code>get_template(render_config: RenderInputsSchema) -&gt; Template</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def get_template(self, render_config: RenderInputsSchema) -&gt; Template:\n\n    return self.get_jinja_env().get_template(\"pipeline/markdown/pipeline.md.j2\")\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererMarkdown.assemble_render_inputs","title":"<code>assemble_render_inputs(instance: Any, render_config: RenderInputsSchema) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def assemble_render_inputs(\n    self, instance: Any, render_config: RenderInputsSchema\n) -&gt; Mapping[str, Any]:\n\n    inputs = render_config.dict()\n    inputs[\"pipeline\"] = instance\n    return inputs\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPngConfig","title":"<code>PipelineRendererPngConfig</code>","text":"<p>         Bases: <code>KiaraRendererConfig</code></p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineRendererPngConfig(KiaraRendererConfig):\n\n    graph_type: Literal[\"execution\", \"data-flow\", \"data-flow-simple\", \"stages\"] = Field(\n        description=\"The type of graph to render.\"\n    )\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPngConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPngConfig.graph_type","title":"<code>graph_type: Literal['execution', 'data-flow', 'data-flow-simple', 'stages'] = Field(description='The type of graph to render.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineInputsSchema","title":"<code>PipelineInputsSchema</code>","text":"<p>         Bases: <code>RenderInputsSchema</code></p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineInputsSchema(RenderInputsSchema):\n\n    stages_extraction_type: str = Field(\n        description=\"The type of stages extraction to use.\", default=\"late\"\n    )\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineInputsSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineInputsSchema.stages_extraction_type","title":"<code>stages_extraction_type: str = Field(description='The type of stages extraction to use.', default='late')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng","title":"<code>PipelineRendererPng</code>","text":"<p>         Bases: <code>KiaraRenderer[Pipeline, PipelineInputsSchema, bytes, PipelineRendererPngConfig]</code></p> Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>class PipelineRendererPng(\n    KiaraRenderer[Pipeline, PipelineInputsSchema, bytes, PipelineRendererPngConfig]\n):\n\n    _renderer_name = \"pipeline_png\"\n    _renderer_config_cls = PipelineRendererPngConfig  # type: ignore\n    _inputs_schema = PipelineInputsSchema\n\n    _renderer_profiles: Mapping[str, Mapping[str, Any]] = {\n        \"execution-graph-image\": {\"graph_type\": \"execution\"},\n        \"data-flow-graph-image\": {\"graph_type\": \"data-flow\"},\n        \"data-flow-simple-graph-image\": {\"graph_type\": \"data-flow-simple\"},\n        \"stages-graph-image\": {\"graph_type\": \"stages\"},\n    }\n\n    def retrieve_doc(self) -&gt; Union[str, None]:\n\n        graph_type = self.renderer_config.graph_type\n\n        if graph_type == \"execution\":\n            graph = \"the execution graph\"\n        elif graph_type == \"data-flow\":\n            graph = \"the data flow graph\"\n        elif graph_type == \"data-flow-simple\":\n            graph = \"a simplified version of the data flow graph\"\n        elif graph_type == \"stages\":\n            graph = \"the stages graph\"\n        else:\n            raise Exception(f\"Invalid graph type: {graph_type}\")\n\n        return f\"Render {graph} of the given pipeline as a image (in png format).\"\n\n    def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        return [PipelineTransformer(kiara=self._kiara)]\n\n    def get_renderer_alias(self) -&gt; str:\n        return f\"{self.renderer_config.graph_type}_png\"\n\n    def retrieve_supported_render_sources(self) -&gt; str:\n        return \"pipeline\"\n\n    def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n        return f\"{self.renderer_config.graph_type}_png\"\n\n    def _render(self, instance: Pipeline, render_config: PipelineInputsSchema) -&gt; bytes:\n\n        graph_type = self.renderer_config.graph_type\n\n        if graph_type == \"execution\":\n            graph = instance.structure.execution_graph\n        elif graph_type == \"data-flow\":\n            graph = instance.structure.data_flow_graph\n        elif graph_type == \"data-flow-simple\":\n            graph = instance.structure.data_flow_graph_simple\n        elif graph_type == \"stages\":\n            graph = instance.structure.get_stages_graph(\n                stages_extraction_type=render_config.stages_extraction_type\n            )\n        else:\n            raise Exception(f\"Invalid graph type: {graph_type}\")\n\n        image = create_image(graph)\n        return image\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng.retrieve_doc","title":"<code>retrieve_doc() -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_doc(self) -&gt; Union[str, None]:\n\n    graph_type = self.renderer_config.graph_type\n\n    if graph_type == \"execution\":\n        graph = \"the execution graph\"\n    elif graph_type == \"data-flow\":\n        graph = \"the data flow graph\"\n    elif graph_type == \"data-flow-simple\":\n        graph = \"a simplified version of the data flow graph\"\n    elif graph_type == \"stages\":\n        graph = \"the stages graph\"\n    else:\n        raise Exception(f\"Invalid graph type: {graph_type}\")\n\n    return f\"Render {graph} of the given pipeline as a image (in png format).\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng.retrieve_source_transformers","title":"<code>retrieve_source_transformers() -&gt; Iterable[SourceTransformer]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n    return [PipelineTransformer(kiara=self._kiara)]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng.get_renderer_alias","title":"<code>get_renderer_alias() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def get_renderer_alias(self) -&gt; str:\n    return f\"{self.renderer_config.graph_type}_png\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_sources(self) -&gt; str:\n    return \"pipeline\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline.PipelineRendererPng.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Iterable[str], str]</code>","text":"Source code in <code>kiara/renderers/included_renderers/pipeline.py</code> <pre><code>def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n    return f\"{self.renderer_config.graph_type}_png\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/pipeline/#kiara.renderers.included_renderers.pipeline-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/value/","title":"value","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value-classes","title":"Classes","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueTransformer","title":"<code>ValueTransformer</code>","text":"<p>         Bases: <code>SourceTransformer</code></p> Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>class ValueTransformer(SourceTransformer):\n    def __init__(self, kiara: \"Kiara\", target_type: str):\n\n        self._kiara: Kiara = kiara\n        self._target_type: str = target_type\n        super().__init__()\n\n    def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n\n        return [Value, uuid.UUID, str]\n\n    def validate_and_transform(self, source: Any) -&gt; Union[Value, None]:\n\n        return self._kiara.data_registry.get_value(source)\n\n    def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n        op_type: RenderValueOperationType = self._kiara.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n        ops = op_type.get_render_operations_for_target_type(\n            target_type=self._target_type\n        )\n\n        return [\n            f\"a value of type '{x}'\"\n            for x in sorted(ops.keys())\n            if x not in [\"any\", \"none\"]\n        ]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueTransformer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueTransformer.retrieve_supported_python_classes","title":"<code>retrieve_supported_python_classes() -&gt; Iterable[Type]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_supported_python_classes(self) -&gt; Iterable[Type]:\n\n    return [Value, uuid.UUID, str]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueTransformer.validate_and_transform","title":"<code>validate_and_transform(source: Any) -&gt; Union[Value, None]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def validate_and_transform(self, source: Any) -&gt; Union[Value, None]:\n\n    return self._kiara.data_registry.get_value(source)\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueTransformer.retrieve_supported_inputs_descs","title":"<code>retrieve_supported_inputs_descs() -&gt; Union[str, Iterable[str]]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_supported_inputs_descs(self) -&gt; Union[str, Iterable[str]]:\n    op_type: RenderValueOperationType = self._kiara.operation_registry.get_operation_type(\"render_value\")  # type: ignore\n    ops = op_type.get_render_operations_for_target_type(\n        target_type=self._target_type\n    )\n\n    return [\n        f\"a value of type '{x}'\"\n        for x in sorted(ops.keys())\n        if x not in [\"any\", \"none\"]\n    ]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderInputsSchema","title":"<code>ValueRenderInputsSchema</code>","text":"<p>         Bases: <code>RenderInputsSchema</code></p> Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>class ValueRenderInputsSchema(RenderInputsSchema):\n    render_config: Mapping[str, Any] = Field(\n        description=\"The render config data.\", default_factory=dict\n    )\n    include_metadata: bool = Field(\n        description=\"Whether to include metadata.\", default=False\n    )\n    include_data: bool = Field(\n        description=\"Whether to include data (only applies when 'include_metadata' is set to 'True').\",\n        default=True,\n    )\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderInputsSchema-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderInputsSchema.render_config","title":"<code>render_config: Mapping[str, Any] = Field(description='The render config data.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderInputsSchema.include_metadata","title":"<code>include_metadata: bool = Field(description='Whether to include metadata.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderInputsSchema.include_data","title":"<code>include_data: bool = Field(description=\"Whether to include data (only applies when 'include_metadata' is set to 'True').\", default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRendererConfig","title":"<code>ValueRendererConfig</code>","text":"<p>         Bases: <code>KiaraRendererConfig</code></p> Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>class ValueRendererConfig(KiaraRendererConfig):\n    target_type: str = Field(description=\"The target type to render the value as.\")\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRendererConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRendererConfig.target_type","title":"<code>target_type: str = Field(description='The target type to render the value as.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer","title":"<code>ValueRenderer</code>","text":"<p>         Bases: <code>KiaraRenderer[Value, ValueRenderInputsSchema, RenderValueResult, ValueRendererConfig]</code></p> Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>class ValueRenderer(\n    KiaraRenderer[\n        Value, ValueRenderInputsSchema, RenderValueResult, ValueRendererConfig\n    ]\n):\n    _renderer_name = \"value_renderer\"\n    _inputs_schema = ValueRenderInputsSchema\n    _renderer_config_cls = ValueRendererConfig\n\n    # _render_profiles: Mapping[str, Mapping[str, Any]] = {\n    #     \"terminal_renderable\": {\"target_type\": \"terminal_renderable\"},\n    #     \"string\": {\"target_type\": \"string\"},\n    # }\n\n    def get_renderer_alias(self) -&gt; str:\n        return f\"value_to_{self.renderer_config.target_type}\"\n\n    def retrieve_supported_render_sources(self) -&gt; str:\n        return \"value\"\n\n    def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n        return f\"value:{self.renderer_config.target_type}\"\n\n    def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n        return [\n            ValueTransformer(\n                kiara=self._kiara, target_type=self.renderer_config.target_type\n            )\n        ]\n\n    def retrieve_doc(self) -&gt; Union[str, None]:\n\n        return f\"Render a value (of a supported type) to a value of type '{self.renderer_config.target_type}'.\"\n\n    def _render(self, instance: Value, render_config: ValueRenderInputsSchema) -&gt; Any:\n\n        target_type = self.renderer_config.target_type\n        op_type: RenderValueOperationType = (\n            self._kiara.operation_registry.get_operation_type(\"render_value\")\n        )  # type: ignore\n        render_op = op_type.get_render_operation(\n            source_type=instance.data_type_name, target_type=target_type\n        )\n        if render_op is None:\n            raise Exception(\n                f\"Can't find render operation for source type '{instance.data_type_name}' to '{target_type}'.\"\n            )\n\n        result: Any = render_op.run(\n            self._kiara,\n            inputs={\"value\": instance, \"render_config\": render_config.render_config},\n        )\n        rendered: RenderValueResult = result[\"render_value_result\"].data  # type: ignore\n\n        if not render_config.include_metadata:\n            result = rendered.rendered\n        else:\n            if not render_config.include_data:\n                rendered.rendered = None\n            result = rendered\n\n        return result\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer-functions","title":"Functions","text":""},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer.get_renderer_alias","title":"<code>get_renderer_alias() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def get_renderer_alias(self) -&gt; str:\n    return f\"value_to_{self.renderer_config.target_type}\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer.retrieve_supported_render_sources","title":"<code>retrieve_supported_render_sources() -&gt; str</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_supported_render_sources(self) -&gt; str:\n    return \"value\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer.retrieve_supported_render_targets","title":"<code>retrieve_supported_render_targets() -&gt; Union[Iterable[str], str]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_supported_render_targets(self) -&gt; Union[Iterable[str], str]:\n    return f\"value:{self.renderer_config.target_type}\"\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer.retrieve_source_transformers","title":"<code>retrieve_source_transformers() -&gt; Iterable[SourceTransformer]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_source_transformers(self) -&gt; Iterable[SourceTransformer]:\n    return [\n        ValueTransformer(\n            kiara=self._kiara, target_type=self.renderer_config.target_type\n        )\n    ]\n</code></pre>"},{"location":"reference/kiara/renderers/included_renderers/value/#kiara.renderers.included_renderers.value.ValueRenderer.retrieve_doc","title":"<code>retrieve_doc() -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/renderers/included_renderers/value.py</code> <pre><code>def retrieve_doc(self) -&gt; Union[str, None]:\n\n    return f\"Render a value (of a supported type) to a value of type '{self.renderer_config.target_type}'.\"\n</code></pre>"},{"location":"reference/kiara/utils/__init__/","title":"utils","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils.logger","title":"<code>logger = structlog.get_logger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils.CAMEL_TO_SNAKE_REGEX","title":"<code>CAMEL_TO_SNAKE_REGEX = re.compile('(?&lt;!^)(?=[A-Z])')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils.WORD_REGEX_PATTERN","title":"<code>WORD_REGEX_PATTERN = re.compile('[^A-Za-z]+')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils.SUBCLASS_TYPE","title":"<code>SUBCLASS_TYPE = TypeVar('SUBCLASS_TYPE')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/__init__/#kiara.utils.is_debug","title":"<code>is_debug() -&gt; bool</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def is_debug() -&gt; bool:\n\n    debug = os.environ.get(\"DEBUG\", \"\")\n    if debug.lower() == \"true\":\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.is_develop","title":"<code>is_develop() -&gt; bool</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def is_develop() -&gt; bool:\n\n    develop = os.environ.get(\"DEVELOP\", \"\")\n    if not develop:\n        develop = os.environ.get(\"DEV\", \"\")\n\n    if develop and develop.lower() != \"false\":\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.get_dev_config","title":"<code>get_dev_config() -&gt; KiaraDevSettings</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def get_dev_config() -&gt; \"KiaraDevSettings\":\n\n    from kiara.utils.develop import KIARA_DEV_SETTINGS\n\n    return KIARA_DEV_SETTINGS\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.is_jupyter","title":"<code>is_jupyter() -&gt; bool</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def is_jupyter() -&gt; bool:\n\n    try:\n        get_ipython  # type: ignore\n    except NameError:\n        return False\n    ipython = get_ipython()  # type: ignore  # noqa\n    shell = ipython.__class__.__name__\n    if shell == \"TerminalInteractiveShell\":\n        return False\n    elif \"google.colab\" in str(ipython.__class__) or shell == \"ZMQInteractiveShell\":\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.log_exception","title":"<code>log_exception(exc: Exception)</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def log_exception(exc: Exception):\n\n    if is_debug():\n        logger.error(exc)\n\n    if is_develop():\n        from kiara.utils.develop import DetailLevel\n\n        config = get_dev_config()\n        if config.log.exc in [DetailLevel.NONE, \"none\"]:\n            return\n\n        show_locals = config.log.exc in [DetailLevel.FULL, \"full\"]\n\n        from kiara.interfaces import get_console\n        from kiara.utils.develop import log_dev_message\n\n        exc_info = sys.exc_info()\n\n        if not exc_info or not exc_info[0]:\n            # TODO: create exc_info from exception?\n            if not is_debug():\n                logger.error(exc)\n        else:\n            console = get_console()\n            from rich.traceback import Traceback\n\n            log_dev_message(\n                Traceback.from_exception(\n                    type(exc_info[0]), exc_info[1], traceback=exc_info[2], show_locals=show_locals, width=console.width - 4  # type: ignore\n                ),\n                title=\"Exception details\",\n            )\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.log_message","title":"<code>log_message(msg: str, **data)</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def log_message(msg: str, **data):\n\n    if is_debug():\n        logger.debug(msg, **data)\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.get_auto_workflow_alias","title":"<code>get_auto_workflow_alias(module_type: str, use_incremental_ids: bool = False) -&gt; str</code>","text":"<p>Return an id for a workflow obj of a provided module class.</p> <p>If 'use_incremental_ids' is set to True, a unique id is returned.</p> <p>Parameters:</p> Name Type Description Default <code>module_type</code> <code>str</code> <p>the name of the module type</p> required <code>use_incremental_ids</code> <code>bool</code> <p>whether to return a unique (incremental) id</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a module id</p> Source code in <code>kiara/utils/__init__.py</code> <pre><code>def get_auto_workflow_alias(module_type: str, use_incremental_ids: bool = False) -&gt; str:\n\"\"\"Return an id for a workflow obj of a provided module class.\n\n    If 'use_incremental_ids' is set to True, a unique id is returned.\n\n    Args:\n        module_type (str): the name of the module type\n        use_incremental_ids (bool): whether to return a unique (incremental) id\n\n    Returns:\n        str: a module id\n    \"\"\"\n\n    if not use_incremental_ids:\n        return module_type\n\n    nr = _AUTO_MODULE_ID.setdefault(module_type, 0)\n    _AUTO_MODULE_ID[module_type] = nr + 1\n\n    return f\"{module_type}_{nr}\"\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.camel_case_to_snake_case","title":"<code>camel_case_to_snake_case(camel_text: str, repl: str = '_')</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def camel_case_to_snake_case(camel_text: str, repl: str = \"_\"):\n    return CAMEL_TO_SNAKE_REGEX.sub(repl, camel_text).lower()\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.to_camel_case","title":"<code>to_camel_case(text: str) -&gt; str</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def to_camel_case(text: str) -&gt; str:\n\n    words = WORD_REGEX_PATTERN.split(text)\n    return \"\".join(w.title() for i, w in enumerate(words))\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.check_valid_field_names","title":"<code>check_valid_field_names(*field_names) -&gt; List[str]</code>","text":"<p>Check whether the provided field names are all valid.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>an iterable of strings with invalid field names</p> Source code in <code>kiara/utils/__init__.py</code> <pre><code>def check_valid_field_names(*field_names) -&gt; List[str]:\n\"\"\"Check whether the provided field names are all valid.\n\n    Returns:\n        an iterable of strings with invalid field names\n    \"\"\"\n\n    return [x for x in field_names if x in INVALID_VALUE_NAMES or x.startswith(\"_\")]\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.find_free_id","title":"<code>find_free_id(stem: str, current_ids: Iterable[str], sep = '_') -&gt; str</code>","text":"<p>Find a free var (or other name) based on a stem string, based on a list of provided existing names.</p> <p>Parameters:</p> Name Type Description Default <code>stem</code> <code>str</code> <p>the base string to use</p> required <code>current_ids</code> <code>Iterable[str]</code> <p>currently existing names</p> required <code>method</code> <code>str</code> <p>the method to create new names (allowed: 'count' -- for now)</p> required <code>method_args</code> <code>dict</code> <p>prototing_config for the creation method</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a free name</p> Source code in <code>kiara/utils/__init__.py</code> <pre><code>def find_free_id(\n    stem: str,\n    current_ids: Iterable[str],\n    sep=\"_\",\n) -&gt; str:\n\"\"\"Find a free var (or other name) based on a stem string, based on a list of provided existing names.\n\n    Args:\n        stem (str): the base string to use\n        current_ids (Iterable[str]): currently existing names\n        method (str): the method to create new names (allowed: 'count' -- for now)\n        method_args (dict): prototing_config for the creation method\n\n    Returns:\n        str: a free name\n    \"\"\"\n\n    start_count = 1\n    if stem not in current_ids:\n        return stem\n\n    i = start_count\n\n    # new_name = None\n    while True:\n        new_name = f\"{stem}{sep}{i}\"\n        if new_name in current_ids:\n            i = i + 1\n            continue\n        break\n    return new_name\n</code></pre>"},{"location":"reference/kiara/utils/__init__/#kiara.utils.first_line","title":"<code>first_line(text: str)</code>","text":"Source code in <code>kiara/utils/__init__.py</code> <pre><code>def first_line(text: str):\n\n    if \"\\n\" in text:\n        return text.split(\"\\n\")[0].strip()\n    else:\n        return text\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/","title":"class_loading","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.KiaraEntryPointItem","title":"<code>KiaraEntryPointItem = Union[Type, Tuple, Callable]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.KiaraEntryPointIterable","title":"<code>KiaraEntryPointIterable = Iterable[KiaraEntryPointItem]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.SUBCLASS_TYPE","title":"<code>SUBCLASS_TYPE = TypeVar('SUBCLASS_TYPE')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_subclasses_under","title":"<code>find_subclasses_under(base_class: Type[SUBCLASS_TYPE], python_module: Union[str, ModuleType]) -&gt; List[Type[SUBCLASS_TYPE]]</code>","text":"<p>Find all (non-abstract) subclasses of a base class that live under a module (recursively).</p> <p>Parameters:</p> Name Type Description Default <code>base_class</code> <code>Type[SUBCLASS_TYPE]</code> <p>the parent class</p> required <code>python_module</code> <code>Union[str, ModuleType]</code> <p>the Python module to search</p> required <p>Returns:</p> Type Description <code>List[Type[SUBCLASS_TYPE]]</code> <p>a list of all subclasses</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_subclasses_under(\n    base_class: Type[SUBCLASS_TYPE],\n    python_module: Union[str, ModuleType],\n) -&gt; List[Type[SUBCLASS_TYPE]]:\n\"\"\"Find all (non-abstract) subclasses of a base class that live under a module (recursively).\n\n    Arguments:\n        base_class: the parent class\n        python_module: the Python module to search\n\n    Returns:\n        a list of all subclasses\n    \"\"\"\n\n    # if hasattr(sys, \"frozen\"):\n    #     raise NotImplementedError(\"Pyinstaller bundling not supported yet.\")\n\n    try:\n        if isinstance(python_module, str):\n            python_module = importlib.import_module(python_module)\n\n        _import_modules_recursively(python_module)\n    except Exception as e:\n        log_exception(e)\n        log_message(\"ignore.python_module\", module=str(python_module), reason=str(e))\n        return []\n\n    subclasses: Iterable[Type[SUBCLASS_TYPE]] = _get_all_subclasses(base_class)\n\n    result = []\n    for sc in subclasses:\n\n        if not sc.__module__.startswith(python_module.__name__):\n            continue\n\n        result.append(sc)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.load_all_subclasses_for_entry_point","title":"<code>load_all_subclasses_for_entry_point(entry_point_name: str, base_class: Type[SUBCLASS_TYPE], ignore_abstract_classes: bool = True, type_id_key: Union[str, None] = None, type_id_func: Union[Callable, None] = None, type_id_no_attach: bool = False, attach_python_metadata: Union[bool, str] = False) -&gt; Dict[str, Type[SUBCLASS_TYPE]]</code>","text":"<p>Find all subclasses of a base class via package entry points.</p> <p>Parameters:</p> Name Type Description Default <code>entry_point_name</code> <code>str</code> <p>the entry point name to query entries for</p> required <code>base_class</code> <code>Type[SUBCLASS_TYPE]</code> <p>the base class to look for</p> required <code>ignore_abstract_classes</code> <code>bool</code> <p>whether to include abstract classes in the result</p> <code>True</code> <code>type_id_key</code> <code>Union[str, None]</code> <p>if provided, the found classes will have their id attached as an attribute, using the value of this as the name. if an attribute of this name already exists, it will be used as id without further processing</p> <code>None</code> <code>type_id_func</code> <code>Union[Callable, None]</code> <p>a function to take the found class as input, and returns a string representing the id of the class. By default, the module path + \".\" + class name (snake-case) is used (minus the string 'kiara_modules.'', if it exists at the beginning <code>None</code> <code>type_id_no_attach</code> <code>bool</code> <p>in case you want to use the type_id_key to set the id, but don't want it attached to classes that don't have it, set this to true. In most cases, you won't need this option</p> <code>False</code> <code>attach_python_metadata</code> <code>Union[bool, str]</code> <p>whether to attach a PythonClass metadata model to the class. By default, '_python_class' is used as attribute name if this argument is 'True', If this argument is a string, that will be used as name instead.</p> <code>False</code> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def load_all_subclasses_for_entry_point(\n    entry_point_name: str,\n    base_class: Type[SUBCLASS_TYPE],\n    ignore_abstract_classes: bool = True,\n    type_id_key: Union[str, None] = None,\n    type_id_func: Union[Callable, None] = None,\n    type_id_no_attach: bool = False,\n    attach_python_metadata: Union[bool, str] = False,\n) -&gt; Dict[str, Type[SUBCLASS_TYPE]]:\n\"\"\"Find all subclasses of a base class via package entry points.\n\n    Arguments:\n        entry_point_name: the entry point name to query entries for\n        base_class: the base class to look for\n        ignore_abstract_classes: whether to include abstract classes in the result\n        type_id_key: if provided, the found classes will have their id attached as an attribute, using the value of this as the name. if an attribute of this name already exists, it will be used as id without further processing\n        type_id_func: a function to take the found class as input, and returns a string representing the id of the class. By default, the module path + \".\" + class name (snake-case) is used (minus the string 'kiara_modules.&lt;project_name&gt;'', if it exists at the beginning\n        type_id_no_attach: in case you want to use the type_id_key to set the id, but don't want it attached to classes that don't have it, set this to true. In most cases, you won't need this option\n        attach_python_metadata: whether to attach a [PythonClass][kiara.models.python_class.PythonClass] metadata model to the class. By default, '_python_class' is used as attribute name if this argument is 'True', If this argument is a string, that will be used as name instead.\n    \"\"\"\n\n    log2 = logging.getLogger(\"stevedore\")\n    out_hdlr = logging.StreamHandler(sys.stdout)\n    out_hdlr.setFormatter(\n        logging.Formatter(\n            f\"{entry_point_name} plugin search message/error -&gt; %(message)s\"\n        )\n    )\n    out_hdlr.setLevel(logging.INFO)\n    log2.addHandler(out_hdlr)\n    if is_debug():\n        log2.setLevel(logging.DEBUG)\n    else:\n        out_hdlr.setLevel(logging.INFO)\n        log2.setLevel(logging.INFO)\n\n    log_message(\"events.loading.entry_points\", entry_point_name=entry_point_name)\n\n    from stevedore import ExtensionManager\n\n    mgr = ExtensionManager(\n        namespace=entry_point_name,\n        invoke_on_load=False,\n        propagate_map_exceptions=True,\n    )\n\n    result_entrypoints: Dict[str, Type[SUBCLASS_TYPE]] = {}\n    result_dynamic: Dict[str, Type[SUBCLASS_TYPE]] = {}\n\n    for plugin in mgr:\n        name = plugin.name\n\n        if isinstance(plugin.plugin, type):\n            # this means an actual (sub-)class was provided in the entrypoint\n\n            cls = plugin.plugin\n            if not issubclass(cls, base_class):\n                log_message(\n                    \"ignore.entrypoint\",\n                    entry_point=name,\n                    base_class=base_class,\n                    sub_class=plugin.plugin,\n                    reason=f\"Entry point reference not a subclass of '{base_class}'.\",\n                )\n                continue\n\n            _process_subclass(\n                sub_class=cls,\n                base_class=base_class,\n                type_id_key=type_id_key,\n                type_id_func=type_id_func,\n                type_id_no_attach=type_id_no_attach,\n                attach_python_metadata=attach_python_metadata,\n                ignore_abstract_classes=ignore_abstract_classes,\n            )\n\n            result_entrypoints[name] = cls\n        elif (\n            isinstance(plugin.plugin, tuple)\n            and len(plugin.plugin) &gt;= 1\n            and callable(plugin.plugin[0])\n        ) or callable(plugin.plugin):\n            try:\n                if callable(plugin.plugin):\n                    func = plugin.plugin\n                    args = []\n                else:\n                    func = plugin.plugin[0]\n                    args = plugin.plugin[1:]\n                classes = func(*args)\n            except Exception as e:\n                log_exception(e)\n                raise Exception(f\"Error trying to load plugin '{plugin.plugin}': {e}\")\n\n            for sub_class in classes:\n                type_id = _process_subclass(\n                    sub_class=sub_class,\n                    base_class=base_class,\n                    type_id_key=type_id_key,\n                    type_id_func=type_id_func,\n                    type_id_no_attach=type_id_no_attach,\n                    attach_python_metadata=attach_python_metadata,\n                    ignore_abstract_classes=ignore_abstract_classes,\n                )\n\n                if type_id is None:\n                    continue\n\n                if type_id in result_dynamic.keys():\n                    raise Exception(\n                        f\"Duplicate type id '{type_id}' for type {entry_point_name}: {result_dynamic[type_id]} -- {sub_class}\"\n                    )\n                result_dynamic[type_id] = sub_class\n\n        else:\n            raise Exception(\n                f\"Can't load subclasses for entry point {entry_point_name} and base class {base_class}: invalid plugin type {type(plugin.plugin)}\"\n            )\n\n    for k, v in result_dynamic.items():\n        if k in result_entrypoints.keys():\n            msg = f\"Duplicate item name '{k}' for type {entry_point_name}: {v} -- {result_entrypoints[k]}.\"\n            try:\n                if type_id_key not in v.__dict__.keys():\n                    msg = f\"{msg} Most likely the name is picked up from a subclass, try to add a '{type_id_key}' class attribute to your implementing class, with the name you want to give your type as value.\"\n            except Exception:\n                pass\n\n            raise Exception(msg)\n        result_entrypoints[k] = v\n\n    return result_entrypoints\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_kiara_modules","title":"<code>find_all_kiara_modules() -&gt; Dict[str, Type[KiaraModule]]</code>","text":"<p>Find all KiaraModule subclasses via package entry points.</p> <p>TODO</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_kiara_modules() -&gt; Dict[str, Type[\"KiaraModule\"]]:\n\"\"\"Find all [KiaraModule][kiara.module.KiaraModule] subclasses via package entry points.\n\n    TODO\n    \"\"\"\n\n    from kiara.modules import KiaraModule\n\n    modules = load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.modules\",\n        base_class=KiaraModule,  # type: ignore\n        type_id_key=\"_module_type_name\",\n        attach_python_metadata=True,\n    )\n\n    result = {}\n    # need to test this, since I couldn't add an abstract method to the KiaraModule class itself (mypy complained because it is potentially overloaded)\n    for k, cls in modules.items():\n\n        if not hasattr(cls, \"process\"):\n            if is_develop():\n                from rich.markdown import Markdown\n\n                msg = f\"Invalid kiara module: **{cls.__module__}.{cls.__name__}**\\n\\nMissing method(s):\\n- *process*\"\n                from kiara.utils.develop import log_dev_message\n\n                log_dev_message(msg=Markdown(msg))\n\n            # TODO: check signature of process method\n            log_message(\n                \"ignore.subclass\",\n                sub_class=cls,\n                base_class=KiaraModule,\n                reason=\"'process' method is missing\",\n            )\n            continue\n\n        result[k] = cls\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_kiara_model_classes","title":"<code>find_all_kiara_model_classes() -&gt; Dict[str, Type[KiaraModel]]</code>","text":"<p>Find all KiaraModule subclasses via package entry points.</p> <p>TODO</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_kiara_model_classes() -&gt; Dict[str, Type[\"KiaraModel\"]]:\n\"\"\"Find all [KiaraModule][kiara.module.KiaraModule] subclasses via package entry points.\n\n    TODO\n    \"\"\"\n\n    from kiara.models import KiaraModel\n\n    return load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.model_classes\",\n        base_class=KiaraModel,  # type: ignore\n        type_id_key=\"_kiara_model_id\",\n        type_id_func=_cls_name_id_func,\n        attach_python_metadata=False,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_archive_types","title":"<code>find_all_archive_types() -&gt; Dict[str, Type[KiaraArchive]]</code>","text":"<p>Find all KiaraArchive subclasses via package entry points.</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_archive_types() -&gt; Dict[str, Type[\"KiaraArchive\"]]:\n\"\"\"Find all [KiaraArchive][kiara.registries.KiaraArchive] subclasses via package entry points.\"\"\"\n\n    from kiara.registries import KiaraArchive\n\n    return load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.archive_type\",\n        base_class=KiaraArchive,  # type: ignore\n        type_id_key=\"_archive_type_name\",\n        type_id_func=_cls_name_id_func,\n        attach_python_metadata=False,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_data_types","title":"<code>find_all_data_types() -&gt; Dict[str, Type[DataType]]</code>","text":"<p>Find all KiaraModule subclasses via package entry points.</p> <p>TODO</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_data_types() -&gt; Dict[str, Type[\"DataType\"]]:\n\"\"\"Find all [KiaraModule][kiara.module.KiaraModule] subclasses via package entry points.\n\n    TODO\n    \"\"\"\n\n    from kiara.data_types import DataType\n\n    all_data_types = load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.data_types\",\n        base_class=DataType,  # type: ignore\n        type_id_key=\"_data_type_name\",\n        type_id_func=_cls_name_id_func,\n    )\n\n    invalid = [x for x in all_data_types.keys() if \".\" in x]\n    if invalid:\n        raise Exception(\n            f\"Invalid value type name(s), type names can't contain '.': {', '.join(invalid)}\"\n        )\n\n    return all_data_types\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_operation_types","title":"<code>find_all_operation_types() -&gt; Dict[str, Type[OperationType]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_operation_types() -&gt; Dict[str, Type[\"OperationType\"]]:\n\n    from kiara.operations import OperationType\n\n    result = load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.operation_types\",\n        base_class=OperationType,  # type: ignore\n        type_id_key=\"_operation_type_name\",\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_kiara_modules_under","title":"<code>find_kiara_modules_under(module: Union[str, ModuleType]) -&gt; List[Type[KiaraModule]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_kiara_modules_under(\n    module: Union[str, ModuleType],\n) -&gt; List[Type[\"KiaraModule\"]]:\n\n    from kiara.modules import KiaraModule\n\n    return find_subclasses_under(\n        base_class=KiaraModule,  # type: ignore\n        python_module=module,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_kiara_model_classes_under","title":"<code>find_kiara_model_classes_under(module: Union[str, ModuleType]) -&gt; List[Type[KiaraModel]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_kiara_model_classes_under(\n    module: Union[str, ModuleType]\n) -&gt; List[Type[\"KiaraModel\"]]:\n\n    from kiara.models import KiaraModel\n\n    result = find_subclasses_under(\n        base_class=KiaraModel,  # type: ignore\n        python_module=module,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_data_types_under","title":"<code>find_data_types_under(module: Union[str, ModuleType]) -&gt; List[Type[DataType]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_data_types_under(module: Union[str, ModuleType]) -&gt; List[Type[\"DataType\"]]:\n\n    from kiara.data_types import DataType\n\n    return find_subclasses_under(\n        base_class=DataType,  # type: ignore\n        python_module=module,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_operations_under","title":"<code>find_operations_under(module: Union[str, ModuleType]) -&gt; List[Type[OperationType]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_operations_under(\n    module: Union[str, ModuleType]\n) -&gt; List[Type[\"OperationType\"]]:\n\n    from kiara.operations import OperationType\n\n    return find_subclasses_under(\n        base_class=OperationType,  # type: ignore\n        python_module=module,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_pipeline_base_path_for_module","title":"<code>find_pipeline_base_path_for_module(module: Union[str, ModuleType]) -&gt; Union[str, None]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_pipeline_base_path_for_module(\n    module: Union[str, ModuleType]\n) -&gt; Union[str, None]:\n\n    # if hasattr(sys, \"frozen\"):\n    #     raise NotImplementedError(\"Pyinstaller bundling not supported yet.\")\n\n    if isinstance(module, str):\n        module = importlib.import_module(module)\n\n    module_file = module.__file__\n    assert module_file is not None\n    path = os.path.dirname(module_file)\n\n    if not os.path.exists(path):\n        log_message(\"ignore.pipeline_folder\", path=path, reason=\"folder does not exist\")\n        return None\n\n    return path\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_kiara_pipeline_paths","title":"<code>find_all_kiara_pipeline_paths(skip_errors: bool = False) -&gt; Dict[str, Union[Dict[str, Any], None]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_kiara_pipeline_paths(\n    skip_errors: bool = False,\n) -&gt; Dict[str, Union[Dict[str, Any], None]]:\n\n    import logging\n\n    log2 = logging.getLogger(\"stevedore\")\n    out_hdlr = logging.StreamHandler(sys.stdout)\n    out_hdlr.setFormatter(\n        logging.Formatter(\"kiara pipeline search plugin error -&gt; %(message)s\")\n    )\n    out_hdlr.setLevel(logging.INFO)\n    log2.addHandler(out_hdlr)\n    log2.setLevel(logging.INFO)\n\n    log_message(\"events.loading.pipelines\")\n\n    from stevedore import ExtensionManager\n\n    mgr = ExtensionManager(\n        namespace=\"kiara.pipelines\", invoke_on_load=False, propagate_map_exceptions=True\n    )\n\n    paths: Dict[str, Union[Dict[str, Any], None]] = {}\n    # TODO: make sure we load 'core' first?\n    for plugin in mgr:\n\n        name = plugin.name\n        if (\n            isinstance(plugin.plugin, tuple)\n            and len(plugin.plugin) &gt;= 1\n            and callable(plugin.plugin[0])\n        ) or callable(plugin.plugin):\n            try:\n                if callable(plugin.plugin):\n                    func = plugin.plugin\n                    args = []\n                else:\n                    func = plugin.plugin[0]\n                    args = plugin.plugin[1:]\n\n                f_args = []\n                metadata: Union[Dict[str, Any], None] = None\n                if len(args) &gt;= 1:\n                    f_args.append(args[0])\n                if len(args) &gt;= 2:\n                    metadata = args[1]\n                    assert isinstance(metadata, Mapping)\n                if len(args) &gt; 3:\n                    logger.debug(\n                        \"ignore.pipeline_lookup_arguments\",\n                        reason=\"more than 2 arguments provided\",\n                        surplus_args=args[2:],\n                        path=f_args[0],\n                    )\n\n                result = func(f_args[0])\n                if not result:\n                    continue\n                if isinstance(result, str):\n                    paths[result] = metadata\n                else:\n                    for path in paths:\n                        assert path not in paths.keys()\n                        paths[path] = metadata\n\n            except Exception as e:\n                log_exception(e)\n                if skip_errors:\n                    log_message(\n                        \"ignore.pipline_entrypoint\", entrypoint_name=name, reason=str(e)\n                    )\n                    continue\n                raise Exception(f\"Error trying to load plugin '{plugin.plugin}': {e}\")\n        else:\n            if skip_errors:\n                log_message(\n                    \"ignore.pipline_entrypoint\",\n                    entrypoint_name=name,\n                    reason=f\"invalid plugin type '{type(plugin.plugin)}'\",\n                )\n                continue\n            msg = f\"Can't load pipelines for entrypoint '{name}': invalid plugin type '{type(plugin.plugin)}'\"\n            raise Exception(msg)\n\n    return paths\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_cli_subcommands","title":"<code>find_all_cli_subcommands()</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_cli_subcommands():\n\n    entry_point_name = \"kiara.cli_subcommands\"\n    log2 = logging.getLogger(\"stevedore\")\n    out_hdlr = logging.StreamHandler(sys.stdout)\n    out_hdlr.setFormatter(\n        logging.Formatter(\n            f\"{entry_point_name} plugin search message/error -&gt; %(message)s\"\n        )\n    )\n    out_hdlr.setLevel(logging.INFO)\n    log2.addHandler(out_hdlr)\n    if is_debug():\n        log2.setLevel(logging.DEBUG)\n    else:\n        out_hdlr.setLevel(logging.INFO)\n        log2.setLevel(logging.INFO)\n\n    log_message(\"events.loading.entry_points\", entry_point_name=entry_point_name)\n    from stevedore import ExtensionManager\n\n    mgr = ExtensionManager(\n        namespace=entry_point_name,\n        invoke_on_load=False,\n        propagate_map_exceptions=True,\n    )\n\n    return [plugin.plugin for plugin in mgr]\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_all_kiara_renderers","title":"<code>find_all_kiara_renderers() -&gt; Dict[str, Type[KiaraRenderer]]</code>","text":"<p>Find all KiaraComponent subclasses via package entry points.</p> <p>TODO</p> Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_all_kiara_renderers() -&gt; Dict[str, Type[\"KiaraRenderer\"]]:\n\"\"\"Find all [KiaraComponent][kiara_plugin.streamilt.components.KiaraComponent] subclasses via package entry points.\n\n    TODO\n    \"\"\"\n\n    from kiara.renderers import KiaraRenderer\n\n    components = load_all_subclasses_for_entry_point(\n        entry_point_name=\"kiara.renderers\",\n        base_class=KiaraRenderer,  # type: ignore\n        type_id_key=\"_renderer_name\",\n        type_id_func=_cls_name_id_func,\n        attach_python_metadata=True,\n    )\n\n    return components\n</code></pre>"},{"location":"reference/kiara/utils/class_loading/#kiara.utils.class_loading.find_kiara_renderers_under","title":"<code>find_kiara_renderers_under(module: Union[str, ModuleType]) -&gt; List[Type[KiaraRenderer]]</code>","text":"Source code in <code>kiara/utils/class_loading.py</code> <pre><code>def find_kiara_renderers_under(\n    module: Union[str, ModuleType],\n) -&gt; List[Type[\"KiaraRenderer\"]]:\n\n    from kiara.renderers import KiaraRenderer\n\n    return find_subclasses_under(\n        base_class=KiaraRenderer,  # type: ignore\n        python_module=module,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/concurrency/","title":"concurrency","text":""},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter","title":"<code>ThreadSaveCounter</code>","text":"<p>         Bases: <code>object</code></p> <p>A thread-safe counter, can be used in kiara modules to update completion percentage.</p> Source code in <code>kiara/utils/concurrency.py</code> <pre><code>class ThreadSaveCounter(object):\n\"\"\"A thread-safe counter, can be used in kiara modules to update completion percentage.\"\"\"\n\n    def __init__(self):\n\n        self._current = 0\n        self._lock = threading.Lock()\n\n    @property\n    def current(self):\n        return self._current\n\n    def current_percent(self, total: int) -&gt; int:\n\n        return int((self.current / total) * 100)\n\n    def increment(self):\n\n        with self._lock:\n            self._current += 1\n            return self._current\n\n    def decrement(self):\n\n        with self._lock:\n            self._current -= 1\n            return self._current\n</code></pre>"},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter.current","title":"<code>current</code>  <code>property</code>","text":""},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter.current_percent","title":"<code>current_percent(total: int) -&gt; int</code>","text":"Source code in <code>kiara/utils/concurrency.py</code> <pre><code>def current_percent(self, total: int) -&gt; int:\n\n    return int((self.current / total) * 100)\n</code></pre>"},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter.increment","title":"<code>increment()</code>","text":"Source code in <code>kiara/utils/concurrency.py</code> <pre><code>def increment(self):\n\n    with self._lock:\n        self._current += 1\n        return self._current\n</code></pre>"},{"location":"reference/kiara/utils/concurrency/#kiara.utils.concurrency.ThreadSaveCounter.decrement","title":"<code>decrement()</code>","text":"Source code in <code>kiara/utils/concurrency.py</code> <pre><code>def decrement(self):\n\n    with self._lock:\n        self._current -= 1\n        return self._current\n</code></pre>"},{"location":"reference/kiara/utils/data/","title":"data","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data.logger","title":"<code>logger = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/data/#kiara.utils.data.pretty_print_data","title":"<code>pretty_print_data(kiara: Kiara, value_id: uuid.UUID, target_type = 'terminal_renderable', **render_config: Any) -&gt; Any</code>","text":"Source code in <code>kiara/utils/data.py</code> <pre><code>def pretty_print_data(\n    kiara: \"Kiara\",\n    value_id: uuid.UUID,\n    target_type=\"terminal_renderable\",\n    **render_config: Any,\n) -&gt; Any:\n\n    value = kiara.data_registry.get_value(value=value_id)\n\n    op_type: PrettyPrintOperationType = kiara.operation_registry.get_operation_type(\"pretty_print\")  # type: ignore\n\n    data_type = value.data_type_name\n    if data_type not in kiara.data_type_names:\n        data_type = \"any\"\n\n    try:\n        op: Union[Operation, None] = op_type.get_operation_for_render_combination(\n            source_type=data_type, target_type=target_type\n        )\n    except Exception as e:\n\n        logger.debug(\n            \"error.pretty_print\",\n            source_type=data_type,\n            target_type=target_type,\n            error=e,\n        )\n\n        op = None\n        if target_type == \"terminal_renderable\":\n            try:\n                op = op_type.get_operation_for_render_combination(\n                    source_type=\"any\", target_type=\"string\"\n                )\n            except Exception:\n                pass\n\n    if op is None:\n        raise Exception(\n            f\"Can't find operation to render '{value.value_schema.type}' as '{target_type}.\"\n        )\n\n    result = op.run(kiara=kiara, inputs={\"value\": value})\n    rendered = result.get_value_data(\"rendered_value\")\n    return rendered\n</code></pre>"},{"location":"reference/kiara/utils/data/#kiara.utils.data.get_data_from_string","title":"<code>get_data_from_string(string_data: str, content_type: Union[str, None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/utils/data.py</code> <pre><code>def get_data_from_string(\n    string_data: str, content_type: Union[str, None] = None\n) -&gt; Any:\n\n    if content_type:\n        assert content_type in [\"json\", \"yaml\"]\n\n    if content_type == \"json\":\n        data = orjson.loads(string_data.encode())\n    elif content_type == \"yaml\":\n        data = yaml.load(string_data)\n    else:\n        try:\n            data = orjson.loads(string_data.encode())\n        except Exception:\n            try:\n                data = yaml.load(string_data)\n            except Exception:\n                raise ValueError(\n                    \"Invalid data format, only 'json' or 'yaml' are supported currently.\"\n                )\n\n    return data\n</code></pre>"},{"location":"reference/kiara/utils/db/","title":"db","text":""},{"location":"reference/kiara/utils/db/#kiara.utils.db-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/db/#kiara.utils.db.get_kiara_db_url","title":"<code>get_kiara_db_url(base_path: str)</code>","text":"Source code in <code>kiara/utils/db.py</code> <pre><code>def get_kiara_db_url(base_path: str):\n\n    abs_path = os.path.abspath(os.path.expanduser(base_path))\n    db_url = f\"sqlite+pysqlite:///{abs_path}/kiara.db\"\n    return db_url\n</code></pre>"},{"location":"reference/kiara/utils/db/#kiara.utils.db.orm_json_serialize","title":"<code>orm_json_serialize(obj: Any) -&gt; str</code>","text":"Source code in <code>kiara/utils/db.py</code> <pre><code>def orm_json_serialize(obj: Any) -&gt; str:\n\n    if hasattr(obj, \"json\"):\n        return obj.json()\n\n    if isinstance(obj, str):\n        return obj\n    elif isinstance(obj, Mapping):\n        return orjson_dumps(obj, default=None)\n    else:\n        raise Exception(f\"Unsupported type for json serialization: {type(obj)}\")\n</code></pre>"},{"location":"reference/kiara/utils/db/#kiara.utils.db.orm_json_deserialize","title":"<code>orm_json_deserialize(obj: str) -&gt; Any</code>","text":"Source code in <code>kiara/utils/db.py</code> <pre><code>def orm_json_deserialize(obj: str) -&gt; Any:\n    return orjson.loads(obj)\n</code></pre>"},{"location":"reference/kiara/utils/debug/","title":"debug","text":""},{"location":"reference/kiara/utils/debug/#kiara.utils.debug-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/debug/#kiara.utils.debug.DEFAULT_VALUE_MAP_RENDER_CONFIG","title":"<code>DEFAULT_VALUE_MAP_RENDER_CONFIG = {'ignore_fields': ['kiara_id', 'data_type_class', 'destiny_backlinks', 'environments', 'property_links']}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/debug/#kiara.utils.debug-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/debug/#kiara.utils.debug-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/debug/#kiara.utils.debug.create_module_preparation_table","title":"<code>create_module_preparation_table(kiara: Kiara, job_config: JobConfig, job_id: uuid.UUID, module: KiaraModule, **render_config: Any) -&gt; Table</code>","text":"Source code in <code>kiara/utils/debug.py</code> <pre><code>def create_module_preparation_table(\n    kiara: \"Kiara\",\n    job_config: JobConfig,\n    job_id: uuid.UUID,\n    module: \"KiaraModule\",\n    **render_config: Any\n) -&gt; Table:\n\n    dev_config = get_dev_config()\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"job_id\", str(job_id))\n\n    module_details = dev_config.log.pre_run.module_info\n    if module_details not in [DetailLevel.NONE.value, DetailLevel.NONE]:\n        if module_details in [DetailLevel.MINIMAL.value, DetailLevel.MINIMAL]:\n            table.add_row(\"module\", job_config.module_type)\n            doc = module.operation.doc\n            table.add_row(\n                \"module desc\",\n                doc.description\n                # kiara.context_info.module_types.item_infos[\n                #     job_config.module_type\n                # ].documentation.description,\n            )\n        elif module_details in [DetailLevel.FULL.value, DetailLevel.FULL]:\n            table.add_row(\"module\", job_config.module_type)\n            doc = module.operation.doc\n            table.add_row(\n                \"module doc\",\n                doc.full_doc\n                # kiara.context_info.module_types.item_infos[\n                #     job_config.module_type\n                # ].documentation.full_doc,\n            )\n            if module_config_is_empty(job_config.module_config):\n                table.add_row(\"module_config\", \"-- no config --\")\n            else:\n                module = kiara.module_registry.create_module(manifest=job_config)\n                table.add_row(\"module_config\", module.config)\n\n    inputs_details = dev_config.log.pre_run.inputs_info\n    if inputs_details not in [DetailLevel.NONE.value, DetailLevel.NONE]:\n        if inputs_details in [DetailLevel.MINIMAL, DetailLevel.MINIMAL.value]:\n            render_config[\"show_type\"] = False\n            value_map_rend = create_value_map_renderable(\n                value_map=job_config.inputs, **render_config\n            )\n            table.add_row(\"inputs\", value_map_rend)\n        elif inputs_details in [DetailLevel.FULL, DetailLevel.FULL.value]:\n            value_map = kiara.data_registry.load_values(values=job_config.inputs)\n            table.add_row(\"inputs\", value_map.create_renderable(**render_config))\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/debug/#kiara.utils.debug.create_post_run_table","title":"<code>create_post_run_table(kiara: Kiara, job: ActiveJob, module: KiaraModule, job_config: JobConfig, **render_config: Any) -&gt; Table</code>","text":"Source code in <code>kiara/utils/debug.py</code> <pre><code>def create_post_run_table(\n    kiara: \"Kiara\",\n    job: ActiveJob,\n    module: \"KiaraModule\",\n    job_config: JobConfig,\n    **render_config: Any\n) -&gt; Table:\n\n    dev_config = get_dev_config()\n    table = Table(show_header=False, box=box.SIMPLE)\n    table.add_column(\"key\", style=\"i\")\n    table.add_column(\"value\")\n\n    table.add_row(\"job_id\", str(job.job_id))\n    module_details = dev_config.log.post_run.module_info\n    if module_details not in [DetailLevel.NONE.value, DetailLevel.NONE]:\n        if module_details in [DetailLevel.MINIMAL.value, DetailLevel.MINIMAL]:\n            table.add_row(\"module\", module.module_type_name)\n            table.add_row(\n                \"module desc\",\n                kiara.context_info.module_types.item_infos[\n                    module.module_type_name\n                ].documentation.description,\n            )\n        elif module_details in [DetailLevel.FULL.value, DetailLevel.FULL]:\n            table.add_row(\"module\", module.module_type_name)\n            table.add_row(\n                \"module doc\",\n                kiara.context_info.module_types.item_infos[\n                    module.module_type_name\n                ].documentation.full_doc,\n            )\n            if module_config_is_empty(module.config.dict()):\n                table.add_row(\"module_config\", \"-- no config --\")\n            else:\n                table.add_row(\"module_config\", module.config)\n\n    inputs_details = dev_config.log.post_run.inputs_info\n    if inputs_details not in [DetailLevel.NONE.value, DetailLevel.NONE]:\n        if inputs_details in [DetailLevel.MINIMAL, DetailLevel.MINIMAL.value]:\n            render_config[\"show_type\"] = False\n            value_map_rend: RenderableType = create_value_map_renderable(\n                value_map=job_config.inputs, **render_config\n            )\n            table.add_row(\"inputs\", value_map_rend)\n        elif inputs_details in [DetailLevel.FULL, DetailLevel.FULL.value]:\n            value_map = kiara.data_registry.load_values(values=job_config.inputs)\n            table.add_row(\"inputs\", value_map.create_renderable(**render_config))\n\n    outputs_details = dev_config.log.post_run.outputs_info\n    if outputs_details not in [DetailLevel.NONE.value, DetailLevel.NONE]:\n        if outputs_details in [DetailLevel.MINIMAL, DetailLevel.MINIMAL.value]:\n            render_config[\"show_type\"] = False\n            if job.results is None:\n                value_map_rend = \"-- no results --\"\n            else:\n                value_map_rend = create_value_map_renderable(\n                    value_map=job.results, **render_config\n                )\n            table.add_row(\"outputs\", value_map_rend)\n        elif outputs_details in [DetailLevel.FULL, DetailLevel.FULL.value]:\n            if job.results is None:\n                value_map_rend = \"-- no results --\"\n            else:\n                value_map = kiara.data_registry.load_values(values=job.results)\n                value_map_rend = value_map.create_renderable(**render_config)\n            table.add_row(\"outputs\", value_map_rend)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/debug/#kiara.utils.debug.terminal_print_manifest","title":"<code>terminal_print_manifest(manifest: Manifest)</code>","text":"Source code in <code>kiara/utils/debug.py</code> <pre><code>def terminal_print_manifest(manifest: Manifest):\n\n    terminal_print(manifest.create_renderable())\n</code></pre>"},{"location":"reference/kiara/utils/debug/#kiara.utils.debug.create_value_map_renderable","title":"<code>create_value_map_renderable(value_map: Mapping[str, Any], **render_config: Any)</code>","text":"Source code in <code>kiara/utils/debug.py</code> <pre><code>def create_value_map_renderable(value_map: Mapping[str, Any], **render_config: Any):\n\n    show_type = render_config.get(\"show_type\", True)\n\n    rc = dict(DEFAULT_VALUE_MAP_RENDER_CONFIG)\n    rc.update(render_config)\n\n    table = Table(show_header=True, box=box.SIMPLE)\n    table.add_column(\"field name\", style=\"i\")\n    if show_type:\n        table.add_column(\"type\")\n    table.add_column(\"value\")\n\n    for k, v in value_map.items():\n        row: List[Any] = [k]\n        if isinstance(v, Value):\n            if show_type:\n                row.append(\"value object\")\n            row.append(v.create_renderable(**rc))\n        elif isinstance(v, uuid.UUID):\n            if show_type:\n                row.append(\"value id\")\n            row.append(str(v))\n        else:\n            if show_type:\n                row.append(\"raw data\")\n            row.append(str(v))\n\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/dicts/","title":"dicts","text":""},{"location":"reference/kiara/utils/dicts/#kiara.utils.dicts-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/dicts/#kiara.utils.dicts.merge_dicts","title":"<code>merge_dicts(*dicts: Mapping[str, Any]) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/dicts.py</code> <pre><code>def merge_dicts(*dicts: Mapping[str, Any]) -&gt; Dict[str, Any]:\n\n    if not dicts:\n        return {}\n\n    current: Dict[str, Any] = {}\n    for d in dicts:\n        dpath.merge(current, dict(copy.deepcopy(d)))\n\n    return current\n</code></pre>"},{"location":"reference/kiara/utils/doc/","title":"doc","text":""},{"location":"reference/kiara/utils/doc/#kiara.utils.doc-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/doc/#kiara.utils.doc-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/doc/#kiara.utils.doc.extract_doc_from_cls","title":"<code>extract_doc_from_cls(cls: typing.Type, only_first_line: bool = False)</code>","text":"Source code in <code>kiara/utils/doc.py</code> <pre><code>def extract_doc_from_cls(cls: typing.Type, only_first_line: bool = False):\n\n    doc = cls.__doc__\n    if not doc:\n        doc = DEFAULT_NO_DESC_VALUE\n    else:\n        doc = cleandoc(doc)\n\n    if only_first_line:\n        return first_line(doc)\n    else:\n        return doc.strip()\n</code></pre>"},{"location":"reference/kiara/utils/downloads/","title":"downloads","text":""},{"location":"reference/kiara/utils/downloads/#kiara.utils.downloads-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/downloads/#kiara.utils.downloads.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/downloads/#kiara.utils.downloads-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/downloads/#kiara.utils.downloads.get_data_from_url","title":"<code>get_data_from_url(url: str, content_type: Union[str, None] = None) -&gt; Mapping[str, Any]</code>","text":"Source code in <code>kiara/utils/downloads.py</code> <pre><code>def get_data_from_url(\n    url: str, content_type: Union[str, None] = None\n) -&gt; Mapping[str, Any]:\n\n    if content_type:\n        assert content_type in [\"json\", \"yaml\"]\n\n    r = httpx.get(url, follow_redirects=True)\n\n    if not content_type:\n        if url.endswith(\".json\"):\n            content_type = \"json\"\n        elif url.endswith(\".yaml\") or url.endswith(\".yml\"):\n            content_type = \"yaml\"\n\n    if content_type == \"json\":\n        result = r.json()\n    elif content_type == \"yaml\":\n        result = yaml.load(r.text)\n    else:\n        try:\n            result = r.json()\n        except Exception:\n            try:\n                result = yaml.load(r.text)\n            except Exception:\n                raise ValueError(f\"Can't parse data from url '{url}'\")\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/files/","title":"files","text":""},{"location":"reference/kiara/utils/files/#kiara.utils.files-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/files/#kiara.utils.files.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/files/#kiara.utils.files-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/files/#kiara.utils.files.get_data_from_file","title":"<code>get_data_from_file(path: Union[str, Path], content_type: Union[str, None] = None) -&gt; Any</code>","text":"Source code in <code>kiara/utils/files.py</code> <pre><code>def get_data_from_file(\n    path: Union[str, Path], content_type: Union[str, None] = None\n) -&gt; Any:\n\n    if isinstance(path, str):\n        path = Path(os.path.expanduser(path))\n\n    content = path.read_text()\n\n    if content_type:\n        assert content_type in [\"json\", \"yaml\"]\n    else:\n        if path.name.endswith(\".json\"):\n            content_type = \"json\"\n        elif path.name.endswith(\".yaml\") or path.name.endswith(\".yml\"):\n            content_type = \"yaml\"\n        else:\n            raise ValueError(\n                \"Invalid data format, only 'json' or 'yaml' are supported currently.\"\n            )\n\n    if content_type == \"json\":\n        data = json.loads(content)\n    else:\n        data = yaml.load(content)\n\n    return data\n</code></pre>"},{"location":"reference/kiara/utils/global_metadata/","title":"global_metadata","text":""},{"location":"reference/kiara/utils/global_metadata/#kiara.utils.global_metadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/global_metadata/#kiara.utils.global_metadata-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/global_metadata/#kiara.utils.global_metadata.get_metadata_for_python_module_or_class","title":"<code>get_metadata_for_python_module_or_class(module_or_class: typing.Union[ModuleType, typing.Type]) -&gt; typing.List[typing.Dict[str, typing.Any]]</code>  <code>cached</code>","text":"Source code in <code>kiara/utils/global_metadata.py</code> <pre><code>@lru_cache()\ndef get_metadata_for_python_module_or_class(\n    module_or_class: typing.Union[ModuleType, typing.Type]\n) -&gt; typing.List[typing.Dict[str, typing.Any]]:\n\n    metadata: typing.List[typing.Dict[str, typing.Any]] = []\n\n    if isinstance(module_or_class, type):\n        if hasattr(module_or_class, KIARA_MODULE_METADATA_ATTRIBUTE):\n            md = getattr(module_or_class, KIARA_MODULE_METADATA_ATTRIBUTE)\n            assert isinstance(md, typing.Mapping)\n            metadata.append(md)  # type: ignore\n        _module_or_class: typing.Union[\n            str, ModuleType, typing.Type\n        ] = module_or_class.__module__\n    else:\n        _module_or_class = module_or_class\n\n    current_module = _module_or_class\n    while current_module:\n\n        if isinstance(current_module, str):\n            current_module = importlib.import_module(current_module)\n\n        if hasattr(current_module, KIARA_MODULE_METADATA_ATTRIBUTE):\n            md = getattr(current_module, KIARA_MODULE_METADATA_ATTRIBUTE)\n            assert isinstance(md, typing.Mapping)\n            metadata.append(md)  # type: ignore\n\n        if \".\" in current_module.__name__:\n            current_module = \".\".join(current_module.__name__.split(\".\")[0:-1])\n        else:\n            current_module = \"\"\n\n    metadata.reverse()\n    return metadata\n</code></pre>"},{"location":"reference/kiara/utils/graphs/","title":"graphs","text":""},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs.print_ascii_graph","title":"<code>print_ascii_graph(graph: nx.Graph, restart_interpreter_if_asciinet_installed: bool = False)</code>","text":"Source code in <code>kiara/utils/graphs.py</code> <pre><code>def print_ascii_graph(\n    graph: nx.Graph, restart_interpreter_if_asciinet_installed: bool = False\n):\n\n    try:\n        from asciinet import graph_to_ascii  # type: ignore\n    except:  # noqa\n        import pip._internal.cli.main as pip\n\n        cmd = [\"-q\", \"--isolated\", \"install\"]\n        cmd.append(\"asciinet\")\n\n        log_message(\"install.python_package\", packages=\"asciinet\")\n        exit_code = pip.main(cmd)\n        try:\n            from asciinet import graph_to_ascii  # type: ignore\n        except:  # noqa:\n            exit_code = 1\n\n        if restart_interpreter_if_asciinet_installed:\n            os.execvp(sys.executable, (sys.executable,) + tuple(sys.argv))  # noqa\n\n        if exit_code != 0:\n            terminal_print(\n                \"\\nCan't print graph on terminal, package 'asciinet' not available. Please install it into the current virtualenv using:\\n\\npip install 'git+https://github.com/cosminbasca/asciinet.git#egg=asciinet&amp;subdirectory=pyasciinet'\"\n            )\n            return\n\n    try:\n        from asciinet._libutil import check_java  # type: ignore\n\n        check_java(\"Java \")\n    except Exception:\n        terminal_print()\n        terminal_print(\n            \"\\nJava is currently necessary to print ascii graph. This might change in the future, but to use this functionality please install a JRE.\"\n        )\n        return\n\n    print(graph_to_ascii(graph))  # noqa\n</code></pre>"},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs.create_image","title":"<code>create_image(graph: nx.Graph) -&gt; bytes</code>","text":"Source code in <code>kiara/utils/graphs.py</code> <pre><code>def create_image(graph: nx.Graph) -&gt; bytes:\n\n    try:\n        import pygraphviz as pgv  # noqa  # type: ignore\n    except:  # noqa\n        raise Exception(\n            \"pygraphviz not available, please install it manually into the current virtualenv\"\n        )\n\n    # graph = nx.relabel_nodes(graph, lambda x: hash(x))\n    G = nx.nx_agraph.to_agraph(graph)\n\n    G.node_attr[\"shape\"] = \"box\"\n    # G.unflatten().layout(prog=\"dot\")\n    G.layout(prog=\"dot\")\n\n    b = G.draw(format=\"png\")\n    return b\n</code></pre>"},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs.save_image","title":"<code>save_image(graph: nx.Graph, path: str)</code>","text":"Source code in <code>kiara/utils/graphs.py</code> <pre><code>def save_image(graph: nx.Graph, path: str):\n\n    with open(path, \"wb\") as f:\n        try:\n            graph_b = create_image(graph=graph)\n        except Exception as e:\n            graph_b = str(e).encode(\"utf-8\")\n        f.write(graph_b)\n</code></pre>"},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs.graph_to_image","title":"<code>graph_to_image(graph: nx.Graph, return_bytes: bool = False) -&gt; Union[bytes, Image]</code>","text":"Source code in <code>kiara/utils/graphs.py</code> <pre><code>def graph_to_image(\n    graph: nx.Graph, return_bytes: bool = False\n) -&gt; Union[bytes, \"Image\"]:\n\n    b = create_image(graph=graph)\n\n    if return_bytes:\n        return b\n    else:\n        try:\n            from IPython.core.display import Image\n\n            return Image(b)\n        except Exception:\n            raise Exception(\n                \"pygraphviz not available, please install it manually into the current virtualenv.\"\n            )\n</code></pre>"},{"location":"reference/kiara/utils/graphs/#kiara.utils.graphs.pipeline_graph_to_image","title":"<code>pipeline_graph_to_image(pipeline: Union[Pipeline, PipelineConfig, PipelineStructure], graph_type: Literal['data-flow', 'data-flow-simple', 'execution', 'stages'] = 'execution', stages_extraction_type: str = 'late', return_bytes: bool = False)</code>","text":"Source code in <code>kiara/utils/graphs.py</code> <pre><code>def pipeline_graph_to_image(\n    pipeline: Union[\"Pipeline\", \"PipelineConfig\", \"PipelineStructure\"],\n    graph_type: Literal[\n        \"data-flow\", \"data-flow-simple\", \"execution\", \"stages\"\n    ] = \"execution\",\n    stages_extraction_type: str = \"late\",\n    return_bytes: bool = False,\n):\n\n    if hasattr(pipeline, \"structure\"):\n        pipeline = pipeline.structure  # type: ignore\n\n    if graph_type == \"data-flow\":\n        graph = pipeline.data_flow_graph  # type: ignore\n    elif graph_type == \"data-flow-simple\":\n        graph = pipeline.data_flow_graph_simple  # type: ignore\n    elif graph_type == \"execution\":\n        graph = pipeline.execution_graph  # type: ignore\n    elif graph_type == \"stages\":\n        graph = pipeline.get_stages_graph(stages_extraction_type=stages_extraction_type)  # type: ignore\n    else:\n        raise Exception(\n            f\"Invalid graph type '{graph_type}': must be one of 'data-flow', 'data-flow-simple', 'execution', 'stages'.\"\n        )\n\n    return graph_to_image(graph=graph, return_bytes=return_bytes)\n</code></pre>"},{"location":"reference/kiara/utils/hashing/","title":"hashing","text":""},{"location":"reference/kiara/utils/hashing/#kiara.utils.hashing-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/hashing/#kiara.utils.hashing.compute_cid","title":"<code>compute_cid(data: Kind, hash_codec: str = 'sha2-256', encode: str = 'base58btc') -&gt; Tuple[bytes, CID]</code>","text":"Source code in <code>kiara/utils/hashing.py</code> <pre><code>def compute_cid(\n    data: Kind,\n    hash_codec: str = \"sha2-256\",\n    encode: str = \"base58btc\",\n) -&gt; Tuple[bytes, CID]:\n\n    encoded = dag_cbor.encode(data)\n    hash_func = multihash.get(hash_codec)\n    digest = hash_func.digest(encoded)\n\n    cid = CID(encode, 1, codec=\"dag-cbor\", digest=digest)\n    return encoded, cid\n</code></pre>"},{"location":"reference/kiara/utils/hashing/#kiara.utils.hashing.compute_cid_from_file","title":"<code>compute_cid_from_file(file: str, codec: Union[str, int, Multicodec] = 'raw', hash_codec: str = 'sha2-256')</code>","text":"Source code in <code>kiara/utils/hashing.py</code> <pre><code>def compute_cid_from_file(\n    file: str, codec: Union[str, int, Multicodec] = \"raw\", hash_codec: str = \"sha2-256\"\n):\n\n    assert hash_codec == \"sha2-256\"\n\n    hash_func = hashlib.sha256\n    file_hash = hash_func()\n\n    CHUNK_SIZE = 65536\n    with open(file, \"rb\") as f:\n        fb = f.read(CHUNK_SIZE)\n        while len(fb) &gt; 0:\n            file_hash.update(fb)\n            fb = f.read(CHUNK_SIZE)\n\n    wrapped = multihash.wrap(file_hash.digest(), \"sha2-256\")\n    return create_cid_digest(digest=wrapped, codec=codec)\n</code></pre>"},{"location":"reference/kiara/utils/hashing/#kiara.utils.hashing.create_cid_digest","title":"<code>create_cid_digest(digest: Union[str, BytesLike, Tuple[Union[str, int, Multihash], Union[str, BytesLike]]], codec: Union[str, int, Multicodec] = 'raw') -&gt; CID</code>","text":"Source code in <code>kiara/utils/hashing.py</code> <pre><code>def create_cid_digest(\n    digest: Union[\n        str, BytesLike, Tuple[Union[str, int, Multihash], Union[str, BytesLike]]\n    ],\n    codec: Union[str, int, Multicodec] = \"raw\",\n) -&gt; CID:\n\n    cid = CID(\"base58btc\", 1, codec, digest)\n    return cid\n</code></pre>"},{"location":"reference/kiara/utils/html/","title":"html","text":""},{"location":"reference/kiara/utils/html/#kiara.utils.html-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/html/#kiara.utils.html-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/html/#kiara.utils.html.generate_html","title":"<code>generate_html(item: Any, render_config: Union[None, Mapping[str, Any]] = None, add_header: bool = False, add_type_column: bool = False) -&gt; Airium</code>","text":"<p>Create html representing this models data.</p> Source code in <code>kiara/utils/html.py</code> <pre><code>def generate_html(\n    item: Any,\n    render_config: Union[None, Mapping[str, Any]] = None,\n    add_header: bool = False,\n    add_type_column: bool = False,\n) -&gt; \"Airium\":\n\"\"\"Create html representing this models data.\"\"\"\n\n    from airium import Airium  # type: ignore\n\n    doc = Airium()\n\n    if render_config is None:\n        render_config = {}\n    else:\n        render_config = dict(render_config)\n\n    if isinstance(item, str):\n        doc(item)\n    elif isinstance(item, BaseModel):\n\n        from kiara.models import KiaraModel\n\n        if isinstance(item, KiaraModel):\n            template_registry = TemplateRegistry.instance()\n            template = template_registry.get_template_for_model_type(\n                model_type=item.model_type_id, template_format=\"html\"\n            )\n\n            if template:\n                rendered = template.render(instance=item)\n                doc(rendered)\n                return doc\n\n        exclude_fields = None\n        model_cls = item.__class__\n        props = model_cls.schema().get(\"properties\", {})\n\n        rows = []\n        for field_name, field in model_cls.__fields__.items():\n\n            if exclude_fields and field_name in exclude_fields:\n                continue\n\n            row = [field_name]\n\n            p = props.get(field_name, None)\n            if add_type_column:\n                p_type = None\n                if p is not None:\n                    p_type = p.get(\"type\", None)\n                    # TODO: check 'anyOf' keys\n\n                if p_type is None:\n                    p_type = \"-- check source --\"\n                row.append(p_type)\n\n            data = getattr(item, field_name)\n            row.append(generate_html(data, render_config=render_config))\n\n            if p is not None:\n                desc = p.get(\"description\", \"\")\n            else:\n                desc = \"\"\n            row.append(desc)\n\n            rows.append(row)\n\n        with doc.table():\n            if add_header:\n                with doc.tr():\n                    doc.th(_t=\"field\")\n                    if add_type_column:\n                        doc.th(_t=\"type\")\n                    doc.th(_t=\"data\")\n                    doc.th(_t=\"description\")\n\n            for row in rows:\n                with doc.tr():\n                    doc.td(_t=row[0])\n                    doc.td(_t=row[1])\n                    doc.td(_t=row[2])\n                    if add_type_column:\n                        doc.td(_t=row[3])\n\n    elif isinstance(item, Mapping):\n        with doc.table():\n            for k, v in item.items():\n                with doc.tr():\n                    doc.td(_t=k)\n                    value_el = generate_html(v)\n                    doc.td(_t=value_el)\n    elif isinstance(item, Iterable):\n\n        with doc.ul():\n            for i in item:\n                with doc.li():\n                    value_el = generate_html(i)\n                    doc(str(value_el))\n\n    else:\n        doc(str(item))\n\n    return doc\n</code></pre>"},{"location":"reference/kiara/utils/json/","title":"json","text":""},{"location":"reference/kiara/utils/json/#kiara.utils.json-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/json/#kiara.utils.json.orjson_dumps","title":"<code>orjson_dumps(v, *, default = None, **args)</code>","text":"Source code in <code>kiara/utils/json.py</code> <pre><code>def orjson_dumps(v, *, default=None, **args):\n    # orjson.dumps returns bytes, to match standard json.dumps we need to decode\n\n    try:\n        return orjson.dumps(v, default=default, **args).decode()\n    except Exception as e:\n        if is_debug():\n            from kiara.utils.cli import terminal_print\n\n            terminal_print(f\"Error dumping json data: {e}\")\n            from kiara import dbg\n\n            dbg(v)\n\n        raise e\n</code></pre>"},{"location":"reference/kiara/utils/metadata/","title":"metadata","text":""},{"location":"reference/kiara/utils/metadata/#kiara.utils.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/metadata/#kiara.utils.metadata-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/metadata/#kiara.utils.metadata.find_metadata_models","title":"<code>find_metadata_models(alias: Union[str, None] = None, only_for_package: Union[str, None] = None) -&gt; MetadataTypeClassesInfo</code>","text":"Source code in <code>kiara/utils/metadata.py</code> <pre><code>def find_metadata_models(\n    alias: Union[str, None] = None, only_for_package: Union[str, None] = None\n) -&gt; MetadataTypeClassesInfo:\n\n    model_registry = ModelRegistry.instance()\n    _group = model_registry.get_models_of_type(ValueMetadata)  # type: ignore\n\n    classes: Dict[str, Type[ValueMetadata]] = {}\n    for model_id, info in _group.item_infos.items():\n        classes[model_id] = info.python_class.get_class()  # type: ignore\n\n    group: MetadataTypeClassesInfo = MetadataTypeClassesInfo.create_from_type_items(group_title=alias, kiara=None, **classes)  # type: ignore\n\n    if only_for_package:\n        temp = {}\n        for key, _info in group.item_infos.items():\n            if _info.context.labels.get(\"package\") == only_for_package:\n                temp[key] = _info\n\n        group = MetadataTypeClassesInfo.construct(\n            group_id=group.instance_id, group_alias=group.group_alias, item_infos=temp  # type: ignore\n        )\n\n    return group\n</code></pre>"},{"location":"reference/kiara/utils/models/","title":"models","text":""},{"location":"reference/kiara/utils/models/#kiara.utils.models-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/models/#kiara.utils.models-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/models/#kiara.utils.models-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/models/#kiara.utils.models.create_pydantic_model","title":"<code>create_pydantic_model(model_cls: Type[BaseModel], _use_pydantic_construct: bool = PYDANTIC_USE_CONSTRUCT, **field_values: Any)</code>","text":"Source code in <code>kiara/utils/models.py</code> <pre><code>def create_pydantic_model(\n    model_cls: Type[BaseModel],\n    _use_pydantic_construct: bool = PYDANTIC_USE_CONSTRUCT,\n    **field_values: Any,\n):\n\n    if _use_pydantic_construct:\n        raise NotImplementedError()\n        return model_cls.construct(**field_values)\n    else:\n        return model_cls(**field_values)\n</code></pre>"},{"location":"reference/kiara/utils/models/#kiara.utils.models.retrieve_data_subcomponent_keys","title":"<code>retrieve_data_subcomponent_keys(data: Any) -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/utils/models.py</code> <pre><code>def retrieve_data_subcomponent_keys(data: Any) -&gt; Iterable[str]:\n\n    if hasattr(data, \"__custom_root_type__\") and data.__custom_root_type__:\n        if isinstance(data.__root__, Mapping):  # type: ignore\n            result = set()\n            for k, v in data.__root__.items():  # type: ignore\n                if isinstance(v, BaseModel):\n                    result.add(k.split(\".\")[0])\n            return result\n        else:\n            return []\n    elif isinstance(data, BaseModel):\n        matches = sorted(data.__fields__.keys())\n        return matches\n    else:\n        log_message(\n            f\"No subcomponents retrieval supported for data of type: {type(data)}\"\n        )\n        return []\n</code></pre>"},{"location":"reference/kiara/utils/models/#kiara.utils.models.get_subcomponent_from_model","title":"<code>get_subcomponent_from_model(data: KiaraModel, path: str) -&gt; KiaraModel</code>","text":"<p>Return subcomponents of a model under a specified path.</p> Source code in <code>kiara/utils/models.py</code> <pre><code>def get_subcomponent_from_model(data: \"KiaraModel\", path: str) -&gt; \"KiaraModel\":\n\"\"\"Return subcomponents of a model under a specified path.\"\"\"\n\n    if \".\" in path:\n        first_token, rest = path.split(\".\", maxsplit=1)\n        sc = data.get_subcomponent(first_token)\n        return sc.get_subcomponent(rest)\n\n    if hasattr(data, \"__custom_root_type__\") and data.__custom_root_type__:\n        if isinstance(data.__root__, Mapping):  # type: ignore\n            if path in data.__root__.keys():  # type: ignore\n                return data.__root__[path]  # type: ignore\n            else:\n                matches = {}\n                for k in data.__root__.keys():  # type: ignore\n                    if k.startswith(f\"{path}.\"):\n                        rest = k[len(path) + 1 :]\n                        matches[rest] = data.__root__[k]  # type: ignore\n\n                if not matches:\n                    raise KeyError(f\"No child models under '{path}'.\")\n                else:\n                    raise NotImplementedError()\n                    # subcomponent_group = KiaraModelGroup.create_from_child_models(**matches)\n                    # return subcomponent_group\n\n        else:\n            raise NotImplementedError()\n    else:\n        if path in data.__fields__.keys():\n            return getattr(data, path)\n        else:\n            raise KeyError(\n                f\"No subcomponent for key '{path}' in model: {data.instance_id}.\"\n            )\n</code></pre>"},{"location":"reference/kiara/utils/models/#kiara.utils.models.assemble_subcomponent_graph","title":"<code>assemble_subcomponent_graph(data: KiaraModel) -&gt; Union[nx.DiGraph, None]</code>","text":"Source code in <code>kiara/utils/models.py</code> <pre><code>def assemble_subcomponent_graph(data: \"KiaraModel\") -&gt; Union[nx.DiGraph, None]:\n\n    from kiara.models import KiaraModel\n\n    graph = nx.DiGraph()\n\n    def assemble_graph(info_model: KiaraModel, current_node_id, level: int = 0):\n        graph.add_node(current_node_id, obj=info_model, level=level)\n        scn = info_model.subcomponent_keys\n        if not scn:\n            return\n        for child_path in scn:\n            child_obj = info_model.get_subcomponent(child_path)\n            new_node_id = f\"{current_node_id}.{child_path}\"\n            graph.add_edge(current_node_id, new_node_id)\n            if isinstance(child_obj, KiaraModel):\n                assemble_graph(child_obj, new_node_id, level + 1)\n\n    assemble_graph(data, KIARA_DEFAULT_ROOT_NODE_ID)\n    return graph\n</code></pre>"},{"location":"reference/kiara/utils/models/#kiara.utils.models.create_subcomponent_tree_renderable","title":"<code>create_subcomponent_tree_renderable(data: KiaraModel, show_data: bool = False) -&gt; Tree</code>","text":"Source code in <code>kiara/utils/models.py</code> <pre><code>def create_subcomponent_tree_renderable(\n    data: \"KiaraModel\", show_data: bool = False\n) -&gt; Tree:\n\n    from kiara.models import KiaraModel\n    from kiara.utils.output import extract_renderable\n\n    def extract_type_string(obj: Any) -&gt; str:\n\n        if isinstance(obj, KiaraModel):\n            return f\"model: {obj.model_type_id}\"\n        elif isinstance(obj, Mapping):\n            return \"dict\"\n        else:\n            return type(obj).__name__\n\n    def assemble_tree(node: Tree, model: Any, level: int):\n\n        if isinstance(model, Mapping) and model:\n            for k, v in model.items():\n                child_tree = node.add(f\"[b i]{k}[/b i] ({extract_type_string(v)})\")\n                assemble_tree(node=child_tree, model=v, level=level + 1)\n            return\n\n        if not isinstance(model, KiaraModel):\n            if show_data:\n                renderable = extract_renderable(model)\n                panel = Panel(\n                    renderable, title=\"[i]data[/i]\", title_align=\"left\", expand=False\n                )\n                node.add(panel)\n            return\n\n        scn = model.subcomponent_keys\n        if not scn:\n            return\n        for child_path in scn:\n            child_obj = model.get_subcomponent(child_path)\n            child_tree = node.add(\n                f\"[b i]{child_path}[/b i] ({extract_type_string(child_obj)})\"\n            )\n            assemble_tree(node=child_tree, model=child_obj, level=level + 1)\n\n    tree = Tree(f\"[b]{data.model_type_id}[/b]: [b]{data.instance_id}[/b]\")\n    assemble_tree(node=tree, model=data, level=0)\n\n    return tree\n</code></pre>"},{"location":"reference/kiara/utils/modules/","title":"modules","text":""},{"location":"reference/kiara/utils/modules/#kiara.utils.modules-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/modules/#kiara.utils.modules.module_config_is_empty","title":"<code>module_config_is_empty(config: Mapping[str, Any])</code>","text":"Source code in <code>kiara/utils/modules.py</code> <pre><code>def module_config_is_empty(config: Mapping[str, Any]):\n\n    c = dict(config)\n    d = c.pop(\"defaults\", None)\n    if d:\n        return False\n    constants = c.pop(\"constants\", None)\n    if constants:\n        return False\n\n    return False if c else True\n</code></pre>"},{"location":"reference/kiara/utils/operations/","title":"operations","text":""},{"location":"reference/kiara/utils/operations/#kiara.utils.operations-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/operations/#kiara.utils.operations.yaml","title":"<code>yaml = YAML(typ='safe')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/operations/#kiara.utils.operations-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/operations/#kiara.utils.operations-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/operations/#kiara.utils.operations.filter_operations","title":"<code>filter_operations(kiara: Kiara, pkg_name: Union[str, None] = None, **operations: Operation) -&gt; OperationGroupInfo</code>","text":"Source code in <code>kiara/utils/operations.py</code> <pre><code>def filter_operations(\n    kiara: \"Kiara\", pkg_name: Union[str, None] = None, **operations: \"Operation\"\n) -&gt; OperationGroupInfo:\n\n    result: Dict[str, OperationInfo] = {}\n\n    # op_infos = kiara.operation_registry.get_context_metadata(only_for_package=pkg_name)\n    modules = kiara.module_registry.get_context_metadata(only_for_package=pkg_name)\n\n    for op_id, op in operations.items():\n\n        if op.module.module_type_name != \"pipeline\":\n            if op.module.module_type_name in modules.item_infos.keys():\n                result[op_id] = OperationInfo.create_from_operation(\n                    kiara=kiara, operation=op\n                )\n                continue\n        else:\n            package: Union[str, None] = op.metadata.get(\"labels\", {}).get(\n                \"package\", None\n            )\n            if not pkg_name or (package and package == pkg_name):\n                result[op_id] = OperationInfo.create_from_operation(\n                    kiara=kiara, operation=op\n                )\n\n        # opt_types = kiara.operation_registry.find_all_operation_types(op_id)\n        # match = False\n        # for ot in opt_types:\n        #     if ot in op_infos.keys():\n        #         match = True\n        #         break\n        #\n        # if match:\n        #     result[op_id] = OperationInfo.create_from_operation(\n        #         kiara=kiara, operation=op\n        #     )\n\n    return OperationGroupInfo.construct(item_infos=result)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/utils/operations/#kiara.utils.operations.create_operation","title":"<code>create_operation(module_or_operation: str, operation_config: Union[None, Mapping[str, Any]] = None, kiara: Union[None, Kiara] = None) -&gt; Operation</code>","text":"Source code in <code>kiara/utils/operations.py</code> <pre><code>def create_operation(\n    module_or_operation: str,\n    operation_config: Union[None, Mapping[str, Any]] = None,\n    kiara: Union[None, \"Kiara\"] = None,\n) -&gt; Operation:\n\n    operation: Union[Operation, None]\n\n    if kiara is None:\n        from kiara.context import Kiara\n\n        kiara = Kiara.instance()\n\n    operation = None\n\n    if module_or_operation in kiara.operation_registry.operation_ids:\n\n        operation = kiara.operation_registry.get_operation(module_or_operation)\n        if operation_config:\n            if module_or_operation in kiara.module_type_names:\n                manifest = Manifest(\n                    module_type=module_or_operation, module_config=operation_config\n                )\n                module = kiara.module_registry.create_module(manifest=manifest)\n                operation = Operation.create_from_module(module)\n            else:\n                raise Exception(\n                    f\"Specified run target '{module_or_operation}' is an operation, additional module configuration is not allowed.\"\n                )\n\n    elif (\n        module_or_operation != \"pipeline\"\n        and module_or_operation in kiara.module_type_names\n    ):\n\n        if operation_config is None:\n            operation_config = {}\n        manifest = Manifest(\n            module_type=module_or_operation, module_config=operation_config\n        )\n        module = kiara.module_registry.create_module(manifest=manifest)\n        operation = Operation.create_from_module(module)\n\n    elif os.path.isfile(module_or_operation):\n        _data = get_data_from_file(module_or_operation)\n        pipeline_name = _data.pop(\"pipeline_name\", None)\n        if pipeline_name is None:\n            pipeline_name = os.path.basename(module_or_operation)\n\n        # self._defaults = data.pop(\"inputs\", {})\n\n        execution_context = ExecutionContext(\n            pipeline_dir=os.path.abspath(os.path.dirname(module_or_operation))\n        )\n        pipeline_config = PipelineConfig.from_config(\n            pipeline_name=pipeline_name,\n            data=_data,\n            kiara=kiara,\n            execution_context=execution_context,\n        )\n\n        manifest = kiara.create_manifest(\"pipeline\", config=pipeline_config.dict())\n        module = kiara.module_registry.create_module(manifest=manifest)\n\n        operation = Operation.create_from_module(module, doc=pipeline_config.doc)\n\n    else:\n        if module_or_operation == \"pipeline\":\n            data: Union[None, Mapping[str, Any]] = operation_config\n        else:\n            try:\n                import json\n\n                data = json.loads(module_or_operation)\n            except Exception:\n                try:\n                    data = yaml.load(module_or_operation)\n                except Exception:\n                    data = None\n\n            if data and not isinstance(data, Mapping):\n                raise Exception(\n                    f\"Could not parse module or operation: {module_or_operation}\"\n                )\n\n        if data:\n            d = dict(data)\n            pipeline_name = d.pop(\"pipeline_name\", None)\n            if pipeline_name is not None:\n\n                execution_context = ExecutionContext(\n                    pipeline_dir=os.path.abspath(os.path.dirname(module_or_operation))\n                )\n                pipeline_config = PipelineConfig.from_config(\n                    pipeline_name=pipeline_name,\n                    data=d,\n                    kiara=kiara,\n                    execution_context=execution_context,\n                )\n\n                manifest = kiara.create_manifest(\n                    \"pipeline\", config=pipeline_config.dict()\n                )\n                module = kiara.module_registry.create_module(manifest=manifest)\n\n                operation = Operation.create_from_module(\n                    module, doc=pipeline_config.doc\n                )\n            else:\n                raise Exception(\"Invalid pipeline config, missing 'pipeline_name' key.\")\n\n        if operation is None:\n\n            if module_or_operation == \"pipeline\":\n                msg = \"Can't assemble pipeline.\"\n            else:\n                msg = f\"Can't assemble operation, invalid operation/module name: {module_or_operation}. Must be registered module or operation name, or file.\"\n            raise NoSuchOperationException(\n                msg=msg,\n                operation_id=module_or_operation,\n                available_operations=sorted(kiara.operation_registry.operation_ids),\n            )\n\n    if operation is None:\n\n        merged = set(kiara.module_type_names)\n        merged.update(kiara.operation_registry.operation_ids)\n        raise NoSuchExecutionTargetException(\n            selected_target=module_or_operation,\n            msg=f\"Invalid run target name '{module_or_operation}'. Must be a path to a pipeline file, or one of the available modules/operations.\",\n            available_targets=sorted(merged),\n        )\n    return operation\n</code></pre>"},{"location":"reference/kiara/utils/operations/#kiara.utils.operations.create_operation_status_renderable","title":"<code>create_operation_status_renderable(operation: Operation, inputs: Union[ValueMap, None], render_config: Any) -&gt; RenderableType</code>","text":"Source code in <code>kiara/utils/operations.py</code> <pre><code>def create_operation_status_renderable(\n    operation: Operation, inputs: Union[\"ValueMap\", None], render_config: Any\n) -&gt; RenderableType:\n\n    show_operation_name = render_config.get(\"show_operation_name\", True)\n    show_operation_doc = render_config.get(\"show_operation_doc\", True)\n    show_inputs = render_config.get(\"show_inputs\", False)\n    show_outputs_schema = render_config.get(\"show_outputs_schema\", False)\n    show_headers = render_config.get(\"show_headers\", True)\n\n    items: List[Any] = []\n\n    if show_operation_name:\n        items.append(f\"Operation: [bold]{operation.operation_id}[/bold]\")\n    if show_operation_doc and operation.doc.is_set:\n        items.append(\"\")\n        items.append(Markdown(operation.doc.full_doc, style=\"i\"))\n\n    if show_inputs:\n        assert inputs is not None\n        if show_headers:\n            items.append(\"\\nInputs:\")\n        _inputs: Union[None, RenderableType] = None\n        try:\n            _inputs = create_value_map_status_renderable(\n                inputs, render_config=render_config\n            )\n        except InvalidValuesException as ive:\n            _inputs = ive.create_renderable(**render_config)\n        except Exception as e:\n            _inputs = f\"[red bold]{e}[/red bold]\"\n        finally:\n            assert _inputs is not None\n            items.append(_inputs)\n    if show_outputs_schema:\n        if show_headers:\n            items.append(\"\\nOutputs:\")\n        outputs_schema = create_table_from_field_schemas(\n            _add_default=False,\n            _add_required=False,\n            _show_header=True,\n            _constants=None,\n            fields=operation.outputs_schema,\n        )\n        items.append(outputs_schema)\n\n    return Group(*items)\n</code></pre>"},{"location":"reference/kiara/utils/output/","title":"output","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.log","title":"<code>log = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.RenderConfig","title":"<code>RenderConfig</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/utils/output.py</code> <pre><code>class RenderConfig(BaseModel):\n\n    render_format: str = Field(description=\"The output format.\", default=\"terminal\")\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.RenderConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.RenderConfig.render_format","title":"<code>render_format: str = Field(description='The output format.', default='terminal')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails","title":"<code>OutputDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/utils/output.py</code> <pre><code>class OutputDetails(BaseModel):\n    @classmethod\n    def from_data(cls, data: Any):\n\n        if isinstance(data, str):\n            if \"=\" in data:\n                data = [data]\n            else:\n                data = [f\"format={data}\"]\n\n        if isinstance(data, Iterable):\n            from kiara.utils.cli import dict_from_cli_args\n\n            data = list(data)\n            if len(data) == 1 and isinstance(data[0], str) and \"=\" not in data[0]:\n                data = [f\"format={data[0]}\"]\n            output_details_dict = dict_from_cli_args(*data)\n        else:\n            raise TypeError(\n                f\"Can't parse output detail config: invalid input type '{type(data)}'.\"\n            )\n\n        output_details = OutputDetails(**output_details_dict)\n        return output_details\n\n    format: str = Field(description=\"The output format.\")\n    target: str = Field(description=\"The output target.\")\n    config: Dict[str, Any] = Field(\n        description=\"Output configuration.\", default_factory=dict\n    )\n\n    @root_validator(pre=True)\n    def _set_defaults(cls, values) -&gt; Dict[str, Any]:\n\n        target: str = values.pop(\"target\", \"terminal\")\n        format: str = values.pop(\"format\", None)\n        if format is None:\n            if target == \"terminal\":\n                format = \"terminal\"\n            else:\n                if target == \"file\":\n                    format = \"json\"\n                else:\n                    ext = target.split(\".\")[-1]\n                    if ext in [\"yaml\", \"json\"]:\n                        format = ext\n                    else:\n                        format = \"json\"\n        result = {\"format\": format, \"target\": target, \"config\": dict(values)}\n\n        return result\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails.format","title":"<code>format: str = Field(description='The output format.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails.target","title":"<code>target: str = Field(description='The output target.')</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails.config","title":"<code>config: Dict[str, Any] = Field(description='Output configuration.', default_factory=dict)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.OutputDetails.from_data","title":"<code>from_data(data: Any)</code>  <code>classmethod</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>@classmethod\ndef from_data(cls, data: Any):\n\n    if isinstance(data, str):\n        if \"=\" in data:\n            data = [data]\n        else:\n            data = [f\"format={data}\"]\n\n    if isinstance(data, Iterable):\n        from kiara.utils.cli import dict_from_cli_args\n\n        data = list(data)\n        if len(data) == 1 and isinstance(data[0], str) and \"=\" not in data[0]:\n            data = [f\"format={data[0]}\"]\n        output_details_dict = dict_from_cli_args(*data)\n    else:\n        raise TypeError(\n            f\"Can't parse output detail config: invalid input type '{type(data)}'.\"\n        )\n\n    output_details = OutputDetails(**output_details_dict)\n    return output_details\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap","title":"<code>TabularWrap</code>","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>kiara/utils/output.py</code> <pre><code>class TabularWrap(ABC):\n    def __init__(self) -&gt; None:\n        self._num_rows: Union[int, None] = None\n        self._column_names: Union[Iterable[str], None] = None\n        self._force_single_line: bool = True\n\n    @property\n    def num_rows(self) -&gt; int:\n        if self._num_rows is None:\n            self._num_rows = self.retrieve_number_of_rows()\n        return self._num_rows\n\n    @property\n    def column_names(self) -&gt; Iterable[str]:\n        if self._column_names is None:\n            self._column_names = self.retrieve_column_names()\n        return self._column_names\n\n    @abstractmethod\n    def retrieve_column_names(self) -&gt; Iterable[str]:\n        pass\n\n    @abstractmethod\n    def retrieve_number_of_rows(self) -&gt; int:\n        pass\n\n    @abstractmethod\n    def slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n        pass\n\n    @abstractmethod\n    def to_pydict(self) -&gt; Mapping:\n        pass\n\n    def as_string(\n        self,\n        rows_head: Union[int, None] = None,\n        rows_tail: Union[int, None] = None,\n        max_row_height: Union[int, None] = None,\n        max_cell_length: Union[int, None] = None,\n    ):\n\n        table_str = \"\"\n        for cn in self.column_names:\n            table_str = f\"{table_str}{cn}\\t\"\n        table_str = f\"{table_str}\\n\"\n\n        for data in self.prepare_table_data(\n            return_column_names=False,\n            rows_head=rows_head,\n            rows_tail=rows_tail,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        ):\n            for cell in data:\n                table_str = f\"{table_str}{cell}\\t\"\n            table_str = f\"{table_str}\\n\"\n\n        return table_str\n\n    def as_html(\n        self,\n        rows_head: Union[int, None] = None,\n        rows_tail: Union[int, None] = None,\n        max_row_height: Union[int, None] = None,\n        max_cell_length: Union[int, None] = None,\n    ) -&gt; str:\n\n        table_str = \"&lt;table&gt;&lt;tr&gt;\"\n        for cn in self.column_names:\n            table_str = f\"{table_str}&lt;th&gt;{cn}&lt;/th&gt;\"\n        table_str = f\"{table_str}&lt;/tr&gt;\"\n\n        for data in self.prepare_table_data(\n            return_column_names=False,\n            rows_head=rows_head,\n            rows_tail=rows_tail,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        ):\n            table_str = f\"{table_str}&lt;tr&gt;\"\n            for cell in data:\n                table_str = f\"{table_str}&lt;td&gt;{cell}&lt;/td&gt;\"\n            table_str = f\"{table_str}&lt;/tr&gt;\"\n        table_str = f\"{table_str}&lt;/table&gt;\"\n        return table_str\n\n    def as_terminal_renderable(\n        self,\n        rows_head: Union[int, None] = None,\n        rows_tail: Union[int, None] = None,\n        max_row_height: Union[int, None] = None,\n        max_cell_length: Union[int, None] = None,\n        show_table_header: bool = True,\n    ) -&gt; RichTable:\n\n        rich_table = RichTable(show_header=show_table_header, box=box.SIMPLE)\n        if max_row_height == 1:\n            overflow = \"ignore\"\n        else:\n            overflow = \"ellipsis\"\n\n        for cn in self.column_names:\n            rich_table.add_column(cn, overflow=overflow)  # type: ignore\n\n        data = self.prepare_table_data(\n            return_column_names=False,\n            rows_head=rows_head,\n            rows_tail=rows_tail,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n\n        for row in data:\n            rich_table.add_row(*row)\n\n        return rich_table\n\n    def prepare_table_data(\n        self,\n        return_column_names: bool = False,\n        rows_head: Union[int, None] = None,\n        rows_tail: Union[int, None] = None,\n        max_row_height: Union[int, None] = None,\n        max_cell_length: Union[int, None] = None,\n    ) -&gt; Iterator[Iterable[Any]]:\n\n        if return_column_names:\n            yield self.column_names\n\n        num_split_rows = 2\n\n        if rows_head is not None:\n\n            if rows_head &lt; 0:\n                rows_head = 0\n\n            if rows_head &gt; self.num_rows:\n                rows_head = self.num_rows\n                rows_tail = None\n                num_split_rows = 0\n\n            if rows_tail is not None:\n                if rows_head + rows_tail &gt;= self.num_rows:  # type: ignore\n                    rows_head = self.num_rows\n                    rows_tail = None\n                    num_split_rows = 0\n        else:\n            num_split_rows = 0\n\n        if rows_head is not None:\n            head = self.slice(0, rows_head)\n            num_rows = rows_head\n        else:\n            head = self\n            num_rows = self.num_rows\n\n        table_dict = head.to_pydict()\n        for i in range(0, num_rows):\n            row = []\n            for cn in self.column_names:\n                cell = table_dict[cn][i]\n                cell_str = str(cell)\n                if max_row_height and max_row_height &gt; 0 and \"\\n\" in cell_str:\n                    lines = cell_str.split(\"\\n\")\n                    if len(lines) &gt; max_row_height:\n                        if max_row_height == 1:\n                            lines = lines[0:1]\n                        else:\n                            half = int(max_row_height / 2)\n                            lines = lines[0:half] + [\"..\"] + lines[-half:]\n                    cell_str = \"\\n\".join(lines)\n\n                if max_cell_length and max_cell_length &gt; 0:\n                    lines = []\n                    for line in cell_str.split(\"\\n\"):\n                        if len(line) &gt; max_cell_length:\n                            line = line[0:max_cell_length] + \" ...\"\n                        else:\n                            line = line\n                        lines.append(line)\n                    cell_str = \"\\n\".join(lines)\n\n                row.append(cell_str)\n\n            yield row\n\n        if num_split_rows:\n            for i in range(0, num_split_rows):\n                row = []\n                for _ in self.column_names:\n                    row.append(\"...\")\n                yield row\n\n        if rows_head:\n            if rows_tail is not None:\n                if rows_tail &lt; 0:\n                    rows_tail = 0\n\n                tail = self.slice(self.num_rows - rows_tail)\n                table_dict = tail.to_pydict()\n                for i in range(0, num_rows):\n\n                    row = []\n                    for cn in self.column_names:\n\n                        cell = table_dict[cn][i]\n                        cell_str = str(cell)\n\n                        if max_row_height and max_row_height &gt; 0 and \"\\n\" in cell_str:\n                            lines = cell_str.split(\"\\n\")\n                            if len(lines) &gt; max_row_height:\n                                if max_row_height == 1:\n                                    lines = lines[0:1]\n                                else:\n                                    half = int(len(lines) / 2)\n                                    lines = lines[0:half] + [\"..\"] + lines[-half:]\n                            cell_str = \"\\n\".join(lines)\n\n                        if max_cell_length and max_cell_length &gt; 0:\n                            lines = []\n                            for line in cell_str.split(\"\\n\"):\n\n                                if len(line) &gt; max_cell_length:\n                                    line = line[0:(max_cell_length)] + \" ...\"\n                                else:\n                                    line = line\n                                lines.append(line)\n                            cell_str = \"\\n\".join(lines)\n\n                        row.append(cell_str)\n\n                    yield row\n\n        return\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.num_rows","title":"<code>num_rows: int</code>  <code>property</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.column_names","title":"<code>column_names: Iterable[str]</code>  <code>property</code>","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.retrieve_column_names","title":"<code>retrieve_column_names() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>@abstractmethod\ndef retrieve_column_names(self) -&gt; Iterable[str]:\n    pass\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.retrieve_number_of_rows","title":"<code>retrieve_number_of_rows() -&gt; int</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>@abstractmethod\ndef retrieve_number_of_rows(self) -&gt; int:\n    pass\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.slice","title":"<code>slice(offset: int = 0, length: Union[int, None] = None) -&gt; TabularWrap</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>@abstractmethod\ndef slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n    pass\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.to_pydict","title":"<code>to_pydict() -&gt; Mapping</code>  <code>abstractmethod</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>@abstractmethod\ndef to_pydict(self) -&gt; Mapping:\n    pass\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.as_string","title":"<code>as_string(rows_head: Union[int, None] = None, rows_tail: Union[int, None] = None, max_row_height: Union[int, None] = None, max_cell_length: Union[int, None] = None)</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def as_string(\n    self,\n    rows_head: Union[int, None] = None,\n    rows_tail: Union[int, None] = None,\n    max_row_height: Union[int, None] = None,\n    max_cell_length: Union[int, None] = None,\n):\n\n    table_str = \"\"\n    for cn in self.column_names:\n        table_str = f\"{table_str}{cn}\\t\"\n    table_str = f\"{table_str}\\n\"\n\n    for data in self.prepare_table_data(\n        return_column_names=False,\n        rows_head=rows_head,\n        rows_tail=rows_tail,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    ):\n        for cell in data:\n            table_str = f\"{table_str}{cell}\\t\"\n        table_str = f\"{table_str}\\n\"\n\n    return table_str\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.as_html","title":"<code>as_html(rows_head: Union[int, None] = None, rows_tail: Union[int, None] = None, max_row_height: Union[int, None] = None, max_cell_length: Union[int, None] = None) -&gt; str</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def as_html(\n    self,\n    rows_head: Union[int, None] = None,\n    rows_tail: Union[int, None] = None,\n    max_row_height: Union[int, None] = None,\n    max_cell_length: Union[int, None] = None,\n) -&gt; str:\n\n    table_str = \"&lt;table&gt;&lt;tr&gt;\"\n    for cn in self.column_names:\n        table_str = f\"{table_str}&lt;th&gt;{cn}&lt;/th&gt;\"\n    table_str = f\"{table_str}&lt;/tr&gt;\"\n\n    for data in self.prepare_table_data(\n        return_column_names=False,\n        rows_head=rows_head,\n        rows_tail=rows_tail,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    ):\n        table_str = f\"{table_str}&lt;tr&gt;\"\n        for cell in data:\n            table_str = f\"{table_str}&lt;td&gt;{cell}&lt;/td&gt;\"\n        table_str = f\"{table_str}&lt;/tr&gt;\"\n    table_str = f\"{table_str}&lt;/table&gt;\"\n    return table_str\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.as_terminal_renderable","title":"<code>as_terminal_renderable(rows_head: Union[int, None] = None, rows_tail: Union[int, None] = None, max_row_height: Union[int, None] = None, max_cell_length: Union[int, None] = None, show_table_header: bool = True) -&gt; RichTable</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def as_terminal_renderable(\n    self,\n    rows_head: Union[int, None] = None,\n    rows_tail: Union[int, None] = None,\n    max_row_height: Union[int, None] = None,\n    max_cell_length: Union[int, None] = None,\n    show_table_header: bool = True,\n) -&gt; RichTable:\n\n    rich_table = RichTable(show_header=show_table_header, box=box.SIMPLE)\n    if max_row_height == 1:\n        overflow = \"ignore\"\n    else:\n        overflow = \"ellipsis\"\n\n    for cn in self.column_names:\n        rich_table.add_column(cn, overflow=overflow)  # type: ignore\n\n    data = self.prepare_table_data(\n        return_column_names=False,\n        rows_head=rows_head,\n        rows_tail=rows_tail,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n\n    for row in data:\n        rich_table.add_row(*row)\n\n    return rich_table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.TabularWrap.prepare_table_data","title":"<code>prepare_table_data(return_column_names: bool = False, rows_head: Union[int, None] = None, rows_tail: Union[int, None] = None, max_row_height: Union[int, None] = None, max_cell_length: Union[int, None] = None) -&gt; Iterator[Iterable[Any]]</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def prepare_table_data(\n    self,\n    return_column_names: bool = False,\n    rows_head: Union[int, None] = None,\n    rows_tail: Union[int, None] = None,\n    max_row_height: Union[int, None] = None,\n    max_cell_length: Union[int, None] = None,\n) -&gt; Iterator[Iterable[Any]]:\n\n    if return_column_names:\n        yield self.column_names\n\n    num_split_rows = 2\n\n    if rows_head is not None:\n\n        if rows_head &lt; 0:\n            rows_head = 0\n\n        if rows_head &gt; self.num_rows:\n            rows_head = self.num_rows\n            rows_tail = None\n            num_split_rows = 0\n\n        if rows_tail is not None:\n            if rows_head + rows_tail &gt;= self.num_rows:  # type: ignore\n                rows_head = self.num_rows\n                rows_tail = None\n                num_split_rows = 0\n    else:\n        num_split_rows = 0\n\n    if rows_head is not None:\n        head = self.slice(0, rows_head)\n        num_rows = rows_head\n    else:\n        head = self\n        num_rows = self.num_rows\n\n    table_dict = head.to_pydict()\n    for i in range(0, num_rows):\n        row = []\n        for cn in self.column_names:\n            cell = table_dict[cn][i]\n            cell_str = str(cell)\n            if max_row_height and max_row_height &gt; 0 and \"\\n\" in cell_str:\n                lines = cell_str.split(\"\\n\")\n                if len(lines) &gt; max_row_height:\n                    if max_row_height == 1:\n                        lines = lines[0:1]\n                    else:\n                        half = int(max_row_height / 2)\n                        lines = lines[0:half] + [\"..\"] + lines[-half:]\n                cell_str = \"\\n\".join(lines)\n\n            if max_cell_length and max_cell_length &gt; 0:\n                lines = []\n                for line in cell_str.split(\"\\n\"):\n                    if len(line) &gt; max_cell_length:\n                        line = line[0:max_cell_length] + \" ...\"\n                    else:\n                        line = line\n                    lines.append(line)\n                cell_str = \"\\n\".join(lines)\n\n            row.append(cell_str)\n\n        yield row\n\n    if num_split_rows:\n        for i in range(0, num_split_rows):\n            row = []\n            for _ in self.column_names:\n                row.append(\"...\")\n            yield row\n\n    if rows_head:\n        if rows_tail is not None:\n            if rows_tail &lt; 0:\n                rows_tail = 0\n\n            tail = self.slice(self.num_rows - rows_tail)\n            table_dict = tail.to_pydict()\n            for i in range(0, num_rows):\n\n                row = []\n                for cn in self.column_names:\n\n                    cell = table_dict[cn][i]\n                    cell_str = str(cell)\n\n                    if max_row_height and max_row_height &gt; 0 and \"\\n\" in cell_str:\n                        lines = cell_str.split(\"\\n\")\n                        if len(lines) &gt; max_row_height:\n                            if max_row_height == 1:\n                                lines = lines[0:1]\n                            else:\n                                half = int(len(lines) / 2)\n                                lines = lines[0:half] + [\"..\"] + lines[-half:]\n                        cell_str = \"\\n\".join(lines)\n\n                    if max_cell_length and max_cell_length &gt; 0:\n                        lines = []\n                        for line in cell_str.split(\"\\n\"):\n\n                            if len(line) &gt; max_cell_length:\n                                line = line[0:(max_cell_length)] + \" ...\"\n                            else:\n                                line = line\n                            lines.append(line)\n                        cell_str = \"\\n\".join(lines)\n\n                    row.append(cell_str)\n\n                yield row\n\n    return\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap","title":"<code>ArrowTabularWrap</code>","text":"<p>         Bases: <code>TabularWrap</code></p> Source code in <code>kiara/utils/output.py</code> <pre><code>class ArrowTabularWrap(TabularWrap):\n    def __init__(self, table: \"ArrowTable\"):\n        self._table: \"ArrowTable\" = table\n        super().__init__()\n\n    def retrieve_column_names(self) -&gt; Iterable[str]:\n        return self._table.column_names\n\n    def retrieve_number_of_rows(self) -&gt; int:\n        return self._table.num_rows\n\n    def slice(self, offset: int = 0, length: Union[int, None] = None):\n        return self._table.slice(offset=offset, length=length)\n\n    def to_pydict(self) -&gt; Mapping:\n        return self._table.to_pydict()\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap.retrieve_column_names","title":"<code>retrieve_column_names() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def retrieve_column_names(self) -&gt; Iterable[str]:\n    return self._table.column_names\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap.retrieve_number_of_rows","title":"<code>retrieve_number_of_rows() -&gt; int</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def retrieve_number_of_rows(self) -&gt; int:\n    return self._table.num_rows\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap.slice","title":"<code>slice(offset: int = 0, length: Union[int, None] = None)</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def slice(self, offset: int = 0, length: Union[int, None] = None):\n    return self._table.slice(offset=offset, length=length)\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.ArrowTabularWrap.to_pydict","title":"<code>to_pydict() -&gt; Mapping</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def to_pydict(self) -&gt; Mapping:\n    return self._table.to_pydict()\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap","title":"<code>DictTabularWrap</code>","text":"<p>         Bases: <code>TabularWrap</code></p> Source code in <code>kiara/utils/output.py</code> <pre><code>class DictTabularWrap(TabularWrap):\n    def __init__(self, data: Mapping[str, List[Any]]):\n\n        self._data: Mapping[str, List[Any]] = data\n        # TODO: assert all rows are equal length\n        super().__init__()\n\n    def retrieve_number_of_rows(self) -&gt; int:\n        key = next(iter(self._data.keys()))\n        return len(self._data[key])\n\n    def retrieve_column_names(self) -&gt; Iterable[str]:\n        return self._data.keys()\n\n    def to_pydict(self) -&gt; Mapping[str, List[Any]]:\n        return self._data\n\n    def slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n\n        result = {}\n        start = None\n        end = None\n        for cn in self._data.keys():\n            if start is None:\n                if offset &gt; len(self._data):\n                    return DictTabularWrap({cn: [] for cn in self._data.keys()})\n                start = offset\n                if not length:\n                    end = len(self._data)\n                else:\n                    end = start + length\n                    if end &gt; len(self._data):\n                        end = len(self._data)\n            result[cn] = self._data[cn][start:end]\n        return DictTabularWrap(result)\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap.retrieve_number_of_rows","title":"<code>retrieve_number_of_rows() -&gt; int</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def retrieve_number_of_rows(self) -&gt; int:\n    key = next(iter(self._data.keys()))\n    return len(self._data[key])\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap.retrieve_column_names","title":"<code>retrieve_column_names() -&gt; Iterable[str]</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def retrieve_column_names(self) -&gt; Iterable[str]:\n    return self._data.keys()\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap.to_pydict","title":"<code>to_pydict() -&gt; Mapping[str, List[Any]]</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def to_pydict(self) -&gt; Mapping[str, List[Any]]:\n    return self._data\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.DictTabularWrap.slice","title":"<code>slice(offset: int = 0, length: Union[int, None] = None) -&gt; TabularWrap</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def slice(self, offset: int = 0, length: Union[int, None] = None) -&gt; \"TabularWrap\":\n\n    result = {}\n    start = None\n    end = None\n    for cn in self._data.keys():\n        if start is None:\n            if offset &gt; len(self._data):\n                return DictTabularWrap({cn: [] for cn in self._data.keys()})\n            start = offset\n            if not length:\n                end = len(self._data)\n            else:\n                end = start + length\n                if end &gt; len(self._data):\n                    end = len(self._data)\n        result[cn] = self._data[cn][start:end]\n    return DictTabularWrap(result)\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_table_from_base_model_cls","title":"<code>create_table_from_base_model_cls(model_cls: Type[BaseModel])</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_table_from_base_model_cls(model_cls: Type[BaseModel]):\n\n    table = RichTable(box=box.SIMPLE, show_lines=True)\n    table.add_column(\"Field\")\n    table.add_column(\"Type\")\n    table.add_column(\"Description\")\n    table.add_column(\"Required\")\n    table.add_column(\"Default\")\n\n    props = model_cls.schema().get(\"properties\", {})\n\n    for field_name, field in sorted(model_cls.__fields__.items()):\n        row = [field_name]\n        p = props.get(field_name, None)\n        p_type = None\n        desc = \"\"\n        if p is not None:\n            p_type = p.get(\"type\", None)\n            # TODO: check 'anyOf' keys\n            desc = p.get(\"description\", \"\")\n\n        if p_type is None:\n            p_type = \"-- check source --\"\n        row.append(p_type)\n\n        row.append(desc)\n        row.append(\"yes\" if field.required else \"no\")\n        default = field.default\n        if callable(default):\n            default = default()\n\n        if default is None:\n            default = \"\"\n        else:\n            try:\n                default = json.dumps(default, indent=2)\n            except Exception:\n                default = str(default)\n        row.append(default)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_dict_from_field_schemas","title":"<code>create_dict_from_field_schemas(fields: Mapping[str, ValueSchema], _add_default: bool = True, _add_required: bool = True, _show_header: bool = False, _constants: Union[Mapping[str, Any], None] = None, _doc_to_string: bool = True) -&gt; Mapping[str, List[Any]]</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_dict_from_field_schemas(\n    fields: Mapping[str, \"ValueSchema\"],\n    _add_default: bool = True,\n    _add_required: bool = True,\n    _show_header: bool = False,\n    _constants: Union[Mapping[str, Any], None] = None,\n    _doc_to_string: bool = True,\n) -&gt; Mapping[str, List[Any]]:\n\n    table: Dict[str, List[Any]] = {}\n    table[\"field_name\"] = []\n    table[\"data_type\"] = []\n    table[\"description\"] = []\n\n    if _add_required:\n        table[\"required\"] = []\n    if _add_default:\n        table[\"default\"] = []\n\n    for field_name, schema in fields.items():\n\n        table[\"field_name\"].append(field_name)\n        table[\"data_type\"].append(schema.type)\n        if _doc_to_string:\n            table[\"description\"].append(schema.doc.full_doc)\n        else:\n            table[\"description\"].append(schema.doc)\n\n        if _add_required:\n            req = schema.is_required()\n            table[\"required\"].append(req)\n\n        if _add_default:\n            if _constants and field_name in _constants.keys():\n                d = f\"{_constants[field_name]} (constant)\"\n            else:\n                if schema.default in [\n                    None,\n                    SpecialValue.NO_VALUE,\n                    SpecialValue.NOT_SET,\n                ]:\n                    d = \"-- no default --\"\n                else:\n                    d = str(schema.default)\n            table[\"default\"].append(d)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_table_from_field_schemas","title":"<code>create_table_from_field_schemas(fields: Mapping[str, ValueSchema], _add_default: bool = True, _add_required: bool = True, _show_header: bool = False, _constants: Union[Mapping[str, Any], None] = None) -&gt; RichTable</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_table_from_field_schemas(\n    fields: Mapping[str, \"ValueSchema\"],\n    _add_default: bool = True,\n    _add_required: bool = True,\n    _show_header: bool = False,\n    _constants: Union[Mapping[str, Any], None] = None,\n) -&gt; RichTable:\n\n    table = RichTable(box=box.SIMPLE, show_header=_show_header)\n    table.add_column(\"field name\", style=\"i\", overflow=\"fold\")\n    table.add_column(\"type\")\n    table.add_column(\"description\")\n\n    if _add_required:\n        table.add_column(\"Required\")\n    if _add_default:\n        if _constants:\n            table.add_column(\"Default / Constant\")\n        else:\n            table.add_column(\"Default\")\n    for field_name, schema in fields.items():\n\n        row: List[RenderableType] = [field_name, schema.type, schema.doc]\n\n        if _add_required:\n            req = schema.is_required()\n            if not req:\n                req_str = \"no\"\n            else:\n                if schema.default in [\n                    None,\n                    SpecialValue.NO_VALUE,\n                    SpecialValue.NOT_SET,\n                ]:\n                    req_str = \"[b]yes[b]\"\n                else:\n                    req_str = \"no\"\n            row.append(req_str)\n\n        if _add_default:\n            if _constants and field_name in _constants.keys():\n                d = f\"[b]{_constants[field_name]}[/b] (constant)\"\n            else:\n                if schema.default in [\n                    None,\n                    SpecialValue.NO_VALUE,\n                    SpecialValue.NOT_SET,\n                ]:\n                    d = \"-- no default --\"\n                else:\n                    d = str(schema.default)\n            row.append(d)\n\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_value_map_status_renderable","title":"<code>create_value_map_status_renderable(inputs: ValueMap, render_config: Union[Mapping[str, Any], None] = None, fields: Union[None, Iterable[str]] = None) -&gt; RichTable</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_value_map_status_renderable(\n    inputs: ValueMap,\n    render_config: Union[Mapping[str, Any], None] = None,\n    fields: Union[None, Iterable[str]] = None,\n) -&gt; RichTable:\n\n    if render_config is None:\n        render_config = {}\n\n    show_description: bool = render_config.get(\"show_description\", True)\n    show_type: bool = render_config.get(\"show_type\", True)\n    show_required: bool = render_config.get(\"show_required\", True)\n    show_default: bool = render_config.get(\"show_default\", True)\n    show_value_ids: bool = render_config.get(\"show_value_ids\", False)\n\n    table = RichTable(box=box.SIMPLE, show_header=True)\n    table.add_column(\"field name\", style=\"i\")\n    table.add_column(\"status\", style=\"b\")\n    if show_type:\n        table.add_column(\"type\")\n    if show_description:\n        table.add_column(\"description\")\n\n    if show_required:\n        table.add_column(\"required\")\n\n    if show_default:\n        table.add_column(\"default\")\n\n    if show_value_ids:\n        table.add_column(\"value id\", overflow=\"fold\")\n\n    invalid = inputs.check_invalid()\n\n    if fields:\n        field_order = fields\n    else:\n        field_order = sorted(inputs.keys())\n\n    for field_name in field_order:\n\n        value = inputs.get(field_name, None)\n        if value is None:\n            log.debug(\n                \"ignore.field\", field_name=field_name, available_fields=inputs.keys()\n            )\n            continue\n\n        row: List[RenderableType] = [field_name]\n\n        if field_name in invalid.keys():\n            row.append(f\"[red]{invalid[field_name]}[/red]\")\n        else:\n            row.append(\"[green]valid[/green]\")\n\n        value_schema = inputs.values_schema[field_name]\n\n        if show_type:\n            row.append(value_schema.type)\n\n        if show_description:\n            row.append(value_schema.doc.description)\n\n        if show_required:\n            req = value_schema.is_required()\n            if not req:\n                req_str = \"no\"\n            else:\n                if value_schema.default in [\n                    None,\n                    SpecialValue.NO_VALUE,\n                    SpecialValue.NOT_SET,\n                ]:\n                    req_str = \"[b]yes[b]\"\n                else:\n                    req_str = \"no\"\n            row.append(req_str)\n\n        if show_default:\n            default = value_schema.default\n            if callable(default):\n                default_val = default()\n            else:\n                default_val = default\n\n            if default_val in [None, SpecialValue.NOT_SET, SpecialValue.NO_VALUE]:\n                default_str = \"\"\n            else:\n                default_str = str(default_val)\n\n            row.append(default_str)\n\n        if show_value_ids:\n            row.append(str(inputs.get_value_obj(field_name=field_name).value_id))\n\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_table_from_model_object","title":"<code>create_table_from_model_object(model: BaseModel, render_config: Union[Mapping[str, Any], None] = None, exclude_fields: Union[Set[str], None] = None)</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_table_from_model_object(\n    model: BaseModel,\n    render_config: Union[Mapping[str, Any], None] = None,\n    exclude_fields: Union[Set[str], None] = None,\n):\n\n    model_cls = model.__class__\n\n    table = RichTable(box=box.SIMPLE, show_lines=True)\n    table.add_column(\"Field\")\n    table.add_column(\"Type\")\n    table.add_column(\"Value\")\n    table.add_column(\"Description\")\n\n    props = model_cls.schema().get(\"properties\", {})\n\n    for field_name, field in sorted(model_cls.__fields__.items()):\n        if exclude_fields and field_name in exclude_fields:\n            continue\n        row: List[RenderableType] = [field_name]\n\n        p = props.get(field_name, None)\n        p_type = None\n        desc = \"\"\n        if p is not None:\n            p_type = p.get(\"type\", None)\n            # TODO: check 'anyOf' keys\n            desc = p.get(\"description\", \"\")\n\n        if p_type is None:\n            p_type = \"-- check source --\"\n        row.append(p_type)\n\n        data = getattr(model, field_name)\n        row.append(extract_renderable(data, render_config=render_config))\n\n        row.append(desc)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.extract_renderable","title":"<code>extract_renderable(item: Any, render_config: Union[Mapping[str, Any], None] = None) -&gt; RenderableType</code>","text":"<p>Try to automatically find and extract or create an object that is renderable by the 'rich' library.</p> Source code in <code>kiara/utils/output.py</code> <pre><code>def extract_renderable(\n    item: Any, render_config: Union[Mapping[str, Any], None] = None\n) -&gt; RenderableType:\n\"\"\"Try to automatically find and extract or create an object that is renderable by the 'rich' library.\"\"\"\n\n    if render_config is None:\n        render_config = {}\n    else:\n        render_config = dict(render_config)\n\n    inline_models_as_json = render_config.setdefault(\"inline_models_as_json\", True)\n\n    if hasattr(item, \"create_renderable\"):\n        return item.create_renderable(**render_config)\n    elif isinstance(item, (ConsoleRenderable, RichCast, str)):\n        return item\n    elif isinstance(item, BaseModel) and not inline_models_as_json:\n        return create_table_from_model_object(item)\n    elif isinstance(item, BaseModel):\n        return item.json(indent=2)\n    elif isinstance(item, Mapping) and not inline_models_as_json:\n        table = RichTable(show_header=False, box=box.SIMPLE)\n        table.add_column(\"Key\", style=\"i\")\n        table.add_column(\"Value\")\n        for k, v in item.items():\n            table.add_row(k, extract_renderable(v, render_config=render_config))\n        return table\n    elif isinstance(item, Mapping):\n        result = {}\n        for k, v in item.items():\n            if isinstance(v, BaseModel):\n                v = v.dict()\n            result[k] = v\n        return orjson_dumps(\n            result, option=orjson.OPT_INDENT_2 | orjson.OPT_NON_STR_KEYS\n        )\n    elif isinstance(item, Iterable):\n        _all = []\n        for i in item:\n            _all.append(extract_renderable(i))\n        rg = Group(*_all)\n        return rg\n    elif isinstance(item, Enum):\n        return str(item.value)\n    elif isinstance(item, Exception):\n        msg = str(item)\n        details = KiaraException.get_root_details(item)\n        if details and details != msg:\n            return Group(msg, \"\", Markdown(details))\n        else:\n            return msg\n    else:\n        return str(item)\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_renderable_from_values","title":"<code>create_renderable_from_values(values: Mapping[str, Value], config: Union[Mapping[str, Any], None] = None) -&gt; RenderableType</code>","text":"<p>Create a renderable for this module configuration.</p> Source code in <code>kiara/utils/output.py</code> <pre><code>def create_renderable_from_values(\n    values: Mapping[str, \"Value\"], config: Union[Mapping[str, Any], None] = None\n) -&gt; RenderableType:\n\"\"\"Create a renderable for this module configuration.\"\"\"\n\n    if config is None:\n        config = {}\n\n    render_format = config.get(\"render_format\", \"terminal\")\n    if render_format not in [\"terminal\"]:\n        raise Exception(f\"Invalid render format: {render_format}\")\n\n    show_pedigree = config.get(\"show_pedigree\", False)\n    show_data = config.get(\"show_data\", False)\n    show_hash = config.get(\"show_hash\", True)\n    # show_load_config = config.get(\"show_load_config\", False)\n\n    table = RichTable(show_lines=True, box=box.MINIMAL_DOUBLE_HEAD)\n    table.add_column(\"value_id\", \"i\")\n    table.add_column(\"data_type\")\n    table.add_column(\"size\")\n    if show_hash:\n        table.add_column(\"hash\")\n    if show_pedigree:\n        table.add_column(\"pedigree\")\n    if show_data:\n        table.add_column(\"data\")\n\n    for id, value in sorted(values.items(), key=lambda item: item[1].value_schema.type):\n        row: List[RenderableType] = [id, value.value_schema.type, str(value.value_size)]\n        if show_hash:\n            row.append(str(value.value_hash))\n        if show_pedigree:\n            if value.pedigree == ORPHAN:\n                pedigree = \"-- n/a --\"\n            else:\n                pedigree = value.pedigree.json(option=orjson.OPT_INDENT_2)\n            row.append(pedigree)\n        if show_data:\n            data = value._data_registry.pretty_print_data(\n                value_id=value.value_id, target_type=\"terminal_renderable\", **config\n            )\n            row.append(data)\n        # if show_load_config:\n        #     load_config = value.retrieve_load_config()\n        #     if load_config is None:\n        #         load_config_str: RenderableType = \"-- not stored (yet) --\"\n        #     else:\n        #         load_config_str = load_config.create_renderable()\n        #     row.append(load_config_str)\n        table.add_row(*row)\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_pipeline_steps_tree","title":"<code>create_pipeline_steps_tree(pipeline_structure: PipelineStructure, pipeline_details: PipelineState) -&gt; Tree</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_pipeline_steps_tree(\n    pipeline_structure: \"PipelineStructure\", pipeline_details: \"PipelineState\"\n) -&gt; Tree:\n\n    from kiara.models.module.pipeline import StepStatus\n\n    steps = Tree(\"steps\")\n\n    for idx, stage in enumerate(pipeline_structure.processing_stages, start=1):\n        stage_node = steps.add(f\"stage: [i]{idx}[/i]\")\n        for step_id in sorted(stage):\n            step_node = stage_node.add(f\"step: [i]{step_id}[/i]\")\n            step_details = pipeline_details.step_states[step_id]\n            status = step_details.status\n            if status is StepStatus.INPUTS_READY:\n                step_node.add(\"status: [yellow]inputs ready[/yellow]\")\n            elif status is StepStatus.RESULTS_READY:\n                step_node.add(\"status: [green]results ready[/green]\")\n            else:\n                invalid_node = step_node.add(\"status: [red]inputs invalid[/red]\")\n                invalid = step_details.invalid_details\n                for k, v in invalid.items():\n                    invalid_node.add(f\"[i]{k}[/i]: {v}\")\n\n    return steps\n</code></pre>"},{"location":"reference/kiara/utils/output/#kiara.utils.output.create_recursive_table_from_model_object","title":"<code>create_recursive_table_from_model_object(model: BaseModel, render_config: Union[Mapping[str, Any], None] = None)</code>","text":"Source code in <code>kiara/utils/output.py</code> <pre><code>def create_recursive_table_from_model_object(\n    model: BaseModel,\n    render_config: Union[Mapping[str, Any], None] = None,\n):\n\n    if render_config is None:\n        render_config = {}\n\n    show_lines = render_config.get(\"show_lines\", True)\n    show_header = render_config.get(\"show_header\", True)\n    model_cls = model.__class__\n\n    table = RichTable(box=box.SIMPLE, show_lines=show_lines, show_header=show_header)\n    table.add_column(\"Field\")\n    table.add_column(\"Value\")\n\n    props = model_cls.schema().get(\"properties\", {})\n\n    for field_name in sorted(model_cls.__fields__.keys()):\n\n        data = getattr(model, field_name)\n        p = props.get(field_name, None)\n        p_type = None\n        desc = None\n        if p is not None:\n            p_type = p.get(\"type\", None)\n            # TODO: check 'anyOf' keys\n            desc = p.get(\"description\", None)\n\n        if p_type is not None:\n            p_type = f\"[i]{p_type}[/i]\"\n\n        if not isinstance(data, BaseModel):\n            data_renderable = extract_renderable(data, render_config=render_config)\n            sub_model = None\n        else:\n            sub_model = create_recursive_table_from_model_object(\n                data, render_config={\"show_lines\": True, \"show_header\": False}\n            )\n            data_renderable = None\n\n        group = []\n\n        if data_renderable:\n            group.append(data_renderable)\n            group.append(\"\")\n        if desc:\n            group.append(f\"[i]{desc}[/i]\")\n\n        if sub_model:\n            group.append(sub_model)\n\n        if p_type:\n            field_name = f\"[b i]{field_name}[/b i] ([i]{p_type}[/i])\"\n        else:\n            field_name = f\"[b i]{field_name}[/b i]\"\n        table.add_row(field_name, Group(*group))\n\n    return table\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/","title":"pipelines","text":""},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.logger","title":"<code>logger = structlog.get_logger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.create_step_value_address","title":"<code>create_step_value_address(value_address_config: Union[str, Mapping[str, Any]], default_field_name: str) -&gt; StepValueAddress</code>","text":"Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def create_step_value_address(\n    value_address_config: Union[str, Mapping[str, Any]],\n    default_field_name: str,\n) -&gt; \"StepValueAddress\":\n\n    if isinstance(value_address_config, StepValueAddress):\n        return value_address_config\n\n    sub_value: Union[Mapping[str, Any], None] = None\n\n    if isinstance(value_address_config, str):\n\n        tokens = value_address_config.split(\".\")\n        if len(tokens) == 1:\n            step_id = value_address_config\n            output_name = default_field_name\n        elif len(tokens) == 2:\n            step_id = tokens[0]\n            output_name = tokens[1]\n        elif len(tokens) == 3:\n            step_id = tokens[0]\n            output_name = tokens[1]\n            sub_value = {\"config\": tokens[2]}\n        else:\n            raise NotImplementedError()\n\n    elif isinstance(value_address_config, Mapping):\n\n        step_id = value_address_config[\"step_id\"]\n        output_name = value_address_config[\"value_name\"]\n        sub_value = value_address_config.get(\"sub_value\", None)\n    else:\n        raise TypeError(\n            f\"Invalid type for creating step value address: {type(value_address_config)}\"\n        )\n\n    if sub_value is not None and not isinstance(sub_value, Mapping):\n        raise ValueError(\n            f\"Invalid type '{type(sub_value)}' for sub_value (step_id: {step_id}, value name: {output_name}): {sub_value}\"\n        )\n\n    input_link = StepValueAddress(\n        step_id=step_id, value_name=output_name, sub_value=sub_value\n    )\n    return input_link\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.ensure_step_value_addresses","title":"<code>ensure_step_value_addresses(link: Union[str, Mapping, Iterable], default_field_name: str) -&gt; List[StepValueAddress]</code>","text":"Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def ensure_step_value_addresses(\n    link: Union[str, Mapping, Iterable], default_field_name: str\n) -&gt; List[\"StepValueAddress\"]:\n\n    if isinstance(link, (str, Mapping)):\n        input_links: List[StepValueAddress] = [\n            create_step_value_address(\n                value_address_config=link, default_field_name=default_field_name\n            )\n        ]\n\n    elif isinstance(link, Iterable):\n        input_links = []\n        for o in link:\n            il = create_step_value_address(\n                value_address_config=o, default_field_name=default_field_name\n            )\n            input_links.append(il)\n    else:\n        raise TypeError(f\"Can't parse input map, invalid type for output: {link}\")\n\n    return input_links\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.get_pipeline_details_from_path","title":"<code>get_pipeline_details_from_path(path: Union[str, Path], module_type_name: Union[str, None] = None, base_module: Union[str, None] = None) -&gt; Dict[str, Any]</code>","text":"<p>Load a pipeline description, save it's content, and determine it the pipeline base name.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>the path to the pipeline file</p> required <code>module_type_name</code> <code>Union[str, None]</code> <p>if specifies, overwrites any auto-detected or assigned pipeline name</p> <code>None</code> <code>base_module</code> <code>Union[str, None]</code> <p>overrides the base module the assembled pipeline module will be located in the python hierarchy</p> <code>None</code> Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def get_pipeline_details_from_path(\n    path: Union[str, Path],\n    module_type_name: Union[str, None] = None,\n    base_module: Union[str, None] = None,\n) -&gt; Dict[str, Any]:\n\"\"\"Load a pipeline description, save it's content, and determine it the pipeline base name.\n\n    Arguments:\n        path: the path to the pipeline file\n        module_type_name: if specifies, overwrites any auto-detected or assigned pipeline name\n        base_module: overrides the base module the assembled pipeline module will be located in the python hierarchy\n\n    \"\"\"\n\n    if isinstance(path, str):\n        path = Path(os.path.expanduser(path))\n\n    if not path.is_file():\n        raise Exception(\n            f\"Can't add pipeline description '{path.as_posix()}': not a file\"\n        )\n\n    data = get_data_from_file(path)\n\n    if not data:\n        raise Exception(\n            f\"Can't register pipeline file '{path.as_posix()}': no content.\"\n        )\n\n    if module_type_name:\n        data[MODULE_TYPE_NAME_KEY] = module_type_name\n\n    if not isinstance(data, Mapping):\n        raise Exception(\"Not a dictionary type.\")\n\n    result = {\"data\": data, \"source\": path.as_posix(), \"source_type\": \"file\"}\n    if base_module:\n        result[\"base_module\"] = base_module\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.check_doc_sidecar","title":"<code>check_doc_sidecar(path: Union[Path, str], data: Dict[str, Any]) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def check_doc_sidecar(path: Union[Path, str], data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\n    if isinstance(path, str):\n        path = Path(os.path.expanduser(path))\n\n    _doc = data[\"data\"].get(\"documentation\", None)\n    if _doc is None:\n        _doc_path = Path(path.as_posix() + \".md\")\n        if _doc_path.is_file():\n            doc = _doc_path.read_text()\n            if doc:\n                data[\"data\"][\"documentation\"] = doc\n\n    return data\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.get_pipeline_config","title":"<code>get_pipeline_config(pipeline: str, kiara: typing.Union[Kiara, None] = None) -&gt; PipelineConfig</code>","text":"<p>Extract a pipeline config from the item specified.</p> <p>The lookup of the 'pipeline' reference happens in this order (first match returns the result): - check whether there is an operation with that name that is a pipeline - check whether the provided string is a path to an existing file - check whether the provided string starts with 'workflow:' and matches a workflow alias (or id), in which case it returns the pipeline config for the workflows current state</p> <p>Parameters:</p> Name Type Description Default <code>pipeline</code> <code>str</code> <p>a reference to the desired pipeline</p> required <code>kiara</code> <code>typing.Union[Kiara, None]</code> <p>the kiara context</p> <code>None</code> <p>Returns:</p> Type Description <code>PipelineConfig</code> <p>a pipeline config object</p> Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def get_pipeline_config(\n    pipeline: str, kiara: typing.Union[\"Kiara\", None] = None\n) -&gt; \"PipelineConfig\":\n\"\"\"Extract a pipeline config from the item specified.\n\n    The lookup of the 'pipeline' reference happens in this order (first match returns the result):\n    - check whether there is an operation with that name that is a pipeline\n    - check whether the provided string is a path to an existing file\n    - check whether the provided string starts with 'workflow:' and matches a workflow alias (or id), in which case it returns the pipeline config for the workflows current state\n\n    Arguments:\n        pipeline: a reference to the desired pipeline\n        kiara: the kiara context\n\n    Returns:\n        a pipeline config object\n    \"\"\"\n\n    if kiara is None:\n        from kiara.context import Kiara\n\n        kiara = Kiara.instance()\n\n    pc: Union[\"PipelineConfig\", None] = None\n    error: Union[Exception, None] = None\n    try:\n        _operation = kiara.operation_registry.get_operation(pipeline)\n\n        pipeline_module: PipelineModule = _operation.module  # type: ignore\n        if pipeline_module.is_pipeline():\n            pc = pipeline_module.config\n    except NoSuchOperationException as nsoe:\n        error = nsoe\n    except InvalidOperationException as ioe:\n        error = ioe\n\n    if pc is None:\n        if os.path.isfile(pipeline):\n            from kiara.models.module.pipeline import PipelineConfig\n\n            pc = PipelineConfig.from_file(pipeline, kiara=kiara)\n\n    if pc is None and pipeline.startswith(\"workflow:\"):\n        try:\n            workflow = pipeline[9:]\n            if \"@\" in workflow:\n                raise NotImplementedError()\n\n            wfm = kiara.workflow_registry.get_workflow_metadata(workflow=workflow)\n            if wfm.current_state:\n                state = kiara.workflow_registry.get_workflow_state(\n                    workflow_state_id=wfm.current_state, workflow=wfm.workflow_id\n                )\n                pc = state.pipeline_config\n        except Exception as e:\n            log_exception(e)\n\n    if pc is None:\n        if error:\n            raise error\n        else:\n            raise Exception(f\"Could not resolve pipeline reference '{pipeline}'.\")\n\n    return pc\n</code></pre>"},{"location":"reference/kiara/utils/pipelines/#kiara.utils.pipelines.find_pipeline_data_in_paths","title":"<code>find_pipeline_data_in_paths(pipeline_paths: Dict[str, Union[Dict[str, Any], None]]) -&gt; Mapping[str, Mapping[str, Any]]</code>","text":"<p>Find pipeline data in the provided paths.</p> <p>The 'pipeline_paths' argument has a local path as key, and a mapping as value that contains optional metadata about the context for all the pipelines that are found under the path.</p> <p>Parameters:</p> Name Type Description Default <code>pipeline_paths</code> <code>Dict[str, Union[Dict[str, Any], None]]</code> <p>a mapping of pipeline names to paths</p> required Source code in <code>kiara/utils/pipelines.py</code> <pre><code>def find_pipeline_data_in_paths(\n    pipeline_paths: Dict[str, Union[Dict[str, Any], None]]\n) -&gt; Mapping[str, Mapping[str, Any]]:\n\"\"\"Find pipeline data in the provided paths.\n\n    The 'pipeline_paths' argument has a local path as key, and a mapping as value that contains optional metadata about the context for all the pipelines that are found under the path.\n\n    Arguments:\n        pipeline_paths: a mapping of pipeline names to paths\n    \"\"\"\n\n    all_pipelines = []\n\n    for _path in pipeline_paths.keys():\n        path = Path(_path)\n        if not path.exists():\n            logger.warning(\n                \"ignore.pipeline_path\", path=path, reason=\"path does not exist\"\n            )\n            continue\n\n        elif path.is_dir():\n\n            for root, dirnames, filenames in os.walk(path, topdown=True):\n\n                dirnames[:] = [d for d in dirnames if d not in DEFAULT_EXCLUDE_DIRS]\n\n                for filename in [\n                    f\n                    for f in filenames\n                    if os.path.isfile(os.path.join(root, f))\n                    and any(f.endswith(ext) for ext in VALID_PIPELINE_FILE_EXTENSIONS)\n                ]:\n\n                    full_path = os.path.join(root, filename)\n                    try:\n\n                        data = get_pipeline_details_from_path(path=full_path)\n                        data = check_doc_sidecar(full_path, data)\n                        existing_metadata = data.pop(\"metadata\", {})\n                        _md = pipeline_paths[_path]\n                        if _md is None:\n                            md = {}\n                        else:\n                            md = dict(_md)\n                        md.update(existing_metadata)\n                        data[\"metadata\"] = md\n\n                        all_pipelines.append(data)\n\n                    except Exception as e:\n                        log_exception(e)\n                        logger.warning(\n                            \"ignore.pipeline_file\", path=full_path, reason=str(e)\n                        )\n\n        elif path.is_file():\n            data = get_pipeline_details_from_path(path=path)\n            data = check_doc_sidecar(path, data)\n            existing_metadata = data.pop(\"metadata\", {})\n            _md = pipeline_paths[_path]\n            if _md is None:\n                md = {}\n            else:\n                md = dict(_md)\n            md.update(existing_metadata)\n            data[\"metadata\"] = md\n            all_pipelines.append(data)\n\n    pipelines = {}\n    for pipeline in all_pipelines:\n        name = pipeline[\"data\"].get(\"pipeline_name\", None)\n        if name is None:\n            source = pipeline[\"source\"]\n            name = os.path.basename(source)\n            if \".\" in name:\n                name, _ = name.rsplit(\".\", maxsplit=1)\n            pipeline[\"data\"][\"pipeline_name\"] = name\n        pipelines[name] = pipeline\n\n    return pipelines\n</code></pre>"},{"location":"reference/kiara/utils/string_vars/","title":"string_vars","text":""},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.log","title":"<code>log = structlog.getLogger()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.create_var_regex","title":"<code>create_var_regex(delimiter_start: Union[str, None] = None, delimiter_end: Union[str, None] = None) -&gt; Pattern</code>","text":"Source code in <code>kiara/utils/string_vars.py</code> <pre><code>def create_var_regex(\n    delimiter_start: Union[str, None] = None, delimiter_end: Union[str, None] = None\n) -&gt; Pattern:\n\n    if delimiter_start is None:\n        delimiter_start = \"\\\\$\\\\{\"\n\n    # TODO: make this smarter\n    if delimiter_end is None:\n        delimiter_end = \"\\\\}\"\n\n    regex = re.compile(delimiter_start + \"\\\\s*(.+?)\\\\s*\" + delimiter_end)\n    return regex\n</code></pre>"},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.find_var_names_in_obj","title":"<code>find_var_names_in_obj(template_obj: Any, delimiter: Union[Pattern, str, None] = None, delimiter_end: Union[str, None] = None) -&gt; Set[str]</code>","text":"Source code in <code>kiara/utils/string_vars.py</code> <pre><code>def find_var_names_in_obj(\n    template_obj: Any,\n    delimiter: Union[Pattern, str, None] = None,\n    delimiter_end: Union[str, None] = None,\n) -&gt; Set[str]:\n\n    if isinstance(delimiter, Pattern):\n        regex = delimiter\n    else:\n        regex = create_var_regex(delimiter_start=delimiter, delimiter_end=delimiter_end)\n\n    var_names = find_regex_matches_in_obj(template_obj, regex=regex)\n\n    return var_names\n</code></pre>"},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.replace_var_names_in_obj","title":"<code>replace_var_names_in_obj(template_obj: Any, repl_dict: typing.Mapping[str, Any], delimiter: Union[Pattern, str, None] = None, delimiter_end: Union[str, None] = None, ignore_missing_keys: bool = False) -&gt; Any</code>","text":"Source code in <code>kiara/utils/string_vars.py</code> <pre><code>def replace_var_names_in_obj(\n    template_obj: Any,\n    repl_dict: typing.Mapping[str, Any],\n    delimiter: Union[Pattern, str, None] = None,\n    delimiter_end: Union[str, None] = None,\n    ignore_missing_keys: bool = False,\n) -&gt; Any:\n\n    if isinstance(delimiter, Pattern):\n        regex = delimiter\n    else:\n        regex = create_var_regex(delimiter_start=delimiter, delimiter_end=delimiter_end)\n\n    if not template_obj:\n        return template_obj\n\n    if isinstance(template_obj, Mapping):\n        result: Any = {}\n        for k, v in template_obj.items():\n            key = replace_var_names_in_obj(\n                template_obj=k,\n                repl_dict=repl_dict,\n                delimiter=regex,\n                ignore_missing_keys=ignore_missing_keys,\n            )\n            value = replace_var_names_in_obj(\n                template_obj=v,\n                repl_dict=repl_dict,\n                delimiter=regex,\n                ignore_missing_keys=ignore_missing_keys,\n            )\n            result[key] = value\n    elif isinstance(template_obj, str):\n        result = replace_var_names_in_string(\n            template_obj,\n            repl_dict=repl_dict,\n            regex=regex,\n            ignore_missing_keys=ignore_missing_keys,\n        )\n    elif isinstance(template_obj, Sequence):\n        result = []\n        for item in template_obj:\n            r = replace_var_names_in_obj(\n                item,\n                repl_dict=repl_dict,\n                delimiter=regex,\n                ignore_missing_keys=ignore_missing_keys,\n            )\n            result.append(r)\n    else:\n        result = template_obj\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.replace_var_names_in_string","title":"<code>replace_var_names_in_string(template_string: str, repl_dict: typing.Mapping[str, Any], regex: Pattern, ignore_missing_keys: bool = False) -&gt; str</code>","text":"Source code in <code>kiara/utils/string_vars.py</code> <pre><code>def replace_var_names_in_string(\n    template_string: str,\n    repl_dict: typing.Mapping[str, Any],\n    regex: Pattern,\n    ignore_missing_keys: bool = False,\n) -&gt; str:\n    def sub(match):\n\n        key = match.groups()[0]\n\n        if key not in repl_dict.keys():\n            if not ignore_missing_keys:\n                raise Exception(\n                    f\"Can't insert variable '{key}'. Key not in provided input values, available keys: {', '.join(repl_dict.keys())}\"\n                )\n            else:\n                return match[0]\n        else:\n            result = repl_dict[key]\n            return result\n\n    result = regex.sub(sub, template_string)\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/string_vars/#kiara.utils.string_vars.find_regex_matches_in_obj","title":"<code>find_regex_matches_in_obj(source_obj: Any, regex: Pattern, current: Union[Set[str], None] = None) -&gt; Set[str]</code>","text":"Source code in <code>kiara/utils/string_vars.py</code> <pre><code>def find_regex_matches_in_obj(\n    source_obj: Any, regex: Pattern, current: Union[Set[str], None] = None\n) -&gt; Set[str]:\n\n    if current is None:\n        current = set()\n\n    if not source_obj:\n        return current\n\n    if isinstance(source_obj, Mapping):\n        for k, v in source_obj.items():\n            find_regex_matches_in_obj(k, regex=regex, current=current)\n            find_regex_matches_in_obj(v, regex=regex, current=current)\n    elif isinstance(source_obj, str):\n\n        matches = regex.findall(source_obj)\n        current.update(matches)\n\n    elif isinstance(source_obj, Sequence):\n\n        for item in source_obj:\n            find_regex_matches_in_obj(item, regex=regex, current=current)\n\n    return current\n</code></pre>"},{"location":"reference/kiara/utils/values/","title":"values","text":""},{"location":"reference/kiara/utils/values/#kiara.utils.values-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/values/#kiara.utils.values-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/values/#kiara.utils.values-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/values/#kiara.utils.values.construct_valuemap","title":"<code>construct_valuemap(kiara_api: KiaraAPI, values: Mapping[str, Union[uuid.UUID, None, str, ValueLink]]) -&gt; ValueMapReadOnly</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def construct_valuemap(\n    kiara_api: \"KiaraAPI\",\n    values: Mapping[str, Union[uuid.UUID, None, str, \"ValueLink\"]],\n) -&gt; \"ValueMapReadOnly\":\n\n    value_items = {}\n    schemas = {}\n    for field_name, value_id in values.items():\n        if value_id is None:\n            value_id = NONE_VALUE_ID\n\n        value = kiara_api.get_value(value=value_id)  # type: ignore\n        value_items[field_name] = value\n        schemas[field_name] = value.value_schema\n\n    from kiara.models.values.value import ValueMapReadOnly\n\n    return ValueMapReadOnly(value_items=value_items, values_schema=schemas)\n</code></pre>"},{"location":"reference/kiara/utils/values/#kiara.utils.values.create_schema_dict","title":"<code>create_schema_dict(schema_config: Mapping[str, Union[ValueSchema, Mapping[str, Any]]]) -&gt; Mapping[str, ValueSchema]</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def create_schema_dict(\n    schema_config: Mapping[str, Union[ValueSchema, Mapping[str, Any]]],\n) -&gt; Mapping[str, ValueSchema]:\n\n    invalid = check_valid_field_names(*schema_config.keys())\n    if invalid:\n        raise Exception(\n            f\"Can't assemble schema because it contains invalid input field name(s) '{', '.join(invalid)}'. Change the input schema to not contain any of the reserved keywords: {', '.join(INVALID_VALUE_NAMES)}\"\n        )\n\n    result = {}\n    for k, v in schema_config.items():\n\n        if isinstance(v, ValueSchema):\n            result[k] = v\n        elif isinstance(v, Mapping):\n            _v = dict(v)\n            if \"doc\" not in _v.keys():\n                _v[\"doc\"] = DEFAULT_NO_DESC_VALUE\n            schema = ValueSchema(**_v)\n\n            result[k] = schema\n        else:\n            if v is None:\n                msg = \"None\"\n            else:\n                msg = v.__class__\n            raise Exception(\n                f\"Invalid return type '{msg}' for field '{k}' when trying to create schema.\"\n            )\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/values/#kiara.utils.values.overlay_constants_and_defaults","title":"<code>overlay_constants_and_defaults(schemas: Mapping[str, ValueSchema], defaults: Mapping[str, Any], constants: Mapping[str, Any])</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def overlay_constants_and_defaults(\n    schemas: Mapping[str, ValueSchema],\n    defaults: Mapping[str, Any],\n    constants: Mapping[str, Any],\n):\n\n    for k, v in schemas.items():\n\n        default_value = defaults.get(k, None)\n        constant_value = constants.get(k, None)\n\n        # value_to_test = None\n        if default_value is not None and constant_value is not None:\n            raise Exception(\n                f\"Module configuration error. Value '{k}' set in both 'constants' and 'defaults', this is not allowed.\"\n            )\n\n        # TODO: perform validation for constants/defaults\n\n        if default_value is not None:\n            schemas[k].default = default_value\n\n        if constant_value is not None:\n            schemas[k].default = constant_value\n            schemas[k].is_constant = True\n\n    input_schemas = {}\n    constants = {}\n    for k, v in schemas.items():\n        if v.is_constant:\n            constants[k] = v\n        else:\n            input_schemas[k] = v\n\n    return input_schemas, constants\n</code></pre>"},{"location":"reference/kiara/utils/values/#kiara.utils.values.augment_values","title":"<code>augment_values(values: Mapping[str, Any], schemas: Mapping[str, ValueSchema], constants: Union[Mapping[str, ValueSchema], None] = None) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def augment_values(\n    values: Mapping[str, Any],\n    schemas: Mapping[str, ValueSchema],\n    constants: Union[Mapping[str, ValueSchema], None] = None,\n) -&gt; Dict[str, Any]:\n\n    # TODO: check if extra fields were provided\n\n    if constants:\n        for k, v in constants.items():\n            if k in values.keys():\n                raise Exception(f\"Invalid input: value provided for constant '{k}'\")\n\n    values_new = {}\n\n    if constants:\n        for field_name, schema in constants.items():\n            v = schema.default\n            assert v not in [None, SpecialValue.NO_VALUE, SpecialValue.NOT_SET]\n            if callable(v):\n                values_new[field_name] = v()\n            else:\n                values_new[field_name] = copy.deepcopy(v)\n\n    for field_name, schema in schemas.items():\n\n        if field_name in values_new.keys():\n            raise Exception(\n                f\"Duplicate field '{field_name}', this is most likely a bug.\"\n            )\n\n        val = values.get(field_name, None)\n        use_default = False\n        if val is None:\n            use_default = True\n        elif hasattr(val, \"is_set\"):\n            if not val.is_set:  # type: ignore\n                use_default = True\n        if use_default:\n            if schema.default != SpecialValue.NOT_SET:\n                if callable(schema.default):\n                    values_new[field_name] = schema.default()\n                else:\n                    values_new[field_name] = copy.deepcopy(schema.default)\n            else:\n                values_new[field_name] = SpecialValue.NOT_SET\n        else:\n            value = values[field_name]\n            assert value is not None\n\n            values_new[field_name] = value\n\n    return values_new\n</code></pre>"},{"location":"reference/kiara/utils/values/#kiara.utils.values.extract_raw_values","title":"<code>extract_raw_values(kiara: Kiara, **value_ids: uuid.UUID) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def extract_raw_values(kiara: \"Kiara\", **value_ids: uuid.UUID) -&gt; Dict[str, Any]:\n\n    result = {}\n    for field_name, value_id in value_ids.items():\n        result[field_name] = extract_raw_value(kiara=kiara, value_id=value_id)\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/values/#kiara.utils.values.extract_raw_value","title":"<code>extract_raw_value(kiara: Kiara, value_id: uuid.UUID)</code>","text":"Source code in <code>kiara/utils/values.py</code> <pre><code>def extract_raw_value(kiara: \"Kiara\", value_id: uuid.UUID):\n    value = kiara.data_registry.get_value(value=value_id)\n\n    # TODO: check without import\n    from kiara.models.values.value import ORPHAN\n\n    if value.pedigree != ORPHAN:\n        # TODO: find alias?\n        return f'\"value:{value_id}\"'\n    else:\n        if value.value_schema.type == \"string\":\n            return f'\"{value.data}\"'\n        elif value.value_schema.type == \"list\":\n            return value.data.list_data\n        else:\n            return value.data\n</code></pre>"},{"location":"reference/kiara/utils/windows/","title":"windows","text":""},{"location":"reference/kiara/utils/windows/#kiara.utils.windows-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/windows/#kiara.utils.windows.is_windows","title":"<code>is_windows = any(platform.win32_ver())</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/windows/#kiara.utils.windows-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/windows/#kiara.utils.windows.fix_windows_longpath","title":"<code>fix_windows_longpath(path: Path) -&gt; Path</code>","text":"Source code in <code>kiara/utils/windows.py</code> <pre><code>def fix_windows_longpath(path: Path) -&gt; Path:\n    if not is_windows:\n        return path\n\n    normalized = os.fspath(path.resolve())\n    if not normalized.startswith(\"\\\\\\\\?\\\\\"):\n        normalized = \"\\\\\\\\?\\\\\" + normalized\n    return Path(normalized)\n</code></pre>"},{"location":"reference/kiara/utils/windows/#kiara.utils.windows.fix_windows_symlink","title":"<code>fix_windows_symlink(source: Path, target: Path) -&gt; None</code>","text":"Source code in <code>kiara/utils/windows.py</code> <pre><code>def fix_windows_symlink(source: Path, target: Path) -&gt; None:\n\n    if not is_windows:\n        target.symlink_to(source)\n        return\n    else:\n        try:\n            target.symlink_to(source)\n        except OSError:\n            import traceback\n\n            raise Exception(\n                \"Operating system does not support symbolic links.\",\n                \"link\",\n                (source, target),\n                traceback.format_exc(),\n            )\n</code></pre>"},{"location":"reference/kiara/utils/windows/#kiara.utils.windows.check_symlink_works","title":"<code>check_symlink_works() -&gt; bool</code>  <code>cached</code>","text":"Source code in <code>kiara/utils/windows.py</code> <pre><code>@lru_cache\ndef check_symlink_works() -&gt; bool:\n\n    dirname = tempfile.mkdtemp()\n\n    source = Path(dirname) / \"source\"\n    target = Path(dirname) / \"target\"\n\n    source.touch()\n    try:\n        target.symlink_to(source)\n        return True\n    except OSError:\n        return False\n    finally:\n        shutil.rmtree(dirname, ignore_errors=True)\n</code></pre>"},{"location":"reference/kiara/utils/yaml/","title":"yaml","text":""},{"location":"reference/kiara/utils/yaml/#kiara.utils.yaml-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/yaml/#kiara.utils.yaml.StringYAML","title":"<code>StringYAML</code>","text":"<p>         Bases: <code>YAML</code></p> Source code in <code>kiara/utils/yaml.py</code> <pre><code>class StringYAML(YAML):\n    def dump(self, data, stream=None, **kw):\n        inefficient = False\n        if stream is None:\n            inefficient = True\n            stream = StringIO()\n        YAML.dump(self, data, stream, **kw)\n        if inefficient:\n            return stream.getvalue()\n</code></pre>"},{"location":"reference/kiara/utils/yaml/#kiara.utils.yaml.StringYAML-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/yaml/#kiara.utils.yaml.StringYAML.dump","title":"<code>dump(data, stream = None, **kw)</code>","text":"Source code in <code>kiara/utils/yaml.py</code> <pre><code>def dump(self, data, stream=None, **kw):\n    inefficient = False\n    if stream is None:\n        inefficient = True\n        stream = StringIO()\n    YAML.dump(self, data, stream, **kw)\n    if inefficient:\n        return stream.getvalue()\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/","title":"cli","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.F","title":"<code>F = TypeVar('F', bound=Callable[Ellipsis, Any])</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.FC","title":"<code>FC = TypeVar('FC', bound=Union[Callable[Ellipsis, Any], Command])</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat","title":"<code>OutputFormat</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>class OutputFormat(Enum):\n    @classmethod\n    def as_dict(cls):\n        return {i.name: i.value for i in cls}\n\n    @classmethod\n    def keys_as_list(cls):\n        return cls._member_names_\n\n    @classmethod\n    def values_as_list(cls):\n        return [i.value for i in cls]\n\n    TERMINAL = \"terminal\"\n    HTML = \"html\"\n    JSON = \"json\"\n    JSON_INCL_SCHEMA = \"json-incl-schema\"\n    JSON_SCHEMA = \"json-schema\"\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.TERMINAL","title":"<code>TERMINAL = 'terminal'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.HTML","title":"<code>HTML = 'html'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.JSON","title":"<code>JSON = 'json'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.JSON_INCL_SCHEMA","title":"<code>JSON_INCL_SCHEMA = 'json-incl-schema'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.JSON_SCHEMA","title":"<code>JSON_SCHEMA = 'json-schema'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.as_dict","title":"<code>as_dict()</code>  <code>classmethod</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>@classmethod\ndef as_dict(cls):\n    return {i.name: i.value for i in cls}\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.keys_as_list","title":"<code>keys_as_list()</code>  <code>classmethod</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>@classmethod\ndef keys_as_list(cls):\n    return cls._member_names_\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.OutputFormat.values_as_list","title":"<code>values_as_list()</code>  <code>classmethod</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>@classmethod\ndef values_as_list(cls):\n    return [i.value for i in cls]\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.terminal_print","title":"<code>terminal_print(msg: Union[Any, None] = None, in_panel: Union[str, None] = None, rich_config: Union[Mapping[str, Any], None] = None, empty_line_before: bool = False, **config: Any) -&gt; None</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def terminal_print(\n    msg: Union[Any, None] = None,\n    in_panel: Union[str, None] = None,\n    rich_config: Union[Mapping[str, Any], None] = None,\n    empty_line_before: bool = False,\n    **config: Any,\n) -&gt; None:\n\n    from kiara.utils.output import extract_renderable\n\n    if msg is None:\n        msg = \"\"\n    console = get_console()\n\n    msg = extract_renderable(msg, render_config=config)\n    # if hasattr(msg, \"create_renderable\"):\n    #     msg = msg.create_renderable(**config)  # type: ignore\n\n    if in_panel is not None:\n        msg = Panel(msg, title_align=\"left\", title=in_panel)\n\n    if empty_line_before:\n        console.print()\n    if rich_config:\n        console.print(msg, **rich_config)\n    else:\n        console.print(msg)\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.is_rich_renderable","title":"<code>is_rich_renderable(item: Any)</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def is_rich_renderable(item: Any):\n    return isinstance(item, (ConsoleRenderable, RichCast, str))\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.output_format_option","title":"<code>output_format_option(*param_decls: str) -&gt; Callable[[FC], FC]</code>","text":"<p>Attaches an option to the command.  All positional arguments are passed as parameter declarations to :class:<code>Option</code>; all keyword arguments are forwarded unchanged (except <code>cls</code>). This is equivalent to creating an :class:<code>Option</code> instance manually and attaching it to the :attr:<code>Command.params</code> list.</p> <p>:param cls: the option class to instantiate.  This defaults to             :class:<code>Option</code>.</p> Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def output_format_option(*param_decls: str) -&gt; Callable[[FC], FC]:\n\"\"\"Attaches an option to the command.  All positional arguments are\n    passed as parameter declarations to :class:`Option`; all keyword\n    arguments are forwarded unchanged (except ``cls``).\n    This is equivalent to creating an :class:`Option` instance manually\n    and attaching it to the :attr:`Command.params` list.\n\n    :param cls: the option class to instantiate.  This defaults to\n                :class:`Option`.\n    \"\"\"\n\n    if not param_decls:\n        param_decls = (\"--format\", \"-f\")\n\n    attrs = {\n        \"help\": \"The output format. Defaults to 'terminal'.\",\n        \"type\": click.Choice(OutputFormat.values_as_list()),\n    }\n\n    def decorator(f: FC) -&gt; FC:\n        # Issue 926, copy attrs, so pre-defined options can re-use the same cls=\n        option_attrs = attrs.copy()\n        OptionClass = option_attrs.pop(\"cls\", None) or Option\n        _param_memo(f, OptionClass(param_decls, **option_attrs))  # type: ignore\n        return f\n\n    return decorator\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.render_json_str","title":"<code>render_json_str(model: BaseModel)</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def render_json_str(model: \"BaseModel\"):\n\n    import orjson\n\n    try:\n        json_str = model.json(option=orjson.OPT_INDENT_2 | orjson.OPT_NON_STR_KEYS)\n    except TypeError:\n        json_str = model.json(indent=2)\n\n    return json_str\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.render_json_schema_str","title":"<code>render_json_schema_str(model: BaseModel)</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def render_json_schema_str(model: \"BaseModel\"):\n\n    import orjson\n\n    try:\n        json_str = model.schema_json(option=orjson.OPT_INDENT_2)\n    except TypeError:\n        json_str = model.schema_json(indent=2)\n\n    return json_str\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.terminal_print_model","title":"<code>terminal_print_model(*models: BaseModel, format: Union[None, OutputFormat, str] = None, empty_line_before: Union[bool, None] = None, in_panel: Union[str, None] = None, **render_config: Any)</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def terminal_print_model(\n    *models: \"BaseModel\",\n    format: Union[None, OutputFormat, str] = None,\n    empty_line_before: Union[bool, None] = None,\n    in_panel: Union[str, None] = None,\n    **render_config: Any,\n):\n\n    import orjson\n\n    from kiara.utils.json import orjson_dumps\n    from kiara.utils.output import extract_renderable\n\n    if format is None:\n        format = OutputFormat.TERMINAL\n\n    if isinstance(format, str):\n        format = OutputFormat(format)\n\n    if empty_line_before is None:\n        if format == OutputFormat.TERMINAL:\n            empty_line_before = True\n        else:\n            empty_line_before = False\n\n    if format == OutputFormat.TERMINAL:\n        if len(models) == 1:\n            terminal_print(\n                models[0],\n                in_panel=in_panel,\n                empty_line_before=empty_line_before,\n                **render_config,\n            )\n        else:\n            rg = []\n            if not models:\n                return\n            for model in models[0:-1]:\n                renderable = extract_renderable(model, render_config)\n                rg.append(renderable)\n                rg.append(Rule(style=\"b\"))\n            last = extract_renderable(models[-1], render_config)\n            rg.append(last)\n            group = Group(*rg)\n            terminal_print(group, in_panel=in_panel, **render_config)\n    elif format == OutputFormat.JSON:\n        if len(models) == 1:\n            json_str = render_json_str(models[0])\n            syntax = Syntax(json_str, \"json\", background_color=\"default\")\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n        else:\n            json_strs = []\n            for model in models:\n                json_str = render_json_str(model)\n                json_strs.append(json_str)\n\n            json_str_full = \"[\" + \",\\n\".join(json_strs) + \"]\"\n            syntax = Syntax(json_str_full, \"json\", background_color=\"default\")\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n\n    elif format == OutputFormat.JSON_SCHEMA:\n        if len(models) == 1:\n            syntax = Syntax(\n                models[0].schema_json(option=orjson.OPT_INDENT_2),\n                \"json\",\n                background_color=\"default\",\n            )\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n        else:\n            json_strs = []\n            for model in models:\n                json_strs.append(render_json_schema_str(model))\n            json_str_full = \"[\" + \",\\n\".join(json_strs) + \"]\"\n            syntax = Syntax(json_str_full, \"json\", background_color=\"default\")\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n    elif format == OutputFormat.JSON_INCL_SCHEMA:\n        if len(models) == 1:\n            data = models[0].dict()\n            schema = models[0].schema()\n            all = {\"data\": data, \"schema\": schema}\n            json_str = orjson_dumps(all, option=orjson.OPT_INDENT_2)\n            syntax = Syntax(json_str, \"json\", background_color=\"default\")\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n        else:\n            all_data = []\n            for model in models:\n                data = model.dict()\n                schema = model.schema()\n                all_data.append({\"data\": data, \"schema\": schema})\n            json_str = orjson_dumps(all_data, option=orjson.OPT_INDENT_2)\n            # print(json_str)\n            syntax = Syntax(json_str, \"json\", background_color=\"default\")\n            terminal_print(\n                syntax,\n                empty_line_before=empty_line_before,\n                rich_config={\"soft_wrap\": True},\n            )\n\n    elif format == OutputFormat.HTML:\n\n        all_html = \"\"\n        for model in models:\n            if hasattr(model, \"create_html\"):\n                html = model.create_html()  # type: ignore\n                all_html = f\"{all_html}\\n{html}\"\n            else:\n                raise NotImplementedError()\n\n        syntax = Syntax(all_html, \"html\", background_color=\"default\")\n        terminal_print(\n            syntax, empty_line_before=empty_line_before, rich_config={\"soft_wrap\": True}\n        )\n</code></pre>"},{"location":"reference/kiara/utils/cli/__init__/#kiara.utils.cli.dict_from_cli_args","title":"<code>dict_from_cli_args(*args: str, list_keys: Union[Iterable[str], None] = None) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/cli/__init__.py</code> <pre><code>def dict_from_cli_args(\n    *args: str, list_keys: Union[Iterable[str], None] = None\n) -&gt; Dict[str, Any]:\n\n    if not args:\n        return {}\n\n    config: Dict[str, Any] = {}\n    for arg in args:\n        if \"=\" in arg:\n            key, value = arg.split(\"=\", maxsplit=1)\n            try:\n                _v = json.loads(value)\n            except Exception:\n                _v = value\n            part_config = {key: _v}\n        elif os.path.isfile(os.path.realpath(os.path.expanduser(arg))):\n            path = os.path.realpath(os.path.expanduser(arg))\n            from kiara.utils.files import get_data_from_file\n\n            part_config = get_data_from_file(path)\n            assert isinstance(part_config, Mapping)\n        else:\n            try:\n                part_config = json.loads(arg)\n                assert isinstance(part_config, Mapping)\n            except Exception:\n                raise Exception(f\"Could not parse argument into data: {arg}\")\n\n        if list_keys is None:\n            list_keys = []\n\n        for k, v in part_config.items():\n            if k in list_keys:\n                config.setdefault(k, []).append(v)\n            else:\n                if k in config.keys():\n                    logger.warning(\"duplicate.key\", old_value=k, new_value=v)\n                config[k] = v\n\n    return config\n</code></pre>"},{"location":"reference/kiara/utils/cli/exceptions/","title":"exceptions","text":""},{"location":"reference/kiara/utils/cli/exceptions/#kiara.utils.cli.exceptions-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/cli/exceptions/#kiara.utils.cli.exceptions.handle_exception","title":"<code>handle_exception(func = None)</code>","text":"Source code in <code>kiara/utils/cli/exceptions.py</code> <pre><code>def handle_exception(\n    func=None,\n):\n\n    if not func:\n        return partial(handle_exception)\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n\n            if is_debug() or is_develop():\n                import traceback\n\n                traceback.print_exc()\n            terminal_print(\"\")\n            terminal_print(e)\n\n    return wrapper\n</code></pre>"},{"location":"reference/kiara/utils/cli/rich_click/","title":"rich_click","text":""},{"location":"reference/kiara/utils/cli/rich_click/#kiara.utils.cli.rich_click-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/cli/rich_click/#kiara.utils.cli.rich_click-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/cli/rich_click/#kiara.utils.cli.rich_click.rich_format_filter_operation_help","title":"<code>rich_format_filter_operation_help(api: KiaraAPI, obj: Union[click.Command, click.Group], ctx: click.Context, cmd_help: str, value: Union[None, str] = None) -&gt; None</code>","text":"<p>Print nicely formatted help text using rich.</p> Source code in <code>kiara/utils/cli/rich_click.py</code> <pre><code>def rich_format_filter_operation_help(\n    api: KiaraAPI,\n    obj: Union[click.Command, click.Group],\n    ctx: click.Context,\n    cmd_help: str,\n    value: Union[None, str] = None,\n) -&gt; None:\n\"\"\"Print nicely formatted help text using rich.\"\"\"\n\n    renderables: List[RenderableType] = []\n    # Header text if we have it\n    if HEADER_TEXT:\n        renderables.append(\n            Padding(_make_rich_rext(HEADER_TEXT, STYLE_HEADER_TEXT), (1, 1, 0, 1))\n        )\n\n    # Print usage\n\n    _cmd = cmd_help\n    renderables.append(Padding(_cmd, 1))\n    d = inspect.getdoc(obj)\n    if d is None:\n        d = \"\"\n    d = textwrap.dedent(d)\n    renderables.append(\n        Padding(\n            Align(d, width=MAX_WIDTH, pad=False),  # type: ignore\n            (0, 1, 1, 1),\n        )\n    )\n\n    v = None\n    if value:\n        filter_op_type: FilterOperationType = api.get_operation_type(\"filter\")  # type: ignore\n        v = api.get_value(value)\n        ops = filter_op_type.find_filter_operations_for_data_type(v.data_type_name)\n        ops_info = OperationGroupInfo.create_from_operations(\n            kiara=api.context, group_title=f\"{v.data_type_name} filters\", **ops\n        )\n        p = Panel(\n            ops_info,\n            title=f\"Available filter operations for type [i]'{v.data_type_name}'[/i]\",\n            title_align=\"left\",\n        )\n        renderables.append(p)\n\n    # Epilogue if we have it\n    if obj.epilog:\n        # Remove single linebreaks, replace double with single\n        lines = obj.epilog.split(\"\\n\\n\")\n        epilogue = \"\\n\".join([x.replace(\"\\n\", \" \").strip() for x in lines])\n        renderables.append(\n            Padding(Align(highlighter(epilogue), width=MAX_WIDTH, pad=False), 1)\n        )\n\n    # Footer text if we have it\n    if FOOTER_TEXT:\n        renderables.append(\n            Padding(_make_rich_rext(FOOTER_TEXT, STYLE_FOOTER_TEXT), (1, 1, 0, 1))\n        )\n\n    terminal_print(Group(*renderables))\n</code></pre>"},{"location":"reference/kiara/utils/cli/rich_click/#kiara.utils.cli.rich_click.rich_format_operation_help","title":"<code>rich_format_operation_help(obj: Union[click.Command, click.Group], ctx: click.Context, operation: Operation, op_inputs: ValueMap, cmd_help: str) -&gt; None</code>","text":"<p>Print nicely formatted help text using rich.</p> <p>Based on original code from rich-cli, by @willmcgugan. https://github.com/Textualize/rich-cli/blob/8a2767c7a340715fc6fbf4930ace717b9b2fc5e5/src/rich_cli/main.py#L162-L236</p> <p>Replacement for the click function format_help(). Takes a command or group and builds the help text output.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>click.Command or click.Group</code> <p>Command or group to build help text for</p> required <code>ctx</code> <code>click.Context</code> <p>Click Context object</p> required <code>table</code> <p>a rich table, including all the inputs of the current operation</p> required Source code in <code>kiara/utils/cli/rich_click.py</code> <pre><code>def rich_format_operation_help(\n    obj: Union[click.Command, click.Group],\n    ctx: click.Context,\n    operation: Operation,\n    op_inputs: ValueMap,\n    cmd_help: str,\n) -&gt; None:\n\"\"\"Print nicely formatted help text using rich.\n\n    Based on original code from rich-cli, by @willmcgugan.\n    https://github.com/Textualize/rich-cli/blob/8a2767c7a340715fc6fbf4930ace717b9b2fc5e5/src/rich_cli/__main__.py#L162-L236\n\n    Replacement for the click function format_help().\n    Takes a command or group and builds the help text output.\n\n    Args:\n        obj (click.Command or click.Group): Command or group to build help text for\n        ctx (click.Context): Click Context object\n        table: a rich table, including all the inputs of the current operation\n    \"\"\"\n\n    renderables: List[RenderableType] = []\n    # Header text if we have it\n    if HEADER_TEXT:\n        renderables.append(\n            Padding(_make_rich_rext(HEADER_TEXT, STYLE_HEADER_TEXT), (1, 1, 0, 1))\n        )\n\n    # Print usage\n\n    _cmd = cmd_help\n    renderables.append(Padding(_cmd, 1))\n    # renderables.append(obj.get_usage(ctx))\n    # renderables.append(Panel(Padding(highlighter(obj.get_usage(ctx)), 1), style=STYLE_USAGE_COMMAND, box=box.MINIMAL))\n\n    # Print command / group help if we have some\n    desc = operation.doc.full_doc\n    renderables.append(\n        Padding(\n            Align(Markdown(desc), width=MAX_WIDTH, pad=False),\n            (0, 1, 1, 1),\n        )\n    )\n\n    # if obj.help:\n    #\n    #     # Print with a max width and some padding\n    #     renderables.append(\n    #         Padding(\n    #             Align(_get_help_text(obj), width=MAX_WIDTH, pad=False),\n    #             (0, 1, 1, 1),\n    #         )\n    #     )\n\n    # Look through OPTION_GROUPS for this command\n    # stick anything unmatched into a default group at the end\n    option_groups = OPTION_GROUPS.get(ctx.command_path, []).copy()\n    option_groups.append({\"options\": []})\n    argument_group_options = []\n\n    for param in obj.get_params(ctx):\n\n        # Skip positional arguments - they don't have opts or helptext and are covered in usage\n        # See https://click.palletsprojects.com/en/8.0.x/documentation/#documenting-arguments\n        if type(param) is click.core.Argument and not SHOW_ARGUMENTS:\n            continue\n\n        # Skip if option is hidden\n        if getattr(param, \"hidden\", False):\n            continue\n\n        # Already mentioned in a config option group\n        for option_group in option_groups:\n            if any([opt in option_group.get(\"options\", []) for opt in param.opts]):\n                break\n\n        # No break, no mention - add to the default group\n        else:\n            if type(param) is click.core.Argument and not GROUP_ARGUMENTS_OPTIONS:\n                argument_group_options.append(param.opts[0])\n            else:\n                list_of_option_groups: List = option_groups[-1][\"options\"]  # type: ignore\n                list_of_option_groups.append(param.opts[0])\n\n    # If we're not grouping arguments and we got some, prepend before default options\n    if len(argument_group_options) &gt; 0:\n        extra_option_group = {\n            \"name\": ARGUMENTS_PANEL_TITLE,\n            \"options\": argument_group_options,\n        }\n        option_groups.insert(len(option_groups) - 1, extra_option_group)  # type: ignore\n\n    # Print each option group panel\n    for option_group in option_groups:\n\n        options_rows = []\n        for opt in option_group.get(\"options\", []):\n\n            # Get the param\n            for param in obj.get_params(ctx):\n                if any([opt in param.opts]):\n                    break\n            # Skip if option is not listed in this group\n            else:\n                continue\n\n            # Short and long form\n            opt_long_strs = []\n            opt_short_strs = []\n            for idx, opt in enumerate(param.opts):\n                opt_str = opt\n                try:\n                    opt_str += \"/\" + param.secondary_opts[idx]\n                except IndexError:\n                    pass\n                if \"--\" in opt:\n                    opt_long_strs.append(opt_str)\n                else:\n                    opt_short_strs.append(opt_str)\n\n            # Column for a metavar, if we have one\n            metavar = Text(style=STYLE_METAVAR, overflow=\"fold\")\n            metavar_str = param.make_metavar()\n\n            # Do it ourselves if this is a positional argument\n            if type(param) is click.core.Argument and metavar_str == param.name.upper():  # type: ignore\n                metavar_str = param.type.name.upper()\n\n            # Skip booleans and choices (handled above)\n            if metavar_str != \"BOOLEAN\":\n                metavar.append(metavar_str)\n\n            # Range - from\n            # https://github.com/pallets/click/blob/c63c70dabd3f86ca68678b4f00951f78f52d0270/src/click/core.py#L2698-L2706\n            try:\n                # skip count with default range type\n                if isinstance(param.type, click.types._NumberRangeBase) and not (\n                    param.count and param.type.min == 0 and param.type.max is None  # type: ignore\n                ):\n                    range_str = param.type._describe_range()\n                    if range_str:\n                        metavar.append(RANGE_STRING.format(range_str))\n            except AttributeError:\n                # click.types._NumberRangeBase is only in Click 8x onwards\n                pass\n\n            # Required asterisk\n            required: RenderableType = \"\"\n            if param.required:\n                required = Text(REQUIRED_SHORT_STRING, style=STYLE_REQUIRED_SHORT)\n\n            # Highlighter to make [ | ] and &lt;&gt; dim\n            class MetavarHighlighter(RegexHighlighter):\n                highlights = [\n                    r\"^(?P&lt;metavar_sep&gt;(\\[|&lt;))\",\n                    r\"(?P&lt;metavar_sep&gt;\\|)\",\n                    r\"(?P&lt;metavar_sep&gt;(\\]|&gt;)$)\",\n                ]\n\n            metavar_highlighter = MetavarHighlighter()\n\n            rows = [\n                required,\n                highlighter(highlighter(\",\".join(opt_long_strs))),\n                highlighter(highlighter(\",\".join(opt_short_strs))),\n                metavar_highlighter(metavar),\n                _get_parameter_help(param, ctx),  # type: ignore\n            ]\n\n            # Remove metavar if specified in config\n            if not SHOW_METAVARS_COLUMN:\n                rows.pop(3)\n\n            options_rows.append(rows)\n\n        if len(options_rows) &gt; 0:\n            t_styles = {\n                \"show_lines\": STYLE_OPTIONS_TABLE_SHOW_LINES,\n                \"leading\": STYLE_OPTIONS_TABLE_LEADING,\n                \"box\": STYLE_OPTIONS_TABLE_BOX,\n                \"border_style\": STYLE_OPTIONS_TABLE_BORDER_STYLE,\n                \"row_styles\": STYLE_OPTIONS_TABLE_ROW_STYLES,\n                \"pad_edge\": STYLE_OPTIONS_TABLE_PAD_EDGE,\n                \"padding\": STYLE_OPTIONS_TABLE_PADDING,\n            }\n            t_styles.update(option_group.get(\"table_styles\", {}))  # type: ignore\n            box_style = getattr(box, t_styles.pop(\"box\"), None)  # type: ignore\n\n            options_table = Table(\n                highlight=True,\n                show_header=False,\n                expand=True,\n                box=box_style,\n                **t_styles,  # type: ignore\n            )\n            # Strip the required column if none are required\n            if all([x[0] == \"\" for x in options_rows]):\n                options_rows = [x[1:] for x in options_rows]\n            for row in options_rows:\n                options_table.add_row(*row)\n            renderables.append(\n                Panel(\n                    options_table,\n                    border_style=STYLE_OPTIONS_PANEL_BORDER,  # type: ignore\n                    title=option_group.get(\"name\", OPTIONS_PANEL_TITLE),  # type: ignore\n                    title_align=ALIGN_OPTIONS_PANEL,  # type: ignore\n                    width=MAX_WIDTH,  # type: ignore\n                )\n            )\n\n    #\n    # Groups only:\n    # List click command groups\n    #\n    if hasattr(obj, \"list_commands\"):\n        # Look through COMMAND_GROUPS for this command\n        # stick anything unmatched into a default group at the end\n        cmd_groups = COMMAND_GROUPS.get(ctx.command_path, []).copy()\n        cmd_groups.append({\"commands\": []})\n        for command in obj.list_commands(ctx):  # type: ignore\n            for cmd_group in cmd_groups:\n                if command in cmd_group.get(\"commands\", []):\n                    break\n            else:\n                commands: List = cmd_groups[-1][\"commands\"]  # type: ignore\n                commands.append(command)\n\n        # Print each command group panel\n        for cmd_group in cmd_groups:\n            t_styles = {\n                \"show_lines\": STYLE_COMMANDS_TABLE_SHOW_LINES,\n                \"leading\": STYLE_COMMANDS_TABLE_LEADING,\n                \"box\": STYLE_COMMANDS_TABLE_BOX,\n                \"border_style\": STYLE_COMMANDS_TABLE_BORDER_STYLE,\n                \"row_styles\": STYLE_COMMANDS_TABLE_ROW_STYLES,\n                \"pad_edge\": STYLE_COMMANDS_TABLE_PAD_EDGE,\n                \"padding\": STYLE_COMMANDS_TABLE_PADDING,\n            }\n            t_styles.update(cmd_group.get(\"table_styles\", {}))  # type: ignore\n            box_style = getattr(box, t_styles.pop(\"box\"), None)  # type: ignore\n\n            commands_table = Table(\n                highlight=False,\n                show_header=False,\n                expand=True,\n                box=box_style,  # type: ignore\n                **t_styles,  # type: ignore\n            )\n            # Define formatting in first column, as commands don't match highlighter regex\n            commands_table.add_column(style=\"bold cyan\", no_wrap=True)\n            for command in cmd_group.get(\"commands\", []):\n                # Skip if command does not exist\n                if command not in obj.list_commands(ctx):  # type: ignore\n                    continue\n                cmd = obj.get_command(ctx, command)  # type: ignore\n                assert cmd is not None\n                if cmd.hidden:\n                    continue\n                # Use the truncated short text as with vanilla text if requested\n                if USE_CLICK_SHORT_HELP:\n                    helptext = cmd.get_short_help_str()\n                else:\n                    # Use short_help function argument if used, or the full help\n                    helptext = cmd.short_help or cmd.help or \"\"\n                commands_table.add_row(command, _make_command_help(helptext))\n            if commands_table.row_count &gt; 0:\n                renderables.append(\n                    Panel(\n                        commands_table,\n                        border_style=STYLE_COMMANDS_PANEL_BORDER,  # type: ignore\n                        title=cmd_group.get(\"name\", COMMANDS_PANEL_TITLE),  # type: ignore\n                        title_align=ALIGN_COMMANDS_PANEL,  # type: ignore\n                        width=MAX_WIDTH,  # type: ignore\n                    )\n                )\n\n    inputs_table = create_operation_status_renderable(\n        operation=operation,\n        inputs=op_inputs,\n        render_config={\n            \"show_operation_name\": False,\n            \"show_inputs\": True,\n            \"show_outputs_schema\": False,\n            \"show_headers\": False,\n            \"show_operation_doc\": False,\n        },\n    )\n    # inputs_table = operation.create_renderable(\n    #     show_operation_name=False,\n    #     show_operation_doc=False,\n    #     show_inputs=True,\n    #     show_outputs_schema=False,\n    #     show_headers=False,\n    # )\n\n    inputs_panel = Panel(\n        inputs_table,\n        title=\"Inputs\",\n        border_style=STYLE_COMMANDS_PANEL_BORDER,  # type: ignore\n        title_align=ALIGN_COMMANDS_PANEL,  # type: ignore\n        width=MAX_WIDTH,  # type: ignore\n    )\n    renderables.append(inputs_panel)\n\n    # Epilogue if we have it\n    if obj.epilog:\n        # Remove single linebreaks, replace double with single\n        lines = obj.epilog.split(\"\\n\\n\")\n        epilogue = \"\\n\".join([x.replace(\"\\n\", \" \").strip() for x in lines])\n        renderables.append(\n            Padding(Align(highlighter(epilogue), width=MAX_WIDTH, pad=False), 1)\n        )\n\n    # Footer text if we have it\n    if FOOTER_TEXT:\n        renderables.append(\n            Padding(_make_rich_rext(FOOTER_TEXT, STYLE_FOOTER_TEXT), (1, 1, 0, 1))\n        )\n\n    group = Group(*renderables)\n    terminal_print(group)\n</code></pre>"},{"location":"reference/kiara/utils/cli/run/","title":"run","text":""},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run.validate_operation_in_terminal","title":"<code>validate_operation_in_terminal(api: KiaraAPI, module_or_operation: Union[str, Path, Mapping[str, Any]], allow_external = False) -&gt; Operation</code>","text":"Source code in <code>kiara/utils/cli/run.py</code> <pre><code>def validate_operation_in_terminal(\n    api: KiaraAPI,\n    module_or_operation: Union[str, Path, Mapping[str, Any]],\n    allow_external=False,\n) -&gt; Operation:\n\n    # kiara_op = KiaraOperation(\n    #     kiara=kiara,\n    #     operation_name=module_or_operation,\n    #     operation_config=module_config,\n    # )\n    try:\n        operation = api.get_operation(operation=module_or_operation)\n        # validate that operation config is valid, ignoring inputs for now\n        # kiara_op.operation\n    except NoSuchExecutionTargetException as nset:\n        terminal_print()\n        terminal_print(nset)\n        terminal_print()\n        terminal_print(\"Existing operations:\")\n        terminal_print()\n        for n in nset.avaliable_targets:\n            terminal_print(f\"  - [i]{n}[/i]\")\n        sys.exit(1)\n    except ValidationError as ve:\n\n        renderables: List[RenderableType] = [\"\"]\n        renderables.append(\"Invalid module configuration:\")\n        renderables.append(\"\")\n        for error in ve.errors():\n            loc = \", \".join(error[\"loc\"])  # type: ignore\n            renderables.append(f\"  [b]{loc}[/b]: [red]{error['msg']}[/red]\")\n\n        try:\n            if isinstance(module_or_operation, str):\n                m = api.context.module_registry.get_module_class(module_or_operation)\n                schema = create_table_from_base_model_cls(m._config_cls)\n                renderables.append(\"\")\n                renderables.append(f\"Module configuration schema for '[b i]{m._module_type_name}[/b i]':\")  # type: ignore\n                renderables.append(\"\")\n                renderables.append(schema)\n        except Exception:\n            pass\n\n        msg = Group(*renderables)\n        terminal_print()\n        terminal_print(msg, in_panel=\"[b red]Module configuration error[/b red]\")\n        sys.exit(1)\n    except Exception as e:\n        log_exception(e)\n        terminal_print()\n        terminal_print(\n            f\"Error when trying to validate the operation [i]'{module_or_operation}'[/i]:\\n\"\n        )\n        terminal_print(f\"    [red]{e}[/red]\")\n        root_cause = KiaraException.get_root_details(e)\n        if root_cause:\n            terminal_print()\n            terminal_print(Markdown(root_cause))\n        sys.exit(1)\n\n    return operation\n</code></pre>"},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run.calculate_aliases","title":"<code>calculate_aliases(operation: Operation, alias_tokens: Iterable[str]) -&gt; Mapping[str, List[str]]</code>","text":"Source code in <code>kiara/utils/cli/run.py</code> <pre><code>def calculate_aliases(\n    operation: Operation, alias_tokens: Iterable[str]\n) -&gt; Mapping[str, List[str]]:\n\n    if not alias_tokens:\n        aliases: Dict[str, List[str]] = {}\n        full_aliases: List[str] = []\n    else:\n        aliases = {}\n        full_aliases = []\n        for a in alias_tokens:\n            if \"=\" not in a:\n                full_aliases.append(a)\n            else:\n                tokens = a.split(\"=\")\n                if len(tokens) != 2:\n                    terminal_print()\n                    terminal_print(\n                        f\"Invalid alias format, can only contain a single '=': {a}\"\n                    )\n                    sys.exit(1)\n\n                aliases.setdefault(tokens[0], []).append(tokens[1])\n\n    # =========================================================================\n    # check save user input\n    final_aliases = {}\n    if alias_tokens:\n        op_output_names = operation.outputs_schema.keys()\n        invalid_fields = []\n        for field_name, alias in aliases.items():\n            if field_name not in op_output_names:\n                invalid_fields.append(field_name)\n            else:\n                final_aliases[field_name] = alias\n\n        for _alias in full_aliases:\n            for field_name in op_output_names:\n                final_aliases.setdefault(field_name, []).append(\n                    f\"{_alias}.{field_name}\"\n                )\n\n        if invalid_fields:\n            terminal_print()\n            terminal_print(\n                f\"Can't run workflow, invalid field name(s) when specifying aliases: {', '.join(invalid_fields)}. Valid field names: {', '.join(op_output_names)}\"\n            )\n            sys.exit(1)\n\n    return final_aliases\n</code></pre>"},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run.set_and_validate_inputs","title":"<code>set_and_validate_inputs(api: KiaraAPI, operation: Operation, inputs: Iterable[str], explain: bool, print_help: bool, click_context: ClickContext, cmd_help: str) -&gt; ValueMap</code>","text":"Source code in <code>kiara/utils/cli/run.py</code> <pre><code>def set_and_validate_inputs(\n    api: KiaraAPI,\n    operation: Operation,\n    inputs: Iterable[str],\n    explain: bool,\n    print_help: bool,\n    click_context: ClickContext,\n    cmd_help: str,\n) -&gt; ValueMap:\n\n    # =========================================================================\n    # prepare inputs\n    list_keys = []\n    for (\n        name,\n        value_schema,\n    ) in operation.operation_details.inputs_schema.items():\n        if value_schema.type in [\"list\"]:\n            list_keys.append(name)\n\n    try:\n        inputs_dict = dict_from_cli_args(*inputs, list_keys=list_keys)\n\n        value_map = api.assemble_value_map(\n            values=inputs_dict,\n            values_schema=operation.inputs_schema,\n            register_data=True,\n            reuse_existing_data=False,\n        )\n    except Exception as e:\n        terminal_print()\n        rg = Group(\n            \"\",\n            f\"Can't run operation: {e}\",\n            \"\",\n            Rule(),\n            \"\",\n            create_operation_status_renderable(\n                operation=operation,\n                inputs=None,\n                render_config={\n                    \"show_operation_name\": True,\n                    \"show_inputs\": False,\n                    \"show_outputs_schema\": True,\n                },\n            ),\n        )\n        terminal_print(rg, in_panel=f\"Run info: [b]{operation.operation_id}[/b]\")\n        sys.exit(1)\n\n    if value_map.check_invalid():\n        terminal_print()\n        rg = Group(\n            \"\",\n            \"Can't run operation: invalid or insufficient input(s)\",\n            \"\",\n            Rule(),\n            \"\",\n            create_operation_status_renderable(\n                operation=operation,\n                inputs=value_map,\n                render_config={\n                    \"show_operation_name\": True,\n                    \"show_inputs\": True,\n                    \"show_outputs_schema\": True,\n                },\n            ),\n        )\n        terminal_print(rg, in_panel=f\"Run info: [b]{operation.operation_id}[/b]\")\n        sys.exit(1)\n\n    if print_help:\n        rich_format_operation_help(\n            obj=click_context.command,\n            ctx=click_context,\n            operation=operation,\n            op_inputs=value_map,\n            cmd_help=cmd_help,\n        )\n        sys.exit(0)\n\n    if explain:\n        terminal_print()\n        rg = Group(\n            \"\",\n            create_operation_status_renderable(\n                operation=operation,\n                inputs=value_map,\n                render_config={\n                    \"show_operation_name\": True,\n                    \"show_inputs\": True,\n                    \"show_outputs_schema\": True,\n                },\n            ),\n        )\n        terminal_print(rg, in_panel=f\"Operation info: [b]{operation.operation_id}[/b]\")\n        sys.exit(0)\n\n    # try:\n    #     operation_inputs = kiara_op.operation_inputs\n    # except InvalidValuesException as ive:\n    #\n    #     terminal_print()\n    #     rg = Group(\n    #         \"\",\n    #         f\"Can't run operation: {ive}\",\n    #         \"\",\n    #         Rule(),\n    #         \"\",\n    #         kiara_op.create_renderable(\n    #             show_operation_name=True, show_inputs=True, show_outputs_schema=True\n    #         ),\n    #     )\n    #     terminal_print(rg, in_panel=f\"Run info: [b]{kiara_op.operation_name}[/b]\")\n    #     sys.exit(1)\n\n    if value_map.check_invalid():\n        terminal_print()\n        rg = Group(\n            \"\",\n            \"Can't run operation: invalid or insufficient input(s)\",\n            \"\",\n            Rule(),\n            \"\",\n            create_operation_status_renderable(\n                operation=operation,\n                inputs=value_map,\n                render_config={\n                    \"show_operation_name\": True,\n                    \"show_inputs\": True,\n                    \"show_outputs_schema\": True,\n                },\n            ),\n        )\n        terminal_print(rg, in_panel=f\"Run info: [b]{operation.operation_id}[/b]\")\n        sys.exit(1)\n\n    if print_help:\n        rich_format_operation_help(\n            obj=click_context.command,\n            ctx=click_context,\n            operation=operation,\n            op_inputs=value_map,\n            cmd_help=cmd_help,\n        )\n        sys.exit(0)\n\n    return value_map\n</code></pre>"},{"location":"reference/kiara/utils/cli/run/#kiara.utils.cli.run.execute_job","title":"<code>execute_job(api: KiaraAPI, operation: Operation, inputs: ValueMap, silent: bool, save_results: bool, aliases: Union[None, Mapping[str, List[str]]]) -&gt; uuid.UUID</code>","text":"<p>Execute the job</p> Source code in <code>kiara/utils/cli/run.py</code> <pre><code>def execute_job(\n    api: KiaraAPI,\n    operation: Operation,\n    inputs: ValueMap,\n    silent: bool,\n    save_results: bool,\n    aliases: Union[None, Mapping[str, List[str]]],\n) -&gt; uuid.UUID:\n\"\"\"Execute the job\"\"\"\n\n    job_id = api.queue_job(operation=operation, inputs=inputs)\n\n    try:\n        outputs = api.get_job_result(job_id=job_id)\n    except FailedJobException as fje:\n        terminal_print()\n        error: Union[str, None] = KiaraException.get_root_details(fje)\n        if not error:\n            error = str(fje)\n        _error = Markdown(error)\n        terminal_print(_error, in_panel=\"Processing error\")\n\n        sys.exit(1)\n    except Exception as e:\n        terminal_print()\n        terminal_print(e)\n        sys.exit(1)\n\n    if not silent:\n        if len(outputs) &gt; 1:\n            title = \"[b]Results[/b]\"\n        else:\n            title = \"[b]Result[/b]\"\n\n        # for field_name, value in outputs.items():\n        #     results.append(\"\")\n        #     results.append(f\"* [b i]{field_name}[/b i]\")\n        #     results.append(kiara_obj.data_registry.render_data(value.value_id))\n\n        terminal_print(\n            outputs, in_panel=title, empty_line_before=True, show_data_type=True\n        )\n\n    # for k, v in outputs.items():\n    #     rendered = kiara_obj.data_registry.render_data(v)\n    #     rich_print(rendered)\n\n    if save_results:\n        try:\n\n            alias_map = create_save_config(\n                field_names=outputs.field_names, aliases=aliases\n            )\n\n            saved_results = api.store_values(outputs, alias_map=alias_map)\n\n            api.context.job_registry.store_job_record(job_id=job_id)\n\n            if len(saved_results) == 1:\n                title = \"[b]Stored result value[/b]\"\n            else:\n                title = \"[b]Stored result values[/b]\"\n            terminal_print(saved_results, in_panel=title, empty_line_before=True)\n        except Exception as e:\n            log_exception(e)\n            terminal_print(f\"[red]Error saving results[/red]: {e}\")\n            sys.exit(1)\n\n    return job_id\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/","title":"develop","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KIARA_DEV_SETTINGS","title":"<code>KIARA_DEV_SETTINGS = KiaraDevSettings()</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.DetailLevel","title":"<code>DetailLevel</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class DetailLevel(Enum):\n\n    NONE = \"none\"\n    MINIMAL = \"minimal\"\n    FULL = \"full\"\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.DetailLevel-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.DetailLevel.NONE","title":"<code>NONE = 'none'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.DetailLevel.MINIMAL","title":"<code>MINIMAL = 'minimal'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.DetailLevel.FULL","title":"<code>FULL = 'full'</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails","title":"<code>PreRunMsgDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class PreRunMsgDetails(BaseModel):\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n        use_enum_values = True\n\n    pipeline_steps: bool = Field(\n        description=\"Whether to also display information for modules that are run as part of a pipeline.\",\n        default=False,\n    )\n    module_info: DetailLevel = Field(\n        description=\"Whether to display details about the module to be run.\",\n        default=DetailLevel.MINIMAL,\n    )\n    internal_modules: bool = Field(\n        description=\"Whether to also print details about runs of internal modules.\",\n        default=False,\n    )\n    inputs_info: DetailLevel = Field(\n        description=\"Whether to display details about the run inputs.\",\n        default=DetailLevel.MINIMAL,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.pipeline_steps","title":"<code>pipeline_steps: bool = Field(description='Whether to also display information for modules that are run as part of a pipeline.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.module_info","title":"<code>module_info: DetailLevel = Field(description='Whether to display details about the module to be run.', default=DetailLevel.MINIMAL)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.internal_modules","title":"<code>internal_modules: bool = Field(description='Whether to also print details about runs of internal modules.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.inputs_info","title":"<code>inputs_info: DetailLevel = Field(description='Whether to display details about the run inputs.', default=DetailLevel.MINIMAL)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PreRunMsgDetails.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails","title":"<code>PostRunMsgDetails</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class PostRunMsgDetails(BaseModel):\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n        use_enum_values = True\n\n    pipeline_steps: bool = Field(\n        description=\"Whether to also display information for modules that are run as part of a pipeline\",\n        default=False,\n    )\n    module_info: DetailLevel = Field(\n        description=\"Whether to display details about the module that was run.\",\n        default=DetailLevel.NONE,\n    )\n    internal_modules: bool = Field(\n        description=\"Whether to also print details about runs of internal module.\",\n        default=False,\n    )\n    inputs_info: DetailLevel = Field(\n        description=\"Whether to display details about the run inputs.\",\n        default=DetailLevel.NONE,\n    )\n    outputs_info: DetailLevel = Field(\n        description=\"Whether to display details about the run outputs.\",\n        default=DetailLevel.MINIMAL,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.pipeline_steps","title":"<code>pipeline_steps: bool = Field(description='Whether to also display information for modules that are run as part of a pipeline', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.module_info","title":"<code>module_info: DetailLevel = Field(description='Whether to display details about the module that was run.', default=DetailLevel.NONE)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.internal_modules","title":"<code>internal_modules: bool = Field(description='Whether to also print details about runs of internal module.', default=False)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.inputs_info","title":"<code>inputs_info: DetailLevel = Field(description='Whether to display details about the run inputs.', default=DetailLevel.NONE)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.outputs_info","title":"<code>outputs_info: DetailLevel = Field(description='Whether to display details about the run outputs.', default=DetailLevel.MINIMAL)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.PostRunMsgDetails.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings","title":"<code>KiaraDevLogSettings</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class KiaraDevLogSettings(BaseModel):\n\n    PROFILES: ClassVar[Dict[str, Any]] = {\n        \"full\": {\n            \"log_pre_run\": True,\n            \"pre_run\": {\n                \"pipeline_steps\": True,\n                \"module_info\": \"full\",\n                \"inputs_info\": \"full\",\n            },\n            \"log_post_run\": True,\n            \"post_run\": {\n                \"pipeline_steps\": True,\n                \"module_info\": \"minimal\",\n                \"inputs_info\": \"minimal\",\n                \"outputs_info\": \"full\",\n            },\n        },\n        \"internal\": {\n            \"pre_run\": {\"internal_modules\": True},\n            \"post_run\": {\"internal_modules\": True},\n        },\n    }\n\n    class Config:\n        extra = Extra.forbid\n        validate_assignment = True\n        use_enum_values = True\n\n    exc: DetailLevel = Field(\n        description=\"How detailed to print exceptions\", default=DetailLevel.MINIMAL\n    )\n    log_pre_run: bool = Field(\n        description=\"Print details about a module and its inputs before running it.\",\n        default=True,\n    )\n    pre_run: PreRunMsgDetails = Field(\n        description=\"Fine-grained settings about what to display in the pre-run message.\",\n        default_factory=PreRunMsgDetails,\n    )\n    log_post_run: bool = Field(\n        description=\"Print details about the results of a module run.\", default=True\n    )\n    post_run: PostRunMsgDetails = Field(\n        description=\"Fine-grained settings aobut what to display in the post-run message.\",\n        default_factory=PostRunMsgDetails,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.PROFILES","title":"<code>PROFILES: ClassVar[Dict[str, Any]] = {'full': {'log_pre_run': True, 'pre_run': {'pipeline_steps': True, 'module_info': 'full', 'inputs_info': 'full'}, 'log_post_run': True, 'post_run': {'pipeline_steps': True, 'module_info': 'minimal', 'inputs_info': 'minimal', 'outputs_info': 'full'}}, 'internal': {'pre_run': {'internal_modules': True}, 'post_run': {'internal_modules': True}}}</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.exc","title":"<code>exc: DetailLevel = Field(description='How detailed to print exceptions', default=DetailLevel.MINIMAL)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.log_pre_run","title":"<code>log_pre_run: bool = Field(description='Print details about a module and its inputs before running it.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.pre_run","title":"<code>pre_run: PreRunMsgDetails = Field(description='Fine-grained settings about what to display in the pre-run message.', default_factory=PreRunMsgDetails)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.log_post_run","title":"<code>log_post_run: bool = Field(description='Print details about the results of a module run.', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.post_run","title":"<code>post_run: PostRunMsgDetails = Field(description='Fine-grained settings aobut what to display in the post-run message.', default_factory=PostRunMsgDetails)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n    validate_assignment = True\n    use_enum_values = True\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevLogSettings.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings","title":"<code>KiaraDevSettings</code>","text":"<p>         Bases: <code>BaseSettings</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class KiaraDevSettings(BaseSettings):\n    class Config:\n\n        extra = Extra.forbid\n        validate_assignment = True\n        env_prefix = \"dev_\"\n        use_enum_values = True\n        env_nested_delimiter = \"__\"\n\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings,\n            env_settings,\n            file_secret_settings,\n        ):\n            return (\n                init_settings,\n                profile_settings_source,\n                dev_config_file_settings_source,\n                env_settings,\n            )\n\n    log: KiaraDevLogSettings = Field(\n        description=\"Settings about what messages to print in 'develop' mode, and what details to include.\",\n        default_factory=KiaraDevLogSettings,\n    )\n    job_cache: bool = Field(\n        description=\"Whether to always disable the job cache (ignores the runtime_job_cache setting in the kiara configuration).\",\n        default=True,\n    )\n\n    def create_renderable(self, **render_config: Any):\n        from kiara.utils.output import create_recursive_table_from_model_object\n\n        return create_recursive_table_from_model_object(\n            self, render_config=render_config\n        )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.log","title":"<code>log: KiaraDevLogSettings = Field(description=\"Settings about what messages to print in 'develop' mode, and what details to include.\", default_factory=KiaraDevLogSettings)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.job_cache","title":"<code>job_cache: bool = Field(description='Whether to always disable the job cache (ignores the runtime_job_cache setting in the kiara configuration).', default=True)</code>  <code>class-attribute</code>","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.Config","title":"<code>Config</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>class Config:\n\n    extra = Extra.forbid\n    validate_assignment = True\n    env_prefix = \"dev_\"\n    use_enum_values = True\n    env_nested_delimiter = \"__\"\n\n    @classmethod\n    def customise_sources(\n        cls,\n        init_settings,\n        env_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            profile_settings_source,\n            dev_config_file_settings_source,\n            env_settings,\n        )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.Config-attributes","title":"Attributes","text":"<code>extra = Extra.forbid</code> <code>class-attribute</code> \u00b6 <code>validate_assignment = True</code> <code>class-attribute</code> \u00b6 <code>env_prefix = 'dev_'</code> <code>class-attribute</code> \u00b6 <code>use_enum_values = True</code> <code>class-attribute</code> \u00b6 <code>env_nested_delimiter = '__'</code> <code>class-attribute</code> \u00b6"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.Config-functions","title":"Functions","text":"<code>customise_sources(init_settings, env_settings, file_secret_settings)</code> <code>classmethod</code> \u00b6 Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>@classmethod\ndef customise_sources(\n    cls,\n    init_settings,\n    env_settings,\n    file_secret_settings,\n):\n    return (\n        init_settings,\n        profile_settings_source,\n        dev_config_file_settings_source,\n        env_settings,\n    )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.KiaraDevSettings.create_renderable","title":"<code>create_renderable(**render_config: Any)</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>def create_renderable(self, **render_config: Any):\n    from kiara.utils.output import create_recursive_table_from_model_object\n\n    return create_recursive_table_from_model_object(\n        self, render_config=render_config\n    )\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.log_dev_message","title":"<code>log_dev_message(msg: RenderableType, title: Union[str, None] = None)</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>def log_dev_message(msg: RenderableType, title: Union[str, None] = None):\n\n    if not is_develop():\n        return\n\n    if not title:\n        title = \"Develop-mode message\"\n    panel = Panel(Group(\"\", msg), title=f\"[yellow]{title}[/yellow]\", title_align=\"left\")\n\n    from kiara.utils.cli import terminal_print\n\n    terminal_print(panel)\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.dev_config_file_settings_source","title":"<code>dev_config_file_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]</code>","text":"<p>A simple settings source that loads variables from a JSON file at the project's root.</p> <p>Here we happen to choose to use the <code>env_file_encoding</code> from Config when reading <code>config.json</code></p> Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>def dev_config_file_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]:\n\"\"\"\n    A simple settings source that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n\n    if os.path.exists(KIARA_DEV_CONFIG_FILE):\n        dev_config = get_data_from_file(KIARA_DEV_CONFIG_FILE)\n    else:\n        dev_config = {}\n    return dev_config\n</code></pre>"},{"location":"reference/kiara/utils/develop/__init__/#kiara.utils.develop.profile_settings_source","title":"<code>profile_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]</code>","text":"Source code in <code>kiara/utils/develop/__init__.py</code> <pre><code>def profile_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]:\n\n    profile_name = os.environ.get(\"DEVELOP\", None)\n    if not profile_name:\n        profile_name = os.environ.get(\"develop\", None)\n    if not profile_name:\n        profile_name = os.environ.get(\"DEV\", None)\n    if not profile_name:\n        profile_name = os.environ.get(\"dev\", None)\n    if not profile_name:\n        profile_name = os.environ.get(\"DEV_PROFILE\", None)\n    if not profile_name:\n        profile_name = os.environ.get(\"dev_profile\", None)\n\n    result: Dict[str, Any] = {}\n    if not profile_name:\n        return result\n\n    profile_name = profile_name.lower()\n\n    from pydantic.fields import ModelField\n\n    model: ModelField\n\n    for model in KiaraDevSettings.__fields__.values():\n        if not issubclass(model.type_, BaseModel):\n            continue\n\n        profiles = getattr(model.type_, \"PROFILES\", None)\n        if not profiles:\n            continue\n\n        p = profiles.get(profile_name, None)\n        if not p:\n            continue\n        result[model.name] = p\n\n    return result\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/","title":"hashfs","text":"<p>HashFS is a content-addressable file management system. What does that mean? Simply, that HashFS manages a directory where files are saved based on the file's hash.</p> <p>Typical use cases for this kind of system are ones where:</p> <ul> <li>Files are written once and never change (e.g. image storage).</li> <li>It's desirable to have no duplicate files (e.g. user uploads).</li> <li>File metadata is stored elsewhere (e.g. in a database).</li> </ul> <p>Adapted from: https://github.com/dgilland/hashfs</p>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs--license","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2015, Derrick Gilland</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs-classes","title":"Classes","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS","title":"<code>HashFS</code>","text":"<p>         Bases: <code>object</code></p> <p>Content addressable file manager.</p> <p>Attributes:</p> Name Type Description <code>root</code> <code>str</code> <p>Directory path used as root of storage space.</p> <code>depth</code> <code>int</code> <p>Depth of subfolders when saving a file.</p> <code>width</code> <code>int</code> <p>Width of each subfolder to create when saving a file.</p> <code>algorithm</code> <code>str</code> <p>Hash algorithm to use when computing file hash. Algorithm should be available in <code>hashlib</code> module. Defaults to <code>'sha256'</code>.</p> <code>fmode</code> <code>int</code> <p>File mode permission to set when adding files to directory. Defaults to <code>0o664</code> which allows owner/group to read/write and everyone else to read.</p> <code>dmode</code> <code>int</code> <p>Directory mode permission to set for subdirectories. Defaults to <code>0o755</code> which allows owner/group to read/write and everyone else to read and everyone to execute.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>class HashFS(object):\n\"\"\"Content addressable file manager.\n\n    Attributes:\n        root (str): Directory path used as root of storage space.\n        depth (int, optional): Depth of subfolders when saving a\n            file.\n        width (int, optional): Width of each subfolder to create when saving a\n            file.\n        algorithm (str): Hash algorithm to use when computing file hash.\n            Algorithm should be available in ``hashlib`` module. Defaults to\n            ``'sha256'``.\n        fmode (int, optional): File mode permission to set when adding files to\n            directory. Defaults to ``0o664`` which allows owner/group to\n            read/write and everyone else to read.\n        dmode (int, optional): Directory mode permission to set for\n            subdirectories. Defaults to ``0o755`` which allows owner/group to\n            read/write and everyone else to read and everyone to execute.\n    \"\"\"\n\n    def __init__(\n        self,\n        root: str,\n        depth: int = 4,\n        width: int = 1,\n        algorithm: str = \"sha256\",\n        fmode=0o664,\n        dmode=0o755,\n    ):\n        self.root: str = os.path.realpath(root)\n        self.depth: int = depth\n        self.width: int = width\n        self.algorithm: str = algorithm\n        self.fmode = fmode\n        self.dmode = dmode\n\n    def put(self, file: BinaryIO) -&gt; \"HashAddress\":\n\"\"\"Store contents of `file` on disk using its content hash for the\n        address.\n\n        Args:\n            file (mixed): Readable object or path to file.\n\n        Returns:\n            HashAddress: File's hash address.\n        \"\"\"\n        stream = Stream(file)\n\n        with closing(stream):\n            id = self.computehash(stream)\n            filepath, is_duplicate = self._copy(stream, id)\n\n        return HashAddress(id, self.relpath(filepath), filepath, is_duplicate)\n\n    def put_with_precomputed_hash(\n        self, file: Union[str, Path, BinaryIO], hash_id: str\n    ) -&gt; \"HashAddress\":\n\n        stream = Stream(file)\n        with closing(stream):\n            filepath, is_duplicate = self._copy(stream=stream, id=hash_id)\n\n        return HashAddress(hash_id, self.relpath(filepath), filepath, is_duplicate)\n\n    def _copy(self, stream: \"Stream\", id: str):\n\"\"\"Copy the contents of `stream` onto disk with an optional file\n        extension appended. The copy process uses a temporary file to store the\n        initial contents and then moves that file to it's final location.\n        \"\"\"\n\n        filepath = self.idpath(id)\n\n        if not os.path.isfile(filepath):\n            # Only move file if it doesn't already exist.\n            is_duplicate = False\n            fname = self._mktempfile(stream)\n            self.makepath(os.path.dirname(filepath))\n            shutil.move(fname, filepath)\n        else:\n            is_duplicate = True\n\n        return (filepath, is_duplicate)\n\n    def _mktempfile(self, stream):\n\"\"\"Create a named temporary file from a :class:`Stream` object and\n        return its filename.\n        \"\"\"\n        tmp = NamedTemporaryFile(delete=False)\n\n        if self.fmode is not None:\n            oldmask = os.umask(0)\n\n            try:\n                os.chmod(tmp.name, self.fmode)\n            finally:\n                os.umask(oldmask)\n\n        for data in stream:\n            tmp.write(to_bytes(data))\n\n        tmp.close()\n\n        return tmp.name\n\n    def get(self, file):\n\"\"\"Return :class:`HashAdress` from given id or path. If `file` does not\n        refer to a valid file, then ``None`` is returned.\n\n        Args:\n            file (str): Address ID or path of file.\n\n        Returns:\n            HashAddress: File's hash address.\n        \"\"\"\n        realpath = self.realpath(file)\n\n        if realpath is None:\n            return None\n        else:\n            return HashAddress(self.unshard(realpath), self.relpath(realpath), realpath)\n\n    def open(self, file, mode=\"rb\"):\n\"\"\"Return open buffer object from given id or path.\n\n        Args:\n            file (str): Address ID or path of file.\n            mode (str, optional): Mode to open file in. Defaults to ``'rb'``.\n\n        Returns:\n            Buffer: An ``io`` buffer dependent on the `mode`.\n\n        Raises:\n            IOError: If file doesn't exist.\n        \"\"\"\n        realpath = self.realpath(file)\n        if realpath is None:\n            raise IOError(\"Could not locate file: {0}\".format(file))\n\n        return io.open(realpath, mode)\n\n    def delete(self, file):\n\"\"\"Delete file using id or path. Remove any empty directories after\n        deleting. No exception is raised if file doesn't exist.\n\n        Args:\n            file (str): Address ID or path of file.\n        \"\"\"\n        realpath = self.realpath(file)\n        if realpath is None:\n            return\n\n        try:\n            os.remove(realpath)\n        except OSError:  # pragma: no cover\n            pass\n        else:\n            self.remove_empty(os.path.dirname(realpath))\n\n    def remove_empty(self, subpath):\n\"\"\"Successively remove all empty folders starting with `subpath` and\n        proceeding \"up\" through directory tree until reaching the :attr:`root`\n        folder.\n        \"\"\"\n        # Don't attempt to remove any folders if subpath is not a\n        # subdirectory of the root directory.\n        if not self.haspath(subpath):\n            return\n\n        while subpath != self.root:\n            if len(os.listdir(subpath)) &gt; 0 or os.path.islink(subpath):\n                break\n            os.rmdir(subpath)\n            subpath = os.path.dirname(subpath)\n\n    def files(self):\n\"\"\"Return generator that yields all files in the :attr:`root`\n        directory.\n        \"\"\"\n        for folder, subfolders, files in walk(self.root):\n            for file in files:\n                yield os.path.abspath(os.path.join(folder, file))\n\n    def folders(self):\n\"\"\"Return generator that yields all folders in the :attr:`root`\n        directory that contain files.\n        \"\"\"\n        for folder, subfolders, files in walk(self.root):\n            if files:\n                yield folder\n\n    def count(self):\n\"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\"\n        count = 0\n        for _ in self:\n            count += 1\n        return count\n\n    def size(self):\n\"\"\"Return the total size in bytes of all files in the :attr:`root`\n        directory.\n        \"\"\"\n        total = 0\n\n        for path in self.files():\n            total += os.path.getsize(path)\n\n        return total\n\n    def exists(self, file):\n\"\"\"Check whether a given file id or path exists on disk.\"\"\"\n        return bool(self.realpath(file))\n\n    def haspath(self, path):\n\"\"\"Return whether `path` is a subdirectory of the :attr:`root`\n        directory.\n        \"\"\"\n        return issubdir(path, self.root)\n\n    def makepath(self, path):\n\"\"\"Physically create the folder path on disk.\"\"\"\n        try:\n            os.makedirs(path, self.dmode)\n        except FileExistsError:\n            assert os.path.isdir(path), \"expected {} to be a directory\".format(path)\n\n    def relpath(self, path):\n\"\"\"Return `path` relative to the :attr:`root` directory.\"\"\"\n        return os.path.relpath(path, self.root)\n\n    def realpath(self, file):\n\"\"\"Attempt to determine the real path of a file id or path through\n        successive checking of candidate paths. If the real path is stored with\n        an extension, the path is considered a match if the basename matches\n        the expected file path of the id.\n        \"\"\"\n        # Check for absoluate path.\n        if os.path.isfile(file):\n            return file\n\n        # Check for relative path.\n        relpath = os.path.join(self.root, file)\n        if os.path.isfile(relpath):\n            return relpath\n\n        # Check for sharded path.\n        filepath = self.idpath(file)\n        if os.path.isfile(filepath):\n            return filepath\n\n        # Check for sharded path with any extension.\n        paths = glob.glob(\"{0}.*\".format(filepath))\n        if paths:\n            return paths[0]\n\n        # Could not determine a match.\n        return None\n\n    def idpath(self, id):\n\"\"\"Build the file path for a given hash id. Optionally, append a\n        file extension.\n        \"\"\"\n        paths = self.shard(id)\n\n        return os.path.join(self.root, *paths)\n\n    def computehash(self, stream) -&gt; str:\n\"\"\"Compute hash of file using :attr:`algorithm`.\"\"\"\n        hashobj = hashlib.new(self.algorithm)\n        for data in stream:\n            hashobj.update(to_bytes(data))\n        return hashobj.hexdigest()\n\n    def shard(self, id):\n\"\"\"Shard content ID into subfolders.\"\"\"\n        return shard(id, self.depth, self.width)\n\n    def unshard(self, path):\n\"\"\"Unshard path to determine hash value.\"\"\"\n        if not self.haspath(path):\n            raise ValueError(\n                \"Cannot unshard path. The path {0!r} is not \"\n                \"a subdirectory of the root directory {1!r}\".format(path, self.root)\n            )\n\n        return os.path.splitext(self.relpath(path))[0].replace(os.sep, \"\")\n\n    def repair(self):\n\"\"\"Repair any file locations whose content address doesn't match it's\n        file path.\n        \"\"\"\n        repaired = []\n        corrupted = tuple(self.corrupted())\n        oldmask = os.umask(0)\n\n        try:\n            for path, address in corrupted:\n                if os.path.isfile(address.abspath):\n                    # File already exists so just delete corrupted path.\n                    os.remove(path)\n                else:\n                    # File doesn't exists so move it.\n                    self.makepath(os.path.dirname(address.abspath))\n                    shutil.move(path, address.abspath)\n\n                os.chmod(address.abspath, self.fmode)\n                repaired.append((path, address))\n        finally:\n            os.umask(oldmask)\n\n        return repaired\n\n    def corrupted(self):\n\"\"\"Return generator that yields corrupted files as ``(path, address)``\n        where ``path`` is the path of the corrupted file and ``address`` is\n        the :class:`HashAddress` of the expected location.\n        \"\"\"\n        for path in self.files():\n            stream = Stream(path)\n\n            with closing(stream):\n                id = self.computehash(stream)\n\n            expected_path = self.idpath(id)\n\n            if expected_path != path:\n                yield (\n                    path,\n                    HashAddress(id, self.relpath(expected_path), expected_path),\n                )\n\n    def __contains__(self, file):\n\"\"\"Return whether a given file id or path is contained in the\n        :attr:`root` directory.\n        \"\"\"\n        return self.exists(file)\n\n    def __iter__(self):\n\"\"\"Iterate over all files in the :attr:`root` directory.\"\"\"\n        return self.files()\n\n    def __len__(self):\n\"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\"\n        return self.count()\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS-attributes","title":"Attributes","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.root","title":"<code>root: str = os.path.realpath(root)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.depth","title":"<code>depth: int = depth</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.width","title":"<code>width: int = width</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.algorithm","title":"<code>algorithm: str = algorithm</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.fmode","title":"<code>fmode = fmode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.dmode","title":"<code>dmode = dmode</code>  <code>instance-attribute</code>","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.put","title":"<code>put(file: BinaryIO) -&gt; HashAddress</code>","text":"<p>Store contents of <code>file</code> on disk using its content hash for the address.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>mixed</code> <p>Readable object or path to file.</p> required <p>Returns:</p> Name Type Description <code>HashAddress</code> <code>HashAddress</code> <p>File's hash address.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def put(self, file: BinaryIO) -&gt; \"HashAddress\":\n\"\"\"Store contents of `file` on disk using its content hash for the\n    address.\n\n    Args:\n        file (mixed): Readable object or path to file.\n\n    Returns:\n        HashAddress: File's hash address.\n    \"\"\"\n    stream = Stream(file)\n\n    with closing(stream):\n        id = self.computehash(stream)\n        filepath, is_duplicate = self._copy(stream, id)\n\n    return HashAddress(id, self.relpath(filepath), filepath, is_duplicate)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.put_with_precomputed_hash","title":"<code>put_with_precomputed_hash(file: Union[str, Path, BinaryIO], hash_id: str) -&gt; HashAddress</code>","text":"Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def put_with_precomputed_hash(\n    self, file: Union[str, Path, BinaryIO], hash_id: str\n) -&gt; \"HashAddress\":\n\n    stream = Stream(file)\n    with closing(stream):\n        filepath, is_duplicate = self._copy(stream=stream, id=hash_id)\n\n    return HashAddress(hash_id, self.relpath(filepath), filepath, is_duplicate)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.get","title":"<code>get(file)</code>","text":"<p>Return :class:<code>HashAdress</code> from given id or path. If <code>file</code> does not refer to a valid file, then <code>None</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Address ID or path of file.</p> required <p>Returns:</p> Name Type Description <code>HashAddress</code> <p>File's hash address.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def get(self, file):\n\"\"\"Return :class:`HashAdress` from given id or path. If `file` does not\n    refer to a valid file, then ``None`` is returned.\n\n    Args:\n        file (str): Address ID or path of file.\n\n    Returns:\n        HashAddress: File's hash address.\n    \"\"\"\n    realpath = self.realpath(file)\n\n    if realpath is None:\n        return None\n    else:\n        return HashAddress(self.unshard(realpath), self.relpath(realpath), realpath)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.open","title":"<code>open(file, mode = 'rb')</code>","text":"<p>Return open buffer object from given id or path.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Address ID or path of file.</p> required <code>mode</code> <code>str</code> <p>Mode to open file in. Defaults to <code>'rb'</code>.</p> <code>'rb'</code> <p>Returns:</p> Name Type Description <code>Buffer</code> <p>An <code>io</code> buffer dependent on the <code>mode</code>.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file doesn't exist.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def open(self, file, mode=\"rb\"):\n\"\"\"Return open buffer object from given id or path.\n\n    Args:\n        file (str): Address ID or path of file.\n        mode (str, optional): Mode to open file in. Defaults to ``'rb'``.\n\n    Returns:\n        Buffer: An ``io`` buffer dependent on the `mode`.\n\n    Raises:\n        IOError: If file doesn't exist.\n    \"\"\"\n    realpath = self.realpath(file)\n    if realpath is None:\n        raise IOError(\"Could not locate file: {0}\".format(file))\n\n    return io.open(realpath, mode)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.delete","title":"<code>delete(file)</code>","text":"<p>Delete file using id or path. Remove any empty directories after deleting. No exception is raised if file doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Address ID or path of file.</p> required Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def delete(self, file):\n\"\"\"Delete file using id or path. Remove any empty directories after\n    deleting. No exception is raised if file doesn't exist.\n\n    Args:\n        file (str): Address ID or path of file.\n    \"\"\"\n    realpath = self.realpath(file)\n    if realpath is None:\n        return\n\n    try:\n        os.remove(realpath)\n    except OSError:  # pragma: no cover\n        pass\n    else:\n        self.remove_empty(os.path.dirname(realpath))\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.remove_empty","title":"<code>remove_empty(subpath)</code>","text":"<p>Successively remove all empty folders starting with <code>subpath</code> and proceeding \"up\" through directory tree until reaching the :attr:<code>root</code> folder.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def remove_empty(self, subpath):\n\"\"\"Successively remove all empty folders starting with `subpath` and\n    proceeding \"up\" through directory tree until reaching the :attr:`root`\n    folder.\n    \"\"\"\n    # Don't attempt to remove any folders if subpath is not a\n    # subdirectory of the root directory.\n    if not self.haspath(subpath):\n        return\n\n    while subpath != self.root:\n        if len(os.listdir(subpath)) &gt; 0 or os.path.islink(subpath):\n            break\n        os.rmdir(subpath)\n        subpath = os.path.dirname(subpath)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.files","title":"<code>files()</code>","text":"<p>Return generator that yields all files in the :attr:<code>root</code> directory.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def files(self):\n\"\"\"Return generator that yields all files in the :attr:`root`\n    directory.\n    \"\"\"\n    for folder, subfolders, files in walk(self.root):\n        for file in files:\n            yield os.path.abspath(os.path.join(folder, file))\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.folders","title":"<code>folders()</code>","text":"<p>Return generator that yields all folders in the :attr:<code>root</code> directory that contain files.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def folders(self):\n\"\"\"Return generator that yields all folders in the :attr:`root`\n    directory that contain files.\n    \"\"\"\n    for folder, subfolders, files in walk(self.root):\n        if files:\n            yield folder\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.count","title":"<code>count()</code>","text":"<p>Return count of the number of files in the :attr:<code>root</code> directory.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def count(self):\n\"\"\"Return count of the number of files in the :attr:`root` directory.\"\"\"\n    count = 0\n    for _ in self:\n        count += 1\n    return count\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.size","title":"<code>size()</code>","text":"<p>Return the total size in bytes of all files in the :attr:<code>root</code> directory.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def size(self):\n\"\"\"Return the total size in bytes of all files in the :attr:`root`\n    directory.\n    \"\"\"\n    total = 0\n\n    for path in self.files():\n        total += os.path.getsize(path)\n\n    return total\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.exists","title":"<code>exists(file)</code>","text":"<p>Check whether a given file id or path exists on disk.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def exists(self, file):\n\"\"\"Check whether a given file id or path exists on disk.\"\"\"\n    return bool(self.realpath(file))\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.haspath","title":"<code>haspath(path)</code>","text":"<p>Return whether <code>path</code> is a subdirectory of the :attr:<code>root</code> directory.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def haspath(self, path):\n\"\"\"Return whether `path` is a subdirectory of the :attr:`root`\n    directory.\n    \"\"\"\n    return issubdir(path, self.root)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.makepath","title":"<code>makepath(path)</code>","text":"<p>Physically create the folder path on disk.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def makepath(self, path):\n\"\"\"Physically create the folder path on disk.\"\"\"\n    try:\n        os.makedirs(path, self.dmode)\n    except FileExistsError:\n        assert os.path.isdir(path), \"expected {} to be a directory\".format(path)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.relpath","title":"<code>relpath(path)</code>","text":"<p>Return <code>path</code> relative to the :attr:<code>root</code> directory.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def relpath(self, path):\n\"\"\"Return `path` relative to the :attr:`root` directory.\"\"\"\n    return os.path.relpath(path, self.root)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.realpath","title":"<code>realpath(file)</code>","text":"<p>Attempt to determine the real path of a file id or path through successive checking of candidate paths. If the real path is stored with an extension, the path is considered a match if the basename matches the expected file path of the id.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def realpath(self, file):\n\"\"\"Attempt to determine the real path of a file id or path through\n    successive checking of candidate paths. If the real path is stored with\n    an extension, the path is considered a match if the basename matches\n    the expected file path of the id.\n    \"\"\"\n    # Check for absoluate path.\n    if os.path.isfile(file):\n        return file\n\n    # Check for relative path.\n    relpath = os.path.join(self.root, file)\n    if os.path.isfile(relpath):\n        return relpath\n\n    # Check for sharded path.\n    filepath = self.idpath(file)\n    if os.path.isfile(filepath):\n        return filepath\n\n    # Check for sharded path with any extension.\n    paths = glob.glob(\"{0}.*\".format(filepath))\n    if paths:\n        return paths[0]\n\n    # Could not determine a match.\n    return None\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.idpath","title":"<code>idpath(id)</code>","text":"<p>Build the file path for a given hash id. Optionally, append a file extension.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def idpath(self, id):\n\"\"\"Build the file path for a given hash id. Optionally, append a\n    file extension.\n    \"\"\"\n    paths = self.shard(id)\n\n    return os.path.join(self.root, *paths)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.computehash","title":"<code>computehash(stream) -&gt; str</code>","text":"<p>Compute hash of file using :attr:<code>algorithm</code>.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def computehash(self, stream) -&gt; str:\n\"\"\"Compute hash of file using :attr:`algorithm`.\"\"\"\n    hashobj = hashlib.new(self.algorithm)\n    for data in stream:\n        hashobj.update(to_bytes(data))\n    return hashobj.hexdigest()\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.shard","title":"<code>shard(id)</code>","text":"<p>Shard content ID into subfolders.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def shard(self, id):\n\"\"\"Shard content ID into subfolders.\"\"\"\n    return shard(id, self.depth, self.width)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.unshard","title":"<code>unshard(path)</code>","text":"<p>Unshard path to determine hash value.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def unshard(self, path):\n\"\"\"Unshard path to determine hash value.\"\"\"\n    if not self.haspath(path):\n        raise ValueError(\n            \"Cannot unshard path. The path {0!r} is not \"\n            \"a subdirectory of the root directory {1!r}\".format(path, self.root)\n        )\n\n    return os.path.splitext(self.relpath(path))[0].replace(os.sep, \"\")\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.repair","title":"<code>repair()</code>","text":"<p>Repair any file locations whose content address doesn't match it's file path.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def repair(self):\n\"\"\"Repair any file locations whose content address doesn't match it's\n    file path.\n    \"\"\"\n    repaired = []\n    corrupted = tuple(self.corrupted())\n    oldmask = os.umask(0)\n\n    try:\n        for path, address in corrupted:\n            if os.path.isfile(address.abspath):\n                # File already exists so just delete corrupted path.\n                os.remove(path)\n            else:\n                # File doesn't exists so move it.\n                self.makepath(os.path.dirname(address.abspath))\n                shutil.move(path, address.abspath)\n\n            os.chmod(address.abspath, self.fmode)\n            repaired.append((path, address))\n    finally:\n        os.umask(oldmask)\n\n    return repaired\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashFS.corrupted","title":"<code>corrupted()</code>","text":"<p>Return generator that yields corrupted files as <code>(path, address)</code> where <code>path</code> is the path of the corrupted file and <code>address</code> is the :class:<code>HashAddress</code> of the expected location.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def corrupted(self):\n\"\"\"Return generator that yields corrupted files as ``(path, address)``\n    where ``path`` is the path of the corrupted file and ``address`` is\n    the :class:`HashAddress` of the expected location.\n    \"\"\"\n    for path in self.files():\n        stream = Stream(path)\n\n        with closing(stream):\n            id = self.computehash(stream)\n\n        expected_path = self.idpath(id)\n\n        if expected_path != path:\n            yield (\n                path,\n                HashAddress(id, self.relpath(expected_path), expected_path),\n            )\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.HashAddress","title":"<code>HashAddress</code>","text":"<p>         Bases: <code>namedtuple(HashAddress, [id, relpath, abspath, is_duplicate])</code></p> <p>File address containing file's path on disk and it's content hash ID.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Hash ID (hexdigest) of file contents.</p> <code>relpath</code> <code>str</code> <p>Relative path location to :attr:<code>HashFS.root</code>.</p> <code>abspath</code> <code>str</code> <p>Absoluate path location of file on disk.</p> <code>is_duplicate</code> <code>boolean</code> <p>Whether the hash address created was a duplicate of a previously existing file. Can only be <code>True</code> after a put operation. Defaults to <code>False</code>.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>class HashAddress(\n    namedtuple(\"HashAddress\", [\"id\", \"relpath\", \"abspath\", \"is_duplicate\"])\n):\n\"\"\"File address containing file's path on disk and it's content hash ID.\n\n    Attributes:\n        id (str): Hash ID (hexdigest) of file contents.\n        relpath (str): Relative path location to :attr:`HashFS.root`.\n        abspath (str): Absoluate path location of file on disk.\n        is_duplicate (boolean, optional): Whether the hash address created was\n            a duplicate of a previously existing file. Can only be ``True``\n            after a put operation. Defaults to ``False``.\n    \"\"\"\n\n    def __new__(cls, id, relpath, abspath, is_duplicate=False):\n        return super(HashAddress, cls).__new__(cls, id, relpath, abspath, is_duplicate)  # type: ignore\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.Stream","title":"<code>Stream</code>","text":"<p>         Bases: <code>object</code></p> <p>Common interface for file-like objects.</p> <p>The input <code>obj</code> can be a file-like object or a path to a file. If <code>obj</code> is a path to a file, then it will be opened until :meth:<code>close</code> is called. If <code>obj</code> is a file-like object, then it's original position will be restored when :meth:<code>close</code> is called instead of closing the object automatically. Closing of the stream is deferred to whatever process passed the stream in.</p> <p>Successive readings of the stream is supported without having to manually set it's position back to <code>0</code>.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>class Stream(object):\n\"\"\"Common interface for file-like objects.\n\n    The input `obj` can be a file-like object or a path to a file. If `obj` is\n    a path to a file, then it will be opened until :meth:`close` is called.\n    If `obj` is a file-like object, then it's original position will be\n    restored when :meth:`close` is called instead of closing the object\n    automatically. Closing of the stream is deferred to whatever process passed\n    the stream in.\n\n    Successive readings of the stream is supported without having to manually\n    set it's position back to ``0``.\n    \"\"\"\n\n    def __init__(self, obj: Union[BinaryIO, str, Path]):\n        if hasattr(obj, \"read\"):\n            pos = obj.tell()  # type: ignore\n        elif os.path.isfile(obj):  # type: ignore\n            obj = io.open(obj, \"rb\")  # type: ignore\n            pos = None\n        else:\n            raise ValueError(\"Object must be a valid file path or a readable object\")\n\n        try:\n            file_stat = os.stat(obj.name)  # type: ignore\n            buffer_size = file_stat.st_blksize\n        except Exception:\n            buffer_size = 8192\n\n        self._obj: BinaryIO = obj  # type: ignore\n        self._pos = pos\n        self._buffer_size = buffer_size\n\n    def __iter__(self):\n\"\"\"Read underlying IO object and yield results. Return object to\n        original position if we didn't open it originally.\n        \"\"\"\n        self._obj.seek(0)\n\n        while True:\n            data = self._obj.read(self._buffer_size)\n\n            if not data:\n                break\n\n            yield data\n\n        if self._pos is not None:\n            self._obj.seek(self._pos)\n\n    def close(self):\n\"\"\"Close underlying IO object if we opened it, else return it to\n        original position.\n        \"\"\"\n        if self._pos is None:\n            self._obj.close()\n        else:\n            self._obj.seek(self._pos)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.Stream-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.Stream.close","title":"<code>close()</code>","text":"<p>Close underlying IO object if we opened it, else return it to original position.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def close(self):\n\"\"\"Close underlying IO object if we opened it, else return it to\n    original position.\n    \"\"\"\n    if self._pos is None:\n        self._obj.close()\n    else:\n        self._obj.seek(self._pos)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs-functions","title":"Functions","text":""},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.to_bytes","title":"<code>to_bytes(text: Union[str, bytes])</code>","text":"Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def to_bytes(text: Union[str, bytes]):\n    if not isinstance(text, bytes):\n        text = bytes(text, \"utf8\")\n    return text\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.compact","title":"<code>compact(items: List[Any]) -&gt; List[Any]</code>","text":"<p>Return only truthy elements of <code>items</code>.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def compact(items: List[Any]) -&gt; List[Any]:\n\"\"\"Return only truthy elements of `items`.\"\"\"\n    return [item for item in items if item]\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.issubdir","title":"<code>issubdir(subpath: str, path: str)</code>","text":"<p>Return whether <code>subpath</code> is a sub-directory of <code>path</code>.</p> Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def issubdir(subpath: str, path: str):\n\"\"\"Return whether `subpath` is a sub-directory of `path`.\"\"\"\n    # Append os.sep so that paths like /usr/var2/log doesn't match /usr/var.\n    path = os.path.realpath(path) + os.sep\n    subpath = os.path.realpath(subpath)\n    return subpath.startswith(path)\n</code></pre>"},{"location":"reference/kiara/utils/hashfs/__init__/#kiara.utils.hashfs.shard","title":"<code>shard(digest, depth, width)</code>","text":"Source code in <code>kiara/utils/hashfs/__init__.py</code> <pre><code>def shard(digest, depth, width):\n    # This creates a list of `depth` number of tokens with width\n    # `width` from the first part of the id plus the remainder.\n    return compact(\n        [digest[i * width : width * (i + 1)] for i in range(depth)]\n        + [digest[depth * width :]]\n    )\n</code></pre>"}]}